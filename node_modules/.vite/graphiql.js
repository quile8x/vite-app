import {
  require_copy_to_clipboard
} from "./chunk-KHTSUSFT.js";
import {
  require_react_dom
} from "./chunk-GGPBC6UB.js";
import {
  require_react
} from "./chunk-IQ6JHC5C.js";
import {
  __commonJS,
  __esm,
  __export,
  __toModule,
  init_define_process_env
} from "./chunk-OF4YZRDE.js";

// node_modules/graphql/version.mjs
var version, versionInfo;
var init_version = __esm({
  "node_modules/graphql/version.mjs"() {
    init_define_process_env();
    version = "15.6.1";
    versionInfo = Object.freeze({
      major: 15,
      minor: 6,
      patch: 1,
      preReleaseTag: null
    });
  }
});

// node_modules/graphql/jsutils/isPromise.mjs
function isPromise(value) {
  return typeof (value === null || value === void 0 ? void 0 : value.then) === "function";
}
var init_isPromise = __esm({
  "node_modules/graphql/jsutils/isPromise.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/isObjectLike.mjs
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof6(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof6(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function isObjectLike(value) {
  return _typeof(value) == "object" && value !== null;
}
var init_isObjectLike = __esm({
  "node_modules/graphql/jsutils/isObjectLike.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/polyfills/symbols.mjs
var SYMBOL_ITERATOR, SYMBOL_ASYNC_ITERATOR, SYMBOL_TO_STRING_TAG;
var init_symbols = __esm({
  "node_modules/graphql/polyfills/symbols.mjs"() {
    init_define_process_env();
    SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
    SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
    SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
  }
});

// node_modules/graphql/language/location.mjs
function getLocation(source, position) {
  var lineRegexp = /\r\n|[\n\r]/g;
  var line = 1;
  var column = position + 1;
  var match;
  while ((match = lineRegexp.exec(source.body)) && match.index < position) {
    line += 1;
    column = position + 1 - (match.index + match[0].length);
  }
  return {
    line,
    column
  };
}
var init_location = __esm({
  "node_modules/graphql/language/location.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}
function printSourceLocation(source, sourceLocation) {
  var firstLineColumnOffset = source.locationOffset.column - 1;
  var body = whitespace(firstLineColumnOffset) + source.body;
  var lineIndex = sourceLocation.line - 1;
  var lineOffset = source.locationOffset.line - 1;
  var lineNum = sourceLocation.line + lineOffset;
  var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  var columnNum = sourceLocation.column + columnOffset;
  var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
  var lines = body.split(/\r\n|[\n\r]/g);
  var locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    var subLineIndex = Math.floor(columnNum / 80);
    var subLineColumnNum = columnNum % 80;
    var subLines = [];
    for (var i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
      return ["", subLine];
    }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
  }
  return locationStr + printPrefixedLines([
    ["".concat(lineNum - 1), lines[lineIndex - 1]],
    ["".concat(lineNum), locationLine],
    ["", whitespace(columnNum - 1) + "^"],
    ["".concat(lineNum + 1), lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  var existingLines = lines.filter(function(_ref) {
    var _ = _ref[0], line = _ref[1];
    return line !== void 0;
  });
  var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
    var prefix = _ref2[0];
    return prefix.length;
  }));
  return existingLines.map(function(_ref3) {
    var prefix = _ref3[0], line = _ref3[1];
    return leftPad(padLen, prefix) + (line ? " | " + line : " |");
  }).join("\n");
}
function whitespace(len) {
  return Array(len + 1).join(" ");
}
function leftPad(len, str) {
  return whitespace(len - str.length) + str;
}
var init_printLocation = __esm({
  "node_modules/graphql/language/printLocation.mjs"() {
    init_define_process_env();
    init_location();
  }
});

// node_modules/graphql/error/GraphQLError.mjs
function _typeof2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof2 = function _typeof6(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof2 = function _typeof6(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof2(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function printError(error2) {
  var output = error2.message;
  if (error2.nodes) {
    for (var _i2 = 0, _error$nodes2 = error2.nodes; _i2 < _error$nodes2.length; _i2++) {
      var node = _error$nodes2[_i2];
      if (node.loc) {
        output += "\n\n" + printLocation(node.loc);
      }
    }
  } else if (error2.source && error2.locations) {
    for (var _i4 = 0, _error$locations2 = error2.locations; _i4 < _error$locations2.length; _i4++) {
      var location = _error$locations2[_i4];
      output += "\n\n" + printSourceLocation(error2.source, location);
    }
  }
  return output;
}
var GraphQLError;
var init_GraphQLError = __esm({
  "node_modules/graphql/error/GraphQLError.mjs"() {
    init_define_process_env();
    init_isObjectLike();
    init_symbols();
    init_location();
    init_printLocation();
    GraphQLError = function(_Error) {
      _inherits(GraphQLError2, _Error);
      var _super = _createSuper(GraphQLError2);
      function GraphQLError2(message, nodes, source, positions, path, originalError, extensions) {
        var _locations2, _source2, _positions2, _extensions2;
        var _this;
        _classCallCheck(this, GraphQLError2);
        _this = _super.call(this, message);
        var _nodes = Array.isArray(nodes) ? nodes.length !== 0 ? nodes : void 0 : nodes ? [nodes] : void 0;
        var _source = source;
        if (!_source && _nodes) {
          var _nodes$0$loc;
          _source = (_nodes$0$loc = _nodes[0].loc) === null || _nodes$0$loc === void 0 ? void 0 : _nodes$0$loc.source;
        }
        var _positions = positions;
        if (!_positions && _nodes) {
          _positions = _nodes.reduce(function(list2, node) {
            if (node.loc) {
              list2.push(node.loc.start);
            }
            return list2;
          }, []);
        }
        if (_positions && _positions.length === 0) {
          _positions = void 0;
        }
        var _locations;
        if (positions && source) {
          _locations = positions.map(function(pos) {
            return getLocation(source, pos);
          });
        } else if (_nodes) {
          _locations = _nodes.reduce(function(list2, node) {
            if (node.loc) {
              list2.push(getLocation(node.loc.source, node.loc.start));
            }
            return list2;
          }, []);
        }
        var _extensions = extensions;
        if (_extensions == null && originalError != null) {
          var originalExtensions = originalError.extensions;
          if (isObjectLike(originalExtensions)) {
            _extensions = originalExtensions;
          }
        }
        Object.defineProperties(_assertThisInitialized(_this), {
          name: {
            value: "GraphQLError"
          },
          message: {
            value: message,
            enumerable: true,
            writable: true
          },
          locations: {
            value: (_locations2 = _locations) !== null && _locations2 !== void 0 ? _locations2 : void 0,
            enumerable: _locations != null
          },
          path: {
            value: path !== null && path !== void 0 ? path : void 0,
            enumerable: path != null
          },
          nodes: {
            value: _nodes !== null && _nodes !== void 0 ? _nodes : void 0
          },
          source: {
            value: (_source2 = _source) !== null && _source2 !== void 0 ? _source2 : void 0
          },
          positions: {
            value: (_positions2 = _positions) !== null && _positions2 !== void 0 ? _positions2 : void 0
          },
          originalError: {
            value: originalError
          },
          extensions: {
            value: (_extensions2 = _extensions) !== null && _extensions2 !== void 0 ? _extensions2 : void 0,
            enumerable: _extensions != null
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
          return _possibleConstructorReturn(_this);
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized(_this), GraphQLError2);
        } else {
          Object.defineProperty(_assertThisInitialized(_this), "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
        return _this;
      }
      _createClass(GraphQLError2, [{
        key: "toString",
        value: function toString3() {
          return printError(this);
        }
      }, {
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "Object";
        }
      }]);
      return GraphQLError2;
    }(_wrapNativeSuper(Error));
  }
});

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError("Syntax Error: ".concat(description), void 0, source, [position]);
}
var init_syntaxError = __esm({
  "node_modules/graphql/error/syntaxError.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/language/kinds.mjs
var Kind;
var init_kinds = __esm({
  "node_modules/graphql/language/kinds.mjs"() {
    init_define_process_env();
    Kind = Object.freeze({
      NAME: "Name",
      DOCUMENT: "Document",
      OPERATION_DEFINITION: "OperationDefinition",
      VARIABLE_DEFINITION: "VariableDefinition",
      SELECTION_SET: "SelectionSet",
      FIELD: "Field",
      ARGUMENT: "Argument",
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_FRAGMENT: "InlineFragment",
      FRAGMENT_DEFINITION: "FragmentDefinition",
      VARIABLE: "Variable",
      INT: "IntValue",
      FLOAT: "FloatValue",
      STRING: "StringValue",
      BOOLEAN: "BooleanValue",
      NULL: "NullValue",
      ENUM: "EnumValue",
      LIST: "ListValue",
      OBJECT: "ObjectValue",
      OBJECT_FIELD: "ObjectField",
      DIRECTIVE: "Directive",
      NAMED_TYPE: "NamedType",
      LIST_TYPE: "ListType",
      NON_NULL_TYPE: "NonNullType",
      SCHEMA_DEFINITION: "SchemaDefinition",
      OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
      SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
      OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
      FIELD_DEFINITION: "FieldDefinition",
      INPUT_VALUE_DEFINITION: "InputValueDefinition",
      INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
      UNION_TYPE_DEFINITION: "UnionTypeDefinition",
      ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
      ENUM_VALUE_DEFINITION: "EnumValueDefinition",
      INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
      DIRECTIVE_DEFINITION: "DirectiveDefinition",
      SCHEMA_EXTENSION: "SchemaExtension",
      SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
      OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
      INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
      UNION_TYPE_EXTENSION: "UnionTypeExtension",
      ENUM_TYPE_EXTENSION: "EnumTypeExtension",
      INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    });
  }
});

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
var init_invariant = __esm({
  "node_modules/graphql/jsutils/invariant.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs
var nodejsCustomInspectSymbol, nodejsCustomInspectSymbol_default;
var init_nodejsCustomInspectSymbol = __esm({
  "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.mjs"() {
    init_define_process_env();
    nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    nodejsCustomInspectSymbol_default = nodejsCustomInspectSymbol;
  }
});

// node_modules/graphql/jsutils/defineInspect.mjs
function defineInspect(classObject) {
  var fn = classObject.prototype.toJSON;
  typeof fn === "function" || invariant(0);
  classObject.prototype.inspect = fn;
  if (nodejsCustomInspectSymbol_default) {
    classObject.prototype[nodejsCustomInspectSymbol_default] = fn;
  }
}
var init_defineInspect = __esm({
  "node_modules/graphql/jsutils/defineInspect.mjs"() {
    init_define_process_env();
    init_invariant();
    init_nodejsCustomInspectSymbol();
  }
});

// node_modules/graphql/language/ast.mjs
function isNode(maybeNode) {
  return maybeNode != null && typeof maybeNode.kind === "string";
}
var Location, Token;
var init_ast = __esm({
  "node_modules/graphql/language/ast.mjs"() {
    init_define_process_env();
    init_defineInspect();
    Location = function() {
      function Location3(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      var _proto = Location3.prototype;
      _proto.toJSON = function toJSON3() {
        return {
          start: this.start,
          end: this.end
        };
      };
      return Location3;
    }();
    defineInspect(Location);
    Token = function() {
      function Token2(kind, start, end, line, column, prev, value) {
        this.kind = kind;
        this.start = start;
        this.end = end;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = prev;
        this.next = null;
      }
      var _proto2 = Token2.prototype;
      _proto2.toJSON = function toJSON3() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      };
      return Token2;
    }();
    defineInspect(Token);
  }
});

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
var init_tokenKind = __esm({
  "node_modules/graphql/language/tokenKind.mjs"() {
    init_define_process_env();
    TokenKind = Object.freeze({
      SOF: "<SOF>",
      EOF: "<EOF>",
      BANG: "!",
      DOLLAR: "$",
      AMP: "&",
      PAREN_L: "(",
      PAREN_R: ")",
      SPREAD: "...",
      COLON: ":",
      EQUALS: "=",
      AT: "@",
      BRACKET_L: "[",
      BRACKET_R: "]",
      BRACE_L: "{",
      PIPE: "|",
      BRACE_R: "}",
      NAME: "Name",
      INT: "Int",
      FLOAT: "Float",
      STRING: "String",
      BLOCK_STRING: "BlockString",
      COMMENT: "Comment"
    });
  }
});

// node_modules/graphql/jsutils/inspect.mjs
function _typeof3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof3 = function _typeof6(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof3 = function _typeof6(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof3(obj);
}
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (_typeof3(value)) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? "[function ".concat(value.name, "]") : "[function]";
    case "object":
      if (value === null) {
        return "null";
      }
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (previouslySeenValues.indexOf(value) !== -1) {
    return "[Circular]";
  }
  var seenValues = [].concat(previouslySeenValues, [value]);
  var customInspectFn = getCustomFn(value);
  if (customInspectFn !== void 0) {
    var customValue = customInspectFn.call(value);
    if (customValue !== value) {
      return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function formatObject(object, seenValues) {
  var keys = Object.keys(object);
  if (keys.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  var properties = keys.map(function(key) {
    var value = formatValue(object[key], seenValues);
    return key + ": " + value;
  });
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  var len = Math.min(MAX_ARRAY_LENGTH, array.length);
  var remaining = array.length - len;
  var items = [];
  for (var i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push("... ".concat(remaining, " more items"));
  }
  return "[" + items.join(", ") + "]";
}
function getCustomFn(object) {
  var customInspectFn = object[String(nodejsCustomInspectSymbol_default)];
  if (typeof customInspectFn === "function") {
    return customInspectFn;
  }
  if (typeof object.inspect === "function") {
    return object.inspect;
  }
}
function getObjectTag(object) {
  var tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    var name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
var MAX_ARRAY_LENGTH, MAX_RECURSIVE_DEPTH;
var init_inspect = __esm({
  "node_modules/graphql/jsutils/inspect.mjs"() {
    init_define_process_env();
    init_nodejsCustomInspectSymbol();
    MAX_ARRAY_LENGTH = 10;
    MAX_RECURSIVE_DEPTH = 2;
  }
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  var booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
var init_devAssert = __esm({
  "node_modules/graphql/jsutils/devAssert.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/instanceOf.mjs
function _typeof4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof4 = function _typeof6(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof4 = function _typeof6(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof4(obj);
}
var instanceOf_default;
var init_instanceOf = __esm({
  "node_modules/graphql/jsutils/instanceOf.mjs"() {
    init_define_process_env();
    init_inspect();
    instanceOf_default = false ? function instanceOf(value, constructor) {
      return value instanceof constructor;
    } : function instanceOf2(value, constructor) {
      if (value instanceof constructor) {
        return true;
      }
      if (_typeof4(value) === "object" && value !== null) {
        var _value$constructor;
        var className = constructor.prototype[Symbol.toStringTag];
        var valueClassName = Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name;
        if (className === valueClassName) {
          var stringifiedValue = inspect(value);
          throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
        }
      }
      return false;
    };
  }
});

// node_modules/graphql/language/source.mjs
function _defineProperties2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties2(Constructor, staticProps);
  return Constructor;
}
function isSource(source) {
  return instanceOf_default(source, Source);
}
var Source;
var init_source = __esm({
  "node_modules/graphql/language/source.mjs"() {
    init_define_process_env();
    init_symbols();
    init_inspect();
    init_devAssert();
    init_instanceOf();
    Source = function() {
      function Source2(body) {
        var name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
        var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          line: 1,
          column: 1
        };
        typeof body === "string" || devAssert(0, "Body must be a string. Received: ".concat(inspect(body), "."));
        this.body = body;
        this.name = name2;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || devAssert(0, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || devAssert(0, "column in locationOffset is 1-indexed and must be positive.");
      }
      _createClass2(Source2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "Source";
        }
      }]);
      return Source2;
    }();
  }
});

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
var init_directiveLocation = __esm({
  "node_modules/graphql/language/directiveLocation.mjs"() {
    init_define_process_env();
    DirectiveLocation = Object.freeze({
      QUERY: "QUERY",
      MUTATION: "MUTATION",
      SUBSCRIPTION: "SUBSCRIPTION",
      FIELD: "FIELD",
      FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
      FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
      INLINE_FRAGMENT: "INLINE_FRAGMENT",
      VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
      SCHEMA: "SCHEMA",
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      FIELD_DEFINITION: "FIELD_DEFINITION",
      ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      ENUM_VALUE: "ENUM_VALUE",
      INPUT_OBJECT: "INPUT_OBJECT",
      INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    });
  }
});

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringValue(rawString) {
  var lines = rawString.split(/\r\n|[\n\r]/g);
  var commonIndent = getBlockStringIndentation(rawString);
  if (commonIndent !== 0) {
    for (var i = 1; i < lines.length; i++) {
      lines[i] = lines[i].slice(commonIndent);
    }
  }
  var startLine = 0;
  while (startLine < lines.length && isBlank(lines[startLine])) {
    ++startLine;
  }
  var endLine = lines.length;
  while (endLine > startLine && isBlank(lines[endLine - 1])) {
    --endLine;
  }
  return lines.slice(startLine, endLine).join("\n");
}
function isBlank(str) {
  for (var i = 0; i < str.length; ++i) {
    if (str[i] !== " " && str[i] !== "	") {
      return false;
    }
  }
  return true;
}
function getBlockStringIndentation(value) {
  var _commonIndent;
  var isFirstLine = true;
  var isEmptyLine = true;
  var indent2 = 0;
  var commonIndent = null;
  for (var i = 0; i < value.length; ++i) {
    switch (value.charCodeAt(i)) {
      case 13:
        if (value.charCodeAt(i + 1) === 10) {
          ++i;
        }
      case 10:
        isFirstLine = false;
        isEmptyLine = true;
        indent2 = 0;
        break;
      case 9:
      case 32:
        ++indent2;
        break;
      default:
        if (isEmptyLine && !isFirstLine && (commonIndent === null || indent2 < commonIndent)) {
          commonIndent = indent2;
        }
        isEmptyLine = false;
    }
  }
  return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
}
function printBlockString(value) {
  var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  var isSingleLine = value.indexOf("\n") === -1;
  var hasLeadingSpace = value[0] === " " || value[0] === "	";
  var hasTrailingQuote = value[value.length - 1] === '"';
  var hasTrailingSlash = value[value.length - 1] === "\\";
  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
  var result = "";
  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
    result += "\n" + indentation;
  }
  result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
  if (printAsMultipleLines) {
    result += "\n";
  }
  return '"""' + result.replace(/"""/g, '\\"""') + '"""';
}
var init_blockString = __esm({
  "node_modules/graphql/language/blockString.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/language/lexer.mjs
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function printCharCode(code) {
  return isNaN(code) ? TokenKind.EOF : code < 127 ? JSON.stringify(String.fromCharCode(code)) : '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"');
}
function readToken(lexer, prev) {
  var source = lexer.source;
  var body = source.body;
  var bodyLength = body.length;
  var pos = prev.end;
  while (pos < bodyLength) {
    var code = body.charCodeAt(pos);
    var _line = lexer.line;
    var _col = 1 + pos - lexer.lineStart;
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++pos;
        continue;
      case 10:
        ++pos;
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 13:
        if (body.charCodeAt(pos + 1) === 10) {
          pos += 2;
        } else {
          ++pos;
        }
        ++lexer.line;
        lexer.lineStart = pos;
        continue;
      case 33:
        return new Token(TokenKind.BANG, pos, pos + 1, _line, _col, prev);
      case 35:
        return readComment(source, pos, _line, _col, prev);
      case 36:
        return new Token(TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
      case 38:
        return new Token(TokenKind.AMP, pos, pos + 1, _line, _col, prev);
      case 40:
        return new Token(TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
      case 41:
        return new Token(TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
      case 46:
        if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
          return new Token(TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
        }
        break;
      case 58:
        return new Token(TokenKind.COLON, pos, pos + 1, _line, _col, prev);
      case 61:
        return new Token(TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
      case 64:
        return new Token(TokenKind.AT, pos, pos + 1, _line, _col, prev);
      case 91:
        return new Token(TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
      case 93:
        return new Token(TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
      case 123:
        return new Token(TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
      case 124:
        return new Token(TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
      case 125:
        return new Token(TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
      case 34:
        if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
          return readBlockString(source, pos, _line, _col, prev, lexer);
        }
        return readString(source, pos, _line, _col, prev);
      case 45:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        return readNumber(source, pos, code, _line, _col, prev);
      case 65:
      case 66:
      case 67:
      case 68:
      case 69:
      case 70:
      case 71:
      case 72:
      case 73:
      case 74:
      case 75:
      case 76:
      case 77:
      case 78:
      case 79:
      case 80:
      case 81:
      case 82:
      case 83:
      case 84:
      case 85:
      case 86:
      case 87:
      case 88:
      case 89:
      case 90:
      case 95:
      case 97:
      case 98:
      case 99:
      case 100:
      case 101:
      case 102:
      case 103:
      case 104:
      case 105:
      case 106:
      case 107:
      case 108:
      case 109:
      case 110:
      case 111:
      case 112:
      case 113:
      case 114:
      case 115:
      case 116:
      case 117:
      case 118:
      case 119:
      case 120:
      case 121:
      case 122:
        return readName(source, pos, _line, _col, prev);
    }
    throw syntaxError(source, pos, unexpectedCharacterMessage(code));
  }
  var line = lexer.line;
  var col = 1 + pos - lexer.lineStart;
  return new Token(TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
}
function unexpectedCharacterMessage(code) {
  if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
    return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
  }
  if (code === 39) {
    return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
  }
  return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
}
function readComment(source, start, line, col, prev) {
  var body = source.body;
  var code;
  var position = start;
  do {
    code = body.charCodeAt(++position);
  } while (!isNaN(code) && (code > 31 || code === 9));
  return new Token(TokenKind.COMMENT, start, position, line, col, prev, body.slice(start + 1, position));
}
function readNumber(source, start, firstCode, line, col, prev) {
  var body = source.body;
  var code = firstCode;
  var position = start;
  var isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (code >= 48 && code <= 57) {
      throw syntaxError(source, position, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
    }
  } else {
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(source, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
  }
  return new Token(isFloat ? TokenKind.FLOAT : TokenKind.INT, start, position, line, col, prev, body.slice(start, position));
}
function readDigits(source, start, firstCode) {
  var body = source.body;
  var position = start;
  var code = firstCode;
  if (code >= 48 && code <= 57) {
    do {
      code = body.charCodeAt(++position);
    } while (code >= 48 && code <= 57);
    return position;
  }
  throw syntaxError(source, position, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
}
function readString(source, start, line, col, prev) {
  var body = source.body;
  var position = start + 1;
  var chunkStart = position;
  var code = 0;
  var value = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position)) && code !== 10 && code !== 13) {
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return new Token(TokenKind.STRING, start, position + 1, line, col, prev, value);
    }
    if (code < 32 && code !== 9) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    ++position;
    if (code === 92) {
      value += body.slice(chunkStart, position - 1);
      code = body.charCodeAt(position);
      switch (code) {
        case 34:
          value += '"';
          break;
        case 47:
          value += "/";
          break;
        case 92:
          value += "\\";
          break;
        case 98:
          value += "\b";
          break;
        case 102:
          value += "\f";
          break;
        case 110:
          value += "\n";
          break;
        case 114:
          value += "\r";
          break;
        case 116:
          value += "	";
          break;
        case 117: {
          var charCode = uniCharCode(body.charCodeAt(position + 1), body.charCodeAt(position + 2), body.charCodeAt(position + 3), body.charCodeAt(position + 4));
          if (charCode < 0) {
            var invalidSequence = body.slice(position + 1, position + 5);
            throw syntaxError(source, position, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
          }
          value += String.fromCharCode(charCode);
          position += 4;
          break;
        }
        default:
          throw syntaxError(source, position, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
      }
      ++position;
      chunkStart = position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function readBlockString(source, start, line, col, prev, lexer) {
  var body = source.body;
  var position = start + 3;
  var chunkStart = position;
  var code = 0;
  var rawValue = "";
  while (position < body.length && !isNaN(code = body.charCodeAt(position))) {
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      rawValue += body.slice(chunkStart, position);
      return new Token(TokenKind.BLOCK_STRING, start, position + 3, line, col, prev, dedentBlockStringValue(rawValue));
    }
    if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
      throw syntaxError(source, position, "Invalid character within String: ".concat(printCharCode(code), "."));
    }
    if (code === 10) {
      ++position;
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 13) {
      if (body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      ++lexer.line;
      lexer.lineStart = position;
    } else if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      rawValue += body.slice(chunkStart, position) + '"""';
      position += 4;
      chunkStart = position;
    } else {
      ++position;
    }
  }
  throw syntaxError(source, position, "Unterminated string.");
}
function uniCharCode(a, b, c, d) {
  return char2hex(a) << 12 | char2hex(b) << 8 | char2hex(c) << 4 | char2hex(d);
}
function char2hex(a) {
  return a >= 48 && a <= 57 ? a - 48 : a >= 65 && a <= 70 ? a - 55 : a >= 97 && a <= 102 ? a - 87 : -1;
}
function readName(source, start, line, col, prev) {
  var body = source.body;
  var bodyLength = body.length;
  var position = start + 1;
  var code = 0;
  while (position !== bodyLength && !isNaN(code = body.charCodeAt(position)) && (code === 95 || code >= 48 && code <= 57 || code >= 65 && code <= 90 || code >= 97 && code <= 122)) {
    ++position;
  }
  return new Token(TokenKind.NAME, start, position, line, col, prev, body.slice(start, position));
}
function isNameStart(code) {
  return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
}
var Lexer;
var init_lexer = __esm({
  "node_modules/graphql/language/lexer.mjs"() {
    init_define_process_env();
    init_syntaxError();
    init_ast();
    init_tokenKind();
    init_blockString();
    Lexer = function() {
      function Lexer2(source) {
        var startOfFileToken = new Token(TokenKind.SOF, 0, 0, 0, 0, null);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      var _proto = Lexer2.prototype;
      _proto.advance = function advance() {
        this.lastToken = this.token;
        var token = this.token = this.lookahead();
        return token;
      };
      _proto.lookahead = function lookahead() {
        var token = this.token;
        if (token.kind !== TokenKind.EOF) {
          do {
            var _token$next;
            token = (_token$next = token.next) !== null && _token$next !== void 0 ? _token$next : token.next = readToken(this, token);
          } while (token.kind === TokenKind.COMMENT);
        }
        return token;
      };
      return Lexer2;
    }();
  }
});

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  var parser = new Parser(source, options);
  return parser.parseDocument();
}
function parseValue(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  var value = parser.parseValueLiteral(false);
  parser.expectToken(TokenKind.EOF);
  return value;
}
function parseType(source, options) {
  var parser = new Parser(source, options);
  parser.expectToken(TokenKind.SOF);
  var type2 = parser.parseTypeReference();
  parser.expectToken(TokenKind.EOF);
  return type2;
}
function getTokenDesc(token) {
  var value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ' "'.concat(value, '"') : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? '"'.concat(kind, '"') : kind;
}
var Parser;
var init_parser = __esm({
  "node_modules/graphql/language/parser.mjs"() {
    init_define_process_env();
    init_syntaxError();
    init_kinds();
    init_ast();
    init_tokenKind();
    init_source();
    init_directiveLocation();
    init_lexer();
    Parser = function() {
      function Parser2(source, options) {
        var sourceObj = isSource(source) ? source : new Source(source);
        this._lexer = new Lexer(sourceObj);
        this._options = options;
      }
      var _proto = Parser2.prototype;
      _proto.parseName = function parseName() {
        var token = this.expectToken(TokenKind.NAME);
        return {
          kind: Kind.NAME,
          value: token.value,
          loc: this.loc(token)
        };
      };
      _proto.parseDocument = function parseDocument() {
        var start = this._lexer.token;
        return {
          kind: Kind.DOCUMENT,
          definitions: this.many(TokenKind.SOF, this.parseDefinition, TokenKind.EOF),
          loc: this.loc(start)
        };
      };
      _proto.parseDefinition = function parseDefinition() {
        if (this.peek(TokenKind.NAME)) {
          switch (this._lexer.token.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "schema":
            case "scalar":
            case "type":
            case "interface":
            case "union":
            case "enum":
            case "input":
            case "directive":
              return this.parseTypeSystemDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        } else if (this.peek(TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        } else if (this.peekDescription()) {
          return this.parseTypeSystemDefinition();
        }
        throw this.unexpected();
      };
      _proto.parseOperationDefinition = function parseOperationDefinition() {
        var start = this._lexer.token;
        if (this.peek(TokenKind.BRACE_L)) {
          return {
            kind: Kind.OPERATION_DEFINITION,
            operation: "query",
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        var operation = this.parseOperationType();
        var name2;
        if (this.peek(TokenKind.NAME)) {
          name2 = this.parseName();
        }
        return {
          kind: Kind.OPERATION_DEFINITION,
          operation,
          name: name2,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseOperationType = function parseOperationType() {
        var operationToken = this.expectToken(TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return "query";
          case "mutation":
            return "mutation";
          case "subscription":
            return "subscription";
        }
        throw this.unexpected(operationToken);
      };
      _proto.parseVariableDefinitions = function parseVariableDefinitions() {
        return this.optionalMany(TokenKind.PAREN_L, this.parseVariableDefinition, TokenKind.PAREN_R);
      };
      _proto.parseVariableDefinition = function parseVariableDefinition() {
        var start = this._lexer.token;
        return {
          kind: Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
          directives: this.parseDirectives(true),
          loc: this.loc(start)
        };
      };
      _proto.parseVariable = function parseVariable() {
        var start = this._lexer.token;
        this.expectToken(TokenKind.DOLLAR);
        return {
          kind: Kind.VARIABLE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseSelectionSet = function parseSelectionSet() {
        var start = this._lexer.token;
        return {
          kind: Kind.SELECTION_SET,
          selections: this.many(TokenKind.BRACE_L, this.parseSelection, TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseSelection = function parseSelection() {
        return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      };
      _proto.parseField = function parseField() {
        var start = this._lexer.token;
        var nameOrAlias = this.parseName();
        var alias;
        var name2;
        if (this.expectOptionalToken(TokenKind.COLON)) {
          alias = nameOrAlias;
          name2 = this.parseName();
        } else {
          name2 = nameOrAlias;
        }
        return {
          kind: Kind.FIELD,
          alias,
          name: name2,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
          loc: this.loc(start)
        };
      };
      _proto.parseArguments = function parseArguments(isConst) {
        var item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
      };
      _proto.parseArgument = function parseArgument() {
        var start = this._lexer.token;
        var name2 = this.parseName();
        this.expectToken(TokenKind.COLON);
        return {
          kind: Kind.ARGUMENT,
          name: name2,
          value: this.parseValueLiteral(false),
          loc: this.loc(start)
        };
      };
      _proto.parseConstArgument = function parseConstArgument() {
        var start = this._lexer.token;
        return {
          kind: Kind.ARGUMENT,
          name: this.parseName(),
          value: (this.expectToken(TokenKind.COLON), this.parseValueLiteral(true)),
          loc: this.loc(start)
        };
      };
      _proto.parseFragment = function parseFragment() {
        var start = this._lexer.token;
        this.expectToken(TokenKind.SPREAD);
        var hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
          return {
            kind: Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false),
            loc: this.loc(start)
          };
        }
        return {
          kind: Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentDefinition = function parseFragmentDefinition() {
        var _this$_options;
        var start = this._lexer.token;
        this.expectKeyword("fragment");
        if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
          return {
            kind: Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start)
          };
        }
        return {
          kind: Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start)
        };
      };
      _proto.parseFragmentName = function parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      };
      _proto.parseValueLiteral = function parseValueLiteral(isConst) {
        var token = this._lexer.token;
        switch (token.kind) {
          case TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case TokenKind.INT:
            this._lexer.advance();
            return {
              kind: Kind.INT,
              value: token.value,
              loc: this.loc(token)
            };
          case TokenKind.FLOAT:
            this._lexer.advance();
            return {
              kind: Kind.FLOAT,
              value: token.value,
              loc: this.loc(token)
            };
          case TokenKind.STRING:
          case TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case TokenKind.NAME:
            this._lexer.advance();
            switch (token.value) {
              case "true":
                return {
                  kind: Kind.BOOLEAN,
                  value: true,
                  loc: this.loc(token)
                };
              case "false":
                return {
                  kind: Kind.BOOLEAN,
                  value: false,
                  loc: this.loc(token)
                };
              case "null":
                return {
                  kind: Kind.NULL,
                  loc: this.loc(token)
                };
              default:
                return {
                  kind: Kind.ENUM,
                  value: token.value,
                  loc: this.loc(token)
                };
            }
          case TokenKind.DOLLAR:
            if (!isConst) {
              return this.parseVariable();
            }
            break;
        }
        throw this.unexpected();
      };
      _proto.parseStringLiteral = function parseStringLiteral() {
        var token = this._lexer.token;
        this._lexer.advance();
        return {
          kind: Kind.STRING,
          value: token.value,
          block: token.kind === TokenKind.BLOCK_STRING,
          loc: this.loc(token)
        };
      };
      _proto.parseList = function parseList(isConst) {
        var _this = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this.parseValueLiteral(isConst);
        };
        return {
          kind: Kind.LIST,
          values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObject = function parseObject(isConst) {
        var _this2 = this;
        var start = this._lexer.token;
        var item = function item2() {
          return _this2.parseObjectField(isConst);
        };
        return {
          kind: Kind.OBJECT,
          fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R),
          loc: this.loc(start)
        };
      };
      _proto.parseObjectField = function parseObjectField(isConst) {
        var start = this._lexer.token;
        var name2 = this.parseName();
        this.expectToken(TokenKind.COLON);
        return {
          kind: Kind.OBJECT_FIELD,
          name: name2,
          value: this.parseValueLiteral(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseDirectives = function parseDirectives(isConst) {
        var directives = [];
        while (this.peek(TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      };
      _proto.parseDirective = function parseDirective(isConst) {
        var start = this._lexer.token;
        this.expectToken(TokenKind.AT);
        return {
          kind: Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeReference = function parseTypeReference() {
        var start = this._lexer.token;
        var type2;
        if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
          type2 = this.parseTypeReference();
          this.expectToken(TokenKind.BRACKET_R);
          type2 = {
            kind: Kind.LIST_TYPE,
            type: type2,
            loc: this.loc(start)
          };
        } else {
          type2 = this.parseNamedType();
        }
        if (this.expectOptionalToken(TokenKind.BANG)) {
          return {
            kind: Kind.NON_NULL_TYPE,
            type: type2,
            loc: this.loc(start)
          };
        }
        return type2;
      };
      _proto.parseNamedType = function parseNamedType() {
        var start = this._lexer.token;
        return {
          kind: Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(start)
        };
      };
      _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
        var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.peekDescription = function peekDescription() {
        return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
      };
      _proto.parseDescription = function parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      };
      _proto.parseSchemaDefinition = function parseSchemaDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.many(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
        return {
          kind: Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
        var start = this._lexer.token;
        var operation = this.parseOperationType();
        this.expectToken(TokenKind.COLON);
        var type2 = this.parseNamedType();
        return {
          kind: Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type: type2,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("scalar");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.SCALAR_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("type");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseFieldsDefinition();
        return {
          kind: Kind.OBJECT_TYPE_DEFINITION,
          description,
          name: name2,
          interfaces,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
        var _this$_options2;
        if (!this.expectOptionalKeyword("implements")) {
          return [];
        }
        if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
          var types = [];
          this.expectOptionalToken(TokenKind.AMP);
          do {
            types.push(this.parseNamedType());
          } while (this.expectOptionalToken(TokenKind.AMP) || this.peek(TokenKind.NAME));
          return types;
        }
        return this.delimitedMany(TokenKind.AMP, this.parseNamedType);
      };
      _proto.parseFieldsDefinition = function parseFieldsDefinition() {
        var _this$_options3;
        if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(TokenKind.BRACE_L) && this._lexer.lookahead().kind === TokenKind.BRACE_R) {
          this._lexer.advance();
          this._lexer.advance();
          return [];
        }
        return this.optionalMany(TokenKind.BRACE_L, this.parseFieldDefinition, TokenKind.BRACE_R);
      };
      _proto.parseFieldDefinition = function parseFieldDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        var args = this.parseArgumentDefs();
        this.expectToken(TokenKind.COLON);
        var type2 = this.parseTypeReference();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.FIELD_DEFINITION,
          description,
          name: name2,
          arguments: args,
          type: type2,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseArgumentDefs = function parseArgumentDefs() {
        return this.optionalMany(TokenKind.PAREN_L, this.parseInputValueDef, TokenKind.PAREN_R);
      };
      _proto.parseInputValueDef = function parseInputValueDef() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        this.expectToken(TokenKind.COLON);
        var type2 = this.parseTypeReference();
        var defaultValue;
        if (this.expectOptionalToken(TokenKind.EQUALS)) {
          defaultValue = this.parseValueLiteral(true);
        }
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.INPUT_VALUE_DEFINITION,
          description,
          name: name2,
          type: type2,
          defaultValue,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("interface");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseFieldsDefinition();
        return {
          kind: Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name: name2,
          interfaces,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("union");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        return {
          kind: Kind.UNION_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          types,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
        return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
      };
      _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("enum");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        return {
          kind: Kind.ENUM_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
        return this.optionalMany(TokenKind.BRACE_L, this.parseEnumValueDefinition, TokenKind.BRACE_R);
      };
      _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: Kind.ENUM_VALUE_DEFINITION,
          description,
          name: name2,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("input");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseInputFieldsDefinition();
        return {
          kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
        return this.optionalMany(TokenKind.BRACE_L, this.parseInputValueDef, TokenKind.BRACE_R);
      };
      _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
        var keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.parseSchemaExtension = function parseSchemaExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.optionalMany(TokenKind.BRACE_L, this.parseOperationTypeDefinition, TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes,
          loc: this.loc(start)
        };
      };
      _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.SCALAR_TYPE_EXTENSION,
          name: name2,
          directives,
          loc: this.loc(start)
        };
      };
      _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields7.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.OBJECT_TYPE_EXTENSION,
          name: name2,
          interfaces,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields7.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.INTERFACE_TYPE_EXTENSION,
          name: name2,
          interfaces,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.UNION_TYPE_EXTENSION,
          name: name2,
          directives,
          types,
          loc: this.loc(start)
        };
      };
      _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var values = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.ENUM_TYPE_EXTENSION,
          name: name2,
          directives,
          values,
          loc: this.loc(start)
        };
      };
      _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
        var start = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var fields7 = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields7.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name: name2,
          directives,
          fields: fields7,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
        var start = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(TokenKind.AT);
        var name2 = this.parseName();
        var args = this.parseArgumentDefs();
        var repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        var locations = this.parseDirectiveLocations();
        return {
          kind: Kind.DIRECTIVE_DEFINITION,
          description,
          name: name2,
          arguments: args,
          repeatable,
          locations,
          loc: this.loc(start)
        };
      };
      _proto.parseDirectiveLocations = function parseDirectiveLocations() {
        return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
      };
      _proto.parseDirectiveLocation = function parseDirectiveLocation() {
        var start = this._lexer.token;
        var name2 = this.parseName();
        if (DirectiveLocation[name2.value] !== void 0) {
          return name2;
        }
        throw this.unexpected(start);
      };
      _proto.loc = function loc(startToken) {
        var _this$_options4;
        if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
          return new Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
      };
      _proto.peek = function peek(kind) {
        return this._lexer.token.kind === kind;
      };
      _proto.expectToken = function expectToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        throw syntaxError(this._lexer.source, token.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token), "."));
      };
      _proto.expectOptionalToken = function expectOptionalToken(kind) {
        var token = this._lexer.token;
        if (token.kind === kind) {
          this._lexer.advance();
          return token;
        }
        return void 0;
      };
      _proto.expectKeyword = function expectKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this._lexer.advance();
        } else {
          throw syntaxError(this._lexer.source, token.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token), "."));
        }
      };
      _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
        var token = this._lexer.token;
        if (token.kind === TokenKind.NAME && token.value === value) {
          this._lexer.advance();
          return true;
        }
        return false;
      };
      _proto.unexpected = function unexpected(atToken) {
        var token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return syntaxError(this._lexer.source, token.start, "Unexpected ".concat(getTokenDesc(token), "."));
      };
      _proto.any = function any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      };
      _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          var nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      };
      _proto.many = function many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      };
      _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      };
      return Parser2;
    }();
  }
});

// node_modules/graphql/language/visitor.mjs
function visit(root, visitor) {
  var visitorKeys = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : QueryDocumentKeys;
  var stack = void 0;
  var inArray = Array.isArray(root);
  var keys = [root];
  var index = -1;
  var edits = [];
  var node = void 0;
  var key = void 0;
  var parent = void 0;
  var path = [];
  var ancestors = [];
  var newRoot = root;
  do {
    index++;
    var isLeaving = index === keys.length;
    var isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
        } else {
          var clone = {};
          for (var _i2 = 0, _Object$keys2 = Object.keys(node); _i2 < _Object$keys2.length; _i2++) {
            var k = _Object$keys2[_i2];
            clone[k] = node[k];
          }
          node = clone;
        }
        var editOffset = 0;
        for (var ii = 0; ii < edits.length; ii++) {
          var editKey = edits[ii][0];
          var editValue = edits[ii][1];
          if (inArray) {
            editKey -= editOffset;
          }
          if (inArray && editValue === null) {
            node.splice(editKey, 1);
            editOffset++;
          } else {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else {
      key = parent ? inArray ? index : keys[index] : void 0;
      node = parent ? parent[key] : newRoot;
      if (node === null || node === void 0) {
        continue;
      }
      if (parent) {
        path.push(key);
      }
    }
    var result = void 0;
    if (!Array.isArray(node)) {
      if (!isNode(node)) {
        throw new Error("Invalid AST Node: ".concat(inspect(node), "."));
      }
      var visitFn = getVisitFn(visitor, node.kind, isLeaving);
      if (visitFn) {
        result = visitFn.call(visitor, node, key, parent, path, ancestors);
        if (result === BREAK) {
          break;
        }
        if (result === false) {
          if (!isLeaving) {
            path.pop();
            continue;
          }
        } else if (result !== void 0) {
          edits.push([key, result]);
          if (!isLeaving) {
            if (isNode(result)) {
              node = result;
            } else {
              path.pop();
              continue;
            }
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _visitorKeys$node$kin;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_visitorKeys$node$kin = visitorKeys[node.kind]) !== null && _visitorKeys$node$kin !== void 0 ? _visitorKeys$node$kin : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    newRoot = edits[edits.length - 1][1];
  }
  return newRoot;
}
function visitInParallel(visitors) {
  var skipping = new Array(visitors.length);
  return {
    enter: function enter(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind, false);
          if (fn) {
            var result = fn.apply(visitors[i], arguments);
            if (result === false) {
              skipping[i] = node;
            } else if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0) {
              return result;
            }
          }
        }
      }
    },
    leave: function leave(node) {
      for (var i = 0; i < visitors.length; i++) {
        if (skipping[i] == null) {
          var fn = getVisitFn(visitors[i], node.kind, true);
          if (fn) {
            var result = fn.apply(visitors[i], arguments);
            if (result === BREAK) {
              skipping[i] = BREAK;
            } else if (result !== void 0 && result !== false) {
              return result;
            }
          }
        } else if (skipping[i] === node) {
          skipping[i] = null;
        }
      }
    }
  };
}
function getVisitFn(visitor, kind, isLeaving) {
  var kindVisitor = visitor[kind];
  if (kindVisitor) {
    if (!isLeaving && typeof kindVisitor === "function") {
      return kindVisitor;
    }
    var kindSpecificVisitor = isLeaving ? kindVisitor.leave : kindVisitor.enter;
    if (typeof kindSpecificVisitor === "function") {
      return kindSpecificVisitor;
    }
  } else {
    var specificVisitor = isLeaving ? visitor.leave : visitor.enter;
    if (specificVisitor) {
      if (typeof specificVisitor === "function") {
        return specificVisitor;
      }
      var specificKindVisitor = specificVisitor[kind];
      if (typeof specificKindVisitor === "function") {
        return specificKindVisitor;
      }
    }
  }
}
var QueryDocumentKeys, BREAK;
var init_visitor = __esm({
  "node_modules/graphql/language/visitor.mjs"() {
    init_define_process_env();
    init_inspect();
    init_ast();
    QueryDocumentKeys = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: [
        "name",
        "variableDefinitions",
        "typeCondition",
        "directives",
        "selectionSet"
      ],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
      InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"]
    };
    BREAK = Object.freeze({});
  }
});

// node_modules/graphql/polyfills/find.mjs
var find, find_default;
var init_find = __esm({
  "node_modules/graphql/polyfills/find.mjs"() {
    init_define_process_env();
    find = Array.prototype.find ? function(list2, predicate) {
      return Array.prototype.find.call(list2, predicate);
    } : function(list2, predicate) {
      for (var _i2 = 0; _i2 < list2.length; _i2++) {
        var value = list2[_i2];
        if (predicate(value)) {
          return value;
        }
      }
    };
    find_default = find;
  }
});

// node_modules/graphql/polyfills/objectValues.mjs
var objectValues, objectValues_default;
var init_objectValues = __esm({
  "node_modules/graphql/polyfills/objectValues.mjs"() {
    init_define_process_env();
    objectValues = Object.values || function(obj) {
      return Object.keys(obj).map(function(key) {
        return obj[key];
      });
    };
    objectValues_default = objectValues;
  }
});

// node_modules/graphql/error/locatedError.mjs
function locatedError(rawOriginalError, nodes, path) {
  var _nodes;
  var originalError = rawOriginalError instanceof Error ? rawOriginalError : new Error("Unexpected error value: " + inspect(rawOriginalError));
  if (Array.isArray(originalError.path)) {
    return originalError;
  }
  return new GraphQLError(originalError.message, (_nodes = originalError.nodes) !== null && _nodes !== void 0 ? _nodes : nodes, originalError.source, originalError.positions, path, originalError);
}
var init_locatedError = __esm({
  "node_modules/graphql/error/locatedError.mjs"() {
    init_define_process_env();
    init_inspect();
    init_GraphQLError();
  }
});

// node_modules/graphql/utilities/assertValidName.mjs
function assertValidName(name2) {
  var error2 = isValidNameError(name2);
  if (error2) {
    throw error2;
  }
  return name2;
}
function isValidNameError(name2) {
  typeof name2 === "string" || devAssert(0, "Expected name to be a string.");
  if (name2.length > 1 && name2[0] === "_" && name2[1] === "_") {
    return new GraphQLError('Name "'.concat(name2, '" must not begin with "__", which is reserved by GraphQL introspection.'));
  }
  if (!NAME_RX.test(name2)) {
    return new GraphQLError('Names must match /^[_a-zA-Z][_a-zA-Z0-9]*$/ but "'.concat(name2, '" does not.'));
  }
}
var NAME_RX;
var init_assertValidName = __esm({
  "node_modules/graphql/utilities/assertValidName.mjs"() {
    init_define_process_env();
    init_devAssert();
    init_GraphQLError();
    NAME_RX = /^[_a-zA-Z][_a-zA-Z0-9]*$/;
  }
});

// node_modules/graphql/polyfills/objectEntries.mjs
var objectEntries, objectEntries_default;
var init_objectEntries = __esm({
  "node_modules/graphql/polyfills/objectEntries.mjs"() {
    init_define_process_env();
    objectEntries = Object.entries || function(obj) {
      return Object.keys(obj).map(function(key) {
        return [key, obj[key]];
      });
    };
    objectEntries_default = objectEntries;
  }
});

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list2, keyFn) {
  return list2.reduce(function(map2, item) {
    map2[keyFn(item)] = item;
    return map2;
  }, Object.create(null));
}
var init_keyMap = __esm({
  "node_modules/graphql/jsutils/keyMap.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map2, fn) {
  var result = Object.create(null);
  for (var _i2 = 0, _objectEntries2 = objectEntries_default(map2); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var _key = _ref2[0];
    var _value = _ref2[1];
    result[_key] = fn(_value, _key);
  }
  return result;
}
var init_mapValue = __esm({
  "node_modules/graphql/jsutils/mapValue.mjs"() {
    init_define_process_env();
    init_objectEntries();
  }
});

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  var map2 = Object.create(null);
  for (var _i2 = 0, _objectEntries2 = objectEntries_default(obj); _i2 < _objectEntries2.length; _i2++) {
    var _ref2 = _objectEntries2[_i2];
    var key = _ref2[0];
    var value = _ref2[1];
    map2[key] = value;
  }
  return map2;
}
var init_toObjMap = __esm({
  "node_modules/graphql/jsutils/toObjMap.mjs"() {
    init_define_process_env();
    init_objectEntries();
  }
});

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list2, keyFn, valFn) {
  return list2.reduce(function(map2, item) {
    map2[keyFn(item)] = valFn(item);
    return map2;
  }, Object.create(null));
}
var init_keyValMap = __esm({
  "node_modules/graphql/jsutils/keyValMap.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/didYouMean.mjs
function didYouMean(firstArg, secondArg) {
  var _ref = typeof firstArg === "string" ? [firstArg, secondArg] : [void 0, firstArg], subMessage = _ref[0], suggestionsArg = _ref[1];
  var message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  var suggestions = suggestionsArg.map(function(x) {
    return '"'.concat(x, '"');
  });
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  var selected = suggestions.slice(0, MAX_SUGGESTIONS);
  var lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
var MAX_SUGGESTIONS;
var init_didYouMean = __esm({
  "node_modules/graphql/jsutils/didYouMean.mjs"() {
    init_define_process_env();
    MAX_SUGGESTIONS = 5;
  }
});

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x) {
  return x;
}
var init_identityFunc = __esm({
  "node_modules/graphql/jsutils/identityFunc.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  var aIdx = 0;
  var bIdx = 0;
  while (aIdx < aStr.length && bIdx < bStr.length) {
    var aChar = aStr.charCodeAt(aIdx);
    var bChar = bStr.charCodeAt(bIdx);
    if (isDigit(aChar) && isDigit(bChar)) {
      var aNum = 0;
      do {
        ++aIdx;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIdx);
      } while (isDigit(aChar) && aNum > 0);
      var bNum = 0;
      do {
        ++bIdx;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIdx);
      } while (isDigit(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIdx;
      ++bIdx;
    }
  }
  return aStr.length - bStr.length;
}
function isDigit(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}
var DIGIT_0, DIGIT_9;
var init_naturalCompare = __esm({
  "node_modules/graphql/jsutils/naturalCompare.mjs"() {
    init_define_process_env();
    DIGIT_0 = 48;
    DIGIT_9 = 57;
  }
});

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  var optionsByDistance = Object.create(null);
  var lexicalDistance2 = new LexicalDistance(input);
  var threshold = Math.floor(input.length * 0.4) + 1;
  for (var _i2 = 0; _i2 < options.length; _i2++) {
    var option = options[_i2];
    var distance = lexicalDistance2.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort(function(a, b) {
    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);
  });
}
function stringToArray(str) {
  var strLength = str.length;
  var array = new Array(strLength);
  for (var i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
var LexicalDistance;
var init_suggestionList = __esm({
  "node_modules/graphql/jsutils/suggestionList.mjs"() {
    init_define_process_env();
    init_naturalCompare();
    LexicalDistance = function() {
      function LexicalDistance2(input) {
        this._input = input;
        this._inputLowerCase = input.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];
      }
      var _proto = LexicalDistance2.prototype;
      _proto.measure = function measure(option, threshold) {
        if (this._input === option) {
          return 0;
        }
        var optionLowerCase = option.toLowerCase();
        if (this._inputLowerCase === optionLowerCase) {
          return 1;
        }
        var a = stringToArray(optionLowerCase);
        var b = this._inputArray;
        if (a.length < b.length) {
          var tmp = a;
          a = b;
          b = tmp;
        }
        var aLength = a.length;
        var bLength = b.length;
        if (aLength - bLength > threshold) {
          return void 0;
        }
        var rows = this._rows;
        for (var j = 0; j <= bLength; j++) {
          rows[0][j] = j;
        }
        for (var i = 1; i <= aLength; i++) {
          var upRow = rows[(i - 1) % 3];
          var currentRow = rows[i % 3];
          var smallestCell = currentRow[0] = i;
          for (var _j = 1; _j <= bLength; _j++) {
            var cost = a[i - 1] === b[_j - 1] ? 0 : 1;
            var currentCell = Math.min(upRow[_j] + 1, currentRow[_j - 1] + 1, upRow[_j - 1] + cost);
            if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {
              var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];
              currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
            }
            if (currentCell < smallestCell) {
              smallestCell = currentCell;
            }
            currentRow[_j] = currentCell;
          }
          if (smallestCell > threshold) {
            return void 0;
          }
        }
        var distance = rows[aLength % 3][bLength];
        return distance <= threshold ? distance : void 0;
      };
      return LexicalDistance2;
    }();
  }
});

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, {
    leave: printDocASTReducer
  });
}
function addDescription(cb) {
  return function(node) {
    return join([node.description, cb(node)], "\n");
  };
}
function join(maybeArray) {
  var _maybeArray$filter$jo;
  var separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter(function(x) {
    return x;
  }).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString) {
  var end = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function isMultiline(str) {
  return str.indexOf("\n") !== -1;
}
function hasMultilineItems(maybeArray) {
  return maybeArray != null && maybeArray.some(isMultiline);
}
var MAX_LINE_LENGTH, printDocASTReducer;
var init_printer = __esm({
  "node_modules/graphql/language/printer.mjs"() {
    init_define_process_env();
    init_visitor();
    init_blockString();
    MAX_LINE_LENGTH = 80;
    printDocASTReducer = {
      Name: function Name(node) {
        return node.value;
      },
      Variable: function Variable(node) {
        return "$" + node.name;
      },
      Document: function Document(node) {
        return join(node.definitions, "\n\n") + "\n";
      },
      OperationDefinition: function OperationDefinition(node) {
        var op = node.operation;
        var name2 = node.name;
        var varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
        var directives = join(node.directives, " ");
        var selectionSet = node.selectionSet;
        return !name2 && !directives && !varDefs && op === "query" ? selectionSet : join([op, join([name2, varDefs]), directives, selectionSet], " ");
      },
      VariableDefinition: function VariableDefinition(_ref) {
        var variable = _ref.variable, type2 = _ref.type, defaultValue = _ref.defaultValue, directives = _ref.directives;
        return variable + ": " + type2 + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "));
      },
      SelectionSet: function SelectionSet(_ref2) {
        var selections = _ref2.selections;
        return block(selections);
      },
      Field: function Field(_ref3) {
        var alias = _ref3.alias, name2 = _ref3.name, args = _ref3.arguments, directives = _ref3.directives, selectionSet = _ref3.selectionSet;
        var prefix = wrap("", alias, ": ") + name2;
        var argsLine = prefix + wrap("(", join(args, ", "), ")");
        if (argsLine.length > MAX_LINE_LENGTH) {
          argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
        }
        return join([argsLine, join(directives, " "), selectionSet], " ");
      },
      Argument: function Argument(_ref4) {
        var name2 = _ref4.name, value = _ref4.value;
        return name2 + ": " + value;
      },
      FragmentSpread: function FragmentSpread(_ref5) {
        var name2 = _ref5.name, directives = _ref5.directives;
        return "..." + name2 + wrap(" ", join(directives, " "));
      },
      InlineFragment: function InlineFragment(_ref6) {
        var typeCondition = _ref6.typeCondition, directives = _ref6.directives, selectionSet = _ref6.selectionSet;
        return join(["...", wrap("on ", typeCondition), join(directives, " "), selectionSet], " ");
      },
      FragmentDefinition: function FragmentDefinition(_ref7) {
        var name2 = _ref7.name, typeCondition = _ref7.typeCondition, variableDefinitions = _ref7.variableDefinitions, directives = _ref7.directives, selectionSet = _ref7.selectionSet;
        return "fragment ".concat(name2).concat(wrap("(", join(variableDefinitions, ", "), ")"), " ") + "on ".concat(typeCondition, " ").concat(wrap("", join(directives, " "), " ")) + selectionSet;
      },
      IntValue: function IntValue(_ref8) {
        var value = _ref8.value;
        return value;
      },
      FloatValue: function FloatValue(_ref9) {
        var value = _ref9.value;
        return value;
      },
      StringValue: function StringValue(_ref10, key) {
        var value = _ref10.value, isBlockString = _ref10.block;
        return isBlockString ? printBlockString(value, key === "description" ? "" : "  ") : JSON.stringify(value);
      },
      BooleanValue: function BooleanValue(_ref11) {
        var value = _ref11.value;
        return value ? "true" : "false";
      },
      NullValue: function NullValue() {
        return "null";
      },
      EnumValue: function EnumValue(_ref12) {
        var value = _ref12.value;
        return value;
      },
      ListValue: function ListValue(_ref13) {
        var values = _ref13.values;
        return "[" + join(values, ", ") + "]";
      },
      ObjectValue: function ObjectValue(_ref14) {
        var fields7 = _ref14.fields;
        return "{" + join(fields7, ", ") + "}";
      },
      ObjectField: function ObjectField(_ref15) {
        var name2 = _ref15.name, value = _ref15.value;
        return name2 + ": " + value;
      },
      Directive: function Directive(_ref16) {
        var name2 = _ref16.name, args = _ref16.arguments;
        return "@" + name2 + wrap("(", join(args, ", "), ")");
      },
      NamedType: function NamedType(_ref17) {
        var name2 = _ref17.name;
        return name2;
      },
      ListType: function ListType(_ref18) {
        var type2 = _ref18.type;
        return "[" + type2 + "]";
      },
      NonNullType: function NonNullType(_ref19) {
        var type2 = _ref19.type;
        return type2 + "!";
      },
      SchemaDefinition: addDescription(function(_ref20) {
        var directives = _ref20.directives, operationTypes = _ref20.operationTypes;
        return join(["schema", join(directives, " "), block(operationTypes)], " ");
      }),
      OperationTypeDefinition: function OperationTypeDefinition(_ref21) {
        var operation = _ref21.operation, type2 = _ref21.type;
        return operation + ": " + type2;
      },
      ScalarTypeDefinition: addDescription(function(_ref22) {
        var name2 = _ref22.name, directives = _ref22.directives;
        return join(["scalar", name2, join(directives, " ")], " ");
      }),
      ObjectTypeDefinition: addDescription(function(_ref23) {
        var name2 = _ref23.name, interfaces = _ref23.interfaces, directives = _ref23.directives, fields7 = _ref23.fields;
        return join(["type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields7)], " ");
      }),
      FieldDefinition: addDescription(function(_ref24) {
        var name2 = _ref24.name, args = _ref24.arguments, type2 = _ref24.type, directives = _ref24.directives;
        return name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " "));
      }),
      InputValueDefinition: addDescription(function(_ref25) {
        var name2 = _ref25.name, type2 = _ref25.type, defaultValue = _ref25.defaultValue, directives = _ref25.directives;
        return join([name2 + ": " + type2, wrap("= ", defaultValue), join(directives, " ")], " ");
      }),
      InterfaceTypeDefinition: addDescription(function(_ref26) {
        var name2 = _ref26.name, interfaces = _ref26.interfaces, directives = _ref26.directives, fields7 = _ref26.fields;
        return join(["interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields7)], " ");
      }),
      UnionTypeDefinition: addDescription(function(_ref27) {
        var name2 = _ref27.name, directives = _ref27.directives, types = _ref27.types;
        return join(["union", name2, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      }),
      EnumTypeDefinition: addDescription(function(_ref28) {
        var name2 = _ref28.name, directives = _ref28.directives, values = _ref28.values;
        return join(["enum", name2, join(directives, " "), block(values)], " ");
      }),
      EnumValueDefinition: addDescription(function(_ref29) {
        var name2 = _ref29.name, directives = _ref29.directives;
        return join([name2, join(directives, " ")], " ");
      }),
      InputObjectTypeDefinition: addDescription(function(_ref30) {
        var name2 = _ref30.name, directives = _ref30.directives, fields7 = _ref30.fields;
        return join(["input", name2, join(directives, " "), block(fields7)], " ");
      }),
      DirectiveDefinition: addDescription(function(_ref31) {
        var name2 = _ref31.name, args = _ref31.arguments, repeatable = _ref31.repeatable, locations = _ref31.locations;
        return "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ");
      }),
      SchemaExtension: function SchemaExtension(_ref32) {
        var directives = _ref32.directives, operationTypes = _ref32.operationTypes;
        return join(["extend schema", join(directives, " "), block(operationTypes)], " ");
      },
      ScalarTypeExtension: function ScalarTypeExtension(_ref33) {
        var name2 = _ref33.name, directives = _ref33.directives;
        return join(["extend scalar", name2, join(directives, " ")], " ");
      },
      ObjectTypeExtension: function ObjectTypeExtension(_ref34) {
        var name2 = _ref34.name, interfaces = _ref34.interfaces, directives = _ref34.directives, fields7 = _ref34.fields;
        return join(["extend type", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields7)], " ");
      },
      InterfaceTypeExtension: function InterfaceTypeExtension(_ref35) {
        var name2 = _ref35.name, interfaces = _ref35.interfaces, directives = _ref35.directives, fields7 = _ref35.fields;
        return join(["extend interface", name2, wrap("implements ", join(interfaces, " & ")), join(directives, " "), block(fields7)], " ");
      },
      UnionTypeExtension: function UnionTypeExtension(_ref36) {
        var name2 = _ref36.name, directives = _ref36.directives, types = _ref36.types;
        return join(["extend union", name2, join(directives, " "), types && types.length !== 0 ? "= " + join(types, " | ") : ""], " ");
      },
      EnumTypeExtension: function EnumTypeExtension(_ref37) {
        var name2 = _ref37.name, directives = _ref37.directives, values = _ref37.values;
        return join(["extend enum", name2, join(directives, " "), block(values)], " ");
      },
      InputObjectTypeExtension: function InputObjectTypeExtension(_ref38) {
        var name2 = _ref38.name, directives = _ref38.directives, fields7 = _ref38.fields;
        return join(["extend input", name2, join(directives, " "), block(fields7)], " ");
      }
    };
  }
});

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(function(node) {
        return valueFromASTUntyped(node, variables);
      });
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, function(field) {
        return field.name.value;
      }, function(field) {
        return valueFromASTUntyped(field.value, variables);
      });
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
  invariant(0, "Unexpected value node: " + inspect(valueNode));
}
var init_valueFromASTUntyped = __esm({
  "node_modules/graphql/utilities/valueFromASTUntyped.mjs"() {
    init_define_process_env();
    init_inspect();
    init_invariant();
    init_keyValMap();
    init_kinds();
  }
});

// node_modules/graphql/type/definition.mjs
function _defineProperties3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties3(Constructor, staticProps);
  return Constructor;
}
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
function assertType(type2) {
  if (!isType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL type."));
  }
  return type2;
}
function isScalarType(type2) {
  return instanceOf_default(type2, GraphQLScalarType);
}
function assertScalarType(type2) {
  if (!isScalarType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Scalar type."));
  }
  return type2;
}
function isObjectType(type2) {
  return instanceOf_default(type2, GraphQLObjectType);
}
function assertObjectType(type2) {
  if (!isObjectType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Object type."));
  }
  return type2;
}
function isInterfaceType(type2) {
  return instanceOf_default(type2, GraphQLInterfaceType);
}
function assertInterfaceType(type2) {
  if (!isInterfaceType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Interface type."));
  }
  return type2;
}
function isUnionType(type2) {
  return instanceOf_default(type2, GraphQLUnionType);
}
function assertUnionType(type2) {
  if (!isUnionType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Union type."));
  }
  return type2;
}
function isEnumType(type2) {
  return instanceOf_default(type2, GraphQLEnumType);
}
function assertEnumType(type2) {
  if (!isEnumType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Enum type."));
  }
  return type2;
}
function isInputObjectType(type2) {
  return instanceOf_default(type2, GraphQLInputObjectType);
}
function assertInputObjectType(type2) {
  if (!isInputObjectType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Input Object type."));
  }
  return type2;
}
function isListType(type2) {
  return instanceOf_default(type2, GraphQLList);
}
function assertListType(type2) {
  if (!isListType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL List type."));
  }
  return type2;
}
function isNonNullType(type2) {
  return instanceOf_default(type2, GraphQLNonNull);
}
function assertNonNullType(type2) {
  if (!isNonNullType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL Non-Null type."));
  }
  return type2;
}
function isInputType(type2) {
  return isScalarType(type2) || isEnumType(type2) || isInputObjectType(type2) || isWrappingType(type2) && isInputType(type2.ofType);
}
function assertInputType(type2) {
  if (!isInputType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL input type."));
  }
  return type2;
}
function isOutputType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isWrappingType(type2) && isOutputType(type2.ofType);
}
function assertOutputType(type2) {
  if (!isOutputType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL output type."));
  }
  return type2;
}
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
function assertLeafType(type2) {
  if (!isLeafType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL leaf type."));
  }
  return type2;
}
function isCompositeType(type2) {
  return isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2);
}
function assertCompositeType(type2) {
  if (!isCompositeType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL composite type."));
  }
  return type2;
}
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
function assertAbstractType(type2) {
  if (!isAbstractType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL abstract type."));
  }
  return type2;
}
function GraphQLList(ofType) {
  if (this instanceof GraphQLList) {
    this.ofType = assertType(ofType);
  } else {
    return new GraphQLList(ofType);
  }
}
function GraphQLNonNull(ofType) {
  if (this instanceof GraphQLNonNull) {
    this.ofType = assertNullableType(ofType);
  } else {
    return new GraphQLNonNull(ofType);
  }
}
function isWrappingType(type2) {
  return isListType(type2) || isNonNullType(type2);
}
function assertWrappingType(type2) {
  if (!isWrappingType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL wrapping type."));
  }
  return type2;
}
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
function assertNullableType(type2) {
  if (!isNullableType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL nullable type."));
  }
  return type2;
}
function getNullableType(type2) {
  if (type2) {
    return isNonNullType(type2) ? type2.ofType : type2;
  }
}
function isNamedType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2);
}
function assertNamedType(type2) {
  if (!isNamedType(type2)) {
    throw new Error("Expected ".concat(inspect(type2), " to be a GraphQL named type."));
  }
  return type2;
}
function getNamedType(type2) {
  if (type2) {
    var unwrappedType = type2;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function undefineIfEmpty(arr) {
  return arr && arr.length > 0 ? arr : void 0;
}
function defineInterfaces(config) {
  var _resolveThunk;
  var interfaces = (_resolveThunk = resolveThunk(config.interfaces)) !== null && _resolveThunk !== void 0 ? _resolveThunk : [];
  Array.isArray(interfaces) || devAssert(0, "".concat(config.name, " interfaces must be an Array or a function which returns an Array."));
  return interfaces;
}
function defineFieldMap(config) {
  var fieldMap = resolveThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function(fieldConfig, fieldName) {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field config must be an object."));
    !("isDeprecated" in fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, ' should provide "deprecationReason" instead of "isDeprecated".'));
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field resolver must be a function if ") + "provided, but got: ".concat(inspect(fieldConfig.resolve), "."));
    var argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " args must be an object with argument names as keys."));
    var args = objectEntries_default(argsConfig).map(function(_ref) {
      var argName = _ref[0], argConfig = _ref[1];
      return {
        name: argName,
        description: argConfig.description,
        type: argConfig.type,
        defaultValue: argConfig.defaultValue,
        deprecationReason: argConfig.deprecationReason,
        extensions: argConfig.extensions && toObjMap(argConfig.extensions),
        astNode: argConfig.astNode
      };
    });
    return {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      args,
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      isDeprecated: fieldConfig.deprecationReason != null,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields7) {
  return mapValue(fields7, function(field) {
    return {
      description: field.description,
      type: field.type,
      args: argsToArgsConfig(field.args),
      resolve: field.resolve,
      subscribe: field.subscribe,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    };
  });
}
function argsToArgsConfig(args) {
  return keyValMap(args, function(arg) {
    return arg.name;
  }, function(arg) {
    return {
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    };
  });
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
function defineTypes(config) {
  var types = resolveThunk(config.types);
  Array.isArray(types) || devAssert(0, "Must provide Array of types or a function which returns such an array for Union ".concat(config.name, "."));
  return types;
}
function didYouMeanEnumValue(enumType, unknownValueStr) {
  var allNames = enumType.getValues().map(function(value) {
    return value.name;
  });
  var suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(0, "".concat(typeName, " values must be an object with value names as keys."));
  return objectEntries_default(valueMap).map(function(_ref2) {
    var valueName = _ref2[0], valueConfig = _ref2[1];
    isPlainObj(valueConfig) || devAssert(0, "".concat(typeName, ".").concat(valueName, ' must refer to an object with a "value" key ') + "representing an internal value but got: ".concat(inspect(valueConfig), "."));
    !("isDeprecated" in valueConfig) || devAssert(0, "".concat(typeName, ".").concat(valueName, ' should provide "deprecationReason" instead of "isDeprecated".'));
    return {
      name: valueName,
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      isDeprecated: valueConfig.deprecationReason != null,
      deprecationReason: valueConfig.deprecationReason,
      extensions: valueConfig.extensions && toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
function defineInputFieldMap(config) {
  var fieldMap = resolveThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(0, "".concat(config.name, " fields must be an object with field names as keys or a function which returns such an object."));
  return mapValue(fieldMap, function(fieldConfig, fieldName) {
    !("resolve" in fieldConfig) || devAssert(0, "".concat(config.name, ".").concat(fieldName, " field has a resolve property, but Input Types cannot define resolvers."));
    return {
      name: fieldName,
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: fieldConfig.extensions && toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}
var GraphQLScalarType, GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType;
var init_definition = __esm({
  "node_modules/graphql/type/definition.mjs"() {
    init_define_process_env();
    init_objectEntries();
    init_symbols();
    init_inspect();
    init_keyMap();
    init_mapValue();
    init_toObjMap();
    init_devAssert();
    init_keyValMap();
    init_instanceOf();
    init_didYouMean();
    init_isObjectLike();
    init_identityFunc();
    init_defineInspect();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_valueFromASTUntyped();
    GraphQLList.prototype.toString = function toString() {
      return "[" + String(this.ofType) + "]";
    };
    GraphQLList.prototype.toJSON = function toJSON() {
      return this.toString();
    };
    Object.defineProperty(GraphQLList.prototype, SYMBOL_TO_STRING_TAG, {
      get: function get() {
        return "GraphQLList";
      }
    });
    defineInspect(GraphQLList);
    GraphQLNonNull.prototype.toString = function toString2() {
      return String(this.ofType) + "!";
    };
    GraphQLNonNull.prototype.toJSON = function toJSON2() {
      return this.toString();
    };
    Object.defineProperty(GraphQLNonNull.prototype, SYMBOL_TO_STRING_TAG, {
      get: function get2() {
        return "GraphQLNonNull";
      }
    });
    defineInspect(GraphQLNonNull);
    GraphQLScalarType = function() {
      function GraphQLScalarType2(config) {
        var _config$parseValue, _config$serialize, _config$parseLiteral;
        var parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
        this.name = config.name;
        this.description = config.description;
        this.specifiedByUrl = config.specifiedByUrl;
        this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
        this.parseValue = parseValue2;
        this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : function(node, variables) {
          return parseValue2(valueFromASTUntyped(node, variables));
        };
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        typeof config.name === "string" || devAssert(0, "Must provide name.");
        config.specifiedByUrl == null || typeof config.specifiedByUrl === "string" || devAssert(0, "".concat(this.name, ' must provide "specifiedByUrl" as a string, ') + "but got: ".concat(inspect(config.specifiedByUrl), "."));
        config.serialize == null || typeof config.serialize === "function" || devAssert(0, "".concat(this.name, ' must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.'));
        if (config.parseLiteral) {
          typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(0, "".concat(this.name, ' must provide both "parseValue" and "parseLiteral" functions.'));
        }
      }
      var _proto = GraphQLScalarType2.prototype;
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          name: this.name,
          description: this.description,
          specifiedByUrl: this.specifiedByUrl,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : []
        };
      };
      _proto.toString = function toString3() {
        return this.name;
      };
      _proto.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLScalarType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLScalarType";
        }
      }]);
      return GraphQLScalarType2;
    }();
    defineInspect(GraphQLScalarType);
    GraphQLObjectType = function() {
      function GraphQLObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.isTypeOf = config.isTypeOf;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || devAssert(0, "Must provide name.");
        config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(0, "".concat(this.name, ' must provide "isTypeOf" as a function, ') + "but got: ".concat(inspect(config.isTypeOf), "."));
      }
      var _proto2 = GraphQLObjectType2.prototype;
      _proto2.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto2.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto2.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes || []
        };
      };
      _proto2.toString = function toString3() {
        return this.name;
      };
      _proto2.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLObjectType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLObjectType";
        }
      }]);
      return GraphQLObjectType2;
    }();
    defineInspect(GraphQLObjectType);
    GraphQLInterfaceType = function() {
      function GraphQLInterfaceType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineFieldMap.bind(void 0, config);
        this._interfaces = defineInterfaces.bind(void 0, config);
        typeof config.name === "string" || devAssert(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(inspect(config.resolveType), "."));
      }
      var _proto3 = GraphQLInterfaceType2.prototype;
      _proto3.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto3.getInterfaces = function getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      };
      _proto3.toConfig = function toConfig() {
        var _this$extensionASTNod2;
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod2 = this.extensionASTNodes) !== null && _this$extensionASTNod2 !== void 0 ? _this$extensionASTNod2 : []
        };
      };
      _proto3.toString = function toString3() {
        return this.name;
      };
      _proto3.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLInterfaceType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLInterfaceType";
        }
      }]);
      return GraphQLInterfaceType2;
    }();
    defineInspect(GraphQLInterfaceType);
    GraphQLUnionType = function() {
      function GraphQLUnionType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.resolveType = config.resolveType;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._types = defineTypes.bind(void 0, config);
        typeof config.name === "string" || devAssert(0, "Must provide name.");
        config.resolveType == null || typeof config.resolveType === "function" || devAssert(0, "".concat(this.name, ' must provide "resolveType" as a function, ') + "but got: ".concat(inspect(config.resolveType), "."));
      }
      var _proto4 = GraphQLUnionType2.prototype;
      _proto4.getTypes = function getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      };
      _proto4.toConfig = function toConfig() {
        var _this$extensionASTNod3;
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod3 = this.extensionASTNodes) !== null && _this$extensionASTNod3 !== void 0 ? _this$extensionASTNod3 : []
        };
      };
      _proto4.toString = function toString3() {
        return this.name;
      };
      _proto4.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLUnionType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLUnionType";
        }
      }]);
      return GraphQLUnionType2;
    }();
    defineInspect(GraphQLUnionType);
    GraphQLEnumType = function() {
      function GraphQLEnumType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._values = defineEnumValues(this.name, config.values);
        this._valueLookup = new Map(this._values.map(function(enumValue) {
          return [enumValue.value, enumValue];
        }));
        this._nameLookup = keyMap(this._values, function(value) {
          return value.name;
        });
        typeof config.name === "string" || devAssert(0, "Must provide name.");
      }
      var _proto5 = GraphQLEnumType2.prototype;
      _proto5.getValues = function getValues() {
        return this._values;
      };
      _proto5.getValue = function getValue(name2) {
        return this._nameLookup[name2];
      };
      _proto5.serialize = function serialize(outputValue) {
        var enumValue = this._valueLookup.get(outputValue);
        if (enumValue === void 0) {
          throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent value: ').concat(inspect(outputValue)));
        }
        return enumValue.name;
      };
      _proto5.parseValue = function parseValue2(inputValue) {
        if (typeof inputValue !== "string") {
          var valueStr = inspect(inputValue);
          throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent non-string value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr));
        }
        var enumValue = this.getValue(inputValue);
        if (enumValue == null) {
          throw new GraphQLError('Value "'.concat(inputValue, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, inputValue));
        }
        return enumValue.value;
      };
      _proto5.parseLiteral = function parseLiteral6(valueNode, _variables) {
        if (valueNode.kind !== Kind.ENUM) {
          var valueStr = print(valueNode);
          throw new GraphQLError('Enum "'.concat(this.name, '" cannot represent non-enum value: ').concat(valueStr, ".") + didYouMeanEnumValue(this, valueStr), valueNode);
        }
        var enumValue = this.getValue(valueNode.value);
        if (enumValue == null) {
          var _valueStr = print(valueNode);
          throw new GraphQLError('Value "'.concat(_valueStr, '" does not exist in "').concat(this.name, '" enum.') + didYouMeanEnumValue(this, _valueStr), valueNode);
        }
        return enumValue.value;
      };
      _proto5.toConfig = function toConfig() {
        var _this$extensionASTNod4;
        var values = keyValMap(this.getValues(), function(value) {
          return value.name;
        }, function(value) {
          return {
            description: value.description,
            value: value.value,
            deprecationReason: value.deprecationReason,
            extensions: value.extensions,
            astNode: value.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          values,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod4 = this.extensionASTNodes) !== null && _this$extensionASTNod4 !== void 0 ? _this$extensionASTNod4 : []
        };
      };
      _proto5.toString = function toString3() {
        return this.name;
      };
      _proto5.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLEnumType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLEnumType";
        }
      }]);
      return GraphQLEnumType2;
    }();
    defineInspect(GraphQLEnumType);
    GraphQLInputObjectType = function() {
      function GraphQLInputObjectType2(config) {
        this.name = config.name;
        this.description = config.description;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = undefineIfEmpty(config.extensionASTNodes);
        this._fields = defineInputFieldMap.bind(void 0, config);
        typeof config.name === "string" || devAssert(0, "Must provide name.");
      }
      var _proto6 = GraphQLInputObjectType2.prototype;
      _proto6.getFields = function getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      };
      _proto6.toConfig = function toConfig() {
        var _this$extensionASTNod5;
        var fields7 = mapValue(this.getFields(), function(field) {
          return {
            description: field.description,
            type: field.type,
            defaultValue: field.defaultValue,
            deprecationReason: field.deprecationReason,
            extensions: field.extensions,
            astNode: field.astNode
          };
        });
        return {
          name: this.name,
          description: this.description,
          fields: fields7,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod5 = this.extensionASTNodes) !== null && _this$extensionASTNod5 !== void 0 ? _this$extensionASTNod5 : []
        };
      };
      _proto6.toString = function toString3() {
        return this.name;
      };
      _proto6.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass3(GraphQLInputObjectType2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLInputObjectType";
        }
      }]);
      return GraphQLInputObjectType2;
    }();
    defineInspect(GraphQLInputObjectType);
  }
});

// node_modules/graphql/utilities/typeComparators.mjs
function isEqualType(typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isNonNullType(typeA) && isNonNullType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  if (isListType(typeA) && isListType(typeB)) {
    return isEqualType(typeA.ofType, typeB.ofType);
  }
  return false;
}
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some(function(type2) {
        return schema.isSubType(typeB, type2);
      });
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}
var init_typeComparators = __esm({
  "node_modules/graphql/utilities/typeComparators.mjs"() {
    init_define_process_env();
    init_definition();
  }
});

// node_modules/graphql/polyfills/arrayFrom.mjs
var arrayFrom, arrayFrom_default;
var init_arrayFrom = __esm({
  "node_modules/graphql/polyfills/arrayFrom.mjs"() {
    init_define_process_env();
    init_symbols();
    arrayFrom = Array.from || function(obj, mapFn, thisArg) {
      if (obj == null) {
        throw new TypeError("Array.from requires an array-like object - not null or undefined");
      }
      var iteratorMethod = obj[SYMBOL_ITERATOR];
      if (typeof iteratorMethod === "function") {
        var iterator = iteratorMethod.call(obj);
        var result = [];
        var step;
        for (var i = 0; !(step = iterator.next()).done; ++i) {
          result.push(mapFn.call(thisArg, step.value, i));
          if (i > 9999999) {
            throw new TypeError("Near-infinite iteration.");
          }
        }
        return result;
      }
      var length = obj.length;
      if (typeof length === "number" && length >= 0 && length % 1 === 0) {
        var _result = [];
        for (var _i = 0; _i < length; ++_i) {
          if (Object.prototype.hasOwnProperty.call(obj, _i)) {
            _result.push(mapFn.call(thisArg, obj[_i], _i));
          }
        }
        return _result;
      }
      return [];
    };
    arrayFrom_default = arrayFrom;
  }
});

// node_modules/graphql/polyfills/isFinite.mjs
var isFinitePolyfill, isFinite_default;
var init_isFinite = __esm({
  "node_modules/graphql/polyfills/isFinite.mjs"() {
    init_define_process_env();
    isFinitePolyfill = Number.isFinite || function(value) {
      return typeof value === "number" && isFinite(value);
    };
    isFinite_default = isFinitePolyfill;
  }
});

// node_modules/graphql/jsutils/safeArrayFrom.mjs
function _typeof5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof5 = function _typeof6(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof5 = function _typeof6(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof5(obj);
}
function safeArrayFrom(collection) {
  var mapFn = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : function(item) {
    return item;
  };
  if (collection == null || _typeof5(collection) !== "object") {
    return null;
  }
  if (Array.isArray(collection)) {
    return collection.map(mapFn);
  }
  var iteratorMethod = collection[SYMBOL_ITERATOR];
  if (typeof iteratorMethod === "function") {
    var iterator = iteratorMethod.call(collection);
    var result = [];
    var step;
    for (var i = 0; !(step = iterator.next()).done; ++i) {
      result.push(mapFn(step.value, i));
    }
    return result;
  }
  var length = collection.length;
  if (typeof length === "number" && length >= 0 && length % 1 === 0) {
    var _result = [];
    for (var _i = 0; _i < length; ++_i) {
      if (!Object.prototype.hasOwnProperty.call(collection, _i)) {
        return null;
      }
      _result.push(mapFn(collection[String(_i)], _i));
    }
    return _result;
  }
  return null;
}
var init_safeArrayFrom = __esm({
  "node_modules/graphql/jsutils/safeArrayFrom.mjs"() {
    init_define_process_env();
    init_symbols();
  }
});

// node_modules/graphql/polyfills/isInteger.mjs
var isInteger, isInteger_default;
var init_isInteger = __esm({
  "node_modules/graphql/polyfills/isInteger.mjs"() {
    init_define_process_env();
    isInteger = Number.isInteger || function(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    isInteger_default = isInteger;
  }
});

// node_modules/graphql/type/scalars.mjs
function serializeInt(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue ? 1 : 0;
  }
  var num = coercedValue;
  if (typeof coercedValue === "string" && coercedValue !== "") {
    num = Number(coercedValue);
  }
  if (!isInteger_default(num)) {
    throw new GraphQLError("Int cannot represent non-integer value: ".concat(inspect(coercedValue)));
  }
  if (num > MAX_INT || num < MIN_INT) {
    throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
  }
  return num;
}
function coerceInt(inputValue) {
  if (!isInteger_default(inputValue)) {
    throw new GraphQLError("Int cannot represent non-integer value: ".concat(inspect(inputValue)));
  }
  if (inputValue > MAX_INT || inputValue < MIN_INT) {
    throw new GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(inputValue));
  }
  return inputValue;
}
function serializeFloat(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue ? 1 : 0;
  }
  var num = coercedValue;
  if (typeof coercedValue === "string" && coercedValue !== "") {
    num = Number(coercedValue);
  }
  if (!isFinite_default(num)) {
    throw new GraphQLError("Float cannot represent non numeric value: ".concat(inspect(coercedValue)));
  }
  return num;
}
function coerceFloat(inputValue) {
  if (!isFinite_default(inputValue)) {
    throw new GraphQLError("Float cannot represent non numeric value: ".concat(inspect(inputValue)));
  }
  return inputValue;
}
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      var valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
function serializeString(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "string") {
    return coercedValue;
  }
  if (typeof coercedValue === "boolean") {
    return coercedValue ? "true" : "false";
  }
  if (isFinite_default(coercedValue)) {
    return coercedValue.toString();
  }
  throw new GraphQLError("String cannot represent value: ".concat(inspect(outputValue)));
}
function coerceString(inputValue) {
  if (typeof inputValue !== "string") {
    throw new GraphQLError("String cannot represent a non string value: ".concat(inspect(inputValue)));
  }
  return inputValue;
}
function serializeBoolean(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "boolean") {
    return coercedValue;
  }
  if (isFinite_default(coercedValue)) {
    return coercedValue !== 0;
  }
  throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(inspect(coercedValue)));
}
function coerceBoolean(inputValue) {
  if (typeof inputValue !== "boolean") {
    throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(inspect(inputValue)));
  }
  return inputValue;
}
function serializeID(outputValue) {
  var coercedValue = serializeObject(outputValue);
  if (typeof coercedValue === "string") {
    return coercedValue;
  }
  if (isInteger_default(coercedValue)) {
    return String(coercedValue);
  }
  throw new GraphQLError("ID cannot represent value: ".concat(inspect(outputValue)));
}
function coerceID(inputValue) {
  if (typeof inputValue === "string") {
    return inputValue;
  }
  if (isInteger_default(inputValue)) {
    return inputValue.toString();
  }
  throw new GraphQLError("ID cannot represent value: ".concat(inspect(inputValue)));
}
function isSpecifiedScalarType(type2) {
  return specifiedScalarTypes.some(function(_ref) {
    var name2 = _ref.name;
    return type2.name === name2;
  });
}
var MAX_INT, MIN_INT, GraphQLInt, GraphQLFloat, GraphQLString, GraphQLBoolean, GraphQLID, specifiedScalarTypes;
var init_scalars = __esm({
  "node_modules/graphql/type/scalars.mjs"() {
    init_define_process_env();
    init_isFinite();
    init_isInteger();
    init_inspect();
    init_isObjectLike();
    init_kinds();
    init_printer();
    init_GraphQLError();
    init_definition();
    MAX_INT = 2147483647;
    MIN_INT = -2147483648;
    GraphQLInt = new GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize: serializeInt,
      parseValue: coerceInt,
      parseLiteral: function parseLiteral(valueNode) {
        if (valueNode.kind !== Kind.INT) {
          throw new GraphQLError("Int cannot represent non-integer value: ".concat(print(valueNode)), valueNode);
        }
        var num = parseInt(valueNode.value, 10);
        if (num > MAX_INT || num < MIN_INT) {
          throw new GraphQLError("Int cannot represent non 32-bit signed integer value: ".concat(valueNode.value), valueNode);
        }
        return num;
      }
    });
    GraphQLFloat = new GraphQLScalarType({
      name: "Float",
      description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize: serializeFloat,
      parseValue: coerceFloat,
      parseLiteral: function parseLiteral2(valueNode) {
        if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
          throw new GraphQLError("Float cannot represent non numeric value: ".concat(print(valueNode)), valueNode);
        }
        return parseFloat(valueNode.value);
      }
    });
    GraphQLString = new GraphQLScalarType({
      name: "String",
      description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize: serializeString,
      parseValue: coerceString,
      parseLiteral: function parseLiteral3(valueNode) {
        if (valueNode.kind !== Kind.STRING) {
          throw new GraphQLError("String cannot represent a non string value: ".concat(print(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    GraphQLBoolean = new GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize: serializeBoolean,
      parseValue: coerceBoolean,
      parseLiteral: function parseLiteral4(valueNode) {
        if (valueNode.kind !== Kind.BOOLEAN) {
          throw new GraphQLError("Boolean cannot represent a non boolean value: ".concat(print(valueNode)), valueNode);
        }
        return valueNode.value;
      }
    });
    GraphQLID = new GraphQLScalarType({
      name: "ID",
      description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize: serializeID,
      parseValue: coerceID,
      parseLiteral: function parseLiteral5(valueNode) {
        if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
          throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), valueNode);
        }
        return valueNode.value;
      }
    });
    specifiedScalarTypes = Object.freeze([GraphQLString, GraphQLInt, GraphQLFloat, GraphQLBoolean, GraphQLID]);
  }
});

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type2) {
  if (isNonNullType(type2)) {
    var astValue = astFromValue(value, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    var items = safeArrayFrom(value);
    if (items != null) {
      var valuesNodes = [];
      for (var _i2 = 0; _i2 < items.length; _i2++) {
        var item = items[_i2];
        var itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value)) {
      return null;
    }
    var fieldNodes = [];
    for (var _i4 = 0, _objectValues2 = objectValues_default(type2.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    var serialized = type2.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && isFinite_default(serialized)) {
      var stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError("Cannot convert value to AST: ".concat(inspect(serialized), "."));
  }
  invariant(0, "Unexpected input type: " + inspect(type2));
}
var integerStringRegExp;
var init_astFromValue = __esm({
  "node_modules/graphql/utilities/astFromValue.mjs"() {
    init_define_process_env();
    init_isFinite();
    init_objectValues();
    init_inspect();
    init_invariant();
    init_isObjectLike();
    init_safeArrayFrom();
    init_kinds();
    init_scalars();
    init_definition();
    integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
  }
});

// node_modules/graphql/type/introspection.mjs
var introspection_exports = {};
__export(introspection_exports, {
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  introspectionTypes: () => introspectionTypes,
  isIntrospectionType: () => isIntrospectionType
});
function isIntrospectionType(type2) {
  return introspectionTypes.some(function(_ref11) {
    var name2 = _ref11.name;
    return type2.name === name2;
  });
}
var __Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, TypeKind, __TypeKind, SchemaMetaFieldDef, TypeMetaFieldDef, TypeNameMetaFieldDef, introspectionTypes;
var init_introspection = __esm({
  "node_modules/graphql/type/introspection.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_inspect();
    init_invariant();
    init_printer();
    init_directiveLocation();
    init_astFromValue();
    init_scalars();
    init_definition();
    __Schema = new GraphQLObjectType({
      name: "__Schema",
      description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: function fields() {
        return {
          description: {
            type: GraphQLString,
            resolve: function resolve4(schema) {
              return schema.description;
            }
          },
          types: {
            description: "A list of all types supported by this server.",
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
            resolve: function resolve4(schema) {
              return objectValues_default(schema.getTypeMap());
            }
          },
          queryType: {
            description: "The type that query operations will be rooted at.",
            type: new GraphQLNonNull(__Type),
            resolve: function resolve4(schema) {
              return schema.getQueryType();
            }
          },
          mutationType: {
            description: "If this server supports mutation, the type that mutation operations will be rooted at.",
            type: __Type,
            resolve: function resolve4(schema) {
              return schema.getMutationType();
            }
          },
          subscriptionType: {
            description: "If this server support subscription, the type that subscription operations will be rooted at.",
            type: __Type,
            resolve: function resolve4(schema) {
              return schema.getSubscriptionType();
            }
          },
          directives: {
            description: "A list of all directives supported by this server.",
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
            resolve: function resolve4(schema) {
              return schema.getDirectives();
            }
          }
        };
      }
    });
    __Directive = new GraphQLObjectType({
      name: "__Directive",
      description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: function fields2() {
        return {
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: function resolve4(directive) {
              return directive.name;
            }
          },
          description: {
            type: GraphQLString,
            resolve: function resolve4(directive) {
              return directive.description;
            }
          },
          isRepeatable: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: function resolve4(directive) {
              return directive.isRepeatable;
            }
          },
          locations: {
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
            resolve: function resolve4(directive) {
              return directive.locations;
            }
          },
          args: {
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve4(field, _ref) {
              var includeDeprecated = _ref.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          }
        };
      }
    });
    __DirectiveLocation = new GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: {
          value: DirectiveLocation.QUERY,
          description: "Location adjacent to a query operation."
        },
        MUTATION: {
          value: DirectiveLocation.MUTATION,
          description: "Location adjacent to a mutation operation."
        },
        SUBSCRIPTION: {
          value: DirectiveLocation.SUBSCRIPTION,
          description: "Location adjacent to a subscription operation."
        },
        FIELD: {
          value: DirectiveLocation.FIELD,
          description: "Location adjacent to a field."
        },
        FRAGMENT_DEFINITION: {
          value: DirectiveLocation.FRAGMENT_DEFINITION,
          description: "Location adjacent to a fragment definition."
        },
        FRAGMENT_SPREAD: {
          value: DirectiveLocation.FRAGMENT_SPREAD,
          description: "Location adjacent to a fragment spread."
        },
        INLINE_FRAGMENT: {
          value: DirectiveLocation.INLINE_FRAGMENT,
          description: "Location adjacent to an inline fragment."
        },
        VARIABLE_DEFINITION: {
          value: DirectiveLocation.VARIABLE_DEFINITION,
          description: "Location adjacent to a variable definition."
        },
        SCHEMA: {
          value: DirectiveLocation.SCHEMA,
          description: "Location adjacent to a schema definition."
        },
        SCALAR: {
          value: DirectiveLocation.SCALAR,
          description: "Location adjacent to a scalar definition."
        },
        OBJECT: {
          value: DirectiveLocation.OBJECT,
          description: "Location adjacent to an object type definition."
        },
        FIELD_DEFINITION: {
          value: DirectiveLocation.FIELD_DEFINITION,
          description: "Location adjacent to a field definition."
        },
        ARGUMENT_DEFINITION: {
          value: DirectiveLocation.ARGUMENT_DEFINITION,
          description: "Location adjacent to an argument definition."
        },
        INTERFACE: {
          value: DirectiveLocation.INTERFACE,
          description: "Location adjacent to an interface definition."
        },
        UNION: {
          value: DirectiveLocation.UNION,
          description: "Location adjacent to a union definition."
        },
        ENUM: {
          value: DirectiveLocation.ENUM,
          description: "Location adjacent to an enum definition."
        },
        ENUM_VALUE: {
          value: DirectiveLocation.ENUM_VALUE,
          description: "Location adjacent to an enum value definition."
        },
        INPUT_OBJECT: {
          value: DirectiveLocation.INPUT_OBJECT,
          description: "Location adjacent to an input object type definition."
        },
        INPUT_FIELD_DEFINITION: {
          value: DirectiveLocation.INPUT_FIELD_DEFINITION,
          description: "Location adjacent to an input object field definition."
        }
      }
    });
    __Type = new GraphQLObjectType({
      name: "__Type",
      description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByUrl`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: function fields3() {
        return {
          kind: {
            type: new GraphQLNonNull(__TypeKind),
            resolve: function resolve4(type2) {
              if (isScalarType(type2)) {
                return TypeKind.SCALAR;
              }
              if (isObjectType(type2)) {
                return TypeKind.OBJECT;
              }
              if (isInterfaceType(type2)) {
                return TypeKind.INTERFACE;
              }
              if (isUnionType(type2)) {
                return TypeKind.UNION;
              }
              if (isEnumType(type2)) {
                return TypeKind.ENUM;
              }
              if (isInputObjectType(type2)) {
                return TypeKind.INPUT_OBJECT;
              }
              if (isListType(type2)) {
                return TypeKind.LIST;
              }
              if (isNonNullType(type2)) {
                return TypeKind.NON_NULL;
              }
              invariant(0, 'Unexpected type: "'.concat(inspect(type2), '".'));
            }
          },
          name: {
            type: GraphQLString,
            resolve: function resolve4(type2) {
              return type2.name !== void 0 ? type2.name : void 0;
            }
          },
          description: {
            type: GraphQLString,
            resolve: function resolve4(type2) {
              return type2.description !== void 0 ? type2.description : void 0;
            }
          },
          specifiedByUrl: {
            type: GraphQLString,
            resolve: function resolve4(obj) {
              return obj.specifiedByUrl !== void 0 ? obj.specifiedByUrl : void 0;
            }
          },
          fields: {
            type: new GraphQLList(new GraphQLNonNull(__Field)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve4(type2, _ref2) {
              var includeDeprecated = _ref2.includeDeprecated;
              if (isObjectType(type2) || isInterfaceType(type2)) {
                var fields7 = objectValues_default(type2.getFields());
                return includeDeprecated ? fields7 : fields7.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          interfaces: {
            type: new GraphQLList(new GraphQLNonNull(__Type)),
            resolve: function resolve4(type2) {
              if (isObjectType(type2) || isInterfaceType(type2)) {
                return type2.getInterfaces();
              }
            }
          },
          possibleTypes: {
            type: new GraphQLList(new GraphQLNonNull(__Type)),
            resolve: function resolve4(type2, _args, _context, _ref3) {
              var schema = _ref3.schema;
              if (isAbstractType(type2)) {
                return schema.getPossibleTypes(type2);
              }
            }
          },
          enumValues: {
            type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve4(type2, _ref4) {
              var includeDeprecated = _ref4.includeDeprecated;
              if (isEnumType(type2)) {
                var values = type2.getValues();
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          inputFields: {
            type: new GraphQLList(new GraphQLNonNull(__InputValue)),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve4(type2, _ref5) {
              var includeDeprecated = _ref5.includeDeprecated;
              if (isInputObjectType(type2)) {
                var values = objectValues_default(type2.getFields());
                return includeDeprecated ? values : values.filter(function(field) {
                  return field.deprecationReason == null;
                });
              }
            }
          },
          ofType: {
            type: __Type,
            resolve: function resolve4(type2) {
              return type2.ofType !== void 0 ? type2.ofType : void 0;
            }
          }
        };
      }
    });
    __Field = new GraphQLObjectType({
      name: "__Field",
      description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: function fields4() {
        return {
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: function resolve4(field) {
              return field.name;
            }
          },
          description: {
            type: GraphQLString,
            resolve: function resolve4(field) {
              return field.description;
            }
          },
          args: {
            type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
            args: {
              includeDeprecated: {
                type: GraphQLBoolean,
                defaultValue: false
              }
            },
            resolve: function resolve4(field, _ref6) {
              var includeDeprecated = _ref6.includeDeprecated;
              return includeDeprecated ? field.args : field.args.filter(function(arg) {
                return arg.deprecationReason == null;
              });
            }
          },
          type: {
            type: new GraphQLNonNull(__Type),
            resolve: function resolve4(field) {
              return field.type;
            }
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: function resolve4(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: function resolve4(field) {
              return field.deprecationReason;
            }
          }
        };
      }
    });
    __InputValue = new GraphQLObjectType({
      name: "__InputValue",
      description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: function fields5() {
        return {
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: function resolve4(inputValue) {
              return inputValue.name;
            }
          },
          description: {
            type: GraphQLString,
            resolve: function resolve4(inputValue) {
              return inputValue.description;
            }
          },
          type: {
            type: new GraphQLNonNull(__Type),
            resolve: function resolve4(inputValue) {
              return inputValue.type;
            }
          },
          defaultValue: {
            type: GraphQLString,
            description: "A GraphQL-formatted string representing the default value for this input value.",
            resolve: function resolve4(inputValue) {
              var type2 = inputValue.type, defaultValue = inputValue.defaultValue;
              var valueAST = astFromValue(defaultValue, type2);
              return valueAST ? print(valueAST) : null;
            }
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: function resolve4(field) {
              return field.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: function resolve4(obj) {
              return obj.deprecationReason;
            }
          }
        };
      }
    });
    __EnumValue = new GraphQLObjectType({
      name: "__EnumValue",
      description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: function fields6() {
        return {
          name: {
            type: new GraphQLNonNull(GraphQLString),
            resolve: function resolve4(enumValue) {
              return enumValue.name;
            }
          },
          description: {
            type: GraphQLString,
            resolve: function resolve4(enumValue) {
              return enumValue.description;
            }
          },
          isDeprecated: {
            type: new GraphQLNonNull(GraphQLBoolean),
            resolve: function resolve4(enumValue) {
              return enumValue.deprecationReason != null;
            }
          },
          deprecationReason: {
            type: GraphQLString,
            resolve: function resolve4(enumValue) {
              return enumValue.deprecationReason;
            }
          }
        };
      }
    });
    TypeKind = Object.freeze({
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      INPUT_OBJECT: "INPUT_OBJECT",
      LIST: "LIST",
      NON_NULL: "NON_NULL"
    });
    __TypeKind = new GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: {
          value: TypeKind.SCALAR,
          description: "Indicates this type is a scalar."
        },
        OBJECT: {
          value: TypeKind.OBJECT,
          description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
        },
        INTERFACE: {
          value: TypeKind.INTERFACE,
          description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
        },
        UNION: {
          value: TypeKind.UNION,
          description: "Indicates this type is a union. `possibleTypes` is a valid field."
        },
        ENUM: {
          value: TypeKind.ENUM,
          description: "Indicates this type is an enum. `enumValues` is a valid field."
        },
        INPUT_OBJECT: {
          value: TypeKind.INPUT_OBJECT,
          description: "Indicates this type is an input object. `inputFields` is a valid field."
        },
        LIST: {
          value: TypeKind.LIST,
          description: "Indicates this type is a list. `ofType` is a valid field."
        },
        NON_NULL: {
          value: TypeKind.NON_NULL,
          description: "Indicates this type is a non-null. `ofType` is a valid field."
        }
      }
    });
    SchemaMetaFieldDef = {
      name: "__schema",
      type: new GraphQLNonNull(__Schema),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: function resolve(_source, _args, _context, _ref7) {
        var schema = _ref7.schema;
        return schema;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    TypeMetaFieldDef = {
      name: "__type",
      type: __Type,
      description: "Request the type information of a single type.",
      args: [{
        name: "name",
        description: void 0,
        type: new GraphQLNonNull(GraphQLString),
        defaultValue: void 0,
        deprecationReason: void 0,
        extensions: void 0,
        astNode: void 0
      }],
      resolve: function resolve2(_source, _ref8, _context, _ref9) {
        var name2 = _ref8.name;
        var schema = _ref9.schema;
        return schema.getType(name2);
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    TypeNameMetaFieldDef = {
      name: "__typename",
      type: new GraphQLNonNull(GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: function resolve3(_source, _args, _context, _ref10) {
        var parentType = _ref10.parentType;
        return parentType.name;
      },
      isDeprecated: false,
      deprecationReason: void 0,
      extensions: void 0,
      astNode: void 0
    };
    introspectionTypes = Object.freeze([__Schema, __Directive, __DirectiveLocation, __Type, __Field, __InputValue, __EnumValue, __TypeKind]);
  }
});

// node_modules/graphql/type/directives.mjs
function _defineProperties4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties4(Constructor, staticProps);
  return Constructor;
}
function isDirective(directive) {
  return instanceOf_default(directive, GraphQLDirective);
}
function assertDirective(directive) {
  if (!isDirective(directive)) {
    throw new Error("Expected ".concat(inspect(directive), " to be a GraphQL directive."));
  }
  return directive;
}
function isSpecifiedDirective(directive) {
  return specifiedDirectives.some(function(_ref2) {
    var name2 = _ref2.name;
    return name2 === directive.name;
  });
}
var GraphQLDirective, GraphQLIncludeDirective, GraphQLSkipDirective, DEFAULT_DEPRECATION_REASON, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective, specifiedDirectives;
var init_directives = __esm({
  "node_modules/graphql/type/directives.mjs"() {
    init_define_process_env();
    init_objectEntries();
    init_symbols();
    init_inspect();
    init_toObjMap();
    init_devAssert();
    init_instanceOf();
    init_isObjectLike();
    init_defineInspect();
    init_directiveLocation();
    init_scalars();
    init_definition();
    GraphQLDirective = function() {
      function GraphQLDirective2(config) {
        var _config$isRepeatable, _config$args;
        this.name = config.name;
        this.description = config.description;
        this.locations = config.locations;
        this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        config.name || devAssert(0, "Directive must be named.");
        Array.isArray(config.locations) || devAssert(0, "@".concat(config.name, " locations must be an Array."));
        var args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
        isObjectLike(args) && !Array.isArray(args) || devAssert(0, "@".concat(config.name, " args must be an object with argument names as keys."));
        this.args = objectEntries_default(args).map(function(_ref) {
          var argName = _ref[0], argConfig = _ref[1];
          return {
            name: argName,
            description: argConfig.description,
            type: argConfig.type,
            defaultValue: argConfig.defaultValue,
            deprecationReason: argConfig.deprecationReason,
            extensions: argConfig.extensions && toObjMap(argConfig.extensions),
            astNode: argConfig.astNode
          };
        });
      }
      var _proto = GraphQLDirective2.prototype;
      _proto.toConfig = function toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: argsToArgsConfig(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode
        };
      };
      _proto.toString = function toString3() {
        return "@" + this.name;
      };
      _proto.toJSON = function toJSON3() {
        return this.toString();
      };
      _createClass4(GraphQLDirective2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLDirective";
        }
      }]);
      return GraphQLDirective2;
    }();
    defineInspect(GraphQLDirective);
    GraphQLIncludeDirective = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Included when true."
        }
      }
    });
    GraphQLSkipDirective = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [DirectiveLocation.FIELD, DirectiveLocation.FRAGMENT_SPREAD, DirectiveLocation.INLINE_FRAGMENT],
      args: {
        if: {
          type: new GraphQLNonNull(GraphQLBoolean),
          description: "Skipped when true."
        }
      }
    });
    DEFAULT_DEPRECATION_REASON = "No longer supported";
    GraphQLDeprecatedDirective = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [DirectiveLocation.FIELD_DEFINITION, DirectiveLocation.ARGUMENT_DEFINITION, DirectiveLocation.INPUT_FIELD_DEFINITION, DirectiveLocation.ENUM_VALUE],
      args: {
        reason: {
          type: GraphQLString,
          description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: DEFAULT_DEPRECATION_REASON
        }
      }
    });
    GraphQLSpecifiedByDirective = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behaviour of this scalar.",
      locations: [DirectiveLocation.SCALAR],
      args: {
        url: {
          type: new GraphQLNonNull(GraphQLString),
          description: "The URL that specifies the behaviour of this scalar."
        }
      }
    });
    specifiedDirectives = Object.freeze([GraphQLIncludeDirective, GraphQLSkipDirective, GraphQLDeprecatedDirective, GraphQLSpecifiedByDirective]);
  }
});

// node_modules/graphql/type/schema.mjs
function _defineProperties5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties5(Constructor, staticProps);
  return Constructor;
}
function isSchema(schema) {
  return instanceOf_default(schema, GraphQLSchema);
}
function assertSchema(schema) {
  if (!isSchema(schema)) {
    throw new Error("Expected ".concat(inspect(schema), " to be a GraphQL schema."));
  }
  return schema;
}
function collectReferencedTypes(type2, typeSet) {
  var namedType = getNamedType(type2);
  if (!typeSet.has(namedType)) {
    typeSet.add(namedType);
    if (isUnionType(namedType)) {
      for (var _i20 = 0, _namedType$getTypes2 = namedType.getTypes(); _i20 < _namedType$getTypes2.length; _i20++) {
        var memberType = _namedType$getTypes2[_i20];
        collectReferencedTypes(memberType, typeSet);
      }
    } else if (isObjectType(namedType) || isInterfaceType(namedType)) {
      for (var _i22 = 0, _namedType$getInterfa6 = namedType.getInterfaces(); _i22 < _namedType$getInterfa6.length; _i22++) {
        var interfaceType = _namedType$getInterfa6[_i22];
        collectReferencedTypes(interfaceType, typeSet);
      }
      for (var _i24 = 0, _objectValues2 = objectValues_default(namedType.getFields()); _i24 < _objectValues2.length; _i24++) {
        var field = _objectValues2[_i24];
        collectReferencedTypes(field.type, typeSet);
        for (var _i26 = 0, _field$args2 = field.args; _i26 < _field$args2.length; _i26++) {
          var arg = _field$args2[_i26];
          collectReferencedTypes(arg.type, typeSet);
        }
      }
    } else if (isInputObjectType(namedType)) {
      for (var _i28 = 0, _objectValues4 = objectValues_default(namedType.getFields()); _i28 < _objectValues4.length; _i28++) {
        var _field = _objectValues4[_i28];
        collectReferencedTypes(_field.type, typeSet);
      }
    }
  }
  return typeSet;
}
var GraphQLSchema;
var init_schema = __esm({
  "node_modules/graphql/type/schema.mjs"() {
    init_define_process_env();
    init_find();
    init_arrayFrom();
    init_objectValues();
    init_symbols();
    init_inspect();
    init_toObjMap();
    init_devAssert();
    init_instanceOf();
    init_isObjectLike();
    init_introspection();
    init_directives();
    init_definition();
    GraphQLSchema = function() {
      function GraphQLSchema2(config) {
        var _config$directives;
        this.__validationErrors = config.assumeValid === true ? [] : void 0;
        isObjectLike(config) || devAssert(0, "Must provide configuration object.");
        !config.types || Array.isArray(config.types) || devAssert(0, '"types" must be Array if provided but got: '.concat(inspect(config.types), "."));
        !config.directives || Array.isArray(config.directives) || devAssert(0, '"directives" must be Array if provided but got: ' + "".concat(inspect(config.directives), "."));
        this.description = config.description;
        this.extensions = config.extensions && toObjMap(config.extensions);
        this.astNode = config.astNode;
        this.extensionASTNodes = config.extensionASTNodes;
        this._queryType = config.query;
        this._mutationType = config.mutation;
        this._subscriptionType = config.subscription;
        this._directives = (_config$directives = config.directives) !== null && _config$directives !== void 0 ? _config$directives : specifiedDirectives;
        var allReferencedTypes = new Set(config.types);
        if (config.types != null) {
          for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
            var type2 = _config$types2[_i2];
            allReferencedTypes.delete(type2);
            collectReferencedTypes(type2, allReferencedTypes);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, allReferencedTypes);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, allReferencedTypes);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, allReferencedTypes);
        }
        for (var _i4 = 0, _this$_directives2 = this._directives; _i4 < _this$_directives2.length; _i4++) {
          var directive = _this$_directives2[_i4];
          if (isDirective(directive)) {
            for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
              var arg = _directive$args2[_i6];
              collectReferencedTypes(arg.type, allReferencedTypes);
            }
          }
        }
        collectReferencedTypes(__Schema, allReferencedTypes);
        this._typeMap = Object.create(null);
        this._subTypeMap = Object.create(null);
        this._implementationsMap = Object.create(null);
        for (var _i8 = 0, _arrayFrom2 = arrayFrom_default(allReferencedTypes); _i8 < _arrayFrom2.length; _i8++) {
          var namedType = _arrayFrom2[_i8];
          if (namedType == null) {
            continue;
          }
          var typeName = namedType.name;
          typeName || devAssert(0, "One of the provided types for building the Schema is missing a name.");
          if (this._typeMap[typeName] !== void 0) {
            throw new Error('Schema must contain uniquely named types but contains multiple types named "'.concat(typeName, '".'));
          }
          this._typeMap[typeName] = namedType;
          if (isInterfaceType(namedType)) {
            for (var _i10 = 0, _namedType$getInterfa2 = namedType.getInterfaces(); _i10 < _namedType$getInterfa2.length; _i10++) {
              var iface = _namedType$getInterfa2[_i10];
              if (isInterfaceType(iface)) {
                var implementations = this._implementationsMap[iface.name];
                if (implementations === void 0) {
                  implementations = this._implementationsMap[iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                implementations.interfaces.push(namedType);
              }
            }
          } else if (isObjectType(namedType)) {
            for (var _i12 = 0, _namedType$getInterfa4 = namedType.getInterfaces(); _i12 < _namedType$getInterfa4.length; _i12++) {
              var _iface = _namedType$getInterfa4[_i12];
              if (isInterfaceType(_iface)) {
                var _implementations = this._implementationsMap[_iface.name];
                if (_implementations === void 0) {
                  _implementations = this._implementationsMap[_iface.name] = {
                    objects: [],
                    interfaces: []
                  };
                }
                _implementations.objects.push(namedType);
              }
            }
          }
        }
      }
      var _proto = GraphQLSchema2.prototype;
      _proto.getQueryType = function getQueryType() {
        return this._queryType;
      };
      _proto.getMutationType = function getMutationType() {
        return this._mutationType;
      };
      _proto.getSubscriptionType = function getSubscriptionType() {
        return this._subscriptionType;
      };
      _proto.getTypeMap = function getTypeMap() {
        return this._typeMap;
      };
      _proto.getType = function getType(name2) {
        return this.getTypeMap()[name2];
      };
      _proto.getPossibleTypes = function getPossibleTypes(abstractType) {
        return isUnionType(abstractType) ? abstractType.getTypes() : this.getImplementations(abstractType).objects;
      };
      _proto.getImplementations = function getImplementations(interfaceType) {
        var implementations = this._implementationsMap[interfaceType.name];
        return implementations !== null && implementations !== void 0 ? implementations : {
          objects: [],
          interfaces: []
        };
      };
      _proto.isPossibleType = function isPossibleType(abstractType, possibleType) {
        return this.isSubType(abstractType, possibleType);
      };
      _proto.isSubType = function isSubType(abstractType, maybeSubType) {
        var map2 = this._subTypeMap[abstractType.name];
        if (map2 === void 0) {
          map2 = Object.create(null);
          if (isUnionType(abstractType)) {
            for (var _i14 = 0, _abstractType$getType2 = abstractType.getTypes(); _i14 < _abstractType$getType2.length; _i14++) {
              var type2 = _abstractType$getType2[_i14];
              map2[type2.name] = true;
            }
          } else {
            var implementations = this.getImplementations(abstractType);
            for (var _i16 = 0, _implementations$obje2 = implementations.objects; _i16 < _implementations$obje2.length; _i16++) {
              var _type = _implementations$obje2[_i16];
              map2[_type.name] = true;
            }
            for (var _i18 = 0, _implementations$inte2 = implementations.interfaces; _i18 < _implementations$inte2.length; _i18++) {
              var _type2 = _implementations$inte2[_i18];
              map2[_type2.name] = true;
            }
          }
          this._subTypeMap[abstractType.name] = map2;
        }
        return map2[maybeSubType.name] !== void 0;
      };
      _proto.getDirectives = function getDirectives() {
        return this._directives;
      };
      _proto.getDirective = function getDirective(name2) {
        return find_default(this.getDirectives(), function(directive) {
          return directive.name === name2;
        });
      };
      _proto.toConfig = function toConfig() {
        var _this$extensionASTNod;
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: objectValues_default(this.getTypeMap()),
          directives: this.getDirectives().slice(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: (_this$extensionASTNod = this.extensionASTNodes) !== null && _this$extensionASTNod !== void 0 ? _this$extensionASTNod : [],
          assumeValid: this.__validationErrors !== void 0
        };
      };
      _createClass5(GraphQLSchema2, [{
        key: SYMBOL_TO_STRING_TAG,
        get: function get3() {
          return "GraphQLSchema";
        }
      }]);
      return GraphQLSchema2;
    }();
  }
});

// node_modules/graphql/type/validate.mjs
function validateSchema(schema) {
  assertSchema(schema);
  if (schema.__validationErrors) {
    return schema.__validationErrors;
  }
  var context = new SchemaValidationContext(schema);
  validateRootTypes(context);
  validateDirectives(context);
  validateTypes(context);
  var errors2 = context.getErrors();
  schema.__validationErrors = errors2;
  return errors2;
}
function assertValidSchema(schema) {
  var errors2 = validateSchema(schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
function validateRootTypes(context) {
  var schema = context.schema;
  var queryType = schema.getQueryType();
  if (!queryType) {
    context.reportError("Query root type must be provided.", schema.astNode);
  } else if (!isObjectType(queryType)) {
    var _getOperationTypeNode;
    context.reportError("Query root type must be Object type, it cannot be ".concat(inspect(queryType), "."), (_getOperationTypeNode = getOperationTypeNode(schema, "query")) !== null && _getOperationTypeNode !== void 0 ? _getOperationTypeNode : queryType.astNode);
  }
  var mutationType = schema.getMutationType();
  if (mutationType && !isObjectType(mutationType)) {
    var _getOperationTypeNode2;
    context.reportError("Mutation root type must be Object type if provided, it cannot be " + "".concat(inspect(mutationType), "."), (_getOperationTypeNode2 = getOperationTypeNode(schema, "mutation")) !== null && _getOperationTypeNode2 !== void 0 ? _getOperationTypeNode2 : mutationType.astNode);
  }
  var subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && !isObjectType(subscriptionType)) {
    var _getOperationTypeNode3;
    context.reportError("Subscription root type must be Object type if provided, it cannot be " + "".concat(inspect(subscriptionType), "."), (_getOperationTypeNode3 = getOperationTypeNode(schema, "subscription")) !== null && _getOperationTypeNode3 !== void 0 ? _getOperationTypeNode3 : subscriptionType.astNode);
  }
}
function getOperationTypeNode(schema, operation) {
  var operationNodes = getAllSubNodes(schema, function(node2) {
    return node2.operationTypes;
  });
  for (var _i2 = 0; _i2 < operationNodes.length; _i2++) {
    var node = operationNodes[_i2];
    if (node.operation === operation) {
      return node.type;
    }
  }
  return void 0;
}
function validateDirectives(context) {
  for (var _i4 = 0, _context$schema$getDi2 = context.schema.getDirectives(); _i4 < _context$schema$getDi2.length; _i4++) {
    var directive = _context$schema$getDi2[_i4];
    if (!isDirective(directive)) {
      context.reportError("Expected directive but got: ".concat(inspect(directive), "."), directive === null || directive === void 0 ? void 0 : directive.astNode);
      continue;
    }
    validateName(context, directive);
    for (var _i6 = 0, _directive$args2 = directive.args; _i6 < _directive$args2.length; _i6++) {
      var arg = _directive$args2[_i6];
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        context.reportError("The type of @".concat(directive.name, "(").concat(arg.name, ":) must be Input Type ") + "but got: ".concat(inspect(arg.type), "."), arg.astNode);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode;
        context.reportError("Required argument @".concat(directive.name, "(").concat(arg.name, ":) cannot be deprecated."), [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode = arg.astNode) === null || _arg$astNode === void 0 ? void 0 : _arg$astNode.type
        ]);
      }
    }
  }
}
function validateName(context, node) {
  var error2 = isValidNameError(node.name);
  if (error2) {
    context.addError(locatedError(error2, node.astNode));
  }
}
function validateTypes(context) {
  var validateInputObjectCircularRefs = createInputObjectCircularRefsValidator(context);
  var typeMap = context.schema.getTypeMap();
  for (var _i8 = 0, _objectValues2 = objectValues_default(typeMap); _i8 < _objectValues2.length; _i8++) {
    var type2 = _objectValues2[_i8];
    if (!isNamedType(type2)) {
      context.reportError("Expected GraphQL named type but got: ".concat(inspect(type2), "."), type2.astNode);
      continue;
    }
    if (!isIntrospectionType(type2)) {
      validateName(context, type2);
    }
    if (isObjectType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isInterfaceType(type2)) {
      validateFields(context, type2);
      validateInterfaces(context, type2);
    } else if (isUnionType(type2)) {
      validateUnionMembers(context, type2);
    } else if (isEnumType(type2)) {
      validateEnumValues(context, type2);
    } else if (isInputObjectType(type2)) {
      validateInputFields(context, type2);
      validateInputObjectCircularRefs(type2);
    }
  }
}
function validateFields(context, type2) {
  var fields7 = objectValues_default(type2.getFields());
  if (fields7.length === 0) {
    context.reportError("Type ".concat(type2.name, " must define one or more fields."), getAllNodes(type2));
  }
  for (var _i10 = 0; _i10 < fields7.length; _i10++) {
    var field = fields7[_i10];
    validateName(context, field);
    if (!isOutputType(field.type)) {
      var _field$astNode;
      context.reportError("The type of ".concat(type2.name, ".").concat(field.name, " must be Output Type ") + "but got: ".concat(inspect(field.type), "."), (_field$astNode = field.astNode) === null || _field$astNode === void 0 ? void 0 : _field$astNode.type);
    }
    for (var _i12 = 0, _field$args2 = field.args; _i12 < _field$args2.length; _i12++) {
      var arg = _field$args2[_i12];
      var argName = arg.name;
      validateName(context, arg);
      if (!isInputType(arg.type)) {
        var _arg$astNode2;
        context.reportError("The type of ".concat(type2.name, ".").concat(field.name, "(").concat(argName, ":) must be Input ") + "Type but got: ".concat(inspect(arg.type), "."), (_arg$astNode2 = arg.astNode) === null || _arg$astNode2 === void 0 ? void 0 : _arg$astNode2.type);
      }
      if (isRequiredArgument(arg) && arg.deprecationReason != null) {
        var _arg$astNode3;
        context.reportError("Required argument ".concat(type2.name, ".").concat(field.name, "(").concat(argName, ":) cannot be deprecated."), [
          getDeprecatedDirectiveNode(arg.astNode),
          (_arg$astNode3 = arg.astNode) === null || _arg$astNode3 === void 0 ? void 0 : _arg$astNode3.type
        ]);
      }
    }
  }
}
function validateInterfaces(context, type2) {
  var ifaceTypeNames = Object.create(null);
  for (var _i14 = 0, _type$getInterfaces2 = type2.getInterfaces(); _i14 < _type$getInterfaces2.length; _i14++) {
    var iface = _type$getInterfaces2[_i14];
    if (!isInterfaceType(iface)) {
      context.reportError("Type ".concat(inspect(type2), " must only implement Interface types, ") + "it cannot implement ".concat(inspect(iface), "."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (type2 === iface) {
      context.reportError("Type ".concat(type2.name, " cannot implement itself because it would create a circular reference."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    if (ifaceTypeNames[iface.name]) {
      context.reportError("Type ".concat(type2.name, " can only implement ").concat(iface.name, " once."), getAllImplementsInterfaceNodes(type2, iface));
      continue;
    }
    ifaceTypeNames[iface.name] = true;
    validateTypeImplementsAncestors(context, type2, iface);
    validateTypeImplementsInterface(context, type2, iface);
  }
}
function validateTypeImplementsInterface(context, type2, iface) {
  var typeFieldMap = type2.getFields();
  for (var _i16 = 0, _objectValues4 = objectValues_default(iface.getFields()); _i16 < _objectValues4.length; _i16++) {
    var ifaceField = _objectValues4[_i16];
    var fieldName = ifaceField.name;
    var typeField = typeFieldMap[fieldName];
    if (!typeField) {
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expected but ").concat(type2.name, " does not provide it."), [ifaceField.astNode].concat(getAllNodes(type2)));
      continue;
    }
    if (!isTypeSubTypeOf(context.schema, typeField.type, ifaceField.type)) {
      var _ifaceField$astNode, _typeField$astNode;
      context.reportError("Interface field ".concat(iface.name, ".").concat(fieldName, " expects type ") + "".concat(inspect(ifaceField.type), " but ").concat(type2.name, ".").concat(fieldName, " ") + "is type ".concat(inspect(typeField.type), "."), [
        (_ifaceField$astNode = ifaceField.astNode) === null || _ifaceField$astNode === void 0 ? void 0 : _ifaceField$astNode.type,
        (_typeField$astNode = typeField.astNode) === null || _typeField$astNode === void 0 ? void 0 : _typeField$astNode.type
      ]);
    }
    var _loop = function _loop3(_i182, _ifaceField$args22) {
      var ifaceArg = _ifaceField$args22[_i182];
      var argName = ifaceArg.name;
      var typeArg = find_default(typeField.args, function(arg) {
        return arg.name === argName;
      });
      if (!typeArg) {
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) expected but ").concat(type2.name, ".").concat(fieldName, " does not provide it."), [ifaceArg.astNode, typeField.astNode]);
        return "continue";
      }
      if (!isEqualType(ifaceArg.type, typeArg.type)) {
        var _ifaceArg$astNode, _typeArg$astNode;
        context.reportError("Interface field argument ".concat(iface.name, ".").concat(fieldName, "(").concat(argName, ":) ") + "expects type ".concat(inspect(ifaceArg.type), " but ") + "".concat(type2.name, ".").concat(fieldName, "(").concat(argName, ":) is type ") + "".concat(inspect(typeArg.type), "."), [
          (_ifaceArg$astNode = ifaceArg.astNode) === null || _ifaceArg$astNode === void 0 ? void 0 : _ifaceArg$astNode.type,
          (_typeArg$astNode = typeArg.astNode) === null || _typeArg$astNode === void 0 ? void 0 : _typeArg$astNode.type
        ]);
      }
    };
    for (var _i18 = 0, _ifaceField$args2 = ifaceField.args; _i18 < _ifaceField$args2.length; _i18++) {
      var _ret = _loop(_i18, _ifaceField$args2);
      if (_ret === "continue")
        continue;
    }
    var _loop2 = function _loop22(_i202, _typeField$args22) {
      var typeArg = _typeField$args22[_i202];
      var argName = typeArg.name;
      var ifaceArg = find_default(ifaceField.args, function(arg) {
        return arg.name === argName;
      });
      if (!ifaceArg && isRequiredArgument(typeArg)) {
        context.reportError("Object field ".concat(type2.name, ".").concat(fieldName, " includes required argument ").concat(argName, " that is missing from the Interface field ").concat(iface.name, ".").concat(fieldName, "."), [typeArg.astNode, ifaceField.astNode]);
      }
    };
    for (var _i20 = 0, _typeField$args2 = typeField.args; _i20 < _typeField$args2.length; _i20++) {
      _loop2(_i20, _typeField$args2);
    }
  }
}
function validateTypeImplementsAncestors(context, type2, iface) {
  var ifaceInterfaces = type2.getInterfaces();
  for (var _i22 = 0, _iface$getInterfaces2 = iface.getInterfaces(); _i22 < _iface$getInterfaces2.length; _i22++) {
    var transitive = _iface$getInterfaces2[_i22];
    if (ifaceInterfaces.indexOf(transitive) === -1) {
      context.reportError(transitive === type2 ? "Type ".concat(type2.name, " cannot implement ").concat(iface.name, " because it would create a circular reference.") : "Type ".concat(type2.name, " must implement ").concat(transitive.name, " because it is implemented by ").concat(iface.name, "."), [].concat(getAllImplementsInterfaceNodes(iface, transitive), getAllImplementsInterfaceNodes(type2, iface)));
    }
  }
}
function validateUnionMembers(context, union) {
  var memberTypes = union.getTypes();
  if (memberTypes.length === 0) {
    context.reportError("Union type ".concat(union.name, " must define one or more member types."), getAllNodes(union));
  }
  var includedTypeNames = Object.create(null);
  for (var _i24 = 0; _i24 < memberTypes.length; _i24++) {
    var memberType = memberTypes[_i24];
    if (includedTypeNames[memberType.name]) {
      context.reportError("Union type ".concat(union.name, " can only include type ").concat(memberType.name, " once."), getUnionMemberTypeNodes(union, memberType.name));
      continue;
    }
    includedTypeNames[memberType.name] = true;
    if (!isObjectType(memberType)) {
      context.reportError("Union type ".concat(union.name, " can only include Object types, ") + "it cannot include ".concat(inspect(memberType), "."), getUnionMemberTypeNodes(union, String(memberType)));
    }
  }
}
function validateEnumValues(context, enumType) {
  var enumValues = enumType.getValues();
  if (enumValues.length === 0) {
    context.reportError("Enum type ".concat(enumType.name, " must define one or more values."), getAllNodes(enumType));
  }
  for (var _i26 = 0; _i26 < enumValues.length; _i26++) {
    var enumValue = enumValues[_i26];
    var valueName = enumValue.name;
    validateName(context, enumValue);
    if (valueName === "true" || valueName === "false" || valueName === "null") {
      context.reportError("Enum type ".concat(enumType.name, " cannot include value: ").concat(valueName, "."), enumValue.astNode);
    }
  }
}
function validateInputFields(context, inputObj) {
  var fields7 = objectValues_default(inputObj.getFields());
  if (fields7.length === 0) {
    context.reportError("Input Object type ".concat(inputObj.name, " must define one or more fields."), getAllNodes(inputObj));
  }
  for (var _i28 = 0; _i28 < fields7.length; _i28++) {
    var field = fields7[_i28];
    validateName(context, field);
    if (!isInputType(field.type)) {
      var _field$astNode2;
      context.reportError("The type of ".concat(inputObj.name, ".").concat(field.name, " must be Input Type ") + "but got: ".concat(inspect(field.type), "."), (_field$astNode2 = field.astNode) === null || _field$astNode2 === void 0 ? void 0 : _field$astNode2.type);
    }
    if (isRequiredInputField(field) && field.deprecationReason != null) {
      var _field$astNode3;
      context.reportError("Required input field ".concat(inputObj.name, ".").concat(field.name, " cannot be deprecated."), [
        getDeprecatedDirectiveNode(field.astNode),
        (_field$astNode3 = field.astNode) === null || _field$astNode3 === void 0 ? void 0 : _field$astNode3.type
      ]);
    }
  }
}
function createInputObjectCircularRefsValidator(context) {
  var visitedTypes = Object.create(null);
  var fieldPath = [];
  var fieldPathIndexByTypeName = Object.create(null);
  return detectCycleRecursive;
  function detectCycleRecursive(inputObj) {
    if (visitedTypes[inputObj.name]) {
      return;
    }
    visitedTypes[inputObj.name] = true;
    fieldPathIndexByTypeName[inputObj.name] = fieldPath.length;
    var fields7 = objectValues_default(inputObj.getFields());
    for (var _i30 = 0; _i30 < fields7.length; _i30++) {
      var field = fields7[_i30];
      if (isNonNullType(field.type) && isInputObjectType(field.type.ofType)) {
        var fieldType = field.type.ofType;
        var cycleIndex = fieldPathIndexByTypeName[fieldType.name];
        fieldPath.push(field);
        if (cycleIndex === void 0) {
          detectCycleRecursive(fieldType);
        } else {
          var cyclePath = fieldPath.slice(cycleIndex);
          var pathStr = cyclePath.map(function(fieldObj) {
            return fieldObj.name;
          }).join(".");
          context.reportError('Cannot reference Input Object "'.concat(fieldType.name, '" within itself through a series of non-null fields: "').concat(pathStr, '".'), cyclePath.map(function(fieldObj) {
            return fieldObj.astNode;
          }));
        }
        fieldPath.pop();
      }
    }
    fieldPathIndexByTypeName[inputObj.name] = void 0;
  }
}
function getAllNodes(object) {
  var astNode = object.astNode, extensionASTNodes = object.extensionASTNodes;
  return astNode ? extensionASTNodes ? [astNode].concat(extensionASTNodes) : [astNode] : extensionASTNodes !== null && extensionASTNodes !== void 0 ? extensionASTNodes : [];
}
function getAllSubNodes(object, getter) {
  var subNodes = [];
  for (var _i32 = 0, _getAllNodes2 = getAllNodes(object); _i32 < _getAllNodes2.length; _i32++) {
    var _getter;
    var node = _getAllNodes2[_i32];
    subNodes = subNodes.concat((_getter = getter(node)) !== null && _getter !== void 0 ? _getter : []);
  }
  return subNodes;
}
function getAllImplementsInterfaceNodes(type2, iface) {
  return getAllSubNodes(type2, function(typeNode) {
    return typeNode.interfaces;
  }).filter(function(ifaceNode) {
    return ifaceNode.name.value === iface.name;
  });
}
function getUnionMemberTypeNodes(union, typeName) {
  return getAllSubNodes(union, function(unionNode) {
    return unionNode.types;
  }).filter(function(typeNode) {
    return typeNode.name.value === typeName;
  });
}
function getDeprecatedDirectiveNode(definitionNode) {
  var _definitionNode$direc;
  return definitionNode === null || definitionNode === void 0 ? void 0 : (_definitionNode$direc = definitionNode.directives) === null || _definitionNode$direc === void 0 ? void 0 : _definitionNode$direc.find(function(node) {
    return node.name.value === GraphQLDeprecatedDirective.name;
  });
}
var SchemaValidationContext;
var init_validate = __esm({
  "node_modules/graphql/type/validate.mjs"() {
    init_define_process_env();
    init_find();
    init_objectValues();
    init_inspect();
    init_GraphQLError();
    init_locatedError();
    init_assertValidName();
    init_typeComparators();
    init_schema();
    init_introspection();
    init_directives();
    init_definition();
    SchemaValidationContext = function() {
      function SchemaValidationContext2(schema) {
        this._errors = [];
        this.schema = schema;
      }
      var _proto = SchemaValidationContext2.prototype;
      _proto.reportError = function reportError(message, nodes) {
        var _nodes = Array.isArray(nodes) ? nodes.filter(Boolean) : nodes;
        this.addError(new GraphQLError(message, _nodes));
      };
      _proto.addError = function addError(error2) {
        this._errors.push(error2);
      };
      _proto.getErrors = function getErrors() {
        return this._errors;
      };
      return SchemaValidationContext2;
    }();
  }
});

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  var innerType;
  if (typeNode.kind === Kind.LIST_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && new GraphQLList(innerType);
  }
  if (typeNode.kind === Kind.NON_NULL_TYPE) {
    innerType = typeFromAST(schema, typeNode.type);
    return innerType && new GraphQLNonNull(innerType);
  }
  if (typeNode.kind === Kind.NAMED_TYPE) {
    return schema.getType(typeNode.name.value);
  }
  invariant(0, "Unexpected type node: " + inspect(typeNode));
}
var init_typeFromAST = __esm({
  "node_modules/graphql/utilities/typeFromAST.mjs"() {
    init_define_process_env();
    init_inspect();
    init_invariant();
    init_kinds();
    init_definition();
  }
});

// node_modules/graphql/utilities/TypeInfo.mjs
function getFieldDef(schema, parentType, fieldNode) {
  var name2 = fieldNode.name.value;
  if (name2 === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  }
  if (name2 === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  }
  if (name2 === TypeNameMetaFieldDef.name && isCompositeType(parentType)) {
    return TypeNameMetaFieldDef;
  }
  if (isObjectType(parentType) || isInterfaceType(parentType)) {
    return parentType.getFields()[name2];
  }
}
function visitWithTypeInfo(typeInfo, visitor) {
  return {
    enter: function enter(node) {
      typeInfo.enter(node);
      var fn = getVisitFn(visitor, node.kind, false);
      if (fn) {
        var result = fn.apply(visitor, arguments);
        if (result !== void 0) {
          typeInfo.leave(node);
          if (isNode(result)) {
            typeInfo.enter(result);
          }
        }
        return result;
      }
    },
    leave: function leave(node) {
      var fn = getVisitFn(visitor, node.kind, true);
      var result;
      if (fn) {
        result = fn.apply(visitor, arguments);
      }
      typeInfo.leave(node);
      return result;
    }
  };
}
var TypeInfo;
var init_TypeInfo = __esm({
  "node_modules/graphql/utilities/TypeInfo.mjs"() {
    init_define_process_env();
    init_find();
    init_kinds();
    init_ast();
    init_visitor();
    init_definition();
    init_introspection();
    init_typeFromAST();
    TypeInfo = function() {
      function TypeInfo2(schema, getFieldDefFn, initialType) {
        this._schema = schema;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = getFieldDefFn !== null && getFieldDefFn !== void 0 ? getFieldDefFn : getFieldDef;
        if (initialType) {
          if (isInputType(initialType)) {
            this._inputTypeStack.push(initialType);
          }
          if (isCompositeType(initialType)) {
            this._parentTypeStack.push(initialType);
          }
          if (isOutputType(initialType)) {
            this._typeStack.push(initialType);
          }
        }
      }
      var _proto = TypeInfo2.prototype;
      _proto.getType = function getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      };
      _proto.getParentType = function getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      };
      _proto.getInputType = function getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      };
      _proto.getParentInputType = function getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      };
      _proto.getFieldDef = function getFieldDef4() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      };
      _proto.getDefaultValue = function getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      };
      _proto.getDirective = function getDirective() {
        return this._directive;
      };
      _proto.getArgument = function getArgument() {
        return this._argument;
      };
      _proto.getEnumValue = function getEnumValue() {
        return this._enumValue;
      };
      _proto.enter = function enter(node) {
        var schema = this._schema;
        switch (node.kind) {
          case Kind.SELECTION_SET: {
            var namedType = getNamedType(this.getType());
            this._parentTypeStack.push(isCompositeType(namedType) ? namedType : void 0);
            break;
          }
          case Kind.FIELD: {
            var parentType = this.getParentType();
            var fieldDef;
            var fieldType;
            if (parentType) {
              fieldDef = this._getFieldDef(schema, parentType, node);
              if (fieldDef) {
                fieldType = fieldDef.type;
              }
            }
            this._fieldDefStack.push(fieldDef);
            this._typeStack.push(isOutputType(fieldType) ? fieldType : void 0);
            break;
          }
          case Kind.DIRECTIVE:
            this._directive = schema.getDirective(node.name.value);
            break;
          case Kind.OPERATION_DEFINITION: {
            var type2;
            switch (node.operation) {
              case "query":
                type2 = schema.getQueryType();
                break;
              case "mutation":
                type2 = schema.getMutationType();
                break;
              case "subscription":
                type2 = schema.getSubscriptionType();
                break;
            }
            this._typeStack.push(isObjectType(type2) ? type2 : void 0);
            break;
          }
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION: {
            var typeConditionAST = node.typeCondition;
            var outputType = typeConditionAST ? typeFromAST(schema, typeConditionAST) : getNamedType(this.getType());
            this._typeStack.push(isOutputType(outputType) ? outputType : void 0);
            break;
          }
          case Kind.VARIABLE_DEFINITION: {
            var inputType = typeFromAST(schema, node.type);
            this._inputTypeStack.push(isInputType(inputType) ? inputType : void 0);
            break;
          }
          case Kind.ARGUMENT: {
            var _this$getDirective;
            var argDef;
            var argType;
            var fieldOrDirective = (_this$getDirective = this.getDirective()) !== null && _this$getDirective !== void 0 ? _this$getDirective : this.getFieldDef();
            if (fieldOrDirective) {
              argDef = find_default(fieldOrDirective.args, function(arg) {
                return arg.name === node.name.value;
              });
              if (argDef) {
                argType = argDef.type;
              }
            }
            this._argument = argDef;
            this._defaultValueStack.push(argDef ? argDef.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(argType) ? argType : void 0);
            break;
          }
          case Kind.LIST: {
            var listType = getNullableType(this.getInputType());
            var itemType = isListType(listType) ? listType.ofType : listType;
            this._defaultValueStack.push(void 0);
            this._inputTypeStack.push(isInputType(itemType) ? itemType : void 0);
            break;
          }
          case Kind.OBJECT_FIELD: {
            var objectType = getNamedType(this.getInputType());
            var inputFieldType;
            var inputField;
            if (isInputObjectType(objectType)) {
              inputField = objectType.getFields()[node.name.value];
              if (inputField) {
                inputFieldType = inputField.type;
              }
            }
            this._defaultValueStack.push(inputField ? inputField.defaultValue : void 0);
            this._inputTypeStack.push(isInputType(inputFieldType) ? inputFieldType : void 0);
            break;
          }
          case Kind.ENUM: {
            var enumType = getNamedType(this.getInputType());
            var enumValue;
            if (isEnumType(enumType)) {
              enumValue = enumType.getValue(node.value);
            }
            this._enumValue = enumValue;
            break;
          }
        }
      };
      _proto.leave = function leave(node) {
        switch (node.kind) {
          case Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case Kind.DIRECTIVE:
            this._directive = null;
            break;
          case Kind.OPERATION_DEFINITION:
          case Kind.INLINE_FRAGMENT:
          case Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.LIST:
          case Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case Kind.ENUM:
            this._enumValue = null;
            break;
        }
      };
      return TypeInfo2;
    }();
  }
});

// node_modules/graphql/language/predicates.mjs
function isDefinitionNode(node) {
  return isExecutableDefinitionNode(node) || isTypeSystemDefinitionNode(node) || isTypeSystemExtensionNode(node);
}
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isSelectionNode(node) {
  return node.kind === Kind.FIELD || node.kind === Kind.FRAGMENT_SPREAD || node.kind === Kind.INLINE_FRAGMENT;
}
function isValueNode(node) {
  return node.kind === Kind.VARIABLE || node.kind === Kind.INT || node.kind === Kind.FLOAT || node.kind === Kind.STRING || node.kind === Kind.BOOLEAN || node.kind === Kind.NULL || node.kind === Kind.ENUM || node.kind === Kind.LIST || node.kind === Kind.OBJECT;
}
function isTypeNode(node) {
  return node.kind === Kind.NAMED_TYPE || node.kind === Kind.LIST_TYPE || node.kind === Kind.NON_NULL_TYPE;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}
var init_predicates = __esm({
  "node_modules/graphql/language/predicates.mjs"() {
    init_define_process_env();
    init_kinds();
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document: function Document2(node) {
      for (var _i2 = 0, _node$definitions2 = node.definitions; _i2 < _node$definitions2.length; _i2++) {
        var definition = _node$definitions2[_i2];
        if (!isExecutableDefinitionNode(definition)) {
          var defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(new GraphQLError("The ".concat(defName, " definition is not executable."), definition));
        }
      }
      return false;
    }
  };
}
var init_ExecutableDefinitionsRule = __esm({
  "node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_kinds();
    init_predicates();
  }
});

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  var knownOperationNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2(node) {
      var operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(new GraphQLError('There can be only one operation named "'.concat(operationName.value, '".'), [knownOperationNames[operationName.value], operationName]));
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: function FragmentDefinition2() {
      return false;
    }
  };
}
var init_UniqueOperationNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  var operationCount = 0;
  return {
    Document: function Document2(node) {
      operationCount = node.definitions.filter(function(definition) {
        return definition.kind === Kind.OPERATION_DEFINITION;
      }).length;
    },
    OperationDefinition: function OperationDefinition2(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(new GraphQLError("This anonymous operation must be the only defined operation.", node));
      }
    }
  };
}
var init_LoneAnonymousOperationRule = __esm({
  "node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_kinds();
  }
});

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition: function OperationDefinition2(node) {
      if (node.operation === "subscription") {
        if (node.selectionSet.selections.length !== 1) {
          context.reportError(new GraphQLError(node.name ? 'Subscription "'.concat(node.name.value, '" must select only one top level field.') : "Anonymous Subscription must select only one top level field.", node.selectionSet.selections.slice(1)));
        }
      }
    }
  };
}
var init_SingleFieldSubscriptionsRule = __esm({
  "node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  var schema = context.getSchema();
  var existingTypesMap = schema ? schema.getTypeMap() : Object.create(null);
  var definedTypes = Object.create(null);
  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  var typeNames = Object.keys(existingTypesMap).concat(Object.keys(definedTypes));
  return {
    NamedType: function NamedType2(node, _1, parent, _2, ancestors) {
      var typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        var definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        var isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && isStandardTypeName(typeName)) {
          return;
        }
        var suggestedTypes = suggestionList(typeName, isSDL ? standardTypeNames.concat(typeNames) : typeNames);
        context.reportError(new GraphQLError('Unknown type "'.concat(typeName, '".') + didYouMean(suggestedTypes), node));
      }
    }
  };
}
function isStandardTypeName(typeName) {
  return standardTypeNames.indexOf(typeName) !== -1;
}
function isSDLNode(value) {
  return !Array.isArray(value) && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}
var standardTypeNames;
var init_KnownTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs"() {
    init_define_process_env();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_predicates();
    init_scalars();
    init_introspection();
    standardTypeNames = [].concat(specifiedScalarTypes, introspectionTypes).map(function(type2) {
      return type2.name;
    });
  }
});

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment: function InlineFragment2(node) {
      var typeCondition = node.typeCondition;
      if (typeCondition) {
        var type2 = typeFromAST(context.getSchema(), typeCondition);
        if (type2 && !isCompositeType(type2)) {
          var typeStr = print(typeCondition);
          context.reportError(new GraphQLError('Fragment cannot condition on non composite type "'.concat(typeStr, '".'), typeCondition));
        }
      }
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      var type2 = typeFromAST(context.getSchema(), node.typeCondition);
      if (type2 && !isCompositeType(type2)) {
        var typeStr = print(node.typeCondition);
        context.reportError(new GraphQLError('Fragment "'.concat(node.name.value, '" cannot condition on non composite type "').concat(typeStr, '".'), node.typeCondition));
      }
    }
  };
}
var init_FragmentsOnCompositeTypesRule = __esm({
  "node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition: function VariableDefinition2(node) {
      var type2 = typeFromAST(context.getSchema(), node.type);
      if (type2 && !isInputType(type2)) {
        var variableName = node.variable.name.value;
        var typeName = print(node.type);
        context.reportError(new GraphQLError('Variable "$'.concat(variableName, '" cannot be non-input type "').concat(typeName, '".'), node.type));
      }
    }
  };
}
var init_VariablesAreInputTypesRule = __esm({
  "node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_printer();
    init_definition();
    init_typeFromAST();
  }
});

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field: function Field3(node) {
      var type2 = context.getType();
      var selectionSet = node.selectionSet;
      if (type2) {
        if (isLeafType(getNamedType(type2))) {
          if (selectionSet) {
            var fieldName = node.name.value;
            var typeStr = inspect(type2);
            context.reportError(new GraphQLError('Field "'.concat(fieldName, '" must not have a selection since type "').concat(typeStr, '" has no subfields.'), selectionSet));
          }
        } else if (!selectionSet) {
          var _fieldName = node.name.value;
          var _typeStr = inspect(type2);
          context.reportError(new GraphQLError('Field "'.concat(_fieldName, '" of type "').concat(_typeStr, '" must have a selection of subfields. Did you mean "').concat(_fieldName, ' { ... }"?'), node));
        }
      }
    }
  };
}
var init_ScalarLeafsRule = __esm({
  "node_modules/graphql/validation/rules/ScalarLeafsRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field: function Field3(node) {
      var type2 = context.getParentType();
      if (type2) {
        var fieldDef = context.getFieldDef();
        if (!fieldDef) {
          var schema = context.getSchema();
          var fieldName = node.name.value;
          var suggestion = didYouMean("to use an inline fragment on", getSuggestedTypeNames(schema, type2, fieldName));
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type2, fieldName));
          }
          context.reportError(new GraphQLError('Cannot query field "'.concat(fieldName, '" on type "').concat(type2.name, '".') + suggestion, node));
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type2, fieldName) {
  if (!isAbstractType(type2)) {
    return [];
  }
  var suggestedTypes = new Set();
  var usageCount = Object.create(null);
  for (var _i2 = 0, _schema$getPossibleTy2 = schema.getPossibleTypes(type2); _i2 < _schema$getPossibleTy2.length; _i2++) {
    var possibleType = _schema$getPossibleTy2[_i2];
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (var _i4 = 0, _possibleType$getInte2 = possibleType.getInterfaces(); _i4 < _possibleType$getInte2.length; _i4++) {
      var _usageCount$possibleI;
      var possibleInterface = _possibleType$getInte2[_i4];
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return arrayFrom_default(suggestedTypes).sort(function(typeA, typeB) {
    var usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map(function(x) {
    return x.name;
  });
}
function getSuggestedFieldNames(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2)) {
    var possibleFieldNames = Object.keys(type2.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}
var init_FieldsOnCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs"() {
    init_define_process_env();
    init_arrayFrom();
    init_didYouMean();
    init_suggestionList();
    init_naturalCompare();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  var knownFragmentNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      var fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(new GraphQLError('There can be only one fragment named "'.concat(fragmentName, '".'), [knownFragmentNames[fragmentName], node.name]));
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread: function FragmentSpread2(node) {
      var fragmentName = node.name.value;
      var fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(new GraphQLError('Unknown fragment "'.concat(fragmentName, '".'), node.name));
      }
    }
  };
}
var init_KnownFragmentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  var operationDefs = [];
  var fragmentDefs = [];
  return {
    OperationDefinition: function OperationDefinition2(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave: function leave() {
        var fragmentNameUsed = Object.create(null);
        for (var _i2 = 0; _i2 < operationDefs.length; _i2++) {
          var operation = operationDefs[_i2];
          for (var _i4 = 0, _context$getRecursive2 = context.getRecursivelyReferencedFragments(operation); _i4 < _context$getRecursive2.length; _i4++) {
            var fragment = _context$getRecursive2[_i4];
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (var _i6 = 0; _i6 < fragmentDefs.length; _i6++) {
          var fragmentDef = fragmentDefs[_i6];
          var fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(new GraphQLError('Fragment "'.concat(fragName, '" is never used.'), fragmentDef));
          }
        }
      }
    }
  };
}
var init_NoUnusedFragmentsRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment: function InlineFragment2(node) {
      var fragType = context.getType();
      var parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        var parentTypeStr = inspect(parentType);
        var fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError('Fragment cannot be spread here as objects of type "'.concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
      }
    },
    FragmentSpread: function FragmentSpread2(node) {
      var fragName = node.name.value;
      var fragType = getFragmentType(context, fragName);
      var parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        var parentTypeStr = inspect(parentType);
        var fragTypeStr = inspect(fragType);
        context.reportError(new GraphQLError('Fragment "'.concat(fragName, '" cannot be spread here as objects of type "').concat(parentTypeStr, '" can never be of type "').concat(fragTypeStr, '".'), node));
      }
    }
  };
}
function getFragmentType(context, name2) {
  var frag = context.getFragment(name2);
  if (frag) {
    var type2 = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type2)) {
      return type2;
    }
  }
}
var init_PossibleFragmentSpreadsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_GraphQLError();
    init_definition();
    init_typeFromAST();
    init_typeComparators();
  }
});

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  var visitedFrags = Object.create(null);
  var spreadPath = [];
  var spreadPathIndexByName = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      return false;
    },
    FragmentDefinition: function FragmentDefinition2(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    var fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    var spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (var _i2 = 0; _i2 < spreadNodes.length; _i2++) {
      var spreadNode = spreadNodes[_i2];
      var spreadName = spreadNode.name.value;
      var cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        var spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        var cyclePath = spreadPath.slice(cycleIndex);
        var viaPath = cyclePath.slice(0, -1).map(function(s) {
          return '"' + s.name.value + '"';
        }).join(", ");
        context.reportError(new GraphQLError('Cannot spread fragment "'.concat(spreadName, '" within itself') + (viaPath !== "" ? " via ".concat(viaPath, ".") : "."), cyclePath));
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}
var init_NoFragmentCyclesRule = __esm({
  "node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  var knownVariableNames = Object.create(null);
  return {
    OperationDefinition: function OperationDefinition2() {
      knownVariableNames = Object.create(null);
    },
    VariableDefinition: function VariableDefinition2(node) {
      var variableName = node.variable.name.value;
      if (knownVariableNames[variableName]) {
        context.reportError(new GraphQLError('There can be only one variable named "$'.concat(variableName, '".'), [knownVariableNames[variableName], node.variable.name]));
      } else {
        knownVariableNames[variableName] = node.variable.name;
      }
    }
  };
}
var init_UniqueVariableNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  var variableNameDefined = Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        variableNameDefined = Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(new GraphQLError(operation.name ? 'Variable "$'.concat(varName, '" is not defined by operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(varName, '" is not defined.'), [node, operation]));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}
var init_NoUndefinedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  var variableDefs = [];
  return {
    OperationDefinition: {
      enter: function enter() {
        variableDefs = [];
      },
      leave: function leave(operation) {
        var variableNameUsed = Object.create(null);
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          variableNameUsed[node.name.value] = true;
        }
        for (var _i4 = 0, _variableDefs2 = variableDefs; _i4 < _variableDefs2.length; _i4++) {
          var variableDef = _variableDefs2[_i4];
          var variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(new GraphQLError(operation.name ? 'Variable "$'.concat(variableName, '" is never used in operation "').concat(operation.name.value, '".') : 'Variable "$'.concat(variableName, '" is never used.'), variableDef));
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(def) {
      variableDefs.push(def);
    }
  };
}
var init_NoUnusedVariablesRule = __esm({
  "node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  var locationsMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    locationsMap[directive.name] = directive.locations;
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map(function(name2) {
        return name2.value;
      });
    }
  }
  return {
    Directive: function Directive3(node, _key, _parent, _path, ancestors) {
      var name2 = node.name.value;
      var locations = locationsMap[name2];
      if (!locations) {
        context.reportError(new GraphQLError('Unknown directive "@'.concat(name2, '".'), node));
        return;
      }
      var candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && locations.indexOf(candidateLocation) === -1) {
        context.reportError(new GraphQLError('Directive "@'.concat(name2, '" may not be used on ').concat(candidateLocation, "."), node));
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  var appliedTo = ancestors[ancestors.length - 1];
  !Array.isArray(appliedTo) || invariant(0);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      var parentNode = ancestors[ancestors.length - 3];
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case "query":
      return DirectiveLocation.QUERY;
    case "mutation":
      return DirectiveLocation.MUTATION;
    case "subscription":
      return DirectiveLocation.SUBSCRIPTION;
  }
  invariant(0, "Unexpected operation: " + inspect(operation));
}
var init_KnownDirectivesRule = __esm({
  "node_modules/graphql/validation/rules/KnownDirectivesRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_invariant();
    init_GraphQLError();
    init_kinds();
    init_directiveLocation();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  var uniqueDirectiveMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  var schemaDirectives = Object.create(null);
  var typeDirectivesMap = Object.create(null);
  return {
    enter: function enter(node) {
      if (node.directives == null) {
        return;
      }
      var seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        var typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = Object.create(null);
        }
      } else {
        seenDirectives = Object.create(null);
      }
      for (var _i6 = 0, _node$directives2 = node.directives; _i6 < _node$directives2.length; _i6++) {
        var _directive = _node$directives2[_i6];
        var directiveName = _directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(new GraphQLError('The directive "@'.concat(directiveName, '" can only be used once at this location.'), [seenDirectives[directiveName], _directive]));
          } else {
            seenDirectives[directiveName] = _directive;
          }
        }
      }
    }
  };
}
var init_UniqueDirectivesPerLocationRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function KnownArgumentNamesRule(context) {
  return _objectSpread(_objectSpread({}, KnownArgumentNamesOnDirectivesRule(context)), {}, {
    Argument: function Argument3(argNode) {
      var argDef = context.getArgument();
      var fieldDef = context.getFieldDef();
      var parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        var argName = argNode.name.value;
        var knownArgsNames = fieldDef.args.map(function(arg) {
          return arg.name;
        });
        var suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(new GraphQLError('Unknown argument "'.concat(argName, '" on field "').concat(parentType.name, ".").concat(fieldDef.name, '".') + didYouMean(suggestions), argNode));
      }
    }
  });
}
function KnownArgumentNamesOnDirectivesRule(context) {
  var directiveArgs = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (var _i2 = 0; _i2 < definedDirectives.length; _i2++) {
    var directive = definedDirectives[_i2];
    directiveArgs[directive.name] = directive.args.map(function(arg) {
      return arg.name;
    });
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i4 = 0; _i4 < astDefinitions.length; _i4++) {
    var def = astDefinitions[_i4];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      var argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map(function(arg) {
        return arg.name.value;
      });
    }
  }
  return {
    Directive: function Directive3(directiveNode) {
      var directiveName = directiveNode.name.value;
      var knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (var _i6 = 0, _directiveNode$argume2 = directiveNode.arguments; _i6 < _directiveNode$argume2.length; _i6++) {
          var argNode = _directiveNode$argume2[_i6];
          var argName = argNode.name.value;
          if (knownArgs.indexOf(argName) === -1) {
            var suggestions = suggestionList(argName, knownArgs);
            context.reportError(new GraphQLError('Unknown argument "'.concat(argName, '" on directive "@').concat(directiveName, '".') + didYouMean(suggestions), argNode));
          }
        }
      }
      return false;
    }
  };
}
var init_KnownArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs"() {
    init_define_process_env();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_directives();
  }
});

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  var knownArgNames = Object.create(null);
  return {
    Field: function Field3() {
      knownArgNames = Object.create(null);
    },
    Directive: function Directive3() {
      knownArgNames = Object.create(null);
    },
    Argument: function Argument3(node) {
      var argName = node.name.value;
      if (knownArgNames[argName]) {
        context.reportError(new GraphQLError('There can be only one argument named "'.concat(argName, '".'), [knownArgNames[argName], node.name]));
      } else {
        knownArgNames[argName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueArgumentNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  return {
    ListValue: function ListValue2(node) {
      var type2 = getNullableType(context.getParentInputType());
      if (!isListType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue: function ObjectValue2(node) {
      var type2 = getNamedType(context.getInputType());
      if (!isInputObjectType(type2)) {
        isValidValueNode(context, node);
        return false;
      }
      var fieldNodeMap = keyMap(node.fields, function(field) {
        return field.name.value;
      });
      for (var _i2 = 0, _objectValues2 = objectValues_default(type2.getFields()); _i2 < _objectValues2.length; _i2++) {
        var fieldDef = _objectValues2[_i2];
        var fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          var typeStr = inspect(fieldDef.type);
          context.reportError(new GraphQLError('Field "'.concat(type2.name, ".").concat(fieldDef.name, '" of required type "').concat(typeStr, '" was not provided.'), node));
        }
      }
    },
    ObjectField: function ObjectField2(node) {
      var parentType = getNamedType(context.getParentInputType());
      var fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        var suggestions = suggestionList(node.name.value, Object.keys(parentType.getFields()));
        context.reportError(new GraphQLError('Field "'.concat(node.name.value, '" is not defined by type "').concat(parentType.name, '".') + didYouMean(suggestions), node));
      }
    },
    NullValue: function NullValue2(node) {
      var type2 = context.getInputType();
      if (isNonNullType(type2)) {
        context.reportError(new GraphQLError('Expected value of type "'.concat(inspect(type2), '", found ').concat(print(node), "."), node));
      }
    },
    EnumValue: function EnumValue3(node) {
      return isValidValueNode(context, node);
    },
    IntValue: function IntValue2(node) {
      return isValidValueNode(context, node);
    },
    FloatValue: function FloatValue2(node) {
      return isValidValueNode(context, node);
    },
    StringValue: function StringValue2(node) {
      return isValidValueNode(context, node);
    },
    BooleanValue: function BooleanValue2(node) {
      return isValidValueNode(context, node);
    }
  };
}
function isValidValueNode(context, node) {
  var locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  var type2 = getNamedType(locationType);
  if (!isLeafType(type2)) {
    var typeStr = inspect(locationType);
    context.reportError(new GraphQLError('Expected value of type "'.concat(typeStr, '", found ').concat(print(node), "."), node));
    return;
  }
  try {
    var parseResult = type2.parseLiteral(node, void 0);
    if (parseResult === void 0) {
      var _typeStr = inspect(locationType);
      context.reportError(new GraphQLError('Expected value of type "'.concat(_typeStr, '", found ').concat(print(node), "."), node));
    }
  } catch (error2) {
    var _typeStr2 = inspect(locationType);
    if (error2 instanceof GraphQLError) {
      context.reportError(error2);
    } else {
      context.reportError(new GraphQLError('Expected value of type "'.concat(_typeStr2, '", found ').concat(print(node), "; ") + error2.message, node, void 0, void 0, void 0, error2));
    }
  }
}
var init_ValuesOfCorrectTypeRule = __esm({
  "node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_keyMap();
    init_inspect();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_printer();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ownKeys2(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ProvidedRequiredArgumentsRule(context) {
  return _objectSpread2(_objectSpread2({}, ProvidedRequiredArgumentsOnDirectivesRule(context)), {}, {
    Field: {
      leave: function leave(fieldNode) {
        var _fieldNode$arguments;
        var fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        var argNodes = (_fieldNode$arguments = fieldNode.arguments) !== null && _fieldNode$arguments !== void 0 ? _fieldNode$arguments : [];
        var argNodeMap = keyMap(argNodes, function(arg) {
          return arg.name.value;
        });
        for (var _i2 = 0, _fieldDef$args2 = fieldDef.args; _i2 < _fieldDef$args2.length; _i2++) {
          var argDef = _fieldDef$args2[_i2];
          var argNode = argNodeMap[argDef.name];
          if (!argNode && isRequiredArgument(argDef)) {
            var argTypeStr = inspect(argDef.type);
            context.reportError(new GraphQLError('Field "'.concat(fieldDef.name, '" argument "').concat(argDef.name, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), fieldNode));
          }
        }
      }
    }
  });
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var requiredArgsMap = Object.create(null);
  var schema = context.getSchema();
  var definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (var _i4 = 0; _i4 < definedDirectives.length; _i4++) {
    var directive = definedDirectives[_i4];
    requiredArgsMap[directive.name] = keyMap(directive.args.filter(isRequiredArgument), function(arg) {
      return arg.name;
    });
  }
  var astDefinitions = context.getDocument().definitions;
  for (var _i6 = 0; _i6 < astDefinitions.length; _i6++) {
    var def = astDefinitions[_i6];
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      var argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(argNodes.filter(isRequiredArgumentNode), function(arg) {
        return arg.name.value;
      });
    }
  }
  return {
    Directive: {
      leave: function leave(directiveNode) {
        var directiveName = directiveNode.name.value;
        var requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          var _argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          var argNodeMap = keyMap(_argNodes, function(arg) {
            return arg.name.value;
          });
          for (var _i8 = 0, _Object$keys2 = Object.keys(requiredArgs); _i8 < _Object$keys2.length; _i8++) {
            var argName = _Object$keys2[_i8];
            if (!argNodeMap[argName]) {
              var argType = requiredArgs[argName].type;
              var argTypeStr = isType(argType) ? inspect(argType) : print(argType);
              context.reportError(new GraphQLError('Directive "@'.concat(directiveName, '" argument "').concat(argName, '" of type "').concat(argTypeStr, '" is required, but it was not provided.'), directiveNode));
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}
var init_ProvidedRequiredArgumentsRule = __esm({
  "node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_keyMap();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_directives();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  var varDefMap = Object.create(null);
  return {
    OperationDefinition: {
      enter: function enter() {
        varDefMap = Object.create(null);
      },
      leave: function leave(operation) {
        var usages = context.getRecursiveVariableUsages(operation);
        for (var _i2 = 0; _i2 < usages.length; _i2++) {
          var _ref2 = usages[_i2];
          var node = _ref2.node;
          var type2 = _ref2.type;
          var defaultValue = _ref2.defaultValue;
          var varName = node.name.value;
          var varDef = varDefMap[varName];
          if (varDef && type2) {
            var schema = context.getSchema();
            var varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(schema, varType, varDef.defaultValue, type2, defaultValue)) {
              var varTypeStr = inspect(varType);
              var typeStr = inspect(type2);
              context.reportError(new GraphQLError('Variable "$'.concat(varName, '" of type "').concat(varTypeStr, '" used in position expecting type "').concat(typeStr, '".'), [varDef, node]));
            }
          }
        }
      }
    },
    VariableDefinition: function VariableDefinition2(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    var hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    var hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    var nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}
var init_VariablesInAllowedPositionRule = __esm({
  "node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_definition();
    init_typeFromAST();
    init_typeComparators();
  }
});

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(function(_ref) {
      var responseName = _ref[0], subReason = _ref[1];
      return 'subfields "'.concat(responseName, '" conflict because ') + reasonMessage(subReason);
    }).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  var comparedFragmentPairs = new PairSet();
  var cachedFieldsAndFragmentNames = new Map();
  return {
    SelectionSet: function SelectionSet2(selectionSet) {
      var conflicts = findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, context.getParentType(), selectionSet);
      for (var _i2 = 0; _i2 < conflicts.length; _i2++) {
        var _ref3 = conflicts[_i2];
        var _ref2$ = _ref3[0];
        var responseName = _ref2$[0];
        var reason = _ref2$[1];
        var fields1 = _ref3[1];
        var fields22 = _ref3[2];
        var reasonMsg = reasonMessage(reason);
        context.reportError(new GraphQLError('Fields "'.concat(responseName, '" conflict because ').concat(reasonMsg, ". Use different aliases on the fields to fetch both if this was intentional."), fields1.concat(fields22)));
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  var conflicts = [];
  var _getFieldsAndFragment = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet), fieldMap = _getFieldsAndFragment[0], fragmentNames = _getFieldsAndFragment[1];
  collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap);
  if (fragmentNames.length !== 0) {
    for (var i = 0; i < fragmentNames.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fieldMap, fragmentNames[i]);
      for (var j = i + 1; j < fragmentNames.length; j++) {
        collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, fragmentNames[i], fragmentNames[j]);
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  var fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  var _getReferencedFieldsA = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment), fieldMap2 = _getReferencedFieldsA[0], fragmentNames2 = _getReferencedFieldsA[1];
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fieldMap2);
  for (var i = 0; i < fragmentNames2.length; i++) {
    collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentNames2[i]);
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(fragmentName1, fragmentName2, areMutuallyExclusive)) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  var fragment1 = context.getFragment(fragmentName1);
  var fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  var _getReferencedFieldsA2 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment1), fieldMap1 = _getReferencedFieldsA2[0], fragmentNames1 = _getReferencedFieldsA2[1];
  var _getReferencedFieldsA3 = getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment2), fieldMap2 = _getReferencedFieldsA3[0], fragmentNames2 = _getReferencedFieldsA3[1];
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  for (var j = 0; j < fragmentNames2.length; j++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentNames2[j]);
  }
  for (var i = 0; i < fragmentNames1.length; i++) {
    collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[i], fragmentName2);
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  var conflicts = [];
  var _getFieldsAndFragment2 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType1, selectionSet1), fieldMap1 = _getFieldsAndFragment2[0], fragmentNames1 = _getFieldsAndFragment2[1];
  var _getFieldsAndFragment3 = getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType2, selectionSet2), fieldMap2 = _getFieldsAndFragment3[0], fragmentNames2 = _getFieldsAndFragment3[1];
  collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fieldMap2);
  if (fragmentNames2.length !== 0) {
    for (var j = 0; j < fragmentNames2.length; j++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap1, fragmentNames2[j]);
    }
  }
  if (fragmentNames1.length !== 0) {
    for (var i = 0; i < fragmentNames1.length; i++) {
      collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap2, fragmentNames1[i]);
    }
  }
  for (var _i3 = 0; _i3 < fragmentNames1.length; _i3++) {
    for (var _j = 0; _j < fragmentNames2.length; _j++) {
      collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentNames1[_i3], fragmentNames2[_j]);
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (var _i5 = 0, _objectEntries2 = objectEntries_default(fieldMap); _i5 < _objectEntries2.length; _i5++) {
    var _ref5 = _objectEntries2[_i5];
    var responseName = _ref5[0];
    var fields7 = _ref5[1];
    if (fields7.length > 1) {
      for (var i = 0; i < fields7.length; i++) {
        for (var j = i + 1; j < fields7.length; j++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, false, responseName, fields7[i], fields7[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (var _i7 = 0, _Object$keys2 = Object.keys(fieldMap1); _i7 < _Object$keys2.length; _i7++) {
    var responseName = _Object$keys2[_i7];
    var fields22 = fieldMap2[responseName];
    if (fields22) {
      var fields1 = fieldMap1[responseName];
      for (var i = 0; i < fields1.length; i++) {
        for (var j = 0; j < fields22.length; j++) {
          var conflict = findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, fields1[i], fields22[j]);
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  var parentType1 = field1[0], node1 = field1[1], def1 = field1[2];
  var parentType2 = field2[0], node2 = field2[1], def2 = field2[2];
  var areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    var _node1$arguments, _node2$arguments;
    var name1 = node1.name.value;
    var name2 = node2.name.value;
    if (name1 !== name2) {
      return [[responseName, '"'.concat(name1, '" and "').concat(name2, '" are different fields')], [node1], [node2]];
    }
    var args1 = (_node1$arguments = node1.arguments) !== null && _node1$arguments !== void 0 ? _node1$arguments : [];
    var args2 = (_node2$arguments = node2.arguments) !== null && _node2$arguments !== void 0 ? _node2$arguments : [];
    if (!sameArguments(args1, args2)) {
      return [[responseName, "they have differing arguments"], [node1], [node2]];
    }
  }
  var type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  var type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [[responseName, 'they return conflicting types "'.concat(inspect(type1), '" and "').concat(inspect(type2), '"')], [node1], [node2]];
  }
  var selectionSet1 = node1.selectionSet;
  var selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    var conflicts = findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, getNamedType(type1), selectionSet1, getNamedType(type2), selectionSet2);
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(arguments1, arguments2) {
  if (arguments1.length !== arguments2.length) {
    return false;
  }
  return arguments1.every(function(argument1) {
    var argument2 = find_default(arguments2, function(argument) {
      return argument.name.value === argument1.name.value;
    });
    if (!argument2) {
      return false;
    }
    return sameValue(argument1.value, argument2.value);
  });
}
function sameValue(value1, value2) {
  return print(value1) === print(value2);
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  var cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (!cached) {
    var nodeAndDefs = Object.create(null);
    var fragmentNames = Object.create(null);
    _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames);
    cached = [nodeAndDefs, Object.keys(fragmentNames)];
    cachedFieldsAndFragmentNames.set(selectionSet, cached);
  }
  return cached;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  var cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  var fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragmentType, fragment.selectionSet);
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (var _i9 = 0, _selectionSet$selecti2 = selectionSet.selections; _i9 < _selectionSet$selecti2.length; _i9++) {
    var selection = _selectionSet$selecti2[_i9];
    switch (selection.kind) {
      case Kind.FIELD: {
        var fieldName = selection.name.value;
        var fieldDef = void 0;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        var responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        var typeCondition = selection.typeCondition;
        var inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(context, inlineFragmentType, selection.selectionSet, nodeAndDefs, fragmentNames);
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [[responseName, conflicts.map(function(_ref6) {
      var reason = _ref6[0];
      return reason;
    })], conflicts.reduce(function(allFields, _ref7) {
      var fields1 = _ref7[1];
      return allFields.concat(fields1);
    }, [node1]), conflicts.reduce(function(allFields, _ref8) {
      var fields22 = _ref8[2];
      return allFields.concat(fields22);
    }, [node2])];
  }
}
var PairSet;
var init_OverlappingFieldsCanBeMergedRule = __esm({
  "node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs"() {
    init_define_process_env();
    init_find();
    init_objectEntries();
    init_inspect();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_typeFromAST();
    PairSet = function() {
      function PairSet2() {
        this._data = Object.create(null);
      }
      var _proto = PairSet2.prototype;
      _proto.has = function has(a, b, areMutuallyExclusive) {
        var first = this._data[a];
        var result = first && first[b];
        if (result === void 0) {
          return false;
        }
        if (areMutuallyExclusive === false) {
          return result === false;
        }
        return true;
      };
      _proto.add = function add(a, b, areMutuallyExclusive) {
        this._pairSetAdd(a, b, areMutuallyExclusive);
        this._pairSetAdd(b, a, areMutuallyExclusive);
      };
      _proto._pairSetAdd = function _pairSetAdd(a, b, areMutuallyExclusive) {
        var map2 = this._data[a];
        if (!map2) {
          map2 = Object.create(null);
          this._data[a] = map2;
        }
        map2[b] = areMutuallyExclusive;
      };
      return PairSet2;
    }();
  }
});

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  var knownNameStack = [];
  var knownNames = Object.create(null);
  return {
    ObjectValue: {
      enter: function enter() {
        knownNameStack.push(knownNames);
        knownNames = Object.create(null);
      },
      leave: function leave() {
        knownNames = knownNameStack.pop();
      }
    },
    ObjectField: function ObjectField2(node) {
      var fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(new GraphQLError('There can be only one input field named "'.concat(fieldName, '".'), [knownNames[fieldName], node.name]));
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}
var init_UniqueInputFieldNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  var oldSchema = context.getSchema();
  var alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  var schemaDefinitionsCount = 0;
  return {
    SchemaDefinition: function SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(new GraphQLError("Cannot define a new schema within a schema extension.", node));
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(new GraphQLError("Must provide only one schema definition.", node));
      }
      ++schemaDefinitionsCount;
    }
  };
}
var init_LoneSchemaDefinitionRule = __esm({
  "node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  var schema = context.getSchema();
  var definedOperationTypes = Object.create(null);
  var existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (var _i2 = 0; _i2 < operationTypesNodes.length; _i2++) {
      var operationType = operationTypesNodes[_i2];
      var operation = operationType.operation;
      var alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(new GraphQLError("Type for ".concat(operation, " already defined in the schema. It cannot be redefined."), operationType));
      } else if (alreadyDefinedOperationType) {
        context.reportError(new GraphQLError("There can be only one ".concat(operation, " type in schema."), [alreadyDefinedOperationType, operationType]));
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}
var init_UniqueOperationTypesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  var knownTypeNames = Object.create(null);
  var schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    var typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(new GraphQLError('Type "'.concat(typeName, '" already exists in the schema. It cannot also be defined in this type definition.'), node.name));
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(new GraphQLError('There can be only one type named "'.concat(typeName, '".'), [knownTypeNames[typeName], node.name]));
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}
var init_UniqueTypeNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  var schema = context.getSchema();
  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
  var knownValueNames = Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    var typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = Object.create(null);
    }
    var valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    var valueNames = knownValueNames[typeName];
    for (var _i2 = 0; _i2 < valueNodes.length; _i2++) {
      var valueDef = valueNodes[_i2];
      var valueName = valueDef.name.value;
      var existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(new GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" already exists in the schema. It cannot also be defined in this type extension.'), valueDef.name));
      } else if (valueNames[valueName]) {
        context.reportError(new GraphQLError('Enum value "'.concat(typeName, ".").concat(valueName, '" can only be defined once.'), [valueNames[valueName], valueDef.name]));
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}
var init_UniqueEnumValueNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  var schema = context.getSchema();
  var existingTypeMap = schema ? schema.getTypeMap() : Object.create(null);
  var knownFieldNames = Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    var typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = Object.create(null);
    }
    var fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    var fieldNames = knownFieldNames[typeName];
    for (var _i2 = 0; _i2 < fieldNodes.length; _i2++) {
      var fieldDef = fieldNodes[_i2];
      var fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(new GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" already exists in the schema. It cannot also be defined in this type extension.'), fieldDef.name));
      } else if (fieldNames[fieldName]) {
        context.reportError(new GraphQLError('Field "'.concat(typeName, ".").concat(fieldName, '" can only be defined once.'), [fieldNames[fieldName], fieldDef.name]));
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type2, fieldName) {
  if (isObjectType(type2) || isInterfaceType(type2) || isInputObjectType(type2)) {
    return type2.getFields()[fieldName] != null;
  }
  return false;
}
var init_UniqueFieldDefinitionNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  var knownDirectiveNames = Object.create(null);
  var schema = context.getSchema();
  return {
    DirectiveDefinition: function DirectiveDefinition(node) {
      var directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(new GraphQLError('Directive "@'.concat(directiveName, '" already exists in the schema. It cannot be redefined.'), node.name));
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(new GraphQLError('There can be only one directive named "@'.concat(directiveName, '".'), [knownDirectiveNames[directiveName], node.name]));
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}
var init_UniqueDirectiveNamesRule = __esm({
  "node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function PossibleTypeExtensionsRule(context) {
  var schema = context.getSchema();
  var definedTypes = Object.create(null);
  for (var _i2 = 0, _context$getDocument$2 = context.getDocument().definitions; _i2 < _context$getDocument$2.length; _i2++) {
    var def = _context$getDocument$2[_i2];
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    var typeName = node.name.value;
    var defNode = definedTypes[typeName];
    var existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    var expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        var kindStr = extensionKindToTypeName(node.kind);
        context.reportError(new GraphQLError("Cannot extend non-".concat(kindStr, ' type "').concat(typeName, '".'), defNode ? [defNode, node] : node));
      }
    } else {
      var allTypeNames = Object.keys(definedTypes);
      if (schema) {
        allTypeNames = allTypeNames.concat(Object.keys(schema.getTypeMap()));
      }
      var suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(new GraphQLError('Cannot extend type "'.concat(typeName, '" because it is not defined.') + didYouMean(suggestedTypes), node.name));
    }
  }
}
function typeToExtKind(type2) {
  if (isScalarType(type2)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type2)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type2)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type2)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type2)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type2)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(0, "Unexpected type: " + inspect(type2));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
  }
  invariant(0, "Unexpected kind: " + inspect(kind));
}
var _defKindToExtKind, defKindToExtKind;
var init_PossibleTypeExtensionsRule = __esm({
  "node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs"() {
    init_define_process_env();
    init_inspect();
    init_invariant();
    init_didYouMean();
    init_suggestionList();
    init_GraphQLError();
    init_kinds();
    init_predicates();
    init_definition();
    defKindToExtKind = (_defKindToExtKind = {}, _defineProperty3(_defKindToExtKind, Kind.SCALAR_TYPE_DEFINITION, Kind.SCALAR_TYPE_EXTENSION), _defineProperty3(_defKindToExtKind, Kind.OBJECT_TYPE_DEFINITION, Kind.OBJECT_TYPE_EXTENSION), _defineProperty3(_defKindToExtKind, Kind.INTERFACE_TYPE_DEFINITION, Kind.INTERFACE_TYPE_EXTENSION), _defineProperty3(_defKindToExtKind, Kind.UNION_TYPE_DEFINITION, Kind.UNION_TYPE_EXTENSION), _defineProperty3(_defKindToExtKind, Kind.ENUM_TYPE_DEFINITION, Kind.ENUM_TYPE_EXTENSION), _defineProperty3(_defKindToExtKind, Kind.INPUT_OBJECT_TYPE_DEFINITION, Kind.INPUT_OBJECT_TYPE_EXTENSION), _defKindToExtKind);
  }
});

// node_modules/graphql/validation/specifiedRules.mjs
var specifiedRules, specifiedSDLRules;
var init_specifiedRules = __esm({
  "node_modules/graphql/validation/specifiedRules.mjs"() {
    init_define_process_env();
    init_ExecutableDefinitionsRule();
    init_UniqueOperationNamesRule();
    init_LoneAnonymousOperationRule();
    init_SingleFieldSubscriptionsRule();
    init_KnownTypeNamesRule();
    init_FragmentsOnCompositeTypesRule();
    init_VariablesAreInputTypesRule();
    init_ScalarLeafsRule();
    init_FieldsOnCorrectTypeRule();
    init_UniqueFragmentNamesRule();
    init_KnownFragmentNamesRule();
    init_NoUnusedFragmentsRule();
    init_PossibleFragmentSpreadsRule();
    init_NoFragmentCyclesRule();
    init_UniqueVariableNamesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedVariablesRule();
    init_KnownDirectivesRule();
    init_UniqueDirectivesPerLocationRule();
    init_KnownArgumentNamesRule();
    init_UniqueArgumentNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_ProvidedRequiredArgumentsRule();
    init_VariablesInAllowedPositionRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_UniqueInputFieldNamesRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    specifiedRules = Object.freeze([ExecutableDefinitionsRule, UniqueOperationNamesRule, LoneAnonymousOperationRule, SingleFieldSubscriptionsRule, KnownTypeNamesRule, FragmentsOnCompositeTypesRule, VariablesAreInputTypesRule, ScalarLeafsRule, FieldsOnCorrectTypeRule, UniqueFragmentNamesRule, KnownFragmentNamesRule, NoUnusedFragmentsRule, PossibleFragmentSpreadsRule, NoFragmentCyclesRule, UniqueVariableNamesRule, NoUndefinedVariablesRule, NoUnusedVariablesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, KnownArgumentNamesRule, UniqueArgumentNamesRule, ValuesOfCorrectTypeRule, ProvidedRequiredArgumentsRule, VariablesInAllowedPositionRule, OverlappingFieldsCanBeMergedRule, UniqueInputFieldNamesRule]);
    specifiedSDLRules = Object.freeze([LoneSchemaDefinitionRule, UniqueOperationTypesRule, UniqueTypeNamesRule, UniqueEnumValueNamesRule, UniqueFieldDefinitionNamesRule, UniqueDirectiveNamesRule, KnownTypeNamesRule, KnownDirectivesRule, UniqueDirectivesPerLocationRule, PossibleTypeExtensionsRule, KnownArgumentNamesOnDirectivesRule, UniqueArgumentNamesRule, UniqueInputFieldNamesRule, ProvidedRequiredArgumentsOnDirectivesRule]);
  }
});

// node_modules/graphql/validation/ValidationContext.mjs
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var ASTValidationContext, SDLValidationContext, ValidationContext;
var init_ValidationContext = __esm({
  "node_modules/graphql/validation/ValidationContext.mjs"() {
    init_define_process_env();
    init_kinds();
    init_visitor();
    init_TypeInfo();
    ASTValidationContext = function() {
      function ASTValidationContext2(ast, onError) {
        this._ast = ast;
        this._fragments = void 0;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = onError;
      }
      var _proto = ASTValidationContext2.prototype;
      _proto.reportError = function reportError(error2) {
        this._onError(error2);
      };
      _proto.getDocument = function getDocument() {
        return this._ast;
      };
      _proto.getFragment = function getFragment(name2) {
        var fragments = this._fragments;
        if (!fragments) {
          this._fragments = fragments = this.getDocument().definitions.reduce(function(frags, statement) {
            if (statement.kind === Kind.FRAGMENT_DEFINITION) {
              frags[statement.name.value] = statement;
            }
            return frags;
          }, Object.create(null));
        }
        return fragments[name2];
      };
      _proto.getFragmentSpreads = function getFragmentSpreads(node) {
        var spreads = this._fragmentSpreads.get(node);
        if (!spreads) {
          spreads = [];
          var setsToVisit = [node];
          while (setsToVisit.length !== 0) {
            var set = setsToVisit.pop();
            for (var _i2 = 0, _set$selections2 = set.selections; _i2 < _set$selections2.length; _i2++) {
              var selection = _set$selections2[_i2];
              if (selection.kind === Kind.FRAGMENT_SPREAD) {
                spreads.push(selection);
              } else if (selection.selectionSet) {
                setsToVisit.push(selection.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(node, spreads);
        }
        return spreads;
      };
      _proto.getRecursivelyReferencedFragments = function getRecursivelyReferencedFragments(operation) {
        var fragments = this._recursivelyReferencedFragments.get(operation);
        if (!fragments) {
          fragments = [];
          var collectedNames = Object.create(null);
          var nodesToVisit = [operation.selectionSet];
          while (nodesToVisit.length !== 0) {
            var node = nodesToVisit.pop();
            for (var _i4 = 0, _this$getFragmentSpre2 = this.getFragmentSpreads(node); _i4 < _this$getFragmentSpre2.length; _i4++) {
              var spread = _this$getFragmentSpre2[_i4];
              var fragName = spread.name.value;
              if (collectedNames[fragName] !== true) {
                collectedNames[fragName] = true;
                var fragment = this.getFragment(fragName);
                if (fragment) {
                  fragments.push(fragment);
                  nodesToVisit.push(fragment.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(operation, fragments);
        }
        return fragments;
      };
      return ASTValidationContext2;
    }();
    SDLValidationContext = function(_ASTValidationContext) {
      _inheritsLoose(SDLValidationContext2, _ASTValidationContext);
      function SDLValidationContext2(ast, schema, onError) {
        var _this;
        _this = _ASTValidationContext.call(this, ast, onError) || this;
        _this._schema = schema;
        return _this;
      }
      var _proto2 = SDLValidationContext2.prototype;
      _proto2.getSchema = function getSchema() {
        return this._schema;
      };
      return SDLValidationContext2;
    }(ASTValidationContext);
    ValidationContext = function(_ASTValidationContext2) {
      _inheritsLoose(ValidationContext2, _ASTValidationContext2);
      function ValidationContext2(schema, ast, typeInfo, onError) {
        var _this2;
        _this2 = _ASTValidationContext2.call(this, ast, onError) || this;
        _this2._schema = schema;
        _this2._typeInfo = typeInfo;
        _this2._variableUsages = new Map();
        _this2._recursiveVariableUsages = new Map();
        return _this2;
      }
      var _proto3 = ValidationContext2.prototype;
      _proto3.getSchema = function getSchema() {
        return this._schema;
      };
      _proto3.getVariableUsages = function getVariableUsages(node) {
        var usages = this._variableUsages.get(node);
        if (!usages) {
          var newUsages = [];
          var typeInfo = new TypeInfo(this._schema);
          visit(node, visitWithTypeInfo(typeInfo, {
            VariableDefinition: function VariableDefinition2() {
              return false;
            },
            Variable: function Variable2(variable) {
              newUsages.push({
                node: variable,
                type: typeInfo.getInputType(),
                defaultValue: typeInfo.getDefaultValue()
              });
            }
          }));
          usages = newUsages;
          this._variableUsages.set(node, usages);
        }
        return usages;
      };
      _proto3.getRecursiveVariableUsages = function getRecursiveVariableUsages(operation) {
        var usages = this._recursiveVariableUsages.get(operation);
        if (!usages) {
          usages = this.getVariableUsages(operation);
          for (var _i6 = 0, _this$getRecursivelyR2 = this.getRecursivelyReferencedFragments(operation); _i6 < _this$getRecursivelyR2.length; _i6++) {
            var frag = _this$getRecursivelyR2[_i6];
            usages = usages.concat(this.getVariableUsages(frag));
          }
          this._recursiveVariableUsages.set(operation, usages);
        }
        return usages;
      };
      _proto3.getType = function getType() {
        return this._typeInfo.getType();
      };
      _proto3.getParentType = function getParentType() {
        return this._typeInfo.getParentType();
      };
      _proto3.getInputType = function getInputType() {
        return this._typeInfo.getInputType();
      };
      _proto3.getParentInputType = function getParentInputType() {
        return this._typeInfo.getParentInputType();
      };
      _proto3.getFieldDef = function getFieldDef4() {
        return this._typeInfo.getFieldDef();
      };
      _proto3.getDirective = function getDirective() {
        return this._typeInfo.getDirective();
      };
      _proto3.getArgument = function getArgument() {
        return this._typeInfo.getArgument();
      };
      _proto3.getEnumValue = function getEnumValue() {
        return this._typeInfo.getEnumValue();
      };
      return ValidationContext2;
    }(ASTValidationContext);
  }
});

// node_modules/graphql/validation/validate.mjs
function validate(schema, documentAST) {
  var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : specifiedRules;
  var typeInfo = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : new TypeInfo(schema);
  var options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
    maxErrors: void 0
  };
  documentAST || devAssert(0, "Must provide document.");
  assertValidSchema(schema);
  var abortObj = Object.freeze({});
  var errors2 = [];
  var context = new ValidationContext(schema, documentAST, typeInfo, function(error2) {
    if (options.maxErrors != null && errors2.length >= options.maxErrors) {
      errors2.push(new GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
      throw abortObj;
    }
    errors2.push(error2);
  });
  var visitor = visitInParallel(rules.map(function(rule) {
    return rule(context);
  }));
  try {
    visit(documentAST, visitWithTypeInfo(typeInfo, visitor));
  } catch (e) {
    if (e !== abortObj) {
      throw e;
    }
  }
  return errors2;
}
function validateSDL(documentAST, schemaToExtend) {
  var rules = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : specifiedSDLRules;
  var errors2 = [];
  var context = new SDLValidationContext(documentAST, schemaToExtend, function(error2) {
    errors2.push(error2);
  });
  var visitors = rules.map(function(rule) {
    return rule(context);
  });
  visit(documentAST, visitInParallel(visitors));
  return errors2;
}
function assertValidSDL(documentAST) {
  var errors2 = validateSDL(documentAST);
  if (errors2.length !== 0) {
    throw new Error(errors2.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
function assertValidSDLExtension(documentAST, schema) {
  var errors2 = validateSDL(documentAST, schema);
  if (errors2.length !== 0) {
    throw new Error(errors2.map(function(error2) {
      return error2.message;
    }).join("\n\n"));
  }
}
var init_validate2 = __esm({
  "node_modules/graphql/validation/validate.mjs"() {
    init_define_process_env();
    init_devAssert();
    init_GraphQLError();
    init_visitor();
    init_validate();
    init_TypeInfo();
    init_specifiedRules();
    init_ValidationContext();
  }
});

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn) {
  var cache0;
  return function memoized(a1, a2, a3) {
    if (!cache0) {
      cache0 = new WeakMap();
    }
    var cache1 = cache0.get(a1);
    var cache2;
    if (cache1) {
      cache2 = cache1.get(a2);
      if (cache2) {
        var cachedValue = cache2.get(a3);
        if (cachedValue !== void 0) {
          return cachedValue;
        }
      }
    } else {
      cache1 = new WeakMap();
      cache0.set(a1, cache1);
    }
    if (!cache2) {
      cache2 = new WeakMap();
      cache1.set(a2, cache2);
    }
    var newValue = fn(a1, a2, a3);
    cache2.set(a3, newValue);
    return newValue;
  };
}
var init_memoize3 = __esm({
  "node_modules/graphql/jsutils/memoize3.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/promiseReduce.mjs
function promiseReduce(values, callback, initialValue) {
  return values.reduce(function(previous, value) {
    return isPromise(previous) ? previous.then(function(resolved) {
      return callback(resolved, value);
    }) : callback(previous, value);
  }, initialValue);
}
var init_promiseReduce = __esm({
  "node_modules/graphql/jsutils/promiseReduce.mjs"() {
    init_define_process_env();
    init_isPromise();
  }
});

// node_modules/graphql/jsutils/promiseForObject.mjs
function promiseForObject(object) {
  var keys = Object.keys(object);
  var valuesAndPromises = keys.map(function(name2) {
    return object[name2];
  });
  return Promise.all(valuesAndPromises).then(function(values) {
    return values.reduce(function(resolvedObject, value, i) {
      resolvedObject[keys[i]] = value;
      return resolvedObject;
    }, Object.create(null));
  });
}
var init_promiseForObject = __esm({
  "node_modules/graphql/jsutils/promiseForObject.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/jsutils/Path.mjs
function addPath(prev, key, typename) {
  return {
    prev,
    key,
    typename
  };
}
function pathToArray(path) {
  var flattened = [];
  var curr = path;
  while (curr) {
    flattened.push(curr.key);
    curr = curr.prev;
  }
  return flattened.reverse();
}
var init_Path = __esm({
  "node_modules/graphql/jsutils/Path.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/utilities/getOperationRootType.mjs
function getOperationRootType(schema, operation) {
  if (operation.operation === "query") {
    var queryType = schema.getQueryType();
    if (!queryType) {
      throw new GraphQLError("Schema does not define the required query root type.", operation);
    }
    return queryType;
  }
  if (operation.operation === "mutation") {
    var mutationType = schema.getMutationType();
    if (!mutationType) {
      throw new GraphQLError("Schema is not configured for mutations.", operation);
    }
    return mutationType;
  }
  if (operation.operation === "subscription") {
    var subscriptionType = schema.getSubscriptionType();
    if (!subscriptionType) {
      throw new GraphQLError("Schema is not configured for subscriptions.", operation);
    }
    return subscriptionType;
  }
  throw new GraphQLError("Can only have query, mutation and subscription operations.", operation);
}
var init_getOperationRootType = __esm({
  "node_modules/graphql/utilities/getOperationRootType.mjs"() {
    init_define_process_env();
    init_GraphQLError();
  }
});

// node_modules/graphql/jsutils/printPathArray.mjs
function printPathArray(path) {
  return path.map(function(key) {
    return typeof key === "number" ? "[" + key.toString() + "]" : "." + key;
  }).join("");
}
var init_printPathArray = __esm({
  "node_modules/graphql/jsutils/printPathArray.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type2, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    var variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    var variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type2)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type2)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type2.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    if (valueNode.kind === Kind.LIST) {
      var coercedValues = [];
      for (var _i2 = 0, _valueNode$values2 = valueNode.values; _i2 < _valueNode$values2.length; _i2++) {
        var itemNode = _valueNode$values2[_i2];
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          var itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    var coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type2)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    var coercedObj = Object.create(null);
    var fieldNodes = keyMap(valueNode.fields, function(field2) {
      return field2.name.value;
    });
    for (var _i4 = 0, _objectValues2 = objectValues_default(type2.getFields()); _i4 < _objectValues2.length; _i4++) {
      var field = _objectValues2[_i4];
      var fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      var fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    return coercedObj;
  }
  if (isLeafType(type2)) {
    var result;
    try {
      result = type2.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(0, "Unexpected input type: " + inspect(type2));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}
var init_valueFromAST = __esm({
  "node_modules/graphql/utilities/valueFromAST.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_keyMap();
    init_inspect();
    init_invariant();
    init_kinds();
    init_definition();
  }
});

// node_modules/graphql/utilities/coerceInputValue.mjs
function coerceInputValue(inputValue, type2) {
  var onError = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultOnError;
  return coerceInputValueImpl(inputValue, type2, onError);
}
function defaultOnError(path, invalidValue, error2) {
  var errorPrefix = "Invalid value " + inspect(invalidValue);
  if (path.length > 0) {
    errorPrefix += ' at "value'.concat(printPathArray(path), '"');
  }
  error2.message = errorPrefix + ": " + error2.message;
  throw error2;
}
function coerceInputValueImpl(inputValue, type2, onError, path) {
  if (isNonNullType(type2)) {
    if (inputValue != null) {
      return coerceInputValueImpl(inputValue, type2.ofType, onError, path);
    }
    onError(pathToArray(path), inputValue, new GraphQLError('Expected non-nullable type "'.concat(inspect(type2), '" not to be null.')));
    return;
  }
  if (inputValue == null) {
    return null;
  }
  if (isListType(type2)) {
    var itemType = type2.ofType;
    var coercedList = safeArrayFrom(inputValue, function(itemValue, index) {
      var itemPath = addPath(path, index, void 0);
      return coerceInputValueImpl(itemValue, itemType, onError, itemPath);
    });
    if (coercedList != null) {
      return coercedList;
    }
    return [coerceInputValueImpl(inputValue, itemType, onError, path)];
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(inputValue)) {
      onError(pathToArray(path), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '" to be an object.')));
      return;
    }
    var coercedValue = {};
    var fieldDefs = type2.getFields();
    for (var _i2 = 0, _objectValues2 = objectValues_default(fieldDefs); _i2 < _objectValues2.length; _i2++) {
      var field = _objectValues2[_i2];
      var fieldValue = inputValue[field.name];
      if (fieldValue === void 0) {
        if (field.defaultValue !== void 0) {
          coercedValue[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          var typeStr = inspect(field.type);
          onError(pathToArray(path), inputValue, new GraphQLError('Field "'.concat(field.name, '" of required type "').concat(typeStr, '" was not provided.')));
        }
        continue;
      }
      coercedValue[field.name] = coerceInputValueImpl(fieldValue, field.type, onError, addPath(path, field.name, type2.name));
    }
    for (var _i4 = 0, _Object$keys2 = Object.keys(inputValue); _i4 < _Object$keys2.length; _i4++) {
      var fieldName = _Object$keys2[_i4];
      if (!fieldDefs[fieldName]) {
        var suggestions = suggestionList(fieldName, Object.keys(type2.getFields()));
        onError(pathToArray(path), inputValue, new GraphQLError('Field "'.concat(fieldName, '" is not defined by type "').concat(type2.name, '".') + didYouMean(suggestions)));
      }
    }
    return coercedValue;
  }
  if (isLeafType(type2)) {
    var parseResult;
    try {
      parseResult = type2.parseValue(inputValue);
    } catch (error2) {
      if (error2 instanceof GraphQLError) {
        onError(pathToArray(path), inputValue, error2);
      } else {
        onError(pathToArray(path), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '". ') + error2.message, void 0, void 0, void 0, void 0, error2));
      }
      return;
    }
    if (parseResult === void 0) {
      onError(pathToArray(path), inputValue, new GraphQLError('Expected type "'.concat(type2.name, '".')));
    }
    return parseResult;
  }
  invariant(0, "Unexpected input type: " + inspect(type2));
}
var init_coerceInputValue = __esm({
  "node_modules/graphql/utilities/coerceInputValue.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_inspect();
    init_invariant();
    init_didYouMean();
    init_isObjectLike();
    init_safeArrayFrom();
    init_suggestionList();
    init_printPathArray();
    init_Path();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/execution/values.mjs
function getVariableValues(schema, varDefNodes, inputs, options) {
  var errors2 = [];
  var maxErrors = options === null || options === void 0 ? void 0 : options.maxErrors;
  try {
    var coerced = coerceVariableValues(schema, varDefNodes, inputs, function(error2) {
      if (maxErrors != null && errors2.length >= maxErrors) {
        throw new GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
      }
      errors2.push(error2);
    });
    if (errors2.length === 0) {
      return {
        coerced
      };
    }
  } catch (error2) {
    errors2.push(error2);
  }
  return {
    errors: errors2
  };
}
function coerceVariableValues(schema, varDefNodes, inputs, onError) {
  var coercedValues = {};
  var _loop = function _loop2(_i22) {
    var varDefNode = varDefNodes[_i22];
    var varName = varDefNode.variable.name.value;
    var varType = typeFromAST(schema, varDefNode.type);
    if (!isInputType(varType)) {
      var varTypeStr = print(varDefNode.type);
      onError(new GraphQLError('Variable "$'.concat(varName, '" expected value of type "').concat(varTypeStr, '" which cannot be used as an input type.'), varDefNode.type));
      return "continue";
    }
    if (!hasOwnProperty(inputs, varName)) {
      if (varDefNode.defaultValue) {
        coercedValues[varName] = valueFromAST(varDefNode.defaultValue, varType);
      } else if (isNonNullType(varType)) {
        var _varTypeStr = inspect(varType);
        onError(new GraphQLError('Variable "$'.concat(varName, '" of required type "').concat(_varTypeStr, '" was not provided.'), varDefNode));
      }
      return "continue";
    }
    var value = inputs[varName];
    if (value === null && isNonNullType(varType)) {
      var _varTypeStr2 = inspect(varType);
      onError(new GraphQLError('Variable "$'.concat(varName, '" of non-null type "').concat(_varTypeStr2, '" must not be null.'), varDefNode));
      return "continue";
    }
    coercedValues[varName] = coerceInputValue(value, varType, function(path, invalidValue, error2) {
      var prefix = 'Variable "$'.concat(varName, '" got invalid value ') + inspect(invalidValue);
      if (path.length > 0) {
        prefix += ' at "'.concat(varName).concat(printPathArray(path), '"');
      }
      onError(new GraphQLError(prefix + "; " + error2.message, varDefNode, void 0, void 0, void 0, error2.originalError));
    });
  };
  for (var _i2 = 0; _i2 < varDefNodes.length; _i2++) {
    var _ret = _loop(_i2);
    if (_ret === "continue")
      continue;
  }
  return coercedValues;
}
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  var coercedValues = {};
  var argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  var argNodeMap = keyMap(argumentNodes, function(arg) {
    return arg.name.value;
  });
  for (var _i4 = 0, _def$args2 = def.args; _i4 < _def$args2.length; _i4++) {
    var argDef = _def$args2[_i4];
    var name2 = argDef.name;
    var argType = argDef.type;
    var argumentNode = argNodeMap[name2];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name2] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError('Argument "'.concat(name2, '" of required type "').concat(inspect(argType), '" ') + "was not provided.", node);
      }
      continue;
    }
    var valueNode = argumentNode.value;
    var isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      var variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name2] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError('Argument "'.concat(name2, '" of required type "').concat(inspect(argType), '" ') + 'was provided the variable "$'.concat(variableName, '" which was not provided a runtime value.'), valueNode);
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError('Argument "'.concat(name2, '" of non-null type "').concat(inspect(argType), '" ') + "must not be null.", valueNode);
    }
    var coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError('Argument "'.concat(name2, '" has invalid value ').concat(print(valueNode), "."), valueNode);
    }
    coercedValues[name2] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var directiveNode = node.directives && find_default(node.directives, function(directive) {
    return directive.name.value === directiveDef.name;
  });
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
var init_values = __esm({
  "node_modules/graphql/execution/values.mjs"() {
    init_define_process_env();
    init_find();
    init_keyMap();
    init_inspect();
    init_printPathArray();
    init_GraphQLError();
    init_kinds();
    init_printer();
    init_definition();
    init_typeFromAST();
    init_valueFromAST();
    init_coerceInputValue();
  }
});

// node_modules/graphql/execution/execute.mjs
function execute(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  return arguments.length === 1 ? executeImpl(argsOrSchema) : executeImpl({
    schema: argsOrSchema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
function executeSync(args) {
  var result = executeImpl(args);
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function executeImpl(args) {
  var schema = args.schema, document2 = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
  assertValidExecutionArguments(schema, document2, variableValues);
  var exeContext = buildExecutionContext(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver);
  if (Array.isArray(exeContext)) {
    return {
      errors: exeContext
    };
  }
  var data = executeOperation(exeContext, exeContext.operation, rootValue);
  return buildResponse(exeContext, data);
}
function buildResponse(exeContext, data) {
  if (isPromise(data)) {
    return data.then(function(resolved) {
      return buildResponse(exeContext, resolved);
    });
  }
  return exeContext.errors.length === 0 ? {
    data
  } : {
    errors: exeContext.errors,
    data
  };
}
function assertValidExecutionArguments(schema, document2, rawVariableValues) {
  document2 || devAssert(0, "Must provide document.");
  assertValidSchema(schema);
  rawVariableValues == null || isObjectLike(rawVariableValues) || devAssert(0, "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided.");
}
function buildExecutionContext(schema, document2, rootValue, contextValue, rawVariableValues, operationName, fieldResolver, typeResolver) {
  var _definition$name, _operation$variableDe;
  var operation;
  var fragments = Object.create(null);
  for (var _i2 = 0, _document$definitions2 = document2.definitions; _i2 < _document$definitions2.length; _i2++) {
    var definition = _document$definitions2[_i2];
    switch (definition.kind) {
      case Kind.OPERATION_DEFINITION:
        if (operationName == null) {
          if (operation !== void 0) {
            return [new GraphQLError("Must provide operation name if query contains multiple operations.")];
          }
          operation = definition;
        } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
          operation = definition;
        }
        break;
      case Kind.FRAGMENT_DEFINITION:
        fragments[definition.name.value] = definition;
        break;
    }
  }
  if (!operation) {
    if (operationName != null) {
      return [new GraphQLError('Unknown operation named "'.concat(operationName, '".'))];
    }
    return [new GraphQLError("Must provide an operation.")];
  }
  var variableDefinitions = (_operation$variableDe = operation.variableDefinitions) !== null && _operation$variableDe !== void 0 ? _operation$variableDe : [];
  var coercedVariableValues = getVariableValues(schema, variableDefinitions, rawVariableValues !== null && rawVariableValues !== void 0 ? rawVariableValues : {}, {
    maxErrors: 50
  });
  if (coercedVariableValues.errors) {
    return coercedVariableValues.errors;
  }
  return {
    schema,
    fragments,
    rootValue,
    contextValue,
    operation,
    variableValues: coercedVariableValues.coerced,
    fieldResolver: fieldResolver !== null && fieldResolver !== void 0 ? fieldResolver : defaultFieldResolver,
    typeResolver: typeResolver !== null && typeResolver !== void 0 ? typeResolver : defaultTypeResolver,
    errors: []
  };
}
function executeOperation(exeContext, operation, rootValue) {
  var type2 = getOperationRootType(exeContext.schema, operation);
  var fields7 = collectFields(exeContext, type2, operation.selectionSet, Object.create(null), Object.create(null));
  var path = void 0;
  try {
    var result = operation.operation === "mutation" ? executeFieldsSerially(exeContext, type2, rootValue, path, fields7) : executeFields(exeContext, type2, rootValue, path, fields7);
    if (isPromise(result)) {
      return result.then(void 0, function(error2) {
        exeContext.errors.push(error2);
        return Promise.resolve(null);
      });
    }
    return result;
  } catch (error2) {
    exeContext.errors.push(error2);
    return null;
  }
}
function executeFieldsSerially(exeContext, parentType, sourceValue, path, fields7) {
  return promiseReduce(Object.keys(fields7), function(results, responseName) {
    var fieldNodes = fields7[responseName];
    var fieldPath = addPath(path, responseName, parentType.name);
    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
    if (result === void 0) {
      return results;
    }
    if (isPromise(result)) {
      return result.then(function(resolvedResult) {
        results[responseName] = resolvedResult;
        return results;
      });
    }
    results[responseName] = result;
    return results;
  }, Object.create(null));
}
function executeFields(exeContext, parentType, sourceValue, path, fields7) {
  var results = Object.create(null);
  var containsPromise = false;
  for (var _i4 = 0, _Object$keys2 = Object.keys(fields7); _i4 < _Object$keys2.length; _i4++) {
    var responseName = _Object$keys2[_i4];
    var fieldNodes = fields7[responseName];
    var fieldPath = addPath(path, responseName, parentType.name);
    var result = resolveField(exeContext, parentType, sourceValue, fieldNodes, fieldPath);
    if (result !== void 0) {
      results[responseName] = result;
      if (isPromise(result)) {
        containsPromise = true;
      }
    }
  }
  if (!containsPromise) {
    return results;
  }
  return promiseForObject(results);
}
function collectFields(exeContext, runtimeType, selectionSet, fields7, visitedFragmentNames) {
  for (var _i6 = 0, _selectionSet$selecti2 = selectionSet.selections; _i6 < _selectionSet$selecti2.length; _i6++) {
    var selection = _selectionSet$selecti2[_i6];
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(exeContext, selection)) {
          continue;
        }
        var name2 = getFieldEntryKey(selection);
        if (!fields7[name2]) {
          fields7[name2] = [];
        }
        fields7[name2].push(selection);
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(exeContext, selection) || !doesFragmentConditionMatch(exeContext, selection, runtimeType)) {
          continue;
        }
        collectFields(exeContext, runtimeType, selection.selectionSet, fields7, visitedFragmentNames);
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        var fragName = selection.name.value;
        if (visitedFragmentNames[fragName] || !shouldIncludeNode(exeContext, selection)) {
          continue;
        }
        visitedFragmentNames[fragName] = true;
        var fragment = exeContext.fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(exeContext, fragment, runtimeType)) {
          continue;
        }
        collectFields(exeContext, runtimeType, fragment.selectionSet, fields7, visitedFragmentNames);
        break;
      }
    }
  }
  return fields7;
}
function shouldIncludeNode(exeContext, node) {
  var skip = getDirectiveValues(GraphQLSkipDirective, node, exeContext.variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  var include = getDirectiveValues(GraphQLIncludeDirective, node, exeContext.variableValues);
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(exeContext, fragment, type2) {
  var typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  var conditionalType = typeFromAST(exeContext.schema, typeConditionNode);
  if (conditionalType === type2) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return exeContext.schema.isSubType(conditionalType, type2);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}
function resolveField(exeContext, parentType, source, fieldNodes, path) {
  var _fieldDef$resolve;
  var fieldNode = fieldNodes[0];
  var fieldName = fieldNode.name.value;
  var fieldDef = getFieldDef2(exeContext.schema, parentType, fieldName);
  if (!fieldDef) {
    return;
  }
  var returnType = fieldDef.type;
  var resolveFn = (_fieldDef$resolve = fieldDef.resolve) !== null && _fieldDef$resolve !== void 0 ? _fieldDef$resolve : exeContext.fieldResolver;
  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path);
  try {
    var args = getArgumentValues(fieldDef, fieldNodes[0], exeContext.variableValues);
    var _contextValue = exeContext.contextValue;
    var result = resolveFn(source, args, _contextValue, info);
    var completed;
    if (isPromise(result)) {
      completed = result.then(function(resolved) {
        return completeValue(exeContext, returnType, fieldNodes, info, path, resolved);
      });
    } else {
      completed = completeValue(exeContext, returnType, fieldNodes, info, path, result);
    }
    if (isPromise(completed)) {
      return completed.then(void 0, function(rawError) {
        var error3 = locatedError(rawError, fieldNodes, pathToArray(path));
        return handleFieldError(error3, returnType, exeContext);
      });
    }
    return completed;
  } catch (rawError) {
    var error2 = locatedError(rawError, fieldNodes, pathToArray(path));
    return handleFieldError(error2, returnType, exeContext);
  }
}
function buildResolveInfo(exeContext, fieldDef, fieldNodes, parentType, path) {
  return {
    fieldName: fieldDef.name,
    fieldNodes,
    returnType: fieldDef.type,
    parentType,
    path,
    schema: exeContext.schema,
    fragments: exeContext.fragments,
    rootValue: exeContext.rootValue,
    operation: exeContext.operation,
    variableValues: exeContext.variableValues
  };
}
function handleFieldError(error2, returnType, exeContext) {
  if (isNonNullType(returnType)) {
    throw error2;
  }
  exeContext.errors.push(error2);
  return null;
}
function completeValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (result instanceof Error) {
    throw result;
  }
  if (isNonNullType(returnType)) {
    var completed = completeValue(exeContext, returnType.ofType, fieldNodes, info, path, result);
    if (completed === null) {
      throw new Error("Cannot return null for non-nullable field ".concat(info.parentType.name, ".").concat(info.fieldName, "."));
    }
    return completed;
  }
  if (result == null) {
    return null;
  }
  if (isListType(returnType)) {
    return completeListValue(exeContext, returnType, fieldNodes, info, path, result);
  }
  if (isLeafType(returnType)) {
    return completeLeafValue(returnType, result);
  }
  if (isAbstractType(returnType)) {
    return completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result);
  }
  if (isObjectType(returnType)) {
    return completeObjectValue(exeContext, returnType, fieldNodes, info, path, result);
  }
  invariant(0, "Cannot complete value of unexpected output type: " + inspect(returnType));
}
function completeListValue(exeContext, returnType, fieldNodes, info, path, result) {
  var itemType = returnType.ofType;
  var containsPromise = false;
  var completedResults = safeArrayFrom(result, function(item, index) {
    var itemPath = addPath(path, index, void 0);
    try {
      var completedItem;
      if (isPromise(item)) {
        completedItem = item.then(function(resolved) {
          return completeValue(exeContext, itemType, fieldNodes, info, itemPath, resolved);
        });
      } else {
        completedItem = completeValue(exeContext, itemType, fieldNodes, info, itemPath, item);
      }
      if (isPromise(completedItem)) {
        containsPromise = true;
        return completedItem.then(void 0, function(rawError) {
          var error3 = locatedError(rawError, fieldNodes, pathToArray(itemPath));
          return handleFieldError(error3, itemType, exeContext);
        });
      }
      return completedItem;
    } catch (rawError) {
      var error2 = locatedError(rawError, fieldNodes, pathToArray(itemPath));
      return handleFieldError(error2, itemType, exeContext);
    }
  });
  if (completedResults == null) {
    throw new GraphQLError('Expected Iterable, but did not find one for field "'.concat(info.parentType.name, ".").concat(info.fieldName, '".'));
  }
  return containsPromise ? Promise.all(completedResults) : completedResults;
}
function completeLeafValue(returnType, result) {
  var serializedResult = returnType.serialize(result);
  if (serializedResult === void 0) {
    throw new Error('Expected a value of type "'.concat(inspect(returnType), '" but ') + "received: ".concat(inspect(result)));
  }
  return serializedResult;
}
function completeAbstractValue(exeContext, returnType, fieldNodes, info, path, result) {
  var _returnType$resolveTy;
  var resolveTypeFn = (_returnType$resolveTy = returnType.resolveType) !== null && _returnType$resolveTy !== void 0 ? _returnType$resolveTy : exeContext.typeResolver;
  var contextValue = exeContext.contextValue;
  var runtimeType = resolveTypeFn(result, contextValue, info, returnType);
  if (isPromise(runtimeType)) {
    return runtimeType.then(function(resolvedRuntimeType) {
      return completeObjectValue(exeContext, ensureValidRuntimeType(resolvedRuntimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
    });
  }
  return completeObjectValue(exeContext, ensureValidRuntimeType(runtimeType, exeContext, returnType, fieldNodes, info, result), fieldNodes, info, path, result);
}
function ensureValidRuntimeType(runtimeTypeOrName, exeContext, returnType, fieldNodes, info, result) {
  if (runtimeTypeOrName == null) {
    throw new GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '". Either the "').concat(returnType.name, '" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.'), fieldNodes);
  }
  var runtimeTypeName = isNamedType(runtimeTypeOrName) ? runtimeTypeOrName.name : runtimeTypeOrName;
  if (typeof runtimeTypeName !== "string") {
    throw new GraphQLError('Abstract type "'.concat(returnType.name, '" must resolve to an Object type at runtime for field "').concat(info.parentType.name, ".").concat(info.fieldName, '" with ') + "value ".concat(inspect(result), ', received "').concat(inspect(runtimeTypeOrName), '".'));
  }
  var runtimeType = exeContext.schema.getType(runtimeTypeName);
  if (runtimeType == null) {
    throw new GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a type "').concat(runtimeTypeName, '" that does not exist inside schema.'), fieldNodes);
  }
  if (!isObjectType(runtimeType)) {
    throw new GraphQLError('Abstract type "'.concat(returnType.name, '" was resolve to a non-object type "').concat(runtimeTypeName, '".'), fieldNodes);
  }
  if (!exeContext.schema.isSubType(returnType, runtimeType)) {
    throw new GraphQLError('Runtime Object type "'.concat(runtimeType.name, '" is not a possible type for "').concat(returnType.name, '".'), fieldNodes);
  }
  return runtimeType;
}
function completeObjectValue(exeContext, returnType, fieldNodes, info, path, result) {
  if (returnType.isTypeOf) {
    var isTypeOf = returnType.isTypeOf(result, exeContext.contextValue, info);
    if (isPromise(isTypeOf)) {
      return isTypeOf.then(function(resolvedIsTypeOf) {
        if (!resolvedIsTypeOf) {
          throw invalidReturnTypeError(returnType, result, fieldNodes);
        }
        return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
      });
    }
    if (!isTypeOf) {
      throw invalidReturnTypeError(returnType, result, fieldNodes);
    }
  }
  return collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result);
}
function invalidReturnTypeError(returnType, result, fieldNodes) {
  return new GraphQLError('Expected value of type "'.concat(returnType.name, '" but got: ').concat(inspect(result), "."), fieldNodes);
}
function collectAndExecuteSubfields(exeContext, returnType, fieldNodes, path, result) {
  var subFieldNodes = collectSubfields(exeContext, returnType, fieldNodes);
  return executeFields(exeContext, returnType, result, path, subFieldNodes);
}
function _collectSubfields(exeContext, returnType, fieldNodes) {
  var subFieldNodes = Object.create(null);
  var visitedFragmentNames = Object.create(null);
  for (var _i8 = 0; _i8 < fieldNodes.length; _i8++) {
    var node = fieldNodes[_i8];
    if (node.selectionSet) {
      subFieldNodes = collectFields(exeContext, returnType, node.selectionSet, subFieldNodes, visitedFragmentNames);
    }
  }
  return subFieldNodes;
}
function getFieldDef2(schema, parentType, fieldName) {
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === parentType) {
    return SchemaMetaFieldDef;
  } else if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === parentType) {
    return TypeMetaFieldDef;
  } else if (fieldName === TypeNameMetaFieldDef.name) {
    return TypeNameMetaFieldDef;
  }
  return parentType.getFields()[fieldName];
}
var collectSubfields, defaultTypeResolver, defaultFieldResolver;
var init_execute = __esm({
  "node_modules/graphql/execution/execute.mjs"() {
    init_define_process_env();
    init_inspect();
    init_memoize3();
    init_invariant();
    init_devAssert();
    init_isPromise();
    init_isObjectLike();
    init_safeArrayFrom();
    init_promiseReduce();
    init_promiseForObject();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_kinds();
    init_validate();
    init_introspection();
    init_directives();
    init_definition();
    init_typeFromAST();
    init_getOperationRootType();
    init_values();
    collectSubfields = memoize3(_collectSubfields);
    defaultTypeResolver = function defaultTypeResolver2(value, contextValue, info, abstractType) {
      if (isObjectLike(value) && typeof value.__typename === "string") {
        return value.__typename;
      }
      var possibleTypes = info.schema.getPossibleTypes(abstractType);
      var promisedIsTypeOfResults = [];
      for (var i = 0; i < possibleTypes.length; i++) {
        var type2 = possibleTypes[i];
        if (type2.isTypeOf) {
          var isTypeOfResult = type2.isTypeOf(value, contextValue, info);
          if (isPromise(isTypeOfResult)) {
            promisedIsTypeOfResults[i] = isTypeOfResult;
          } else if (isTypeOfResult) {
            return type2.name;
          }
        }
      }
      if (promisedIsTypeOfResults.length) {
        return Promise.all(promisedIsTypeOfResults).then(function(isTypeOfResults) {
          for (var _i9 = 0; _i9 < isTypeOfResults.length; _i9++) {
            if (isTypeOfResults[_i9]) {
              return possibleTypes[_i9].name;
            }
          }
        });
      }
    };
    defaultFieldResolver = function defaultFieldResolver2(source, args, contextValue, info) {
      if (isObjectLike(source) || typeof source === "function") {
        var property = source[info.fieldName];
        if (typeof property === "function") {
          return source[info.fieldName](args, contextValue, info);
        }
        return property;
      }
    };
  }
});

// node_modules/graphql/graphql.mjs
function graphql(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  var _arguments = arguments;
  return new Promise(function(resolve4) {
    return resolve4(_arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
      schema: argsOrSchema,
      source,
      rootValue,
      contextValue,
      variableValues,
      operationName,
      fieldResolver,
      typeResolver
    }));
  });
}
function graphqlSync(argsOrSchema, source, rootValue, contextValue, variableValues, operationName, fieldResolver, typeResolver) {
  var result = arguments.length === 1 ? graphqlImpl(argsOrSchema) : graphqlImpl({
    schema: argsOrSchema,
    source,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
  if (isPromise(result)) {
    throw new Error("GraphQL execution failed to complete synchronously.");
  }
  return result;
}
function graphqlImpl(args) {
  var schema = args.schema, source = args.source, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, typeResolver = args.typeResolver;
  var schemaValidationErrors = validateSchema(schema);
  if (schemaValidationErrors.length > 0) {
    return {
      errors: schemaValidationErrors
    };
  }
  var document2;
  try {
    document2 = parse(source);
  } catch (syntaxError2) {
    return {
      errors: [syntaxError2]
    };
  }
  var validationErrors = validate(schema, document2);
  if (validationErrors.length > 0) {
    return {
      errors: validationErrors
    };
  }
  return execute({
    schema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    typeResolver
  });
}
var init_graphql = __esm({
  "node_modules/graphql/graphql.mjs"() {
    init_define_process_env();
    init_isPromise();
    init_parser();
    init_validate2();
    init_validate();
    init_execute();
  }
});

// node_modules/graphql/type/index.mjs
var init_type = __esm({
  "node_modules/graphql/type/index.mjs"() {
    init_define_process_env();
    init_schema();
    init_definition();
    init_directives();
    init_scalars();
    init_introspection();
    init_validate();
  }
});

// node_modules/graphql/language/index.mjs
var init_language = __esm({
  "node_modules/graphql/language/index.mjs"() {
    init_define_process_env();
    init_source();
    init_location();
    init_printLocation();
    init_kinds();
    init_tokenKind();
    init_lexer();
    init_parser();
    init_printer();
    init_visitor();
    init_ast();
    init_predicates();
    init_directiveLocation();
  }
});

// node_modules/graphql/execution/index.mjs
var init_execution = __esm({
  "node_modules/graphql/execution/index.mjs"() {
    init_define_process_env();
    init_Path();
    init_execute();
    init_values();
  }
});

// node_modules/graphql/jsutils/isAsyncIterable.mjs
function isAsyncIterable(maybeAsyncIterable) {
  return typeof (maybeAsyncIterable === null || maybeAsyncIterable === void 0 ? void 0 : maybeAsyncIterable[SYMBOL_ASYNC_ITERATOR]) === "function";
}
var init_isAsyncIterable = __esm({
  "node_modules/graphql/jsutils/isAsyncIterable.mjs"() {
    init_define_process_env();
    init_symbols();
  }
});

// node_modules/graphql/subscription/mapAsyncIterator.mjs
function _defineProperty4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function mapAsyncIterator(iterable, callback, rejectCallback) {
  var iteratorMethod = iterable[SYMBOL_ASYNC_ITERATOR];
  var iterator = iteratorMethod.call(iterable);
  var $return;
  var abruptClose;
  if (typeof iterator.return === "function") {
    $return = iterator.return;
    abruptClose = function abruptClose2(error2) {
      var rethrow = function rethrow2() {
        return Promise.reject(error2);
      };
      return $return.call(iterator).then(rethrow, rethrow);
    };
  }
  function mapResult(result) {
    return result.done ? result : asyncMapValue(result.value, callback).then(iteratorResult, abruptClose);
  }
  var mapReject;
  if (rejectCallback) {
    var reject = rejectCallback;
    mapReject = function mapReject2(error2) {
      return asyncMapValue(error2, reject).then(iteratorResult, abruptClose);
    };
  }
  return _defineProperty4({
    next: function next() {
      return iterator.next().then(mapResult, mapReject);
    },
    return: function _return() {
      return $return ? $return.call(iterator).then(mapResult, mapReject) : Promise.resolve({
        value: void 0,
        done: true
      });
    },
    throw: function _throw(error2) {
      if (typeof iterator.throw === "function") {
        return iterator.throw(error2).then(mapResult, mapReject);
      }
      return Promise.reject(error2).catch(abruptClose);
    }
  }, SYMBOL_ASYNC_ITERATOR, function() {
    return this;
  });
}
function asyncMapValue(value, callback) {
  return new Promise(function(resolve4) {
    return resolve4(callback(value));
  });
}
function iteratorResult(value) {
  return {
    value,
    done: false
  };
}
var init_mapAsyncIterator = __esm({
  "node_modules/graphql/subscription/mapAsyncIterator.mjs"() {
    init_define_process_env();
    init_symbols();
  }
});

// node_modules/graphql/subscription/subscribe.mjs
function subscribe(argsOrSchema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver, subscribeFieldResolver) {
  return arguments.length === 1 ? subscribeImpl(argsOrSchema) : subscribeImpl({
    schema: argsOrSchema,
    document: document2,
    rootValue,
    contextValue,
    variableValues,
    operationName,
    fieldResolver,
    subscribeFieldResolver
  });
}
function reportGraphQLError(error2) {
  if (error2 instanceof GraphQLError) {
    return {
      errors: [error2]
    };
  }
  throw error2;
}
function subscribeImpl(args) {
  var schema = args.schema, document2 = args.document, rootValue = args.rootValue, contextValue = args.contextValue, variableValues = args.variableValues, operationName = args.operationName, fieldResolver = args.fieldResolver, subscribeFieldResolver = args.subscribeFieldResolver;
  var sourcePromise = createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, subscribeFieldResolver);
  var mapSourceToResponse = function mapSourceToResponse2(payload) {
    return execute({
      schema,
      document: document2,
      rootValue: payload,
      contextValue,
      variableValues,
      operationName,
      fieldResolver
    });
  };
  return sourcePromise.then(function(resultOrStream) {
    return isAsyncIterable(resultOrStream) ? mapAsyncIterator(resultOrStream, mapSourceToResponse, reportGraphQLError) : resultOrStream;
  });
}
function createSourceEventStream(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver) {
  assertValidExecutionArguments(schema, document2, variableValues);
  return new Promise(function(resolve4) {
    var exeContext = buildExecutionContext(schema, document2, rootValue, contextValue, variableValues, operationName, fieldResolver);
    resolve4(Array.isArray(exeContext) ? {
      errors: exeContext
    } : executeSubscription(exeContext));
  }).catch(reportGraphQLError);
}
function executeSubscription(exeContext) {
  var schema = exeContext.schema, operation = exeContext.operation, variableValues = exeContext.variableValues, rootValue = exeContext.rootValue;
  var type2 = getOperationRootType(schema, operation);
  var fields7 = collectFields(exeContext, type2, operation.selectionSet, Object.create(null), Object.create(null));
  var responseNames = Object.keys(fields7);
  var responseName = responseNames[0];
  var fieldNodes = fields7[responseName];
  var fieldNode = fieldNodes[0];
  var fieldName = fieldNode.name.value;
  var fieldDef = getFieldDef2(schema, type2, fieldName);
  if (!fieldDef) {
    throw new GraphQLError('The subscription field "'.concat(fieldName, '" is not defined.'), fieldNodes);
  }
  var path = addPath(void 0, responseName, type2.name);
  var info = buildResolveInfo(exeContext, fieldDef, fieldNodes, type2, path);
  return new Promise(function(resolveResult) {
    var _fieldDef$subscribe;
    var args = getArgumentValues(fieldDef, fieldNodes[0], variableValues);
    var contextValue = exeContext.contextValue;
    var resolveFn = (_fieldDef$subscribe = fieldDef.subscribe) !== null && _fieldDef$subscribe !== void 0 ? _fieldDef$subscribe : exeContext.fieldResolver;
    resolveResult(resolveFn(rootValue, args, contextValue, info));
  }).then(function(eventStream) {
    if (eventStream instanceof Error) {
      throw locatedError(eventStream, fieldNodes, pathToArray(path));
    }
    if (!isAsyncIterable(eventStream)) {
      throw new Error("Subscription field must return Async Iterable. " + "Received: ".concat(inspect(eventStream), "."));
    }
    return eventStream;
  }, function(error2) {
    throw locatedError(error2, fieldNodes, pathToArray(path));
  });
}
var init_subscribe = __esm({
  "node_modules/graphql/subscription/subscribe.mjs"() {
    init_define_process_env();
    init_inspect();
    init_isAsyncIterable();
    init_Path();
    init_GraphQLError();
    init_locatedError();
    init_values();
    init_execute();
    init_getOperationRootType();
    init_mapAsyncIterator();
  }
});

// node_modules/graphql/subscription/index.mjs
var init_subscription = __esm({
  "node_modules/graphql/subscription/index.mjs"() {
    init_define_process_env();
    init_subscribe();
  }
});

// node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs
function NoDeprecatedCustomRule(context) {
  return {
    Field: function Field3(node) {
      var fieldDef = context.getFieldDef();
      var deprecationReason = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.deprecationReason;
      if (fieldDef && deprecationReason != null) {
        var parentType = context.getParentType();
        parentType != null || invariant(0);
        context.reportError(new GraphQLError("The field ".concat(parentType.name, ".").concat(fieldDef.name, " is deprecated. ").concat(deprecationReason), node));
      }
    },
    Argument: function Argument3(node) {
      var argDef = context.getArgument();
      var deprecationReason = argDef === null || argDef === void 0 ? void 0 : argDef.deprecationReason;
      if (argDef && deprecationReason != null) {
        var directiveDef = context.getDirective();
        if (directiveDef != null) {
          context.reportError(new GraphQLError('Directive "@'.concat(directiveDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
        } else {
          var parentType = context.getParentType();
          var fieldDef = context.getFieldDef();
          parentType != null && fieldDef != null || invariant(0);
          context.reportError(new GraphQLError('Field "'.concat(parentType.name, ".").concat(fieldDef.name, '" argument "').concat(argDef.name, '" is deprecated. ').concat(deprecationReason), node));
        }
      }
    },
    ObjectField: function ObjectField2(node) {
      var inputObjectDef = getNamedType(context.getParentInputType());
      if (isInputObjectType(inputObjectDef)) {
        var inputFieldDef = inputObjectDef.getFields()[node.name.value];
        var deprecationReason = inputFieldDef === null || inputFieldDef === void 0 ? void 0 : inputFieldDef.deprecationReason;
        if (deprecationReason != null) {
          context.reportError(new GraphQLError("The input field ".concat(inputObjectDef.name, ".").concat(inputFieldDef.name, " is deprecated. ").concat(deprecationReason), node));
        }
      }
    },
    EnumValue: function EnumValue3(node) {
      var enumValueDef = context.getEnumValue();
      var deprecationReason = enumValueDef === null || enumValueDef === void 0 ? void 0 : enumValueDef.deprecationReason;
      if (enumValueDef && deprecationReason != null) {
        var enumTypeDef = getNamedType(context.getInputType());
        enumTypeDef != null || invariant(0);
        context.reportError(new GraphQLError('The enum value "'.concat(enumTypeDef.name, ".").concat(enumValueDef.name, '" is deprecated. ').concat(deprecationReason), node));
      }
    }
  };
}
var init_NoDeprecatedCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoDeprecatedCustomRule.mjs"() {
    init_define_process_env();
    init_invariant();
    init_GraphQLError();
    init_definition();
  }
});

// node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs
function NoSchemaIntrospectionCustomRule(context) {
  return {
    Field: function Field3(node) {
      var type2 = getNamedType(context.getType());
      if (type2 && isIntrospectionType(type2)) {
        context.reportError(new GraphQLError('GraphQL introspection has been disabled, but the requested query contained the field "'.concat(node.name.value, '".'), node));
      }
    }
  };
}
var init_NoSchemaIntrospectionCustomRule = __esm({
  "node_modules/graphql/validation/rules/custom/NoSchemaIntrospectionCustomRule.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_definition();
    init_introspection();
  }
});

// node_modules/graphql/validation/index.mjs
var init_validation = __esm({
  "node_modules/graphql/validation/index.mjs"() {
    init_define_process_env();
    init_validate2();
    init_ValidationContext();
    init_specifiedRules();
    init_ExecutableDefinitionsRule();
    init_FieldsOnCorrectTypeRule();
    init_FragmentsOnCompositeTypesRule();
    init_KnownArgumentNamesRule();
    init_KnownDirectivesRule();
    init_KnownFragmentNamesRule();
    init_KnownTypeNamesRule();
    init_LoneAnonymousOperationRule();
    init_NoFragmentCyclesRule();
    init_NoUndefinedVariablesRule();
    init_NoUnusedFragmentsRule();
    init_NoUnusedVariablesRule();
    init_OverlappingFieldsCanBeMergedRule();
    init_PossibleFragmentSpreadsRule();
    init_ProvidedRequiredArgumentsRule();
    init_ScalarLeafsRule();
    init_SingleFieldSubscriptionsRule();
    init_UniqueArgumentNamesRule();
    init_UniqueDirectivesPerLocationRule();
    init_UniqueFragmentNamesRule();
    init_UniqueInputFieldNamesRule();
    init_UniqueOperationNamesRule();
    init_UniqueVariableNamesRule();
    init_ValuesOfCorrectTypeRule();
    init_VariablesAreInputTypesRule();
    init_VariablesInAllowedPositionRule();
    init_LoneSchemaDefinitionRule();
    init_UniqueOperationTypesRule();
    init_UniqueTypeNamesRule();
    init_UniqueEnumValueNamesRule();
    init_UniqueFieldDefinitionNamesRule();
    init_UniqueDirectiveNamesRule();
    init_PossibleTypeExtensionsRule();
    init_NoDeprecatedCustomRule();
    init_NoSchemaIntrospectionCustomRule();
  }
});

// node_modules/graphql/error/formatError.mjs
function formatError(error2) {
  var _error$message;
  error2 || devAssert(0, "Received null or undefined error.");
  var message = (_error$message = error2.message) !== null && _error$message !== void 0 ? _error$message : "An unknown error occurred.";
  var locations = error2.locations;
  var path = error2.path;
  var extensions = error2.extensions;
  return extensions ? {
    message,
    locations,
    path,
    extensions
  } : {
    message,
    locations,
    path
  };
}
var init_formatError = __esm({
  "node_modules/graphql/error/formatError.mjs"() {
    init_define_process_env();
    init_devAssert();
  }
});

// node_modules/graphql/error/index.mjs
var init_error = __esm({
  "node_modules/graphql/error/index.mjs"() {
    init_define_process_env();
    init_GraphQLError();
    init_syntaxError();
    init_locatedError();
    init_formatError();
  }
});

// node_modules/graphql/utilities/getIntrospectionQuery.mjs
function ownKeys3(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty5(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function getIntrospectionQuery(options) {
  var optionsWithDefault = _objectSpread3({
    descriptions: true,
    specifiedByUrl: false,
    directiveIsRepeatable: false,
    schemaDescription: false,
    inputValueDeprecation: false
  }, options);
  var descriptions = optionsWithDefault.descriptions ? "description" : "";
  var specifiedByUrl = optionsWithDefault.specifiedByUrl ? "specifiedByUrl" : "";
  var directiveIsRepeatable = optionsWithDefault.directiveIsRepeatable ? "isRepeatable" : "";
  var schemaDescription = optionsWithDefault.schemaDescription ? descriptions : "";
  function inputDeprecation(str) {
    return optionsWithDefault.inputValueDeprecation ? str : "";
  }
  return "\n    query IntrospectionQuery {\n      __schema {\n        ".concat(schemaDescription, "\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ").concat(descriptions, "\n          ").concat(directiveIsRepeatable, "\n          locations\n          args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ").concat(descriptions, "\n      ").concat(specifiedByUrl, "\n      fields(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        args").concat(inputDeprecation("(includeDeprecated: true)"), " {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields").concat(inputDeprecation("(includeDeprecated: true)"), " {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ").concat(descriptions, "\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ").concat(descriptions, "\n      type { ...TypeRef }\n      defaultValue\n      ").concat(inputDeprecation("isDeprecated"), "\n      ").concat(inputDeprecation("deprecationReason"), "\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  ");
}
var init_getIntrospectionQuery = __esm({
  "node_modules/graphql/utilities/getIntrospectionQuery.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/utilities/getOperationAST.mjs
function getOperationAST(documentAST, operationName) {
  var operation = null;
  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var definition = _documentAST$definiti2[_i2];
    if (definition.kind === Kind.OPERATION_DEFINITION) {
      var _definition$name;
      if (operationName == null) {
        if (operation) {
          return null;
        }
        operation = definition;
      } else if (((_definition$name = definition.name) === null || _definition$name === void 0 ? void 0 : _definition$name.value) === operationName) {
        return definition;
      }
    }
  }
  return operation;
}
var init_getOperationAST = __esm({
  "node_modules/graphql/utilities/getOperationAST.mjs"() {
    init_define_process_env();
    init_kinds();
  }
});

// node_modules/graphql/utilities/introspectionFromSchema.mjs
function ownKeys4(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys4(Object(source), true).forEach(function(key) {
        _defineProperty6(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function introspectionFromSchema(schema, options) {
  var optionsWithDefaults = _objectSpread4({
    specifiedByUrl: true,
    directiveIsRepeatable: true,
    schemaDescription: true,
    inputValueDeprecation: true
  }, options);
  var document2 = parse(getIntrospectionQuery(optionsWithDefaults));
  var result = executeSync({
    schema,
    document: document2
  });
  !result.errors && result.data || invariant(0);
  return result.data;
}
var init_introspectionFromSchema = __esm({
  "node_modules/graphql/utilities/introspectionFromSchema.mjs"() {
    init_define_process_env();
    init_invariant();
    init_parser();
    init_execute();
    init_getIntrospectionQuery();
  }
});

// node_modules/graphql/utilities/buildClientSchema.mjs
function buildClientSchema(introspection, options) {
  isObjectLike(introspection) && isObjectLike(introspection.__schema) || devAssert(0, 'Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: '.concat(inspect(introspection), "."));
  var schemaIntrospection = introspection.__schema;
  var typeMap = keyValMap(schemaIntrospection.types, function(typeIntrospection) {
    return typeIntrospection.name;
  }, function(typeIntrospection) {
    return buildType(typeIntrospection);
  });
  for (var _i2 = 0, _ref2 = [].concat(specifiedScalarTypes, introspectionTypes); _i2 < _ref2.length; _i2++) {
    var stdType = _ref2[_i2];
    if (typeMap[stdType.name]) {
      typeMap[stdType.name] = stdType;
    }
  }
  var queryType = schemaIntrospection.queryType ? getObjectType(schemaIntrospection.queryType) : null;
  var mutationType = schemaIntrospection.mutationType ? getObjectType(schemaIntrospection.mutationType) : null;
  var subscriptionType = schemaIntrospection.subscriptionType ? getObjectType(schemaIntrospection.subscriptionType) : null;
  var directives = schemaIntrospection.directives ? schemaIntrospection.directives.map(buildDirective) : [];
  return new GraphQLSchema({
    description: schemaIntrospection.description,
    query: queryType,
    mutation: mutationType,
    subscription: subscriptionType,
    types: objectValues_default(typeMap),
    directives,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
  function getType(typeRef) {
    if (typeRef.kind === TypeKind.LIST) {
      var itemRef = typeRef.ofType;
      if (!itemRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      return new GraphQLList(getType(itemRef));
    }
    if (typeRef.kind === TypeKind.NON_NULL) {
      var nullableRef = typeRef.ofType;
      if (!nullableRef) {
        throw new Error("Decorated type deeper than introspection query.");
      }
      var nullableType = getType(nullableRef);
      return new GraphQLNonNull(assertNullableType(nullableType));
    }
    return getNamedType2(typeRef);
  }
  function getNamedType2(typeRef) {
    var typeName = typeRef.name;
    if (!typeName) {
      throw new Error("Unknown type reference: ".concat(inspect(typeRef), "."));
    }
    var type2 = typeMap[typeName];
    if (!type2) {
      throw new Error("Invalid or incomplete schema, unknown type: ".concat(typeName, ". Ensure that a full introspection query is used in order to build a client schema."));
    }
    return type2;
  }
  function getObjectType(typeRef) {
    return assertObjectType(getNamedType2(typeRef));
  }
  function getInterfaceType(typeRef) {
    return assertInterfaceType(getNamedType2(typeRef));
  }
  function buildType(type2) {
    if (type2 != null && type2.name != null && type2.kind != null) {
      switch (type2.kind) {
        case TypeKind.SCALAR:
          return buildScalarDef(type2);
        case TypeKind.OBJECT:
          return buildObjectDef(type2);
        case TypeKind.INTERFACE:
          return buildInterfaceDef(type2);
        case TypeKind.UNION:
          return buildUnionDef(type2);
        case TypeKind.ENUM:
          return buildEnumDef(type2);
        case TypeKind.INPUT_OBJECT:
          return buildInputObjectDef(type2);
      }
    }
    var typeStr = inspect(type2);
    throw new Error("Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ".concat(typeStr, "."));
  }
  function buildScalarDef(scalarIntrospection) {
    return new GraphQLScalarType({
      name: scalarIntrospection.name,
      description: scalarIntrospection.description,
      specifiedByUrl: scalarIntrospection.specifiedByUrl
    });
  }
  function buildImplementationsList(implementingIntrospection) {
    if (implementingIntrospection.interfaces === null && implementingIntrospection.kind === TypeKind.INTERFACE) {
      return [];
    }
    if (!implementingIntrospection.interfaces) {
      var implementingIntrospectionStr = inspect(implementingIntrospection);
      throw new Error("Introspection result missing interfaces: ".concat(implementingIntrospectionStr, "."));
    }
    return implementingIntrospection.interfaces.map(getInterfaceType);
  }
  function buildObjectDef(objectIntrospection) {
    return new GraphQLObjectType({
      name: objectIntrospection.name,
      description: objectIntrospection.description,
      interfaces: function interfaces() {
        return buildImplementationsList(objectIntrospection);
      },
      fields: function fields7() {
        return buildFieldDefMap(objectIntrospection);
      }
    });
  }
  function buildInterfaceDef(interfaceIntrospection) {
    return new GraphQLInterfaceType({
      name: interfaceIntrospection.name,
      description: interfaceIntrospection.description,
      interfaces: function interfaces() {
        return buildImplementationsList(interfaceIntrospection);
      },
      fields: function fields7() {
        return buildFieldDefMap(interfaceIntrospection);
      }
    });
  }
  function buildUnionDef(unionIntrospection) {
    if (!unionIntrospection.possibleTypes) {
      var unionIntrospectionStr = inspect(unionIntrospection);
      throw new Error("Introspection result missing possibleTypes: ".concat(unionIntrospectionStr, "."));
    }
    return new GraphQLUnionType({
      name: unionIntrospection.name,
      description: unionIntrospection.description,
      types: function types() {
        return unionIntrospection.possibleTypes.map(getObjectType);
      }
    });
  }
  function buildEnumDef(enumIntrospection) {
    if (!enumIntrospection.enumValues) {
      var enumIntrospectionStr = inspect(enumIntrospection);
      throw new Error("Introspection result missing enumValues: ".concat(enumIntrospectionStr, "."));
    }
    return new GraphQLEnumType({
      name: enumIntrospection.name,
      description: enumIntrospection.description,
      values: keyValMap(enumIntrospection.enumValues, function(valueIntrospection) {
        return valueIntrospection.name;
      }, function(valueIntrospection) {
        return {
          description: valueIntrospection.description,
          deprecationReason: valueIntrospection.deprecationReason
        };
      })
    });
  }
  function buildInputObjectDef(inputObjectIntrospection) {
    if (!inputObjectIntrospection.inputFields) {
      var inputObjectIntrospectionStr = inspect(inputObjectIntrospection);
      throw new Error("Introspection result missing inputFields: ".concat(inputObjectIntrospectionStr, "."));
    }
    return new GraphQLInputObjectType({
      name: inputObjectIntrospection.name,
      description: inputObjectIntrospection.description,
      fields: function fields7() {
        return buildInputValueDefMap(inputObjectIntrospection.inputFields);
      }
    });
  }
  function buildFieldDefMap(typeIntrospection) {
    if (!typeIntrospection.fields) {
      throw new Error("Introspection result missing fields: ".concat(inspect(typeIntrospection), "."));
    }
    return keyValMap(typeIntrospection.fields, function(fieldIntrospection) {
      return fieldIntrospection.name;
    }, buildField);
  }
  function buildField(fieldIntrospection) {
    var type2 = getType(fieldIntrospection.type);
    if (!isOutputType(type2)) {
      var typeStr = inspect(type2);
      throw new Error("Introspection must provide output type for fields, but received: ".concat(typeStr, "."));
    }
    if (!fieldIntrospection.args) {
      var fieldIntrospectionStr = inspect(fieldIntrospection);
      throw new Error("Introspection result missing field args: ".concat(fieldIntrospectionStr, "."));
    }
    return {
      description: fieldIntrospection.description,
      deprecationReason: fieldIntrospection.deprecationReason,
      type: type2,
      args: buildInputValueDefMap(fieldIntrospection.args)
    };
  }
  function buildInputValueDefMap(inputValueIntrospections) {
    return keyValMap(inputValueIntrospections, function(inputValue) {
      return inputValue.name;
    }, buildInputValue);
  }
  function buildInputValue(inputValueIntrospection) {
    var type2 = getType(inputValueIntrospection.type);
    if (!isInputType(type2)) {
      var typeStr = inspect(type2);
      throw new Error("Introspection must provide input type for arguments, but received: ".concat(typeStr, "."));
    }
    var defaultValue = inputValueIntrospection.defaultValue != null ? valueFromAST(parseValue(inputValueIntrospection.defaultValue), type2) : void 0;
    return {
      description: inputValueIntrospection.description,
      type: type2,
      defaultValue,
      deprecationReason: inputValueIntrospection.deprecationReason
    };
  }
  function buildDirective(directiveIntrospection) {
    if (!directiveIntrospection.args) {
      var directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error("Introspection result missing directive args: ".concat(directiveIntrospectionStr, "."));
    }
    if (!directiveIntrospection.locations) {
      var _directiveIntrospectionStr = inspect(directiveIntrospection);
      throw new Error("Introspection result missing directive locations: ".concat(_directiveIntrospectionStr, "."));
    }
    return new GraphQLDirective({
      name: directiveIntrospection.name,
      description: directiveIntrospection.description,
      isRepeatable: directiveIntrospection.isRepeatable,
      locations: directiveIntrospection.locations.slice(),
      args: buildInputValueDefMap(directiveIntrospection.args)
    });
  }
}
var init_buildClientSchema = __esm({
  "node_modules/graphql/utilities/buildClientSchema.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_inspect();
    init_devAssert();
    init_keyValMap();
    init_isObjectLike();
    init_parser();
    init_schema();
    init_directives();
    init_scalars();
    init_introspection();
    init_definition();
    init_valueFromAST();
  }
});

// node_modules/graphql/utilities/extendSchema.mjs
function ownKeys5(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys5(Object(source), true).forEach(function(key) {
        _defineProperty7(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function extendSchema(schema, documentAST, options) {
  assertSchema(schema);
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDLExtension(documentAST, schema);
  }
  var schemaConfig = schema.toConfig();
  var extendedConfig = extendSchemaImpl(schemaConfig, documentAST, options);
  return schemaConfig === extendedConfig ? schema : new GraphQLSchema(extendedConfig);
}
function extendSchemaImpl(schemaConfig, documentAST, options) {
  var _schemaDef, _schemaDef$descriptio, _schemaDef2, _options$assumeValid;
  var typeDefs = [];
  var typeExtensionsMap = Object.create(null);
  var directiveDefs = [];
  var schemaDef;
  var schemaExtensions = [];
  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var def = _documentAST$definiti2[_i2];
    if (def.kind === Kind.SCHEMA_DEFINITION) {
      schemaDef = def;
    } else if (def.kind === Kind.SCHEMA_EXTENSION) {
      schemaExtensions.push(def);
    } else if (isTypeDefinitionNode(def)) {
      typeDefs.push(def);
    } else if (isTypeExtensionNode(def)) {
      var extendedTypeName = def.name.value;
      var existingTypeExtensions = typeExtensionsMap[extendedTypeName];
      typeExtensionsMap[extendedTypeName] = existingTypeExtensions ? existingTypeExtensions.concat([def]) : [def];
    } else if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      directiveDefs.push(def);
    }
  }
  if (Object.keys(typeExtensionsMap).length === 0 && typeDefs.length === 0 && directiveDefs.length === 0 && schemaExtensions.length === 0 && schemaDef == null) {
    return schemaConfig;
  }
  var typeMap = Object.create(null);
  for (var _i4 = 0, _schemaConfig$types2 = schemaConfig.types; _i4 < _schemaConfig$types2.length; _i4++) {
    var existingType = _schemaConfig$types2[_i4];
    typeMap[existingType.name] = extendNamedType(existingType);
  }
  for (var _i6 = 0; _i6 < typeDefs.length; _i6++) {
    var _stdTypeMap$name;
    var typeNode = typeDefs[_i6];
    var name2 = typeNode.name.value;
    typeMap[name2] = (_stdTypeMap$name = stdTypeMap[name2]) !== null && _stdTypeMap$name !== void 0 ? _stdTypeMap$name : buildType(typeNode);
  }
  var operationTypes = _objectSpread5(_objectSpread5({
    query: schemaConfig.query && replaceNamedType(schemaConfig.query),
    mutation: schemaConfig.mutation && replaceNamedType(schemaConfig.mutation),
    subscription: schemaConfig.subscription && replaceNamedType(schemaConfig.subscription)
  }, schemaDef && getOperationTypes([schemaDef])), getOperationTypes(schemaExtensions));
  return _objectSpread5(_objectSpread5({
    description: (_schemaDef = schemaDef) === null || _schemaDef === void 0 ? void 0 : (_schemaDef$descriptio = _schemaDef.description) === null || _schemaDef$descriptio === void 0 ? void 0 : _schemaDef$descriptio.value
  }, operationTypes), {}, {
    types: objectValues_default(typeMap),
    directives: [].concat(schemaConfig.directives.map(replaceDirective), directiveDefs.map(buildDirective)),
    extensions: void 0,
    astNode: (_schemaDef2 = schemaDef) !== null && _schemaDef2 !== void 0 ? _schemaDef2 : schemaConfig.astNode,
    extensionASTNodes: schemaConfig.extensionASTNodes.concat(schemaExtensions),
    assumeValid: (_options$assumeValid = options === null || options === void 0 ? void 0 : options.assumeValid) !== null && _options$assumeValid !== void 0 ? _options$assumeValid : false
  });
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    }
    if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceDirective(directive) {
    var config = directive.toConfig();
    return new GraphQLDirective(_objectSpread5(_objectSpread5({}, config), {}, {
      args: mapValue(config.args, extendArg)
    }));
  }
  function extendNamedType(type2) {
    if (isIntrospectionType(type2) || isSpecifiedScalarType(type2)) {
      return type2;
    }
    if (isScalarType(type2)) {
      return extendScalarType(type2);
    }
    if (isObjectType(type2)) {
      return extendObjectType(type2);
    }
    if (isInterfaceType(type2)) {
      return extendInterfaceType(type2);
    }
    if (isUnionType(type2)) {
      return extendUnionType(type2);
    }
    if (isEnumType(type2)) {
      return extendEnumType(type2);
    }
    if (isInputObjectType(type2)) {
      return extendInputObjectType(type2);
    }
    invariant(0, "Unexpected type: " + inspect(type2));
  }
  function extendInputObjectType(type2) {
    var _typeExtensionsMap$co;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$co = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co !== void 0 ? _typeExtensionsMap$co : [];
    return new GraphQLInputObjectType(_objectSpread5(_objectSpread5({}, config), {}, {
      fields: function fields7() {
        return _objectSpread5(_objectSpread5({}, mapValue(config.fields, function(field) {
          return _objectSpread5(_objectSpread5({}, field), {}, {
            type: replaceType(field.type)
          });
        })), buildInputFieldMap(extensions));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendEnumType(type2) {
    var _typeExtensionsMap$ty;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$ty = typeExtensionsMap[type2.name]) !== null && _typeExtensionsMap$ty !== void 0 ? _typeExtensionsMap$ty : [];
    return new GraphQLEnumType(_objectSpread5(_objectSpread5({}, config), {}, {
      values: _objectSpread5(_objectSpread5({}, config.values), buildEnumValueMap(extensions)),
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendScalarType(type2) {
    var _typeExtensionsMap$co2;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$co2 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co2 !== void 0 ? _typeExtensionsMap$co2 : [];
    var specifiedByUrl = config.specifiedByUrl;
    for (var _i8 = 0; _i8 < extensions.length; _i8++) {
      var _getSpecifiedByUrl;
      var extensionNode = extensions[_i8];
      specifiedByUrl = (_getSpecifiedByUrl = getSpecifiedByUrl(extensionNode)) !== null && _getSpecifiedByUrl !== void 0 ? _getSpecifiedByUrl : specifiedByUrl;
    }
    return new GraphQLScalarType(_objectSpread5(_objectSpread5({}, config), {}, {
      specifiedByUrl,
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendObjectType(type2) {
    var _typeExtensionsMap$co3;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$co3 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co3 !== void 0 ? _typeExtensionsMap$co3 : [];
    return new GraphQLObjectType(_objectSpread5(_objectSpread5({}, config), {}, {
      interfaces: function interfaces() {
        return [].concat(type2.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
      },
      fields: function fields7() {
        return _objectSpread5(_objectSpread5({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendInterfaceType(type2) {
    var _typeExtensionsMap$co4;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$co4 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co4 !== void 0 ? _typeExtensionsMap$co4 : [];
    return new GraphQLInterfaceType(_objectSpread5(_objectSpread5({}, config), {}, {
      interfaces: function interfaces() {
        return [].concat(type2.getInterfaces().map(replaceNamedType), buildInterfaces(extensions));
      },
      fields: function fields7() {
        return _objectSpread5(_objectSpread5({}, mapValue(config.fields, extendField)), buildFieldMap(extensions));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendUnionType(type2) {
    var _typeExtensionsMap$co5;
    var config = type2.toConfig();
    var extensions = (_typeExtensionsMap$co5 = typeExtensionsMap[config.name]) !== null && _typeExtensionsMap$co5 !== void 0 ? _typeExtensionsMap$co5 : [];
    return new GraphQLUnionType(_objectSpread5(_objectSpread5({}, config), {}, {
      types: function types() {
        return [].concat(type2.getTypes().map(replaceNamedType), buildUnionTypes(extensions));
      },
      extensionASTNodes: config.extensionASTNodes.concat(extensions)
    }));
  }
  function extendField(field) {
    return _objectSpread5(_objectSpread5({}, field), {}, {
      type: replaceType(field.type),
      args: mapValue(field.args, extendArg)
    });
  }
  function extendArg(arg) {
    return _objectSpread5(_objectSpread5({}, arg), {}, {
      type: replaceType(arg.type)
    });
  }
  function getOperationTypes(nodes) {
    var opTypes = {};
    for (var _i10 = 0; _i10 < nodes.length; _i10++) {
      var _node$operationTypes;
      var node = nodes[_i10];
      var operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
      for (var _i12 = 0; _i12 < operationTypesNodes.length; _i12++) {
        var operationType = operationTypesNodes[_i12];
        opTypes[operationType.operation] = getNamedType2(operationType.type);
      }
    }
    return opTypes;
  }
  function getNamedType2(node) {
    var _stdTypeMap$name2;
    var name3 = node.name.value;
    var type2 = (_stdTypeMap$name2 = stdTypeMap[name3]) !== null && _stdTypeMap$name2 !== void 0 ? _stdTypeMap$name2 : typeMap[name3];
    if (type2 === void 0) {
      throw new Error('Unknown type: "'.concat(name3, '".'));
    }
    return type2;
  }
  function getWrappedType(node) {
    if (node.kind === Kind.LIST_TYPE) {
      return new GraphQLList(getWrappedType(node.type));
    }
    if (node.kind === Kind.NON_NULL_TYPE) {
      return new GraphQLNonNull(getWrappedType(node.type));
    }
    return getNamedType2(node);
  }
  function buildDirective(node) {
    var locations = node.locations.map(function(_ref) {
      var value = _ref.value;
      return value;
    });
    return new GraphQLDirective({
      name: node.name.value,
      description: getDescription(node, options),
      locations,
      isRepeatable: node.repeatable,
      args: buildArgumentMap(node.arguments),
      astNode: node
    });
  }
  function buildFieldMap(nodes) {
    var fieldConfigMap = Object.create(null);
    for (var _i14 = 0; _i14 < nodes.length; _i14++) {
      var _node$fields;
      var node = nodes[_i14];
      var nodeFields = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
      for (var _i16 = 0; _i16 < nodeFields.length; _i16++) {
        var field = nodeFields[_i16];
        fieldConfigMap[field.name.value] = {
          type: getWrappedType(field.type),
          description: getDescription(field, options),
          args: buildArgumentMap(field.arguments),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return fieldConfigMap;
  }
  function buildArgumentMap(args) {
    var argsNodes = args !== null && args !== void 0 ? args : [];
    var argConfigMap = Object.create(null);
    for (var _i18 = 0; _i18 < argsNodes.length; _i18++) {
      var arg = argsNodes[_i18];
      var type2 = getWrappedType(arg.type);
      argConfigMap[arg.name.value] = {
        type: type2,
        description: getDescription(arg, options),
        defaultValue: valueFromAST(arg.defaultValue, type2),
        deprecationReason: getDeprecationReason(arg),
        astNode: arg
      };
    }
    return argConfigMap;
  }
  function buildInputFieldMap(nodes) {
    var inputFieldMap = Object.create(null);
    for (var _i20 = 0; _i20 < nodes.length; _i20++) {
      var _node$fields2;
      var node = nodes[_i20];
      var fieldsNodes = (_node$fields2 = node.fields) !== null && _node$fields2 !== void 0 ? _node$fields2 : [];
      for (var _i22 = 0; _i22 < fieldsNodes.length; _i22++) {
        var field = fieldsNodes[_i22];
        var type2 = getWrappedType(field.type);
        inputFieldMap[field.name.value] = {
          type: type2,
          description: getDescription(field, options),
          defaultValue: valueFromAST(field.defaultValue, type2),
          deprecationReason: getDeprecationReason(field),
          astNode: field
        };
      }
    }
    return inputFieldMap;
  }
  function buildEnumValueMap(nodes) {
    var enumValueMap = Object.create(null);
    for (var _i24 = 0; _i24 < nodes.length; _i24++) {
      var _node$values;
      var node = nodes[_i24];
      var valuesNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
      for (var _i26 = 0; _i26 < valuesNodes.length; _i26++) {
        var value = valuesNodes[_i26];
        enumValueMap[value.name.value] = {
          description: getDescription(value, options),
          deprecationReason: getDeprecationReason(value),
          astNode: value
        };
      }
    }
    return enumValueMap;
  }
  function buildInterfaces(nodes) {
    var interfaces = [];
    for (var _i28 = 0; _i28 < nodes.length; _i28++) {
      var _node$interfaces;
      var node = nodes[_i28];
      var interfacesNodes = (_node$interfaces = node.interfaces) !== null && _node$interfaces !== void 0 ? _node$interfaces : [];
      for (var _i30 = 0; _i30 < interfacesNodes.length; _i30++) {
        var type2 = interfacesNodes[_i30];
        interfaces.push(getNamedType2(type2));
      }
    }
    return interfaces;
  }
  function buildUnionTypes(nodes) {
    var types = [];
    for (var _i32 = 0; _i32 < nodes.length; _i32++) {
      var _node$types;
      var node = nodes[_i32];
      var typeNodes = (_node$types = node.types) !== null && _node$types !== void 0 ? _node$types : [];
      for (var _i34 = 0; _i34 < typeNodes.length; _i34++) {
        var type2 = typeNodes[_i34];
        types.push(getNamedType2(type2));
      }
    }
    return types;
  }
  function buildType(astNode) {
    var _typeExtensionsMap$na;
    var name3 = astNode.name.value;
    var description = getDescription(astNode, options);
    var extensionNodes = (_typeExtensionsMap$na = typeExtensionsMap[name3]) !== null && _typeExtensionsMap$na !== void 0 ? _typeExtensionsMap$na : [];
    switch (astNode.kind) {
      case Kind.OBJECT_TYPE_DEFINITION: {
        var extensionASTNodes = extensionNodes;
        var allNodes = [astNode].concat(extensionASTNodes);
        return new GraphQLObjectType({
          name: name3,
          description,
          interfaces: function interfaces() {
            return buildInterfaces(allNodes);
          },
          fields: function fields7() {
            return buildFieldMap(allNodes);
          },
          astNode,
          extensionASTNodes
        });
      }
      case Kind.INTERFACE_TYPE_DEFINITION: {
        var _extensionASTNodes = extensionNodes;
        var _allNodes = [astNode].concat(_extensionASTNodes);
        return new GraphQLInterfaceType({
          name: name3,
          description,
          interfaces: function interfaces() {
            return buildInterfaces(_allNodes);
          },
          fields: function fields7() {
            return buildFieldMap(_allNodes);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes
        });
      }
      case Kind.ENUM_TYPE_DEFINITION: {
        var _extensionASTNodes2 = extensionNodes;
        var _allNodes2 = [astNode].concat(_extensionASTNodes2);
        return new GraphQLEnumType({
          name: name3,
          description,
          values: buildEnumValueMap(_allNodes2),
          astNode,
          extensionASTNodes: _extensionASTNodes2
        });
      }
      case Kind.UNION_TYPE_DEFINITION: {
        var _extensionASTNodes3 = extensionNodes;
        var _allNodes3 = [astNode].concat(_extensionASTNodes3);
        return new GraphQLUnionType({
          name: name3,
          description,
          types: function types() {
            return buildUnionTypes(_allNodes3);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes3
        });
      }
      case Kind.SCALAR_TYPE_DEFINITION: {
        var _extensionASTNodes4 = extensionNodes;
        return new GraphQLScalarType({
          name: name3,
          description,
          specifiedByUrl: getSpecifiedByUrl(astNode),
          astNode,
          extensionASTNodes: _extensionASTNodes4
        });
      }
      case Kind.INPUT_OBJECT_TYPE_DEFINITION: {
        var _extensionASTNodes5 = extensionNodes;
        var _allNodes4 = [astNode].concat(_extensionASTNodes5);
        return new GraphQLInputObjectType({
          name: name3,
          description,
          fields: function fields7() {
            return buildInputFieldMap(_allNodes4);
          },
          astNode,
          extensionASTNodes: _extensionASTNodes5
        });
      }
    }
    invariant(0, "Unexpected type definition node: " + inspect(astNode));
  }
}
function getDeprecationReason(node) {
  var deprecated = getDirectiveValues(GraphQLDeprecatedDirective, node);
  return deprecated === null || deprecated === void 0 ? void 0 : deprecated.reason;
}
function getSpecifiedByUrl(node) {
  var specifiedBy = getDirectiveValues(GraphQLSpecifiedByDirective, node);
  return specifiedBy === null || specifiedBy === void 0 ? void 0 : specifiedBy.url;
}
function getDescription(node, options) {
  if (node.description) {
    return node.description.value;
  }
  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {
    var rawValue = getLeadingCommentBlock(node);
    if (rawValue !== void 0) {
      return dedentBlockStringValue("\n" + rawValue);
    }
  }
}
function getLeadingCommentBlock(node) {
  var loc = node.loc;
  if (!loc) {
    return;
  }
  var comments = [];
  var token = loc.startToken.prev;
  while (token != null && token.kind === TokenKind.COMMENT && token.next && token.prev && token.line + 1 === token.next.line && token.line !== token.prev.line) {
    var value = String(token.value);
    comments.push(value);
    token = token.prev;
  }
  return comments.length > 0 ? comments.reverse().join("\n") : void 0;
}
var stdTypeMap;
var init_extendSchema = __esm({
  "node_modules/graphql/utilities/extendSchema.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_keyMap();
    init_inspect();
    init_mapValue();
    init_invariant();
    init_devAssert();
    init_kinds();
    init_tokenKind();
    init_blockString();
    init_predicates();
    init_validate2();
    init_values();
    init_schema();
    init_scalars();
    init_introspection();
    init_directives();
    init_definition();
    init_valueFromAST();
    stdTypeMap = keyMap(specifiedScalarTypes.concat(introspectionTypes), function(type2) {
      return type2.name;
    });
  }
});

// node_modules/graphql/utilities/buildASTSchema.mjs
function buildASTSchema(documentAST, options) {
  documentAST != null && documentAST.kind === Kind.DOCUMENT || devAssert(0, "Must provide valid Document AST.");
  if ((options === null || options === void 0 ? void 0 : options.assumeValid) !== true && (options === null || options === void 0 ? void 0 : options.assumeValidSDL) !== true) {
    assertValidSDL(documentAST);
  }
  var emptySchemaConfig = {
    description: void 0,
    types: [],
    directives: [],
    extensions: void 0,
    extensionASTNodes: [],
    assumeValid: false
  };
  var config = extendSchemaImpl(emptySchemaConfig, documentAST, options);
  if (config.astNode == null) {
    for (var _i2 = 0, _config$types2 = config.types; _i2 < _config$types2.length; _i2++) {
      var type2 = _config$types2[_i2];
      switch (type2.name) {
        case "Query":
          config.query = type2;
          break;
        case "Mutation":
          config.mutation = type2;
          break;
        case "Subscription":
          config.subscription = type2;
          break;
      }
    }
  }
  var directives = config.directives;
  var _loop = function _loop2(_i42) {
    var stdDirective = specifiedDirectives[_i42];
    if (directives.every(function(directive) {
      return directive.name !== stdDirective.name;
    })) {
      directives.push(stdDirective);
    }
  };
  for (var _i4 = 0; _i4 < specifiedDirectives.length; _i4++) {
    _loop(_i4);
  }
  return new GraphQLSchema(config);
}
function buildSchema(source, options) {
  var document2 = parse(source, {
    noLocation: options === null || options === void 0 ? void 0 : options.noLocation,
    allowLegacySDLEmptyFields: options === null || options === void 0 ? void 0 : options.allowLegacySDLEmptyFields,
    allowLegacySDLImplementsInterfaces: options === null || options === void 0 ? void 0 : options.allowLegacySDLImplementsInterfaces,
    experimentalFragmentVariables: options === null || options === void 0 ? void 0 : options.experimentalFragmentVariables
  });
  return buildASTSchema(document2, {
    commentDescriptions: options === null || options === void 0 ? void 0 : options.commentDescriptions,
    assumeValidSDL: options === null || options === void 0 ? void 0 : options.assumeValidSDL,
    assumeValid: options === null || options === void 0 ? void 0 : options.assumeValid
  });
}
var init_buildASTSchema = __esm({
  "node_modules/graphql/utilities/buildASTSchema.mjs"() {
    init_define_process_env();
    init_devAssert();
    init_kinds();
    init_parser();
    init_validate2();
    init_schema();
    init_directives();
    init_extendSchema();
  }
});

// node_modules/graphql/utilities/lexicographicSortSchema.mjs
function ownKeys6(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys6(Object(source), true).forEach(function(key) {
        _defineProperty8(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function lexicographicSortSchema(schema) {
  var schemaConfig = schema.toConfig();
  var typeMap = keyValMap(sortByName(schemaConfig.types), function(type2) {
    return type2.name;
  }, sortNamedType);
  return new GraphQLSchema(_objectSpread6(_objectSpread6({}, schemaConfig), {}, {
    types: objectValues_default(typeMap),
    directives: sortByName(schemaConfig.directives).map(sortDirective),
    query: replaceMaybeType(schemaConfig.query),
    mutation: replaceMaybeType(schemaConfig.mutation),
    subscription: replaceMaybeType(schemaConfig.subscription)
  }));
  function replaceType(type2) {
    if (isListType(type2)) {
      return new GraphQLList(replaceType(type2.ofType));
    } else if (isNonNullType(type2)) {
      return new GraphQLNonNull(replaceType(type2.ofType));
    }
    return replaceNamedType(type2);
  }
  function replaceNamedType(type2) {
    return typeMap[type2.name];
  }
  function replaceMaybeType(maybeType) {
    return maybeType && replaceNamedType(maybeType);
  }
  function sortDirective(directive) {
    var config = directive.toConfig();
    return new GraphQLDirective(_objectSpread6(_objectSpread6({}, config), {}, {
      locations: sortBy(config.locations, function(x) {
        return x;
      }),
      args: sortArgs(config.args)
    }));
  }
  function sortArgs(args) {
    return sortObjMap(args, function(arg) {
      return _objectSpread6(_objectSpread6({}, arg), {}, {
        type: replaceType(arg.type)
      });
    });
  }
  function sortFields(fieldsMap) {
    return sortObjMap(fieldsMap, function(field) {
      return _objectSpread6(_objectSpread6({}, field), {}, {
        type: replaceType(field.type),
        args: sortArgs(field.args)
      });
    });
  }
  function sortInputFields(fieldsMap) {
    return sortObjMap(fieldsMap, function(field) {
      return _objectSpread6(_objectSpread6({}, field), {}, {
        type: replaceType(field.type)
      });
    });
  }
  function sortTypes(arr) {
    return sortByName(arr).map(replaceNamedType);
  }
  function sortNamedType(type2) {
    if (isScalarType(type2) || isIntrospectionType(type2)) {
      return type2;
    }
    if (isObjectType(type2)) {
      var config = type2.toConfig();
      return new GraphQLObjectType(_objectSpread6(_objectSpread6({}, config), {}, {
        interfaces: function interfaces() {
          return sortTypes(config.interfaces);
        },
        fields: function fields7() {
          return sortFields(config.fields);
        }
      }));
    }
    if (isInterfaceType(type2)) {
      var _config = type2.toConfig();
      return new GraphQLInterfaceType(_objectSpread6(_objectSpread6({}, _config), {}, {
        interfaces: function interfaces() {
          return sortTypes(_config.interfaces);
        },
        fields: function fields7() {
          return sortFields(_config.fields);
        }
      }));
    }
    if (isUnionType(type2)) {
      var _config2 = type2.toConfig();
      return new GraphQLUnionType(_objectSpread6(_objectSpread6({}, _config2), {}, {
        types: function types() {
          return sortTypes(_config2.types);
        }
      }));
    }
    if (isEnumType(type2)) {
      var _config3 = type2.toConfig();
      return new GraphQLEnumType(_objectSpread6(_objectSpread6({}, _config3), {}, {
        values: sortObjMap(_config3.values)
      }));
    }
    if (isInputObjectType(type2)) {
      var _config4 = type2.toConfig();
      return new GraphQLInputObjectType(_objectSpread6(_objectSpread6({}, _config4), {}, {
        fields: function fields7() {
          return sortInputFields(_config4.fields);
        }
      }));
    }
    invariant(0, "Unexpected type: " + inspect(type2));
  }
}
function sortObjMap(map2, sortValueFn) {
  var sortedMap = Object.create(null);
  var sortedKeys = sortBy(Object.keys(map2), function(x) {
    return x;
  });
  for (var _i2 = 0; _i2 < sortedKeys.length; _i2++) {
    var key = sortedKeys[_i2];
    var value = map2[key];
    sortedMap[key] = sortValueFn ? sortValueFn(value) : value;
  }
  return sortedMap;
}
function sortByName(array) {
  return sortBy(array, function(obj) {
    return obj.name;
  });
}
function sortBy(array, mapToKey) {
  return array.slice().sort(function(obj1, obj2) {
    var key1 = mapToKey(obj1);
    var key2 = mapToKey(obj2);
    return naturalCompare(key1, key2);
  });
}
var init_lexicographicSortSchema = __esm({
  "node_modules/graphql/utilities/lexicographicSortSchema.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_inspect();
    init_invariant();
    init_keyValMap();
    init_naturalCompare();
    init_schema();
    init_directives();
    init_introspection();
    init_definition();
  }
});

// node_modules/graphql/utilities/printSchema.mjs
function printSchema(schema, options) {
  return printFilteredSchema(schema, function(n) {
    return !isSpecifiedDirective(n);
  }, isDefinedType, options);
}
function printIntrospectionSchema(schema, options) {
  return printFilteredSchema(schema, isSpecifiedDirective, isIntrospectionType, options);
}
function isDefinedType(type2) {
  return !isSpecifiedScalarType(type2) && !isIntrospectionType(type2);
}
function printFilteredSchema(schema, directiveFilter, typeFilter, options) {
  var directives = schema.getDirectives().filter(directiveFilter);
  var types = objectValues_default(schema.getTypeMap()).filter(typeFilter);
  return [printSchemaDefinition(schema)].concat(directives.map(function(directive) {
    return printDirective(directive, options);
  }), types.map(function(type2) {
    return printType(type2, options);
  })).filter(Boolean).join("\n\n") + "\n";
}
function printSchemaDefinition(schema) {
  if (schema.description == null && isSchemaOfCommonNames(schema)) {
    return;
  }
  var operationTypes = [];
  var queryType = schema.getQueryType();
  if (queryType) {
    operationTypes.push("  query: ".concat(queryType.name));
  }
  var mutationType = schema.getMutationType();
  if (mutationType) {
    operationTypes.push("  mutation: ".concat(mutationType.name));
  }
  var subscriptionType = schema.getSubscriptionType();
  if (subscriptionType) {
    operationTypes.push("  subscription: ".concat(subscriptionType.name));
  }
  return printDescription({}, schema) + "schema {\n".concat(operationTypes.join("\n"), "\n}");
}
function isSchemaOfCommonNames(schema) {
  var queryType = schema.getQueryType();
  if (queryType && queryType.name !== "Query") {
    return false;
  }
  var mutationType = schema.getMutationType();
  if (mutationType && mutationType.name !== "Mutation") {
    return false;
  }
  var subscriptionType = schema.getSubscriptionType();
  if (subscriptionType && subscriptionType.name !== "Subscription") {
    return false;
  }
  return true;
}
function printType(type2, options) {
  if (isScalarType(type2)) {
    return printScalar(type2, options);
  }
  if (isObjectType(type2)) {
    return printObject(type2, options);
  }
  if (isInterfaceType(type2)) {
    return printInterface(type2, options);
  }
  if (isUnionType(type2)) {
    return printUnion(type2, options);
  }
  if (isEnumType(type2)) {
    return printEnum(type2, options);
  }
  if (isInputObjectType(type2)) {
    return printInputObject(type2, options);
  }
  invariant(0, "Unexpected type: " + inspect(type2));
}
function printScalar(type2, options) {
  return printDescription(options, type2) + "scalar ".concat(type2.name) + printSpecifiedByUrl(type2);
}
function printImplementedInterfaces(type2) {
  var interfaces = type2.getInterfaces();
  return interfaces.length ? " implements " + interfaces.map(function(i) {
    return i.name;
  }).join(" & ") : "";
}
function printObject(type2, options) {
  return printDescription(options, type2) + "type ".concat(type2.name) + printImplementedInterfaces(type2) + printFields(options, type2);
}
function printInterface(type2, options) {
  return printDescription(options, type2) + "interface ".concat(type2.name) + printImplementedInterfaces(type2) + printFields(options, type2);
}
function printUnion(type2, options) {
  var types = type2.getTypes();
  var possibleTypes = types.length ? " = " + types.join(" | ") : "";
  return printDescription(options, type2) + "union " + type2.name + possibleTypes;
}
function printEnum(type2, options) {
  var values = type2.getValues().map(function(value, i) {
    return printDescription(options, value, "  ", !i) + "  " + value.name + printDeprecated(value.deprecationReason);
  });
  return printDescription(options, type2) + "enum ".concat(type2.name) + printBlock(values);
}
function printInputObject(type2, options) {
  var fields7 = objectValues_default(type2.getFields()).map(function(f, i) {
    return printDescription(options, f, "  ", !i) + "  " + printInputValue(f);
  });
  return printDescription(options, type2) + "input ".concat(type2.name) + printBlock(fields7);
}
function printFields(options, type2) {
  var fields7 = objectValues_default(type2.getFields()).map(function(f, i) {
    return printDescription(options, f, "  ", !i) + "  " + f.name + printArgs(options, f.args, "  ") + ": " + String(f.type) + printDeprecated(f.deprecationReason);
  });
  return printBlock(fields7);
}
function printBlock(items) {
  return items.length !== 0 ? " {\n" + items.join("\n") + "\n}" : "";
}
function printArgs(options, args) {
  var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  if (args.length === 0) {
    return "";
  }
  if (args.every(function(arg) {
    return !arg.description;
  })) {
    return "(" + args.map(printInputValue).join(", ") + ")";
  }
  return "(\n" + args.map(function(arg, i) {
    return printDescription(options, arg, "  " + indentation, !i) + "  " + indentation + printInputValue(arg);
  }).join("\n") + "\n" + indentation + ")";
}
function printInputValue(arg) {
  var defaultAST = astFromValue(arg.defaultValue, arg.type);
  var argDecl = arg.name + ": " + String(arg.type);
  if (defaultAST) {
    argDecl += " = ".concat(print(defaultAST));
  }
  return argDecl + printDeprecated(arg.deprecationReason);
}
function printDirective(directive, options) {
  return printDescription(options, directive) + "directive @" + directive.name + printArgs(options, directive.args) + (directive.isRepeatable ? " repeatable" : "") + " on " + directive.locations.join(" | ");
}
function printDeprecated(reason) {
  if (reason == null) {
    return "";
  }
  var reasonAST = astFromValue(reason, GraphQLString);
  if (reasonAST && reason !== DEFAULT_DEPRECATION_REASON) {
    return " @deprecated(reason: " + print(reasonAST) + ")";
  }
  return " @deprecated";
}
function printSpecifiedByUrl(scalar) {
  if (scalar.specifiedByUrl == null) {
    return "";
  }
  var url = scalar.specifiedByUrl;
  var urlAST = astFromValue(url, GraphQLString);
  urlAST || invariant(0, "Unexpected null value returned from `astFromValue` for specifiedByUrl");
  return " @specifiedBy(url: " + print(urlAST) + ")";
}
function printDescription(options, def) {
  var indentation = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "";
  var firstInBlock = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;
  var description = def.description;
  if (description == null) {
    return "";
  }
  if ((options === null || options === void 0 ? void 0 : options.commentDescriptions) === true) {
    return printDescriptionWithComments(description, indentation, firstInBlock);
  }
  var preferMultipleLines = description.length > 70;
  var blockString = printBlockString(description, "", preferMultipleLines);
  var prefix = indentation && !firstInBlock ? "\n" + indentation : indentation;
  return prefix + blockString.replace(/\n/g, "\n" + indentation) + "\n";
}
function printDescriptionWithComments(description, indentation, firstInBlock) {
  var prefix = indentation && !firstInBlock ? "\n" : "";
  var comment = description.split("\n").map(function(line) {
    return indentation + (line !== "" ? "# " + line : "#");
  }).join("\n");
  return prefix + comment + "\n";
}
var init_printSchema = __esm({
  "node_modules/graphql/utilities/printSchema.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_inspect();
    init_invariant();
    init_printer();
    init_blockString();
    init_introspection();
    init_scalars();
    init_directives();
    init_definition();
    init_astFromValue();
  }
});

// node_modules/graphql/utilities/concatAST.mjs
function concatAST(documents) {
  var definitions = [];
  for (var _i2 = 0; _i2 < documents.length; _i2++) {
    var doc = documents[_i2];
    definitions = definitions.concat(doc.definitions);
  }
  return {
    kind: "Document",
    definitions
  };
}
var init_concatAST = __esm({
  "node_modules/graphql/utilities/concatAST.mjs"() {
    init_define_process_env();
  }
});

// node_modules/graphql/utilities/separateOperations.mjs
function separateOperations(documentAST) {
  var operations = [];
  var depGraph = Object.create(null);
  for (var _i2 = 0, _documentAST$definiti2 = documentAST.definitions; _i2 < _documentAST$definiti2.length; _i2++) {
    var definitionNode = _documentAST$definiti2[_i2];
    switch (definitionNode.kind) {
      case Kind.OPERATION_DEFINITION:
        operations.push(definitionNode);
        break;
      case Kind.FRAGMENT_DEFINITION:
        depGraph[definitionNode.name.value] = collectDependencies(definitionNode.selectionSet);
        break;
    }
  }
  var separatedDocumentASTs = Object.create(null);
  var _loop = function _loop2(_i42) {
    var operation = operations[_i42];
    var dependencies = new Set();
    for (var _i6 = 0, _collectDependencies2 = collectDependencies(operation.selectionSet); _i6 < _collectDependencies2.length; _i6++) {
      var fragmentName = _collectDependencies2[_i6];
      collectTransitiveDependencies(dependencies, depGraph, fragmentName);
    }
    var operationName = operation.name ? operation.name.value : "";
    separatedDocumentASTs[operationName] = {
      kind: Kind.DOCUMENT,
      definitions: documentAST.definitions.filter(function(node) {
        return node === operation || node.kind === Kind.FRAGMENT_DEFINITION && dependencies.has(node.name.value);
      })
    };
  };
  for (var _i4 = 0; _i4 < operations.length; _i4++) {
    _loop(_i4);
  }
  return separatedDocumentASTs;
}
function collectTransitiveDependencies(collected, depGraph, fromName) {
  if (!collected.has(fromName)) {
    collected.add(fromName);
    var immediateDeps = depGraph[fromName];
    if (immediateDeps !== void 0) {
      for (var _i8 = 0; _i8 < immediateDeps.length; _i8++) {
        var toName = immediateDeps[_i8];
        collectTransitiveDependencies(collected, depGraph, toName);
      }
    }
  }
}
function collectDependencies(selectionSet) {
  var dependencies = [];
  visit(selectionSet, {
    FragmentSpread: function FragmentSpread2(node) {
      dependencies.push(node.name.value);
    }
  });
  return dependencies;
}
var init_separateOperations = __esm({
  "node_modules/graphql/utilities/separateOperations.mjs"() {
    init_define_process_env();
    init_kinds();
    init_visitor();
  }
});

// node_modules/graphql/utilities/stripIgnoredCharacters.mjs
function stripIgnoredCharacters(source) {
  var sourceObj = isSource(source) ? source : new Source(source);
  var body = sourceObj.body;
  var lexer = new Lexer(sourceObj);
  var strippedBody = "";
  var wasLastAddedTokenNonPunctuator = false;
  while (lexer.advance().kind !== TokenKind.EOF) {
    var currentToken = lexer.token;
    var tokenKind = currentToken.kind;
    var isNonPunctuator = !isPunctuatorTokenKind(currentToken.kind);
    if (wasLastAddedTokenNonPunctuator) {
      if (isNonPunctuator || currentToken.kind === TokenKind.SPREAD) {
        strippedBody += " ";
      }
    }
    var tokenBody = body.slice(currentToken.start, currentToken.end);
    if (tokenKind === TokenKind.BLOCK_STRING) {
      strippedBody += dedentBlockString(tokenBody);
    } else {
      strippedBody += tokenBody;
    }
    wasLastAddedTokenNonPunctuator = isNonPunctuator;
  }
  return strippedBody;
}
function dedentBlockString(blockStr) {
  var rawStr = blockStr.slice(3, -3);
  var body = dedentBlockStringValue(rawStr);
  if (getBlockStringIndentation(body) > 0) {
    body = "\n" + body;
  }
  var lastChar = body[body.length - 1];
  var hasTrailingQuote = lastChar === '"' && body.slice(-4) !== '\\"""';
  if (hasTrailingQuote || lastChar === "\\") {
    body += "\n";
  }
  return '"""' + body + '"""';
}
var init_stripIgnoredCharacters = __esm({
  "node_modules/graphql/utilities/stripIgnoredCharacters.mjs"() {
    init_define_process_env();
    init_source();
    init_tokenKind();
    init_lexer();
    init_blockString();
  }
});

// node_modules/graphql/utilities/findBreakingChanges.mjs
function ownKeys7(object, enumerableOnly) {
  var keys = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys.push.apply(keys, symbols);
  }
  return keys;
}
function _objectSpread7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys7(Object(source), true).forEach(function(key) {
        _defineProperty9(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function findBreakingChanges(oldSchema, newSchema) {
  var breakingChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
    return change.type in BreakingChangeType;
  });
  return breakingChanges;
}
function findDangerousChanges(oldSchema, newSchema) {
  var dangerousChanges = findSchemaChanges(oldSchema, newSchema).filter(function(change) {
    return change.type in DangerousChangeType;
  });
  return dangerousChanges;
}
function findSchemaChanges(oldSchema, newSchema) {
  return [].concat(findTypeChanges(oldSchema, newSchema), findDirectiveChanges(oldSchema, newSchema));
}
function findDirectiveChanges(oldSchema, newSchema) {
  var schemaChanges = [];
  var directivesDiff = diff(oldSchema.getDirectives(), newSchema.getDirectives());
  for (var _i2 = 0, _directivesDiff$remov2 = directivesDiff.removed; _i2 < _directivesDiff$remov2.length; _i2++) {
    var oldDirective = _directivesDiff$remov2[_i2];
    schemaChanges.push({
      type: BreakingChangeType.DIRECTIVE_REMOVED,
      description: "".concat(oldDirective.name, " was removed.")
    });
  }
  for (var _i4 = 0, _directivesDiff$persi2 = directivesDiff.persisted; _i4 < _directivesDiff$persi2.length; _i4++) {
    var _ref2 = _directivesDiff$persi2[_i4];
    var _oldDirective = _ref2[0];
    var newDirective = _ref2[1];
    var argsDiff = diff(_oldDirective.args, newDirective.args);
    for (var _i6 = 0, _argsDiff$added2 = argsDiff.added; _i6 < _argsDiff$added2.length; _i6++) {
      var newArg = _argsDiff$added2[_i6];
      if (isRequiredArgument(newArg)) {
        schemaChanges.push({
          type: BreakingChangeType.REQUIRED_DIRECTIVE_ARG_ADDED,
          description: "A required arg ".concat(newArg.name, " on directive ").concat(_oldDirective.name, " was added.")
        });
      }
    }
    for (var _i8 = 0, _argsDiff$removed2 = argsDiff.removed; _i8 < _argsDiff$removed2.length; _i8++) {
      var oldArg = _argsDiff$removed2[_i8];
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_ARG_REMOVED,
        description: "".concat(oldArg.name, " was removed from ").concat(_oldDirective.name, ".")
      });
    }
    if (_oldDirective.isRepeatable && !newDirective.isRepeatable) {
      schemaChanges.push({
        type: BreakingChangeType.DIRECTIVE_REPEATABLE_REMOVED,
        description: "Repeatable flag was removed from ".concat(_oldDirective.name, ".")
      });
    }
    for (var _i10 = 0, _oldDirective$locatio2 = _oldDirective.locations; _i10 < _oldDirective$locatio2.length; _i10++) {
      var location = _oldDirective$locatio2[_i10];
      if (newDirective.locations.indexOf(location) === -1) {
        schemaChanges.push({
          type: BreakingChangeType.DIRECTIVE_LOCATION_REMOVED,
          description: "".concat(location, " was removed from ").concat(_oldDirective.name, ".")
        });
      }
    }
  }
  return schemaChanges;
}
function findTypeChanges(oldSchema, newSchema) {
  var schemaChanges = [];
  var typesDiff = diff(objectValues_default(oldSchema.getTypeMap()), objectValues_default(newSchema.getTypeMap()));
  for (var _i12 = 0, _typesDiff$removed2 = typesDiff.removed; _i12 < _typesDiff$removed2.length; _i12++) {
    var oldType = _typesDiff$removed2[_i12];
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED,
      description: isSpecifiedScalarType(oldType) ? "Standard scalar ".concat(oldType.name, " was removed because it is not referenced anymore.") : "".concat(oldType.name, " was removed.")
    });
  }
  for (var _i14 = 0, _typesDiff$persisted2 = typesDiff.persisted; _i14 < _typesDiff$persisted2.length; _i14++) {
    var _ref4 = _typesDiff$persisted2[_i14];
    var _oldType = _ref4[0];
    var newType = _ref4[1];
    if (isEnumType(_oldType) && isEnumType(newType)) {
      schemaChanges.push.apply(schemaChanges, findEnumTypeChanges(_oldType, newType));
    } else if (isUnionType(_oldType) && isUnionType(newType)) {
      schemaChanges.push.apply(schemaChanges, findUnionTypeChanges(_oldType, newType));
    } else if (isInputObjectType(_oldType) && isInputObjectType(newType)) {
      schemaChanges.push.apply(schemaChanges, findInputObjectTypeChanges(_oldType, newType));
    } else if (isObjectType(_oldType) && isObjectType(newType)) {
      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
    } else if (isInterfaceType(_oldType) && isInterfaceType(newType)) {
      schemaChanges.push.apply(schemaChanges, findFieldChanges(_oldType, newType).concat(findImplementedInterfacesChanges(_oldType, newType)));
    } else if (_oldType.constructor !== newType.constructor) {
      schemaChanges.push({
        type: BreakingChangeType.TYPE_CHANGED_KIND,
        description: "".concat(_oldType.name, " changed from ") + "".concat(typeKindName(_oldType), " to ").concat(typeKindName(newType), ".")
      });
    }
  }
  return schemaChanges;
}
function findInputObjectTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var fieldsDiff = diff(objectValues_default(oldType.getFields()), objectValues_default(newType.getFields()));
  for (var _i16 = 0, _fieldsDiff$added2 = fieldsDiff.added; _i16 < _fieldsDiff$added2.length; _i16++) {
    var newField = _fieldsDiff$added2[_i16];
    if (isRequiredInputField(newField)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_INPUT_FIELD_ADDED,
        description: "A required field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_INPUT_FIELD_ADDED,
        description: "An optional field ".concat(newField.name, " on input type ").concat(oldType.name, " was added.")
      });
    }
  }
  for (var _i18 = 0, _fieldsDiff$removed2 = fieldsDiff.removed; _i18 < _fieldsDiff$removed2.length; _i18++) {
    var oldField = _fieldsDiff$removed2[_i18];
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
    });
  }
  for (var _i20 = 0, _fieldsDiff$persisted2 = fieldsDiff.persisted; _i20 < _fieldsDiff$persisted2.length; _i20++) {
    var _ref6 = _fieldsDiff$persisted2[_i20];
    var _oldField = _ref6[0];
    var _newField = _ref6[1];
    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldField.type, _newField.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(_oldField.name, " changed type from ") + "".concat(String(_oldField.type), " to ").concat(String(_newField.type), ".")
      });
    }
  }
  return schemaChanges;
}
function findUnionTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var possibleTypesDiff = diff(oldType.getTypes(), newType.getTypes());
  for (var _i22 = 0, _possibleTypesDiff$ad2 = possibleTypesDiff.added; _i22 < _possibleTypesDiff$ad2.length; _i22++) {
    var newPossibleType = _possibleTypesDiff$ad2[_i22];
    schemaChanges.push({
      type: DangerousChangeType.TYPE_ADDED_TO_UNION,
      description: "".concat(newPossibleType.name, " was added to union type ").concat(oldType.name, ".")
    });
  }
  for (var _i24 = 0, _possibleTypesDiff$re2 = possibleTypesDiff.removed; _i24 < _possibleTypesDiff$re2.length; _i24++) {
    var oldPossibleType = _possibleTypesDiff$re2[_i24];
    schemaChanges.push({
      type: BreakingChangeType.TYPE_REMOVED_FROM_UNION,
      description: "".concat(oldPossibleType.name, " was removed from union type ").concat(oldType.name, ".")
    });
  }
  return schemaChanges;
}
function findEnumTypeChanges(oldType, newType) {
  var schemaChanges = [];
  var valuesDiff = diff(oldType.getValues(), newType.getValues());
  for (var _i26 = 0, _valuesDiff$added2 = valuesDiff.added; _i26 < _valuesDiff$added2.length; _i26++) {
    var newValue = _valuesDiff$added2[_i26];
    schemaChanges.push({
      type: DangerousChangeType.VALUE_ADDED_TO_ENUM,
      description: "".concat(newValue.name, " was added to enum type ").concat(oldType.name, ".")
    });
  }
  for (var _i28 = 0, _valuesDiff$removed2 = valuesDiff.removed; _i28 < _valuesDiff$removed2.length; _i28++) {
    var oldValue = _valuesDiff$removed2[_i28];
    schemaChanges.push({
      type: BreakingChangeType.VALUE_REMOVED_FROM_ENUM,
      description: "".concat(oldValue.name, " was removed from enum type ").concat(oldType.name, ".")
    });
  }
  return schemaChanges;
}
function findImplementedInterfacesChanges(oldType, newType) {
  var schemaChanges = [];
  var interfacesDiff = diff(oldType.getInterfaces(), newType.getInterfaces());
  for (var _i30 = 0, _interfacesDiff$added2 = interfacesDiff.added; _i30 < _interfacesDiff$added2.length; _i30++) {
    var newInterface = _interfacesDiff$added2[_i30];
    schemaChanges.push({
      type: DangerousChangeType.IMPLEMENTED_INTERFACE_ADDED,
      description: "".concat(newInterface.name, " added to interfaces implemented by ").concat(oldType.name, ".")
    });
  }
  for (var _i32 = 0, _interfacesDiff$remov2 = interfacesDiff.removed; _i32 < _interfacesDiff$remov2.length; _i32++) {
    var oldInterface = _interfacesDiff$remov2[_i32];
    schemaChanges.push({
      type: BreakingChangeType.IMPLEMENTED_INTERFACE_REMOVED,
      description: "".concat(oldType.name, " no longer implements interface ").concat(oldInterface.name, ".")
    });
  }
  return schemaChanges;
}
function findFieldChanges(oldType, newType) {
  var schemaChanges = [];
  var fieldsDiff = diff(objectValues_default(oldType.getFields()), objectValues_default(newType.getFields()));
  for (var _i34 = 0, _fieldsDiff$removed4 = fieldsDiff.removed; _i34 < _fieldsDiff$removed4.length; _i34++) {
    var oldField = _fieldsDiff$removed4[_i34];
    schemaChanges.push({
      type: BreakingChangeType.FIELD_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " was removed.")
    });
  }
  for (var _i36 = 0, _fieldsDiff$persisted4 = fieldsDiff.persisted; _i36 < _fieldsDiff$persisted4.length; _i36++) {
    var _ref8 = _fieldsDiff$persisted4[_i36];
    var _oldField2 = _ref8[0];
    var newField = _ref8[1];
    schemaChanges.push.apply(schemaChanges, findArgChanges(oldType, _oldField2, newField));
    var isSafe = isChangeSafeForObjectOrInterfaceField(_oldField2.type, newField.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.FIELD_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(_oldField2.name, " changed type from ") + "".concat(String(_oldField2.type), " to ").concat(String(newField.type), ".")
      });
    }
  }
  return schemaChanges;
}
function findArgChanges(oldType, oldField, newField) {
  var schemaChanges = [];
  var argsDiff = diff(oldField.args, newField.args);
  for (var _i38 = 0, _argsDiff$removed4 = argsDiff.removed; _i38 < _argsDiff$removed4.length; _i38++) {
    var oldArg = _argsDiff$removed4[_i38];
    schemaChanges.push({
      type: BreakingChangeType.ARG_REMOVED,
      description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(oldArg.name, " was removed.")
    });
  }
  for (var _i40 = 0, _argsDiff$persisted2 = argsDiff.persisted; _i40 < _argsDiff$persisted2.length; _i40++) {
    var _ref10 = _argsDiff$persisted2[_i40];
    var _oldArg = _ref10[0];
    var newArg = _ref10[1];
    var isSafe = isChangeSafeForInputObjectFieldOrFieldArg(_oldArg.type, newArg.type);
    if (!isSafe) {
      schemaChanges.push({
        type: BreakingChangeType.ARG_CHANGED_KIND,
        description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed type from ") + "".concat(String(_oldArg.type), " to ").concat(String(newArg.type), ".")
      });
    } else if (_oldArg.defaultValue !== void 0) {
      if (newArg.defaultValue === void 0) {
        schemaChanges.push({
          type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
          description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " defaultValue was removed.")
        });
      } else {
        var oldValueStr = stringifyValue(_oldArg.defaultValue, _oldArg.type);
        var newValueStr = stringifyValue(newArg.defaultValue, newArg.type);
        if (oldValueStr !== newValueStr) {
          schemaChanges.push({
            type: DangerousChangeType.ARG_DEFAULT_VALUE_CHANGE,
            description: "".concat(oldType.name, ".").concat(oldField.name, " arg ").concat(_oldArg.name, " has changed defaultValue from ").concat(oldValueStr, " to ").concat(newValueStr, ".")
          });
        }
      }
    }
  }
  for (var _i42 = 0, _argsDiff$added4 = argsDiff.added; _i42 < _argsDiff$added4.length; _i42++) {
    var _newArg = _argsDiff$added4[_i42];
    if (isRequiredArgument(_newArg)) {
      schemaChanges.push({
        type: BreakingChangeType.REQUIRED_ARG_ADDED,
        description: "A required arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
      });
    } else {
      schemaChanges.push({
        type: DangerousChangeType.OPTIONAL_ARG_ADDED,
        description: "An optional arg ".concat(_newArg.name, " on ").concat(oldType.name, ".").concat(oldField.name, " was added.")
      });
    }
  }
  return schemaChanges;
}
function isChangeSafeForObjectOrInterfaceField(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType) || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType.ofType, newType.ofType);
  }
  return isNamedType(newType) && oldType.name === newType.name || isNonNullType(newType) && isChangeSafeForObjectOrInterfaceField(oldType, newType.ofType);
}
function isChangeSafeForInputObjectFieldOrFieldArg(oldType, newType) {
  if (isListType(oldType)) {
    return isListType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    return isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType.ofType) || !isNonNullType(newType) && isChangeSafeForInputObjectFieldOrFieldArg(oldType.ofType, newType);
  }
  return isNamedType(newType) && oldType.name === newType.name;
}
function typeKindName(type2) {
  if (isScalarType(type2)) {
    return "a Scalar type";
  }
  if (isObjectType(type2)) {
    return "an Object type";
  }
  if (isInterfaceType(type2)) {
    return "an Interface type";
  }
  if (isUnionType(type2)) {
    return "a Union type";
  }
  if (isEnumType(type2)) {
    return "an Enum type";
  }
  if (isInputObjectType(type2)) {
    return "an Input type";
  }
  invariant(0, "Unexpected type: " + inspect(type2));
}
function stringifyValue(value, type2) {
  var ast = astFromValue(value, type2);
  ast != null || invariant(0);
  var sortedAST = visit(ast, {
    ObjectValue: function ObjectValue2(objectNode) {
      var fields7 = [].concat(objectNode.fields);
      fields7.sort(function(fieldA, fieldB) {
        return naturalCompare(fieldA.name.value, fieldB.name.value);
      });
      return _objectSpread7(_objectSpread7({}, objectNode), {}, {
        fields: fields7
      });
    }
  });
  return print(sortedAST);
}
function diff(oldArray, newArray) {
  var added = [];
  var removed = [];
  var persisted = [];
  var oldMap = keyMap(oldArray, function(_ref11) {
    var name2 = _ref11.name;
    return name2;
  });
  var newMap = keyMap(newArray, function(_ref12) {
    var name2 = _ref12.name;
    return name2;
  });
  for (var _i44 = 0; _i44 < oldArray.length; _i44++) {
    var oldItem = oldArray[_i44];
    var newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      persisted.push([oldItem, newItem]);
    }
  }
  for (var _i46 = 0; _i46 < newArray.length; _i46++) {
    var _newItem = newArray[_i46];
    if (oldMap[_newItem.name] === void 0) {
      added.push(_newItem);
    }
  }
  return {
    added,
    persisted,
    removed
  };
}
var BreakingChangeType, DangerousChangeType;
var init_findBreakingChanges = __esm({
  "node_modules/graphql/utilities/findBreakingChanges.mjs"() {
    init_define_process_env();
    init_objectValues();
    init_keyMap();
    init_inspect();
    init_invariant();
    init_naturalCompare();
    init_printer();
    init_visitor();
    init_scalars();
    init_definition();
    init_astFromValue();
    BreakingChangeType = Object.freeze({
      TYPE_REMOVED: "TYPE_REMOVED",
      TYPE_CHANGED_KIND: "TYPE_CHANGED_KIND",
      TYPE_REMOVED_FROM_UNION: "TYPE_REMOVED_FROM_UNION",
      VALUE_REMOVED_FROM_ENUM: "VALUE_REMOVED_FROM_ENUM",
      REQUIRED_INPUT_FIELD_ADDED: "REQUIRED_INPUT_FIELD_ADDED",
      IMPLEMENTED_INTERFACE_REMOVED: "IMPLEMENTED_INTERFACE_REMOVED",
      FIELD_REMOVED: "FIELD_REMOVED",
      FIELD_CHANGED_KIND: "FIELD_CHANGED_KIND",
      REQUIRED_ARG_ADDED: "REQUIRED_ARG_ADDED",
      ARG_REMOVED: "ARG_REMOVED",
      ARG_CHANGED_KIND: "ARG_CHANGED_KIND",
      DIRECTIVE_REMOVED: "DIRECTIVE_REMOVED",
      DIRECTIVE_ARG_REMOVED: "DIRECTIVE_ARG_REMOVED",
      REQUIRED_DIRECTIVE_ARG_ADDED: "REQUIRED_DIRECTIVE_ARG_ADDED",
      DIRECTIVE_REPEATABLE_REMOVED: "DIRECTIVE_REPEATABLE_REMOVED",
      DIRECTIVE_LOCATION_REMOVED: "DIRECTIVE_LOCATION_REMOVED"
    });
    DangerousChangeType = Object.freeze({
      VALUE_ADDED_TO_ENUM: "VALUE_ADDED_TO_ENUM",
      TYPE_ADDED_TO_UNION: "TYPE_ADDED_TO_UNION",
      OPTIONAL_INPUT_FIELD_ADDED: "OPTIONAL_INPUT_FIELD_ADDED",
      OPTIONAL_ARG_ADDED: "OPTIONAL_ARG_ADDED",
      IMPLEMENTED_INTERFACE_ADDED: "IMPLEMENTED_INTERFACE_ADDED",
      ARG_DEFAULT_VALUE_CHANGE: "ARG_DEFAULT_VALUE_CHANGE"
    });
  }
});

// node_modules/graphql/utilities/findDeprecatedUsages.mjs
function findDeprecatedUsages(schema, ast) {
  return validate(schema, ast, [NoDeprecatedCustomRule]);
}
var init_findDeprecatedUsages = __esm({
  "node_modules/graphql/utilities/findDeprecatedUsages.mjs"() {
    init_define_process_env();
    init_validate2();
    init_NoDeprecatedCustomRule();
  }
});

// node_modules/graphql/utilities/index.mjs
var init_utilities = __esm({
  "node_modules/graphql/utilities/index.mjs"() {
    init_define_process_env();
    init_getIntrospectionQuery();
    init_getOperationAST();
    init_getOperationRootType();
    init_introspectionFromSchema();
    init_buildClientSchema();
    init_buildASTSchema();
    init_extendSchema();
    init_lexicographicSortSchema();
    init_printSchema();
    init_typeFromAST();
    init_valueFromAST();
    init_valueFromASTUntyped();
    init_astFromValue();
    init_TypeInfo();
    init_coerceInputValue();
    init_concatAST();
    init_separateOperations();
    init_stripIgnoredCharacters();
    init_typeComparators();
    init_assertValidName();
    init_findBreakingChanges();
    init_findDeprecatedUsages();
  }
});

// node_modules/graphql/index.mjs
var graphql_exports = {};
__export(graphql_exports, {
  BREAK: () => BREAK,
  BreakingChangeType: () => BreakingChangeType,
  DEFAULT_DEPRECATION_REASON: () => DEFAULT_DEPRECATION_REASON,
  DangerousChangeType: () => DangerousChangeType,
  DirectiveLocation: () => DirectiveLocation,
  ExecutableDefinitionsRule: () => ExecutableDefinitionsRule,
  FieldsOnCorrectTypeRule: () => FieldsOnCorrectTypeRule,
  FragmentsOnCompositeTypesRule: () => FragmentsOnCompositeTypesRule,
  GraphQLBoolean: () => GraphQLBoolean,
  GraphQLDeprecatedDirective: () => GraphQLDeprecatedDirective,
  GraphQLDirective: () => GraphQLDirective,
  GraphQLEnumType: () => GraphQLEnumType,
  GraphQLError: () => GraphQLError,
  GraphQLFloat: () => GraphQLFloat,
  GraphQLID: () => GraphQLID,
  GraphQLIncludeDirective: () => GraphQLIncludeDirective,
  GraphQLInputObjectType: () => GraphQLInputObjectType,
  GraphQLInt: () => GraphQLInt,
  GraphQLInterfaceType: () => GraphQLInterfaceType,
  GraphQLList: () => GraphQLList,
  GraphQLNonNull: () => GraphQLNonNull,
  GraphQLObjectType: () => GraphQLObjectType,
  GraphQLScalarType: () => GraphQLScalarType,
  GraphQLSchema: () => GraphQLSchema,
  GraphQLSkipDirective: () => GraphQLSkipDirective,
  GraphQLSpecifiedByDirective: () => GraphQLSpecifiedByDirective,
  GraphQLString: () => GraphQLString,
  GraphQLUnionType: () => GraphQLUnionType,
  Kind: () => Kind,
  KnownArgumentNamesRule: () => KnownArgumentNamesRule,
  KnownDirectivesRule: () => KnownDirectivesRule,
  KnownFragmentNamesRule: () => KnownFragmentNamesRule,
  KnownTypeNamesRule: () => KnownTypeNamesRule,
  Lexer: () => Lexer,
  Location: () => Location,
  LoneAnonymousOperationRule: () => LoneAnonymousOperationRule,
  LoneSchemaDefinitionRule: () => LoneSchemaDefinitionRule,
  NoDeprecatedCustomRule: () => NoDeprecatedCustomRule,
  NoFragmentCyclesRule: () => NoFragmentCyclesRule,
  NoSchemaIntrospectionCustomRule: () => NoSchemaIntrospectionCustomRule,
  NoUndefinedVariablesRule: () => NoUndefinedVariablesRule,
  NoUnusedFragmentsRule: () => NoUnusedFragmentsRule,
  NoUnusedVariablesRule: () => NoUnusedVariablesRule,
  OverlappingFieldsCanBeMergedRule: () => OverlappingFieldsCanBeMergedRule,
  PossibleFragmentSpreadsRule: () => PossibleFragmentSpreadsRule,
  PossibleTypeExtensionsRule: () => PossibleTypeExtensionsRule,
  ProvidedRequiredArgumentsRule: () => ProvidedRequiredArgumentsRule,
  ScalarLeafsRule: () => ScalarLeafsRule,
  SchemaMetaFieldDef: () => SchemaMetaFieldDef,
  SingleFieldSubscriptionsRule: () => SingleFieldSubscriptionsRule,
  Source: () => Source,
  Token: () => Token,
  TokenKind: () => TokenKind,
  TypeInfo: () => TypeInfo,
  TypeKind: () => TypeKind,
  TypeMetaFieldDef: () => TypeMetaFieldDef,
  TypeNameMetaFieldDef: () => TypeNameMetaFieldDef,
  UniqueArgumentNamesRule: () => UniqueArgumentNamesRule,
  UniqueDirectiveNamesRule: () => UniqueDirectiveNamesRule,
  UniqueDirectivesPerLocationRule: () => UniqueDirectivesPerLocationRule,
  UniqueEnumValueNamesRule: () => UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule: () => UniqueFieldDefinitionNamesRule,
  UniqueFragmentNamesRule: () => UniqueFragmentNamesRule,
  UniqueInputFieldNamesRule: () => UniqueInputFieldNamesRule,
  UniqueOperationNamesRule: () => UniqueOperationNamesRule,
  UniqueOperationTypesRule: () => UniqueOperationTypesRule,
  UniqueTypeNamesRule: () => UniqueTypeNamesRule,
  UniqueVariableNamesRule: () => UniqueVariableNamesRule,
  ValidationContext: () => ValidationContext,
  ValuesOfCorrectTypeRule: () => ValuesOfCorrectTypeRule,
  VariablesAreInputTypesRule: () => VariablesAreInputTypesRule,
  VariablesInAllowedPositionRule: () => VariablesInAllowedPositionRule,
  __Directive: () => __Directive,
  __DirectiveLocation: () => __DirectiveLocation,
  __EnumValue: () => __EnumValue,
  __Field: () => __Field,
  __InputValue: () => __InputValue,
  __Schema: () => __Schema,
  __Type: () => __Type,
  __TypeKind: () => __TypeKind,
  assertAbstractType: () => assertAbstractType,
  assertCompositeType: () => assertCompositeType,
  assertDirective: () => assertDirective,
  assertEnumType: () => assertEnumType,
  assertInputObjectType: () => assertInputObjectType,
  assertInputType: () => assertInputType,
  assertInterfaceType: () => assertInterfaceType,
  assertLeafType: () => assertLeafType,
  assertListType: () => assertListType,
  assertNamedType: () => assertNamedType,
  assertNonNullType: () => assertNonNullType,
  assertNullableType: () => assertNullableType,
  assertObjectType: () => assertObjectType,
  assertOutputType: () => assertOutputType,
  assertScalarType: () => assertScalarType,
  assertSchema: () => assertSchema,
  assertType: () => assertType,
  assertUnionType: () => assertUnionType,
  assertValidName: () => assertValidName,
  assertValidSchema: () => assertValidSchema,
  assertWrappingType: () => assertWrappingType,
  astFromValue: () => astFromValue,
  buildASTSchema: () => buildASTSchema,
  buildClientSchema: () => buildClientSchema,
  buildSchema: () => buildSchema,
  coerceInputValue: () => coerceInputValue,
  concatAST: () => concatAST,
  createSourceEventStream: () => createSourceEventStream,
  defaultFieldResolver: () => defaultFieldResolver,
  defaultTypeResolver: () => defaultTypeResolver,
  doTypesOverlap: () => doTypesOverlap,
  execute: () => execute,
  executeSync: () => executeSync,
  extendSchema: () => extendSchema,
  findBreakingChanges: () => findBreakingChanges,
  findDangerousChanges: () => findDangerousChanges,
  findDeprecatedUsages: () => findDeprecatedUsages,
  formatError: () => formatError,
  getDescription: () => getDescription,
  getDirectiveValues: () => getDirectiveValues,
  getIntrospectionQuery: () => getIntrospectionQuery,
  getLocation: () => getLocation,
  getNamedType: () => getNamedType,
  getNullableType: () => getNullableType,
  getOperationAST: () => getOperationAST,
  getOperationRootType: () => getOperationRootType,
  getVisitFn: () => getVisitFn,
  graphql: () => graphql,
  graphqlSync: () => graphqlSync,
  introspectionFromSchema: () => introspectionFromSchema,
  introspectionTypes: () => introspectionTypes,
  isAbstractType: () => isAbstractType,
  isCompositeType: () => isCompositeType,
  isDefinitionNode: () => isDefinitionNode,
  isDirective: () => isDirective,
  isEnumType: () => isEnumType,
  isEqualType: () => isEqualType,
  isExecutableDefinitionNode: () => isExecutableDefinitionNode,
  isInputObjectType: () => isInputObjectType,
  isInputType: () => isInputType,
  isInterfaceType: () => isInterfaceType,
  isIntrospectionType: () => isIntrospectionType,
  isLeafType: () => isLeafType,
  isListType: () => isListType,
  isNamedType: () => isNamedType,
  isNonNullType: () => isNonNullType,
  isNullableType: () => isNullableType,
  isObjectType: () => isObjectType,
  isOutputType: () => isOutputType,
  isRequiredArgument: () => isRequiredArgument,
  isRequiredInputField: () => isRequiredInputField,
  isScalarType: () => isScalarType,
  isSchema: () => isSchema,
  isSelectionNode: () => isSelectionNode,
  isSpecifiedDirective: () => isSpecifiedDirective,
  isSpecifiedScalarType: () => isSpecifiedScalarType,
  isType: () => isType,
  isTypeDefinitionNode: () => isTypeDefinitionNode,
  isTypeExtensionNode: () => isTypeExtensionNode,
  isTypeNode: () => isTypeNode,
  isTypeSubTypeOf: () => isTypeSubTypeOf,
  isTypeSystemDefinitionNode: () => isTypeSystemDefinitionNode,
  isTypeSystemExtensionNode: () => isTypeSystemExtensionNode,
  isUnionType: () => isUnionType,
  isValidNameError: () => isValidNameError,
  isValueNode: () => isValueNode,
  isWrappingType: () => isWrappingType,
  lexicographicSortSchema: () => lexicographicSortSchema,
  locatedError: () => locatedError,
  parse: () => parse,
  parseType: () => parseType,
  parseValue: () => parseValue,
  print: () => print,
  printError: () => printError,
  printIntrospectionSchema: () => printIntrospectionSchema,
  printLocation: () => printLocation,
  printSchema: () => printSchema,
  printSourceLocation: () => printSourceLocation,
  printType: () => printType,
  responsePathAsArray: () => pathToArray,
  separateOperations: () => separateOperations,
  specifiedDirectives: () => specifiedDirectives,
  specifiedRules: () => specifiedRules,
  specifiedScalarTypes: () => specifiedScalarTypes,
  stripIgnoredCharacters: () => stripIgnoredCharacters,
  subscribe: () => subscribe,
  syntaxError: () => syntaxError,
  typeFromAST: () => typeFromAST,
  validate: () => validate,
  validateSchema: () => validateSchema,
  valueFromAST: () => valueFromAST,
  valueFromASTUntyped: () => valueFromASTUntyped,
  version: () => version,
  versionInfo: () => versionInfo,
  visit: () => visit,
  visitInParallel: () => visitInParallel,
  visitWithTypeInfo: () => visitWithTypeInfo
});
var init_graphql2 = __esm({
  "node_modules/graphql/index.mjs"() {
    init_define_process_env();
    init_version();
    init_graphql();
    init_type();
    init_language();
    init_execution();
    init_subscription();
    init_validation();
    init_error();
    init_utilities();
  }
});

// node_modules/nullthrows/nullthrows.js
var require_nullthrows = __commonJS({
  "node_modules/nullthrows/nullthrows.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function nullthrows2(x, message) {
      if (x != null) {
        return x;
      }
      var error2 = new Error(message !== void 0 ? message : "Got unexpected " + x);
      error2.framesToPop = 1;
      throw error2;
    }
    module.exports = nullthrows2;
    module.exports.default = nullthrows2;
    Object.defineProperty(module.exports, "__esModule", { value: true });
  }
});

// node_modules/graphql-language-service-utils/esm/fragmentDependencies.js
var import_nullthrows, getFragmentDependencies, getFragmentDependenciesForAST;
var init_fragmentDependencies = __esm({
  "node_modules/graphql-language-service-utils/esm/fragmentDependencies.js"() {
    init_define_process_env();
    init_graphql2();
    import_nullthrows = __toModule(require_nullthrows());
    getFragmentDependencies = (operationString, fragmentDefinitions) => {
      if (!fragmentDefinitions) {
        return [];
      }
      let parsedOperation;
      try {
        parsedOperation = parse(operationString, {
          allowLegacySDLImplementsInterfaces: true,
          allowLegacySDLEmptyFields: true
        });
      } catch (error2) {
        return [];
      }
      return getFragmentDependenciesForAST(parsedOperation, fragmentDefinitions);
    };
    getFragmentDependenciesForAST = (parsedOperation, fragmentDefinitions) => {
      if (!fragmentDefinitions) {
        return [];
      }
      const existingFrags = new Map();
      const referencedFragNames = new Set();
      visit(parsedOperation, {
        FragmentDefinition(node) {
          existingFrags.set(node.name.value, true);
        },
        FragmentSpread(node) {
          if (!referencedFragNames.has(node.name.value)) {
            referencedFragNames.add(node.name.value);
          }
        }
      });
      const asts = new Set();
      referencedFragNames.forEach((name2) => {
        if (!existingFrags.has(name2) && fragmentDefinitions.has(name2)) {
          asts.add((0, import_nullthrows.default)(fragmentDefinitions.get(name2)));
        }
      });
      const referencedFragments = [];
      asts.forEach((ast) => {
        visit(ast, {
          FragmentSpread(node) {
            if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
              asts.add((0, import_nullthrows.default)(fragmentDefinitions.get(node.name.value)));
              referencedFragNames.add(node.name.value);
            }
          }
        });
        if (!existingFrags.has(ast.name.value)) {
          referencedFragments.push(ast);
        }
      });
      return referencedFragments;
    };
  }
});

// node_modules/graphql-language-service-utils/esm/getASTNodeAtPosition.js
function getASTNodeAtPosition(query, ast, point) {
  const offset = pointToOffset(query, point);
  let nodeContainingPosition;
  visit(ast, {
    enter(node) {
      if (node.kind !== "Name" && node.loc && node.loc.start <= offset && offset <= node.loc.end) {
        nodeContainingPosition = node;
      } else {
        return false;
      }
    },
    leave(node) {
      if (node.loc && node.loc.start <= offset && offset <= node.loc.end) {
        return false;
      }
    }
  });
  return nodeContainingPosition;
}
function pointToOffset(text2, point) {
  const linesUntilPosition = text2.split("\n").slice(0, point.line);
  return point.character + linesUntilPosition.map((line) => line.length + 1).reduce((a, b) => a + b, 0);
}
var init_getASTNodeAtPosition = __esm({
  "node_modules/graphql-language-service-utils/esm/getASTNodeAtPosition.js"() {
    init_define_process_env();
    init_graphql2();
  }
});

// node_modules/graphql-language-service-utils/esm/Range.js
function offsetToPosition(text2, loc) {
  const EOL = "\n";
  const buf = text2.slice(0, loc);
  const lines = buf.split(EOL).length - 1;
  const lastLineIndex = buf.lastIndexOf(EOL);
  return new Position(lines, loc - lastLineIndex - 1);
}
function locToRange(text2, loc) {
  const start = offsetToPosition(text2, loc.start);
  const end = offsetToPosition(text2, loc.end);
  return new Range(start, end);
}
var Range, Position;
var init_Range = __esm({
  "node_modules/graphql-language-service-utils/esm/Range.js"() {
    init_define_process_env();
    Range = class {
      constructor(start, end) {
        this.containsPosition = (position) => {
          if (this.start.line === position.line) {
            return this.start.character <= position.character;
          } else if (this.end.line === position.line) {
            return this.end.character >= position.character;
          } else {
            return this.start.line <= position.line && this.end.line >= position.line;
          }
        };
        this.start = start;
        this.end = end;
      }
      setStart(line, character) {
        this.start = new Position(line, character);
      }
      setEnd(line, character) {
        this.end = new Position(line, character);
      }
    };
    Position = class {
      constructor(line, character) {
        this.lessThanOrEqualTo = (position) => this.line < position.line || this.line === position.line && this.character <= position.character;
        this.line = line;
        this.character = character;
      }
      setLine(line) {
        this.line = line;
      }
      setCharacter(character) {
        this.character = character;
      }
    };
  }
});

// node_modules/graphql/validation/rules/ExecutableDefinitions.mjs
var init_ExecutableDefinitions = __esm({
  "node_modules/graphql/validation/rules/ExecutableDefinitions.mjs"() {
    init_define_process_env();
    init_ExecutableDefinitionsRule();
  }
});

// node_modules/graphql-language-service-utils/esm/validateWithCustomRules.js
function validateWithCustomRules(schema, ast, customRules, isRelayCompatMode) {
  const rules = specifiedRules.filter((rule) => {
    if (rule === NoUnusedFragmentsRule || rule === ExecutableDefinitionsRule) {
      return false;
    }
    if (isRelayCompatMode && rule === KnownFragmentNamesRule) {
      return false;
    }
    return true;
  });
  if (customRules) {
    Array.prototype.push.apply(rules, customRules);
  }
  const errors2 = validate(schema, ast, rules);
  return errors2.filter((error2) => {
    if (error2.message.indexOf("Unknown directive") !== -1 && error2.nodes) {
      const node = error2.nodes[0];
      if (node && node.kind === Kind.DIRECTIVE) {
        const name2 = node.name.value;
        if (name2 === "arguments" || name2 === "argumentDefinitions") {
          return false;
        }
      }
    }
    return true;
  });
}
var init_validateWithCustomRules = __esm({
  "node_modules/graphql-language-service-utils/esm/validateWithCustomRules.js"() {
    init_define_process_env();
    init_graphql2();
    init_ExecutableDefinitions();
  }
});

// node_modules/graphql-language-service-utils/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  Position: () => Position,
  Range: () => Range,
  getASTNodeAtPosition: () => getASTNodeAtPosition,
  getFragmentDependencies: () => getFragmentDependencies,
  getFragmentDependenciesForAST: () => getFragmentDependenciesForAST,
  locToRange: () => locToRange,
  offsetToPosition: () => offsetToPosition,
  pointToOffset: () => pointToOffset,
  validateWithCustomRules: () => validateWithCustomRules
});
var init_esm = __esm({
  "node_modules/graphql-language-service-utils/esm/index.js"() {
    init_define_process_env();
    init_fragmentDependencies();
    init_getASTNodeAtPosition();
    init_Range();
    init_validateWithCustomRules();
  }
});

// node_modules/markdown-it/node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/markdown-it/node_modules/entities/lib/maps/entities.json"(exports, module) {
    module.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/markdown-it/lib/common/entities.js
var require_entities2 = __commonJS({
  "node_modules/markdown-it/lib/common/entities.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = require_entities();
  }
});

// node_modules/uc.micro/categories/P/regex.js
var require_regex = __commonJS({
  "node_modules/uc.micro/categories/P/regex.js"(exports, module) {
    init_define_process_env();
    module.exports = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
  }
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
  "node_modules/mdurl/encode.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var encodeCache = {};
    function getEncodeCache(exclude) {
      var i, ch, cache = encodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = encodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        if (/^[0-9a-z]$/i.test(ch)) {
          cache.push(ch);
        } else {
          cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
        }
      }
      for (i = 0; i < exclude.length; i++) {
        cache[exclude.charCodeAt(i)] = exclude[i];
      }
      return cache;
    }
    function encode2(string, exclude, keepEscaped) {
      var i, l, code, nextCode, cache, result = "";
      if (typeof exclude !== "string") {
        keepEscaped = exclude;
        exclude = encode2.defaultChars;
      }
      if (typeof keepEscaped === "undefined") {
        keepEscaped = true;
      }
      cache = getEncodeCache(exclude);
      for (i = 0, l = string.length; i < l; i++) {
        code = string.charCodeAt(i);
        if (keepEscaped && code === 37 && i + 2 < l) {
          if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
            result += string.slice(i, i + 3);
            i += 2;
            continue;
          }
        }
        if (code < 128) {
          result += cache[code];
          continue;
        }
        if (code >= 55296 && code <= 57343) {
          if (code >= 55296 && code <= 56319 && i + 1 < l) {
            nextCode = string.charCodeAt(i + 1);
            if (nextCode >= 56320 && nextCode <= 57343) {
              result += encodeURIComponent(string[i] + string[i + 1]);
              i++;
              continue;
            }
          }
          result += "%EF%BF%BD";
          continue;
        }
        result += encodeURIComponent(string[i]);
      }
      return result;
    }
    encode2.defaultChars = ";/?:@&=+$,-_.!~*'()#";
    encode2.componentChars = "-_.!~*'()";
    module.exports = encode2;
  }
});

// node_modules/mdurl/decode.js
var require_decode = __commonJS({
  "node_modules/mdurl/decode.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var decodeCache = {};
    function getDecodeCache(exclude) {
      var i, ch, cache = decodeCache[exclude];
      if (cache) {
        return cache;
      }
      cache = decodeCache[exclude] = [];
      for (i = 0; i < 128; i++) {
        ch = String.fromCharCode(i);
        cache.push(ch);
      }
      for (i = 0; i < exclude.length; i++) {
        ch = exclude.charCodeAt(i);
        cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
      }
      return cache;
    }
    function decode2(string, exclude) {
      var cache;
      if (typeof exclude !== "string") {
        exclude = decode2.defaultChars;
      }
      cache = getDecodeCache(exclude);
      return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
        var i, l, b1, b2, b3, b4, chr, result = "";
        for (i = 0, l = seq.length; i < l; i += 3) {
          b1 = parseInt(seq.slice(i + 1, i + 3), 16);
          if (b1 < 128) {
            result += cache[b1];
            continue;
          }
          if ((b1 & 224) === 192 && i + 3 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            if ((b2 & 192) === 128) {
              chr = b1 << 6 & 1984 | b2 & 63;
              if (chr < 128) {
                result += "\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 3;
              continue;
            }
          }
          if ((b1 & 240) === 224 && i + 6 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128) {
              chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
              if (chr < 2048 || chr >= 55296 && chr <= 57343) {
                result += "\uFFFD\uFFFD\uFFFD";
              } else {
                result += String.fromCharCode(chr);
              }
              i += 6;
              continue;
            }
          }
          if ((b1 & 248) === 240 && i + 9 < l) {
            b2 = parseInt(seq.slice(i + 4, i + 6), 16);
            b3 = parseInt(seq.slice(i + 7, i + 9), 16);
            b4 = parseInt(seq.slice(i + 10, i + 12), 16);
            if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
              chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
              if (chr < 65536 || chr > 1114111) {
                result += "\uFFFD\uFFFD\uFFFD\uFFFD";
              } else {
                chr -= 65536;
                result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
              }
              i += 9;
              continue;
            }
          }
          result += "\uFFFD";
        }
        return result;
      });
    }
    decode2.defaultChars = ";/?:@&=+$,#";
    decode2.componentChars = "";
    module.exports = decode2;
  }
});

// node_modules/mdurl/format.js
var require_format = __commonJS({
  "node_modules/mdurl/format.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function format(url) {
      var result = "";
      result += url.protocol || "";
      result += url.slashes ? "//" : "";
      result += url.auth ? url.auth + "@" : "";
      if (url.hostname && url.hostname.indexOf(":") !== -1) {
        result += "[" + url.hostname + "]";
      } else {
        result += url.hostname || "";
      }
      result += url.port ? ":" + url.port : "";
      result += url.pathname || "";
      result += url.search || "";
      result += url.hash || "";
      return result;
    };
  }
});

// node_modules/mdurl/parse.js
var require_parse = __commonJS({
  "node_modules/mdurl/parse.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.pathname = null;
    }
    var protocolPattern = /^([a-z0-9.+-]+:)/i;
    var portPattern = /:[0-9]*$/;
    var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
    var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
    var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
    var autoEscape = ["'"].concat(unwise);
    var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
    var hostEndingChars = ["/", "?", "#"];
    var hostnameMaxLen = 255;
    var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
    var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
    var hostlessProtocol = {
      "javascript": true,
      "javascript:": true
    };
    var slashedProtocol = {
      "http": true,
      "https": true,
      "ftp": true,
      "gopher": true,
      "file": true,
      "http:": true,
      "https:": true,
      "ftp:": true,
      "gopher:": true,
      "file:": true
    };
    function urlParse(url, slashesDenoteHost) {
      if (url && url instanceof Url) {
        return url;
      }
      var u = new Url();
      u.parse(url, slashesDenoteHost);
      return u;
    }
    Url.prototype.parse = function(url, slashesDenoteHost) {
      var i, l, lowerProto, hec, slashes, rest = url;
      rest = rest.trim();
      if (!slashesDenoteHost && url.split("#").length === 1) {
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
          }
          return this;
        }
      }
      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        lowerProto = proto.toLowerCase();
        this.protocol = proto;
        rest = rest.substr(proto.length);
      }
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        slashes = rest.substr(0, 2) === "//";
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }
      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
        var hostEnd = -1;
        for (i = 0; i < hostEndingChars.length; i++) {
          hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        var auth, atSign;
        if (hostEnd === -1) {
          atSign = rest.lastIndexOf("@");
        } else {
          atSign = rest.lastIndexOf("@", hostEnd);
        }
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = auth;
        }
        hostEnd = -1;
        for (i = 0; i < nonHostChars.length; i++) {
          hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
            hostEnd = hec;
          }
        }
        if (hostEnd === -1) {
          hostEnd = rest.length;
        }
        if (rest[hostEnd - 1] === ":") {
          hostEnd--;
        }
        var host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);
        this.parseHost(host);
        this.hostname = this.hostname || "";
        var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) {
              continue;
            }
            if (!part.match(hostnamePartPattern)) {
              var newpart = "";
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  newpart += "x";
                } else {
                  newpart += part[j];
                }
              }
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = notHost.join(".") + rest;
                }
                this.hostname = validParts.join(".");
                break;
              }
            }
          }
        }
        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = "";
        }
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        }
      }
      var hash = rest.indexOf("#");
      if (hash !== -1) {
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf("?");
      if (qm !== -1) {
        this.search = rest.substr(qm);
        rest = rest.slice(0, qm);
      }
      if (rest) {
        this.pathname = rest;
      }
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = "";
      }
      return this;
    };
    Url.prototype.parseHost = function(host) {
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ":") {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) {
        this.hostname = host;
      }
    };
    module.exports = urlParse;
  }
});

// node_modules/mdurl/index.js
var require_mdurl = __commonJS({
  "node_modules/mdurl/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports.encode = require_encode();
    module.exports.decode = require_decode();
    module.exports.format = require_format();
    module.exports.parse = require_parse();
  }
});

// node_modules/uc.micro/properties/Any/regex.js
var require_regex2 = __commonJS({
  "node_modules/uc.micro/properties/Any/regex.js"(exports, module) {
    init_define_process_env();
    module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  }
});

// node_modules/uc.micro/categories/Cc/regex.js
var require_regex3 = __commonJS({
  "node_modules/uc.micro/categories/Cc/regex.js"(exports, module) {
    init_define_process_env();
    module.exports = /[\0-\x1F\x7F-\x9F]/;
  }
});

// node_modules/uc.micro/categories/Cf/regex.js
var require_regex4 = __commonJS({
  "node_modules/uc.micro/categories/Cf/regex.js"(exports, module) {
    init_define_process_env();
    module.exports = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
  }
});

// node_modules/uc.micro/categories/Z/regex.js
var require_regex5 = __commonJS({
  "node_modules/uc.micro/categories/Z/regex.js"(exports, module) {
    init_define_process_env();
    module.exports = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  }
});

// node_modules/uc.micro/index.js
var require_uc = __commonJS({
  "node_modules/uc.micro/index.js"(exports) {
    init_define_process_env();
    "use strict";
    exports.Any = require_regex2();
    exports.Cc = require_regex3();
    exports.Cf = require_regex4();
    exports.P = require_regex();
    exports.Z = require_regex5();
  }
});

// node_modules/markdown-it/lib/common/utils.js
var require_utils = __commonJS({
  "node_modules/markdown-it/lib/common/utils.js"(exports) {
    init_define_process_env();
    "use strict";
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function has(object, key) {
      return _hasOwnProperty.call(object, key);
    }
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be object");
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function arrayReplaceAt(src, pos, newElements) {
      return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
    }
    function isValidEntityCode(c) {
      if (c >= 55296 && c <= 57343) {
        return false;
      }
      if (c >= 64976 && c <= 65007) {
        return false;
      }
      if ((c & 65535) === 65535 || (c & 65535) === 65534) {
        return false;
      }
      if (c >= 0 && c <= 8) {
        return false;
      }
      if (c === 11) {
        return false;
      }
      if (c >= 14 && c <= 31) {
        return false;
      }
      if (c >= 127 && c <= 159) {
        return false;
      }
      if (c > 1114111) {
        return false;
      }
      return true;
    }
    function fromCodePoint(c) {
      if (c > 65535) {
        c -= 65536;
        var surrogate1 = 55296 + (c >> 10), surrogate2 = 56320 + (c & 1023);
        return String.fromCharCode(surrogate1, surrogate2);
      }
      return String.fromCharCode(c);
    }
    var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
    var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
    var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
    var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
    var entities = require_entities2();
    function replaceEntityPattern(match, name2) {
      var code = 0;
      if (has(entities, name2)) {
        return entities[name2];
      }
      if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
        code = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
        if (isValidEntityCode(code)) {
          return fromCodePoint(code);
        }
      }
      return match;
    }
    function unescapeMd(str) {
      if (str.indexOf("\\") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_MD_RE, "$1");
    }
    function unescapeAll(str) {
      if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
        return str;
      }
      return str.replace(UNESCAPE_ALL_RE, function(match, escaped, entity) {
        if (escaped) {
          return escaped;
        }
        return replaceEntityPattern(match, entity);
      });
    }
    var HTML_ESCAPE_TEST_RE = /[&<>"]/;
    var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
    var HTML_REPLACEMENTS = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;"
    };
    function replaceUnsafeChar(ch) {
      return HTML_REPLACEMENTS[ch];
    }
    function escapeHtml(str) {
      if (HTML_ESCAPE_TEST_RE.test(str)) {
        return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
      }
      return str;
    }
    var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
    function escapeRE(str) {
      return str.replace(REGEXP_ESCAPE_RE, "\\$&");
    }
    function isSpace(code) {
      switch (code) {
        case 9:
        case 32:
          return true;
      }
      return false;
    }
    function isWhiteSpace(code) {
      if (code >= 8192 && code <= 8202) {
        return true;
      }
      switch (code) {
        case 9:
        case 10:
        case 11:
        case 12:
        case 13:
        case 32:
        case 160:
        case 5760:
        case 8239:
        case 8287:
        case 12288:
          return true;
      }
      return false;
    }
    var UNICODE_PUNCT_RE = require_regex();
    function isPunctChar(ch) {
      return UNICODE_PUNCT_RE.test(ch);
    }
    function isMdAsciiPunct(ch) {
      switch (ch) {
        case 33:
        case 34:
        case 35:
        case 36:
        case 37:
        case 38:
        case 39:
        case 40:
        case 41:
        case 42:
        case 43:
        case 44:
        case 45:
        case 46:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 124:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    function normalizeReference(str) {
      str = str.trim().replace(/\s+/g, " ");
      if ("\u1E9E".toLowerCase() === "\u1E7E") {
        str = str.replace(//g, "\xDF");
      }
      return str.toLowerCase().toUpperCase();
    }
    exports.lib = {};
    exports.lib.mdurl = require_mdurl();
    exports.lib.ucmicro = require_uc();
    exports.assign = assign2;
    exports.isString = isString;
    exports.has = has;
    exports.unescapeMd = unescapeMd;
    exports.unescapeAll = unescapeAll;
    exports.isValidEntityCode = isValidEntityCode;
    exports.fromCodePoint = fromCodePoint;
    exports.escapeHtml = escapeHtml;
    exports.arrayReplaceAt = arrayReplaceAt;
    exports.isSpace = isSpace;
    exports.isWhiteSpace = isWhiteSpace;
    exports.isMdAsciiPunct = isMdAsciiPunct;
    exports.isPunctChar = isPunctChar;
    exports.escapeRE = escapeRE;
    exports.normalizeReference = normalizeReference;
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_label.js
var require_parse_link_label = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_label.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function parseLinkLabel(state, start, disableNested) {
      var level, found, marker, prevPos, labelEnd = -1, max = state.posMax, oldPos = state.pos;
      state.pos = start + 1;
      level = 1;
      while (state.pos < max) {
        marker = state.src.charCodeAt(state.pos);
        if (marker === 93) {
          level--;
          if (level === 0) {
            found = true;
            break;
          }
        }
        prevPos = state.pos;
        state.md.inline.skipToken(state);
        if (marker === 91) {
          if (prevPos === state.pos - 1) {
            level++;
          } else if (disableNested) {
            state.pos = oldPos;
            return -1;
          }
        }
      }
      if (found) {
        labelEnd = state.pos;
      }
      state.pos = oldPos;
      return labelEnd;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_destination.js
var require_parse_link_destination = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_destination.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkDestination(str, pos, max) {
      var code, level, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (str.charCodeAt(pos) === 60) {
        pos++;
        while (pos < max) {
          code = str.charCodeAt(pos);
          if (code === 10) {
            return result;
          }
          if (code === 62) {
            result.pos = pos + 1;
            result.str = unescapeAll(str.slice(start + 1, pos));
            result.ok = true;
            return result;
          }
          if (code === 92 && pos + 1 < max) {
            pos += 2;
            continue;
          }
          pos++;
        }
        return result;
      }
      level = 0;
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === 32) {
          break;
        }
        if (code < 32 || code === 127) {
          break;
        }
        if (code === 92 && pos + 1 < max) {
          pos += 2;
          continue;
        }
        if (code === 40) {
          level++;
        }
        if (code === 41) {
          if (level === 0) {
            break;
          }
          level--;
        }
        pos++;
      }
      if (start === pos) {
        return result;
      }
      if (level !== 0) {
        return result;
      }
      result.str = unescapeAll(str.slice(start, pos));
      result.lines = lines;
      result.pos = pos;
      result.ok = true;
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/parse_link_title.js
var require_parse_link_title = __commonJS({
  "node_modules/markdown-it/lib/helpers/parse_link_title.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var unescapeAll = require_utils().unescapeAll;
    module.exports = function parseLinkTitle(str, pos, max) {
      var code, marker, lines = 0, start = pos, result = {
        ok: false,
        pos: 0,
        lines: 0,
        str: ""
      };
      if (pos >= max) {
        return result;
      }
      marker = str.charCodeAt(pos);
      if (marker !== 34 && marker !== 39 && marker !== 40) {
        return result;
      }
      pos++;
      if (marker === 40) {
        marker = 41;
      }
      while (pos < max) {
        code = str.charCodeAt(pos);
        if (code === marker) {
          result.pos = pos + 1;
          result.lines = lines;
          result.str = unescapeAll(str.slice(start + 1, pos));
          result.ok = true;
          return result;
        } else if (code === 10) {
          lines++;
        } else if (code === 92 && pos + 1 < max) {
          pos++;
          if (str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
        pos++;
      }
      return result;
    };
  }
});

// node_modules/markdown-it/lib/helpers/index.js
var require_helpers = __commonJS({
  "node_modules/markdown-it/lib/helpers/index.js"(exports) {
    init_define_process_env();
    "use strict";
    exports.parseLinkLabel = require_parse_link_label();
    exports.parseLinkDestination = require_parse_link_destination();
    exports.parseLinkTitle = require_parse_link_title();
  }
});

// node_modules/markdown-it/lib/renderer.js
var require_renderer = __commonJS({
  "node_modules/markdown-it/lib/renderer.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var assign2 = require_utils().assign;
    var unescapeAll = require_utils().unescapeAll;
    var escapeHtml = require_utils().escapeHtml;
    var default_rules = {};
    default_rules.code_inline = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<code" + slf.renderAttrs(token) + ">" + escapeHtml(tokens[idx].content) + "</code>";
    };
    default_rules.code_block = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      return "<pre" + slf.renderAttrs(token) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
    };
    default_rules.fence = function(tokens, idx, options, env, slf) {
      var token = tokens[idx], info = token.info ? unescapeAll(token.info).trim() : "", langName = "", highlighted, i, tmpAttrs, tmpToken;
      if (info) {
        langName = info.split(/\s+/g)[0];
      }
      if (options.highlight) {
        highlighted = options.highlight(token.content, langName) || escapeHtml(token.content);
      } else {
        highlighted = escapeHtml(token.content);
      }
      if (highlighted.indexOf("<pre") === 0) {
        return highlighted + "\n";
      }
      if (info) {
        i = token.attrIndex("class");
        tmpAttrs = token.attrs ? token.attrs.slice() : [];
        if (i < 0) {
          tmpAttrs.push(["class", options.langPrefix + langName]);
        } else {
          tmpAttrs[i][1] += " " + options.langPrefix + langName;
        }
        tmpToken = {
          attrs: tmpAttrs
        };
        return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
      }
      return "<pre><code" + slf.renderAttrs(token) + ">" + highlighted + "</code></pre>\n";
    };
    default_rules.image = function(tokens, idx, options, env, slf) {
      var token = tokens[idx];
      token.attrs[token.attrIndex("alt")][1] = slf.renderInlineAsText(token.children, options, env);
      return slf.renderToken(tokens, idx, options);
    };
    default_rules.hardbreak = function(tokens, idx, options) {
      return options.xhtmlOut ? "<br />\n" : "<br>\n";
    };
    default_rules.softbreak = function(tokens, idx, options) {
      return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
    };
    default_rules.text = function(tokens, idx) {
      return escapeHtml(tokens[idx].content);
    };
    default_rules.html_block = function(tokens, idx) {
      return tokens[idx].content;
    };
    default_rules.html_inline = function(tokens, idx) {
      return tokens[idx].content;
    };
    function Renderer() {
      this.rules = assign2({}, default_rules);
    }
    Renderer.prototype.renderAttrs = function renderAttrs(token) {
      var i, l, result;
      if (!token.attrs) {
        return "";
      }
      result = "";
      for (i = 0, l = token.attrs.length; i < l; i++) {
        result += " " + escapeHtml(token.attrs[i][0]) + '="' + escapeHtml(token.attrs[i][1]) + '"';
      }
      return result;
    };
    Renderer.prototype.renderToken = function renderToken(tokens, idx, options) {
      var nextToken, result = "", needLf = false, token = tokens[idx];
      if (token.hidden) {
        return "";
      }
      if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {
        result += "\n";
      }
      result += (token.nesting === -1 ? "</" : "<") + token.tag;
      result += this.renderAttrs(token);
      if (token.nesting === 0 && options.xhtmlOut) {
        result += " /";
      }
      if (token.block) {
        needLf = true;
        if (token.nesting === 1) {
          if (idx + 1 < tokens.length) {
            nextToken = tokens[idx + 1];
            if (nextToken.type === "inline" || nextToken.hidden) {
              needLf = false;
            } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {
              needLf = false;
            }
          }
        }
      }
      result += needLf ? ">\n" : ">";
      return result;
    };
    Renderer.prototype.renderInline = function(tokens, options, env) {
      var type2, result = "", rules = this.rules;
      for (var i = 0, len = tokens.length; i < len; i++) {
        type2 = tokens[i].type;
        if (typeof rules[type2] !== "undefined") {
          result += rules[type2](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options);
        }
      }
      return result;
    };
    Renderer.prototype.renderInlineAsText = function(tokens, options, env) {
      var result = "";
      for (var i = 0, len = tokens.length; i < len; i++) {
        if (tokens[i].type === "text") {
          result += tokens[i].content;
        } else if (tokens[i].type === "image") {
          result += this.renderInlineAsText(tokens[i].children, options, env);
        }
      }
      return result;
    };
    Renderer.prototype.render = function(tokens, options, env) {
      var i, len, type2, result = "", rules = this.rules;
      for (i = 0, len = tokens.length; i < len; i++) {
        type2 = tokens[i].type;
        if (type2 === "inline") {
          result += this.renderInline(tokens[i].children, options, env);
        } else if (typeof rules[type2] !== "undefined") {
          result += rules[tokens[i].type](tokens, i, options, env, this);
        } else {
          result += this.renderToken(tokens, i, options, env);
        }
      }
      return result;
    };
    module.exports = Renderer;
  }
});

// node_modules/markdown-it/lib/ruler.js
var require_ruler = __commonJS({
  "node_modules/markdown-it/lib/ruler.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function Ruler() {
      this.__rules__ = [];
      this.__cache__ = null;
    }
    Ruler.prototype.__find__ = function(name2) {
      for (var i = 0; i < this.__rules__.length; i++) {
        if (this.__rules__[i].name === name2) {
          return i;
        }
      }
      return -1;
    };
    Ruler.prototype.__compile__ = function() {
      var self2 = this;
      var chains = [""];
      self2.__rules__.forEach(function(rule) {
        if (!rule.enabled) {
          return;
        }
        rule.alt.forEach(function(altName) {
          if (chains.indexOf(altName) < 0) {
            chains.push(altName);
          }
        });
      });
      self2.__cache__ = {};
      chains.forEach(function(chain) {
        self2.__cache__[chain] = [];
        self2.__rules__.forEach(function(rule) {
          if (!rule.enabled) {
            return;
          }
          if (chain && rule.alt.indexOf(chain) < 0) {
            return;
          }
          self2.__cache__[chain].push(rule.fn);
        });
      });
    };
    Ruler.prototype.at = function(name2, fn, options) {
      var index = this.__find__(name2);
      var opt2 = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + name2);
      }
      this.__rules__[index].fn = fn;
      this.__rules__[index].alt = opt2.alt || [];
      this.__cache__ = null;
    };
    Ruler.prototype.before = function(beforeName, ruleName, fn, options) {
      var index = this.__find__(beforeName);
      var opt2 = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + beforeName);
      }
      this.__rules__.splice(index, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt2.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.after = function(afterName, ruleName, fn, options) {
      var index = this.__find__(afterName);
      var opt2 = options || {};
      if (index === -1) {
        throw new Error("Parser rule not found: " + afterName);
      }
      this.__rules__.splice(index + 1, 0, {
        name: ruleName,
        enabled: true,
        fn,
        alt: opt2.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.push = function(ruleName, fn, options) {
      var opt2 = options || {};
      this.__rules__.push({
        name: ruleName,
        enabled: true,
        fn,
        alt: opt2.alt || []
      });
      this.__cache__ = null;
    };
    Ruler.prototype.enable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = true;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.enableOnly = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      this.__rules__.forEach(function(rule) {
        rule.enabled = false;
      });
      this.enable(list2, ignoreInvalid);
    };
    Ruler.prototype.disable = function(list2, ignoreInvalid) {
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      var result = [];
      list2.forEach(function(name2) {
        var idx = this.__find__(name2);
        if (idx < 0) {
          if (ignoreInvalid) {
            return;
          }
          throw new Error("Rules manager: invalid rule name " + name2);
        }
        this.__rules__[idx].enabled = false;
        result.push(name2);
      }, this);
      this.__cache__ = null;
      return result;
    };
    Ruler.prototype.getRules = function(chainName) {
      if (this.__cache__ === null) {
        this.__compile__();
      }
      return this.__cache__[chainName] || [];
    };
    module.exports = Ruler;
  }
});

// node_modules/markdown-it/lib/rules_core/normalize.js
var require_normalize = __commonJS({
  "node_modules/markdown-it/lib/rules_core/normalize.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var NEWLINES_RE = /\r\n?|\n/g;
    var NULL_RE = /\0/g;
    module.exports = function normalize(state) {
      var str;
      str = state.src.replace(NEWLINES_RE, "\n");
      str = str.replace(NULL_RE, "\uFFFD");
      state.src = str;
    };
  }
});

// node_modules/markdown-it/lib/rules_core/block.js
var require_block = __commonJS({
  "node_modules/markdown-it/lib/rules_core/block.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function block2(state) {
      var token;
      if (state.inlineMode) {
        token = new state.Token("inline", "", 0);
        token.content = state.src;
        token.map = [0, 1];
        token.children = [];
        state.tokens.push(token);
      } else {
        state.md.block.parse(state.src, state.md, state.env, state.tokens);
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/inline.js
var require_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_core/inline.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function inline(state) {
      var tokens = state.tokens, tok, i, l;
      for (i = 0, l = tokens.length; i < l; i++) {
        tok = tokens[i];
        if (tok.type === "inline") {
          state.md.inline.parse(tok.content, state.md, state.env, tok.children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/linkify.js
var require_linkify = __commonJS({
  "node_modules/markdown-it/lib/rules_core/linkify.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var arrayReplaceAt = require_utils().arrayReplaceAt;
    function isLinkOpen(str) {
      return /^<a[>\s]/i.test(str);
    }
    function isLinkClose(str) {
      return /^<\/a\s*>/i.test(str);
    }
    module.exports = function linkify(state) {
      var i, j, l, tokens, token, currentToken, nodes, ln, text2, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state.tokens, links;
      if (!state.md.options.linkify) {
        return;
      }
      for (j = 0, l = blockTokens.length; j < l; j++) {
        if (blockTokens[j].type !== "inline" || !state.md.linkify.pretest(blockTokens[j].content)) {
          continue;
        }
        tokens = blockTokens[j].children;
        htmlLinkLevel = 0;
        for (i = tokens.length - 1; i >= 0; i--) {
          currentToken = tokens[i];
          if (currentToken.type === "link_close") {
            i--;
            while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
              i--;
            }
            continue;
          }
          if (currentToken.type === "html_inline") {
            if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
              htmlLinkLevel--;
            }
            if (isLinkClose(currentToken.content)) {
              htmlLinkLevel++;
            }
          }
          if (htmlLinkLevel > 0) {
            continue;
          }
          if (currentToken.type === "text" && state.md.linkify.test(currentToken.content)) {
            text2 = currentToken.content;
            links = state.md.linkify.match(text2);
            nodes = [];
            level = currentToken.level;
            lastPos = 0;
            for (ln = 0; ln < links.length; ln++) {
              url = links[ln].url;
              fullUrl = state.md.normalizeLink(url);
              if (!state.md.validateLink(fullUrl)) {
                continue;
              }
              urlText = links[ln].text;
              if (!links[ln].schema) {
                urlText = state.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
              } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
                urlText = state.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
              } else {
                urlText = state.md.normalizeLinkText(urlText);
              }
              pos = links[ln].index;
              if (pos > lastPos) {
                token = new state.Token("text", "", 0);
                token.content = text2.slice(lastPos, pos);
                token.level = level;
                nodes.push(token);
              }
              token = new state.Token("link_open", "a", 1);
              token.attrs = [["href", fullUrl]];
              token.level = level++;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              token = new state.Token("text", "", 0);
              token.content = urlText;
              token.level = level;
              nodes.push(token);
              token = new state.Token("link_close", "a", -1);
              token.level = --level;
              token.markup = "linkify";
              token.info = "auto";
              nodes.push(token);
              lastPos = links[ln].lastIndex;
            }
            if (lastPos < text2.length) {
              token = new state.Token("text", "", 0);
              token.content = text2.slice(lastPos);
              token.level = level;
              nodes.push(token);
            }
            blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
          }
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/replacements.js
var require_replacements = __commonJS({
  "node_modules/markdown-it/lib/rules_core/replacements.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
    var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
    var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
    var SCOPED_ABBR = {
      c: "\xA9",
      r: "\xAE",
      p: "\xA7",
      tm: "\u2122"
    };
    function replaceFn(match, name2) {
      return SCOPED_ABBR[name2.toLowerCase()];
    }
    function replace_scoped(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          token.content = token.content.replace(SCOPED_ABBR_RE, replaceFn);
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    function replace_rare(inlineTokens) {
      var i, token, inside_autolink = 0;
      for (i = inlineTokens.length - 1; i >= 0; i--) {
        token = inlineTokens[i];
        if (token.type === "text" && !inside_autolink) {
          if (RARE_RE.test(token.content)) {
            token.content = token.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---([^-]|$)/mg, "$1\u2014$2").replace(/(^|\s)--(\s|$)/mg, "$1\u2013$2").replace(/(^|[^-\s])--([^-\s]|$)/mg, "$1\u2013$2");
          }
        }
        if (token.type === "link_open" && token.info === "auto") {
          inside_autolink--;
        }
        if (token.type === "link_close" && token.info === "auto") {
          inside_autolink++;
        }
      }
    }
    module.exports = function replace(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline") {
          continue;
        }
        if (SCOPED_ABBR_TEST_RE.test(state.tokens[blkIdx].content)) {
          replace_scoped(state.tokens[blkIdx].children);
        }
        if (RARE_RE.test(state.tokens[blkIdx].content)) {
          replace_rare(state.tokens[blkIdx].children);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_core/smartquotes.js
var require_smartquotes = __commonJS({
  "node_modules/markdown-it/lib/rules_core/smartquotes.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    var QUOTE_TEST_RE = /['"]/;
    var QUOTE_RE = /['"]/g;
    var APOSTROPHE = "\u2019";
    function replaceAt(str, index, ch) {
      return str.substr(0, index) + ch + str.substr(index + 1);
    }
    function process_inlines(tokens, state) {
      var i, token, text2, t2, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
      stack = [];
      for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        thisLevel = tokens[i].level;
        for (j = stack.length - 1; j >= 0; j--) {
          if (stack[j].level <= thisLevel) {
            break;
          }
        }
        stack.length = j + 1;
        if (token.type !== "text") {
          continue;
        }
        text2 = token.content;
        pos = 0;
        max = text2.length;
        OUTER:
          while (pos < max) {
            QUOTE_RE.lastIndex = pos;
            t2 = QUOTE_RE.exec(text2);
            if (!t2) {
              break;
            }
            canOpen = canClose = true;
            pos = t2.index + 1;
            isSingle = t2[0] === "'";
            lastChar = 32;
            if (t2.index - 1 >= 0) {
              lastChar = text2.charCodeAt(t2.index - 1);
            } else {
              for (j = i - 1; j >= 0; j--) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (tokens[j].type !== "text")
                  continue;
                lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
                break;
              }
            }
            nextChar = 32;
            if (pos < max) {
              nextChar = text2.charCodeAt(pos);
            } else {
              for (j = i + 1; j < tokens.length; j++) {
                if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
                  break;
                if (tokens[j].type !== "text")
                  continue;
                nextChar = tokens[j].content.charCodeAt(0);
                break;
              }
            }
            isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
            isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
            isLastWhiteSpace = isWhiteSpace(lastChar);
            isNextWhiteSpace = isWhiteSpace(nextChar);
            if (isNextWhiteSpace) {
              canOpen = false;
            } else if (isNextPunctChar) {
              if (!(isLastWhiteSpace || isLastPunctChar)) {
                canOpen = false;
              }
            }
            if (isLastWhiteSpace) {
              canClose = false;
            } else if (isLastPunctChar) {
              if (!(isNextWhiteSpace || isNextPunctChar)) {
                canClose = false;
              }
            }
            if (nextChar === 34 && t2[0] === '"') {
              if (lastChar >= 48 && lastChar <= 57) {
                canClose = canOpen = false;
              }
            }
            if (canOpen && canClose) {
              canOpen = false;
              canClose = isNextPunctChar;
            }
            if (!canOpen && !canClose) {
              if (isSingle) {
                token.content = replaceAt(token.content, t2.index, APOSTROPHE);
              }
              continue;
            }
            if (canClose) {
              for (j = stack.length - 1; j >= 0; j--) {
                item = stack[j];
                if (stack[j].level < thisLevel) {
                  break;
                }
                if (item.single === isSingle && stack[j].level === thisLevel) {
                  item = stack[j];
                  if (isSingle) {
                    openQuote = state.md.options.quotes[2];
                    closeQuote = state.md.options.quotes[3];
                  } else {
                    openQuote = state.md.options.quotes[0];
                    closeQuote = state.md.options.quotes[1];
                  }
                  token.content = replaceAt(token.content, t2.index, closeQuote);
                  tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
                  pos += closeQuote.length - 1;
                  if (item.token === i) {
                    pos += openQuote.length - 1;
                  }
                  text2 = token.content;
                  max = text2.length;
                  stack.length = j;
                  continue OUTER;
                }
              }
            }
            if (canOpen) {
              stack.push({
                token: i,
                pos: t2.index,
                single: isSingle,
                level: thisLevel
              });
            } else if (canClose && isSingle) {
              token.content = replaceAt(token.content, t2.index, APOSTROPHE);
            }
          }
      }
    }
    module.exports = function smartquotes(state) {
      var blkIdx;
      if (!state.md.options.typographer) {
        return;
      }
      for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {
        if (state.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {
          continue;
        }
        process_inlines(state.tokens[blkIdx].children, state);
      }
    };
  }
});

// node_modules/markdown-it/lib/token.js
var require_token = __commonJS({
  "node_modules/markdown-it/lib/token.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function Token2(type2, tag, nesting) {
      this.type = type2;
      this.tag = tag;
      this.attrs = null;
      this.map = null;
      this.nesting = nesting;
      this.level = 0;
      this.children = null;
      this.content = "";
      this.markup = "";
      this.info = "";
      this.meta = null;
      this.block = false;
      this.hidden = false;
    }
    Token2.prototype.attrIndex = function attrIndex(name2) {
      var attrs, i, len;
      if (!this.attrs) {
        return -1;
      }
      attrs = this.attrs;
      for (i = 0, len = attrs.length; i < len; i++) {
        if (attrs[i][0] === name2) {
          return i;
        }
      }
      return -1;
    };
    Token2.prototype.attrPush = function attrPush(attrData) {
      if (this.attrs) {
        this.attrs.push(attrData);
      } else {
        this.attrs = [attrData];
      }
    };
    Token2.prototype.attrSet = function attrSet(name2, value) {
      var idx = this.attrIndex(name2), attrData = [name2, value];
      if (idx < 0) {
        this.attrPush(attrData);
      } else {
        this.attrs[idx] = attrData;
      }
    };
    Token2.prototype.attrGet = function attrGet(name2) {
      var idx = this.attrIndex(name2), value = null;
      if (idx >= 0) {
        value = this.attrs[idx][1];
      }
      return value;
    };
    Token2.prototype.attrJoin = function attrJoin(name2, value) {
      var idx = this.attrIndex(name2);
      if (idx < 0) {
        this.attrPush([name2, value]);
      } else {
        this.attrs[idx][1] = this.attrs[idx][1] + " " + value;
      }
    };
    module.exports = Token2;
  }
});

// node_modules/markdown-it/lib/rules_core/state_core.js
var require_state_core = __commonJS({
  "node_modules/markdown-it/lib/rules_core/state_core.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Token2 = require_token();
    function StateCore(src, md4, env) {
      this.src = src;
      this.env = env;
      this.tokens = [];
      this.inlineMode = false;
      this.md = md4;
    }
    StateCore.prototype.Token = Token2;
    module.exports = StateCore;
  }
});

// node_modules/markdown-it/lib/parser_core.js
var require_parser_core = __commonJS({
  "node_modules/markdown-it/lib/parser_core.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["normalize", require_normalize()],
      ["block", require_block()],
      ["inline", require_inline()],
      ["linkify", require_linkify()],
      ["replacements", require_replacements()],
      ["smartquotes", require_smartquotes()]
    ];
    function Core() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
    }
    Core.prototype.process = function(state) {
      var i, l, rules;
      rules = this.ruler.getRules("");
      for (i = 0, l = rules.length; i < l; i++) {
        rules[i](state);
      }
    };
    Core.prototype.State = require_state_core();
    module.exports = Core;
  }
});

// node_modules/markdown-it/lib/rules_block/table.js
var require_table = __commonJS({
  "node_modules/markdown-it/lib/rules_block/table.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    function getLine(state, line) {
      var pos = state.bMarks[line] + state.blkIndent, max = state.eMarks[line];
      return state.src.substr(pos, max - pos);
    }
    function escapedSplit(str) {
      var result = [], pos = 0, max = str.length, ch, escapes = 0, lastPos = 0, backTicked = false, lastBackTick = 0;
      ch = str.charCodeAt(pos);
      while (pos < max) {
        if (ch === 96) {
          if (backTicked) {
            backTicked = false;
            lastBackTick = pos;
          } else if (escapes % 2 === 0) {
            backTicked = true;
            lastBackTick = pos;
          }
        } else if (ch === 124 && escapes % 2 === 0 && !backTicked) {
          result.push(str.substring(lastPos, pos));
          lastPos = pos + 1;
        }
        if (ch === 92) {
          escapes++;
        } else {
          escapes = 0;
        }
        pos++;
        if (pos === max && backTicked) {
          backTicked = false;
          pos = lastBackTick + 1;
        }
        ch = str.charCodeAt(pos);
      }
      result.push(str.substring(lastPos));
      return result;
    }
    module.exports = function table(state, startLine, endLine, silent) {
      var ch, lineText, pos, i, nextLine, columns, columnCount, token, aligns, t2, tableLines, tbodyLines;
      if (startLine + 2 > endLine) {
        return false;
      }
      nextLine = startLine + 1;
      if (state.sCount[nextLine] < state.blkIndent) {
        return false;
      }
      if (state.sCount[nextLine] - state.blkIndent >= 4) {
        return false;
      }
      pos = state.bMarks[nextLine] + state.tShift[nextLine];
      if (pos >= state.eMarks[nextLine]) {
        return false;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch !== 124 && ch !== 45 && ch !== 58) {
        return false;
      }
      while (pos < state.eMarks[nextLine]) {
        ch = state.src.charCodeAt(pos);
        if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace(ch)) {
          return false;
        }
        pos++;
      }
      lineText = getLine(state, startLine + 1);
      columns = lineText.split("|");
      aligns = [];
      for (i = 0; i < columns.length; i++) {
        t2 = columns[i].trim();
        if (!t2) {
          if (i === 0 || i === columns.length - 1) {
            continue;
          } else {
            return false;
          }
        }
        if (!/^:?-+:?$/.test(t2)) {
          return false;
        }
        if (t2.charCodeAt(t2.length - 1) === 58) {
          aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
        } else if (t2.charCodeAt(0) === 58) {
          aligns.push("left");
        } else {
          aligns.push("");
        }
      }
      lineText = getLine(state, startLine).trim();
      if (lineText.indexOf("|") === -1) {
        return false;
      }
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      columns = escapedSplit(lineText.replace(/^\||\|$/g, ""));
      columnCount = columns.length;
      if (columnCount > aligns.length) {
        return false;
      }
      if (silent) {
        return true;
      }
      token = state.push("table_open", "table", 1);
      token.map = tableLines = [startLine, 0];
      token = state.push("thead_open", "thead", 1);
      token.map = [startLine, startLine + 1];
      token = state.push("tr_open", "tr", 1);
      token.map = [startLine, startLine + 1];
      for (i = 0; i < columns.length; i++) {
        token = state.push("th_open", "th", 1);
        token.map = [startLine, startLine + 1];
        if (aligns[i]) {
          token.attrs = [["style", "text-align:" + aligns[i]]];
        }
        token = state.push("inline", "", 0);
        token.content = columns[i].trim();
        token.map = [startLine, startLine + 1];
        token.children = [];
        token = state.push("th_close", "th", -1);
      }
      token = state.push("tr_close", "tr", -1);
      token = state.push("thead_close", "thead", -1);
      token = state.push("tbody_open", "tbody", 1);
      token.map = tbodyLines = [startLine + 2, 0];
      for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        lineText = getLine(state, nextLine).trim();
        if (lineText.indexOf("|") === -1) {
          break;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          break;
        }
        columns = escapedSplit(lineText.replace(/^\||\|$/g, ""));
        token = state.push("tr_open", "tr", 1);
        for (i = 0; i < columnCount; i++) {
          token = state.push("td_open", "td", 1);
          if (aligns[i]) {
            token.attrs = [["style", "text-align:" + aligns[i]]];
          }
          token = state.push("inline", "", 0);
          token.content = columns[i] ? columns[i].trim() : "";
          token.children = [];
          token = state.push("td_close", "td", -1);
        }
        token = state.push("tr_close", "tr", -1);
      }
      token = state.push("tbody_close", "tbody", -1);
      token = state.push("table_close", "table", -1);
      tableLines[1] = tbodyLines[1] = nextLine;
      state.line = nextLine;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/code.js
var require_code = __commonJS({
  "node_modules/markdown-it/lib/rules_block/code.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function code(state, startLine, endLine) {
      var nextLine, last, token;
      if (state.sCount[startLine] - state.blkIndent < 4) {
        return false;
      }
      last = nextLine = startLine + 1;
      while (nextLine < endLine) {
        if (state.isEmpty(nextLine)) {
          nextLine++;
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          nextLine++;
          last = nextLine;
          continue;
        }
        break;
      }
      state.line = last;
      token = state.push("code_block", "code", 0);
      token.content = state.getLines(startLine, last, 4 + state.blkIndent, true);
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/fence.js
var require_fence = __commonJS({
  "node_modules/markdown-it/lib/rules_block/fence.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function fence(state, startLine, endLine, silent) {
      var marker, len, params, nextLine, mem, token, markup, haveEndMarker = false, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (pos + 3 > max) {
        return false;
      }
      marker = state.src.charCodeAt(pos);
      if (marker !== 126 && marker !== 96) {
        return false;
      }
      mem = pos;
      pos = state.skipChars(pos, marker);
      len = pos - mem;
      if (len < 3) {
        return false;
      }
      markup = state.src.slice(mem, pos);
      params = state.src.slice(pos, max);
      if (marker === 96) {
        if (params.indexOf(String.fromCharCode(marker)) >= 0) {
          return false;
        }
      }
      if (silent) {
        return true;
      }
      nextLine = startLine;
      for (; ; ) {
        nextLine++;
        if (nextLine >= endLine) {
          break;
        }
        pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos < max && state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.src.charCodeAt(pos) !== marker) {
          continue;
        }
        if (state.sCount[nextLine] - state.blkIndent >= 4) {
          continue;
        }
        pos = state.skipChars(pos, marker);
        if (pos - mem < len) {
          continue;
        }
        pos = state.skipSpaces(pos);
        if (pos < max) {
          continue;
        }
        haveEndMarker = true;
        break;
      }
      len = state.sCount[startLine];
      state.line = nextLine + (haveEndMarker ? 1 : 0);
      token = state.push("fence", "code", 0);
      token.info = params;
      token.content = state.getLines(startLine + 1, nextLine, len, true);
      token.markup = markup;
      token.map = [startLine, state.line];
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/blockquote.js
var require_blockquote = __commonJS({
  "node_modules/markdown-it/lib/rules_block/blockquote.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function blockquote(state, startLine, endLine, silent) {
      var adjustTab, ch, i, initial, l, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token, wasOutdented, oldLineMax = state.lineMax, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos++) !== 62) {
        return false;
      }
      if (silent) {
        return true;
      }
      initial = offset = state.sCount[startLine] + pos - (state.bMarks[startLine] + state.tShift[startLine]);
      if (state.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state.bsCount[startLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks = [state.bMarks[startLine]];
      state.bMarks[startLine] = pos;
      while (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (isSpace(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      oldBSCount = [state.bsCount[startLine]];
      state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
      lastLineEmpty = pos >= max;
      oldSCount = [state.sCount[startLine]];
      state.sCount[startLine] = offset - initial;
      oldTShift = [state.tShift[startLine]];
      state.tShift[startLine] = pos - state.bMarks[startLine];
      terminatorRules = state.md.block.ruler.getRules("blockquote");
      oldParentType = state.parentType;
      state.parentType = "blockquote";
      wasOutdented = false;
      for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
        if (state.sCount[nextLine] < state.blkIndent)
          wasOutdented = true;
        pos = state.bMarks[nextLine] + state.tShift[nextLine];
        max = state.eMarks[nextLine];
        if (pos >= max) {
          break;
        }
        if (state.src.charCodeAt(pos++) === 62 && !wasOutdented) {
          initial = offset = state.sCount[nextLine] + pos - (state.bMarks[nextLine] + state.tShift[nextLine]);
          if (state.src.charCodeAt(pos) === 32) {
            pos++;
            initial++;
            offset++;
            adjustTab = false;
            spaceAfterMarker = true;
          } else if (state.src.charCodeAt(pos) === 9) {
            spaceAfterMarker = true;
            if ((state.bsCount[nextLine] + offset) % 4 === 3) {
              pos++;
              initial++;
              offset++;
              adjustTab = false;
            } else {
              adjustTab = true;
            }
          } else {
            spaceAfterMarker = false;
          }
          oldBMarks.push(state.bMarks[nextLine]);
          state.bMarks[nextLine] = pos;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (isSpace(ch)) {
              if (ch === 9) {
                offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
              } else {
                offset++;
              }
            } else {
              break;
            }
            pos++;
          }
          lastLineEmpty = pos >= max;
          oldBSCount.push(state.bsCount[nextLine]);
          state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
          oldSCount.push(state.sCount[nextLine]);
          state.sCount[nextLine] = offset - initial;
          oldTShift.push(state.tShift[nextLine]);
          state.tShift[nextLine] = pos - state.bMarks[nextLine];
          continue;
        }
        if (lastLineEmpty) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          state.lineMax = nextLine;
          if (state.blkIndent !== 0) {
            oldBMarks.push(state.bMarks[nextLine]);
            oldBSCount.push(state.bsCount[nextLine]);
            oldTShift.push(state.tShift[nextLine]);
            oldSCount.push(state.sCount[nextLine]);
            state.sCount[nextLine] -= state.blkIndent;
          }
          break;
        }
        oldBMarks.push(state.bMarks[nextLine]);
        oldBSCount.push(state.bsCount[nextLine]);
        oldTShift.push(state.tShift[nextLine]);
        oldSCount.push(state.sCount[nextLine]);
        state.sCount[nextLine] = -1;
      }
      oldIndent = state.blkIndent;
      state.blkIndent = 0;
      token = state.push("blockquote_open", "blockquote", 1);
      token.markup = ">";
      token.map = lines = [startLine, 0];
      state.md.block.tokenize(state, startLine, nextLine);
      token = state.push("blockquote_close", "blockquote", -1);
      token.markup = ">";
      state.lineMax = oldLineMax;
      state.parentType = oldParentType;
      lines[1] = state.line;
      for (i = 0; i < oldTShift.length; i++) {
        state.bMarks[i + startLine] = oldBMarks[i];
        state.tShift[i + startLine] = oldTShift[i];
        state.sCount[i + startLine] = oldSCount[i];
        state.bsCount[i + startLine] = oldBSCount[i];
      }
      state.blkIndent = oldIndent;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/hr.js
var require_hr = __commonJS({
  "node_modules/markdown-it/lib/rules_block/hr.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function hr(state, startLine, endLine, silent) {
      var marker, cnt, ch, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 95) {
        return false;
      }
      cnt = 1;
      while (pos < max) {
        ch = state.src.charCodeAt(pos++);
        if (ch !== marker && !isSpace(ch)) {
          return false;
        }
        if (ch === marker) {
          cnt++;
        }
      }
      if (cnt < 3) {
        return false;
      }
      if (silent) {
        return true;
      }
      state.line = startLine + 1;
      token = state.push("hr", "hr", 0);
      token.map = [startLine, state.line];
      token.markup = Array(cnt + 1).join(String.fromCharCode(marker));
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/list.js
var require_list = __commonJS({
  "node_modules/markdown-it/lib/rules_block/list.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    function skipBulletListMarker(state, startLine) {
      var marker, pos, max, ch;
      pos = state.bMarks[startLine] + state.tShift[startLine];
      max = state.eMarks[startLine];
      marker = state.src.charCodeAt(pos++);
      if (marker !== 42 && marker !== 45 && marker !== 43) {
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function skipOrderedListMarker(state, startLine) {
      var ch, start = state.bMarks[startLine] + state.tShift[startLine], pos = start, max = state.eMarks[startLine];
      if (pos + 1 >= max) {
        return -1;
      }
      ch = state.src.charCodeAt(pos++);
      if (ch < 48 || ch > 57) {
        return -1;
      }
      for (; ; ) {
        if (pos >= max) {
          return -1;
        }
        ch = state.src.charCodeAt(pos++);
        if (ch >= 48 && ch <= 57) {
          if (pos - start >= 10) {
            return -1;
          }
          continue;
        }
        if (ch === 41 || ch === 46) {
          break;
        }
        return -1;
      }
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          return -1;
        }
      }
      return pos;
    }
    function markTightParagraphs(state, idx) {
      var i, l, level = state.level + 2;
      for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {
        if (state.tokens[i].level === level && state.tokens[i].type === "paragraph_open") {
          state.tokens[i + 2].hidden = true;
          state.tokens[i].hidden = true;
          i += 2;
        }
      }
    }
    module.exports = function list2(state, startLine, endLine, silent) {
      var ch, contentStart, i, indent2, indentAfterMarker, initial, isOrdered, itemLines, l, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token, isTerminatingParagraph = false, tight = true;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.listIndent >= 0 && state.sCount[startLine] - state.listIndent >= 4 && state.sCount[startLine] < state.blkIndent) {
        return false;
      }
      if (silent && state.parentType === "paragraph") {
        if (state.tShift[startLine] >= state.blkIndent) {
          isTerminatingParagraph = true;
        }
      }
      if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {
        isOrdered = true;
        start = state.bMarks[startLine] + state.tShift[startLine];
        markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));
        if (isTerminatingParagraph && markerValue !== 1)
          return false;
      } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {
        isOrdered = false;
      } else {
        return false;
      }
      if (isTerminatingParagraph) {
        if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine])
          return false;
      }
      markerCharCode = state.src.charCodeAt(posAfterMarker - 1);
      if (silent) {
        return true;
      }
      listTokIdx = state.tokens.length;
      if (isOrdered) {
        token = state.push("ordered_list_open", "ol", 1);
        if (markerValue !== 1) {
          token.attrs = [["start", markerValue]];
        }
      } else {
        token = state.push("bullet_list_open", "ul", 1);
      }
      token.map = listLines = [startLine, 0];
      token.markup = String.fromCharCode(markerCharCode);
      nextLine = startLine;
      prevEmptyEnd = false;
      terminatorRules = state.md.block.ruler.getRules("list");
      oldParentType = state.parentType;
      state.parentType = "list";
      while (nextLine < endLine) {
        pos = posAfterMarker;
        max = state.eMarks[nextLine];
        initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);
        while (pos < max) {
          ch = state.src.charCodeAt(pos);
          if (ch === 9) {
            offset += 4 - (offset + state.bsCount[nextLine]) % 4;
          } else if (ch === 32) {
            offset++;
          } else {
            break;
          }
          pos++;
        }
        contentStart = pos;
        if (contentStart >= max) {
          indentAfterMarker = 1;
        } else {
          indentAfterMarker = offset - initial;
        }
        if (indentAfterMarker > 4) {
          indentAfterMarker = 1;
        }
        indent2 = initial + indentAfterMarker;
        token = state.push("list_item_open", "li", 1);
        token.markup = String.fromCharCode(markerCharCode);
        token.map = itemLines = [startLine, 0];
        oldTight = state.tight;
        oldTShift = state.tShift[startLine];
        oldSCount = state.sCount[startLine];
        oldListIndent = state.listIndent;
        state.listIndent = state.blkIndent;
        state.blkIndent = indent2;
        state.tight = true;
        state.tShift[startLine] = contentStart - state.bMarks[startLine];
        state.sCount[startLine] = offset;
        if (contentStart >= max && state.isEmpty(startLine + 1)) {
          state.line = Math.min(state.line + 2, endLine);
        } else {
          state.md.block.tokenize(state, startLine, endLine, true);
        }
        if (!state.tight || prevEmptyEnd) {
          tight = false;
        }
        prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);
        state.blkIndent = state.listIndent;
        state.listIndent = oldListIndent;
        state.tShift[startLine] = oldTShift;
        state.sCount[startLine] = oldSCount;
        state.tight = oldTight;
        token = state.push("list_item_close", "li", -1);
        token.markup = String.fromCharCode(markerCharCode);
        nextLine = startLine = state.line;
        itemLines[1] = nextLine;
        contentStart = state.bMarks[startLine];
        if (nextLine >= endLine) {
          break;
        }
        if (state.sCount[nextLine] < state.blkIndent) {
          break;
        }
        if (state.sCount[startLine] - state.blkIndent >= 4) {
          break;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
        if (isOrdered) {
          posAfterMarker = skipOrderedListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        } else {
          posAfterMarker = skipBulletListMarker(state, nextLine);
          if (posAfterMarker < 0) {
            break;
          }
        }
        if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {
          break;
        }
      }
      if (isOrdered) {
        token = state.push("ordered_list_close", "ol", -1);
      } else {
        token = state.push("bullet_list_close", "ul", -1);
      }
      token.markup = String.fromCharCode(markerCharCode);
      listLines[1] = nextLine;
      state.line = nextLine;
      state.parentType = oldParentType;
      if (tight) {
        markTightParagraphs(state, listTokIdx);
      }
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/reference.js
var require_reference = __commonJS({
  "node_modules/markdown-it/lib/rules_block/reference.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function reference(state, startLine, _endLine, silent) {
      var ch, destEndPos, destEndLineNo, endLine, href, i, l, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine], nextLine = startLine + 1;
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 91) {
        return false;
      }
      while (++pos < max) {
        if (state.src.charCodeAt(pos) === 93 && state.src.charCodeAt(pos - 1) !== 92) {
          if (pos + 1 === max) {
            return false;
          }
          if (state.src.charCodeAt(pos + 1) !== 58) {
            return false;
          }
          break;
        }
      }
      endLine = state.lineMax;
      terminatorRules = state.md.block.ruler.getRules("reference");
      oldParentType = state.parentType;
      state.parentType = "reference";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      str = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      max = str.length;
      for (pos = 1; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 91) {
          return false;
        } else if (ch === 93) {
          labelEnd = pos;
          break;
        } else if (ch === 10) {
          lines++;
        } else if (ch === 92) {
          pos++;
          if (pos < max && str.charCodeAt(pos) === 10) {
            lines++;
          }
        }
      }
      if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
        return false;
      }
      for (pos = labelEnd + 2; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkDestination(str, pos, max);
      if (!res.ok) {
        return false;
      }
      href = state.md.normalizeLink(res.str);
      if (!state.md.validateLink(href)) {
        return false;
      }
      pos = res.pos;
      lines += res.lines;
      destEndPos = pos;
      destEndLineNo = lines;
      start = pos;
      for (; pos < max; pos++) {
        ch = str.charCodeAt(pos);
        if (ch === 10) {
          lines++;
        } else if (isSpace(ch)) {
        } else {
          break;
        }
      }
      res = state.md.helpers.parseLinkTitle(str, pos, max);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        lines += res.lines;
      } else {
        title = "";
        pos = destEndPos;
        lines = destEndLineNo;
      }
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
        pos++;
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        if (title) {
          title = "";
          pos = destEndPos;
          lines = destEndLineNo;
          while (pos < max) {
            ch = str.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
        }
      }
      if (pos < max && str.charCodeAt(pos) !== 10) {
        return false;
      }
      label = normalizeReference(str.slice(1, labelEnd));
      if (!label) {
        return false;
      }
      if (silent) {
        return true;
      }
      if (typeof state.env.references === "undefined") {
        state.env.references = {};
      }
      if (typeof state.env.references[label] === "undefined") {
        state.env.references[label] = { title, href };
      }
      state.parentType = oldParentType;
      state.line = startLine + lines + 1;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/heading.js
var require_heading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/heading.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function heading(state, startLine, endLine, silent) {
      var ch, level, tmp, token, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      ch = state.src.charCodeAt(pos);
      if (ch !== 35 || pos >= max) {
        return false;
      }
      level = 1;
      ch = state.src.charCodeAt(++pos);
      while (ch === 35 && pos < max && level <= 6) {
        level++;
        ch = state.src.charCodeAt(++pos);
      }
      if (level > 6 || pos < max && !isSpace(ch)) {
        return false;
      }
      if (silent) {
        return true;
      }
      max = state.skipSpacesBack(max, pos);
      tmp = state.skipCharsBack(max, 35, pos);
      if (tmp > pos && isSpace(state.src.charCodeAt(tmp - 1))) {
        max = tmp;
      }
      state.line = startLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = "########".slice(0, level);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = state.src.slice(pos, max).trim();
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = "########".slice(0, level);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/lheading.js
var require_lheading = __commonJS({
  "node_modules/markdown-it/lib/rules_block/lheading.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function lheading(state, startLine, endLine) {
      var content, terminate, i, l, token, pos, max, level, marker, nextLine = startLine + 1, oldParentType, terminatorRules = state.md.block.ruler.getRules("paragraph");
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] >= state.blkIndent) {
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          if (pos < max) {
            marker = state.src.charCodeAt(pos);
            if (marker === 45 || marker === 61) {
              pos = state.skipChars(pos, marker);
              pos = state.skipSpaces(pos);
              if (pos >= max) {
                level = marker === 61 ? 1 : 2;
                break;
              }
            }
          }
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      if (!level) {
        return false;
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine + 1;
      token = state.push("heading_open", "h" + String(level), 1);
      token.markup = String.fromCharCode(marker);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line - 1];
      token.children = [];
      token = state.push("heading_close", "h" + String(level), -1);
      token.markup = String.fromCharCode(marker);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/common/html_blocks.js
var require_html_blocks = __commonJS({
  "node_modules/markdown-it/lib/common/html_blocks.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "meta",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
  }
});

// node_modules/markdown-it/lib/common/html_re.js
var require_html_re = __commonJS({
  "node_modules/markdown-it/lib/common/html_re.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
    var unquoted = "[^\"'=<>`\\x00-\\x20]+";
    var single_quoted = "'[^']*'";
    var double_quoted = '"[^"]*"';
    var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
    var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
    var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
    var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
    var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
    var processing = "<[?].*?[?]>";
    var declaration = "<![A-Z]+\\s+[^>]*>";
    var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
    var HTML_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
    var HTML_OPEN_CLOSE_TAG_RE = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
    module.exports.HTML_TAG_RE = HTML_TAG_RE;
    module.exports.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE;
  }
});

// node_modules/markdown-it/lib/rules_block/html_block.js
var require_html_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/html_block.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var block_names = require_html_blocks();
    var HTML_OPEN_CLOSE_TAG_RE = require_html_re().HTML_OPEN_CLOSE_TAG_RE;
    var HTML_SEQUENCES = [
      [/^<(script|pre|style)(?=(\s|>|$))/i, /<\/(script|pre|style)>/i, true],
      [/^<!--/, /-->/, true],
      [/^<\?/, /\?>/, true],
      [/^<![A-Z]/, />/, true],
      [/^<!\[CDATA\[/, /\]\]>/, true],
      [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
      [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
    ];
    module.exports = function html_block(state, startLine, endLine, silent) {
      var i, nextLine, token, lineText, pos = state.bMarks[startLine] + state.tShift[startLine], max = state.eMarks[startLine];
      if (state.sCount[startLine] - state.blkIndent >= 4) {
        return false;
      }
      if (!state.md.options.html) {
        return false;
      }
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      lineText = state.src.slice(pos, max);
      for (i = 0; i < HTML_SEQUENCES.length; i++) {
        if (HTML_SEQUENCES[i][0].test(lineText)) {
          break;
        }
      }
      if (i === HTML_SEQUENCES.length) {
        return false;
      }
      if (silent) {
        return HTML_SEQUENCES[i][2];
      }
      nextLine = startLine + 1;
      if (!HTML_SEQUENCES[i][1].test(lineText)) {
        for (; nextLine < endLine; nextLine++) {
          if (state.sCount[nextLine] < state.blkIndent) {
            break;
          }
          pos = state.bMarks[nextLine] + state.tShift[nextLine];
          max = state.eMarks[nextLine];
          lineText = state.src.slice(pos, max);
          if (HTML_SEQUENCES[i][1].test(lineText)) {
            if (lineText.length !== 0) {
              nextLine++;
            }
            break;
          }
        }
      }
      state.line = nextLine;
      token = state.push("html_block", "", 0);
      token.map = [startLine, nextLine];
      token.content = state.getLines(startLine, nextLine, state.blkIndent, true);
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/paragraph.js
var require_paragraph = __commonJS({
  "node_modules/markdown-it/lib/rules_block/paragraph.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function paragraph(state, startLine) {
      var content, terminate, i, l, token, oldParentType, nextLine = startLine + 1, terminatorRules = state.md.block.ruler.getRules("paragraph"), endLine = state.lineMax;
      oldParentType = state.parentType;
      state.parentType = "paragraph";
      for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {
        if (state.sCount[nextLine] - state.blkIndent > 3) {
          continue;
        }
        if (state.sCount[nextLine] < 0) {
          continue;
        }
        terminate = false;
        for (i = 0, l = terminatorRules.length; i < l; i++) {
          if (terminatorRules[i](state, nextLine, endLine, true)) {
            terminate = true;
            break;
          }
        }
        if (terminate) {
          break;
        }
      }
      content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();
      state.line = nextLine;
      token = state.push("paragraph_open", "p", 1);
      token.map = [startLine, state.line];
      token = state.push("inline", "", 0);
      token.content = content;
      token.map = [startLine, state.line];
      token.children = [];
      token = state.push("paragraph_close", "p", -1);
      state.parentType = oldParentType;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_block/state_block.js
var require_state_block = __commonJS({
  "node_modules/markdown-it/lib/rules_block/state_block.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Token2 = require_token();
    var isSpace = require_utils().isSpace;
    function StateBlock(src, md4, env, tokens) {
      var ch, s, start, pos, len, indent2, offset, indent_found;
      this.src = src;
      this.md = md4;
      this.env = env;
      this.tokens = tokens;
      this.bMarks = [];
      this.eMarks = [];
      this.tShift = [];
      this.sCount = [];
      this.bsCount = [];
      this.blkIndent = 0;
      this.line = 0;
      this.lineMax = 0;
      this.tight = false;
      this.ddIndent = -1;
      this.listIndent = -1;
      this.parentType = "root";
      this.level = 0;
      this.result = "";
      s = this.src;
      indent_found = false;
      for (start = pos = indent2 = offset = 0, len = s.length; pos < len; pos++) {
        ch = s.charCodeAt(pos);
        if (!indent_found) {
          if (isSpace(ch)) {
            indent2++;
            if (ch === 9) {
              offset += 4 - offset % 4;
            } else {
              offset++;
            }
            continue;
          } else {
            indent_found = true;
          }
        }
        if (ch === 10 || pos === len - 1) {
          if (ch !== 10) {
            pos++;
          }
          this.bMarks.push(start);
          this.eMarks.push(pos);
          this.tShift.push(indent2);
          this.sCount.push(offset);
          this.bsCount.push(0);
          indent_found = false;
          indent2 = 0;
          offset = 0;
          start = pos + 1;
        }
      }
      this.bMarks.push(s.length);
      this.eMarks.push(s.length);
      this.tShift.push(0);
      this.sCount.push(0);
      this.bsCount.push(0);
      this.lineMax = this.bMarks.length - 1;
    }
    StateBlock.prototype.push = function(type2, tag, nesting) {
      var token = new Token2(type2, tag, nesting);
      token.block = true;
      if (nesting < 0)
        this.level--;
      token.level = this.level;
      if (nesting > 0)
        this.level++;
      this.tokens.push(token);
      return token;
    };
    StateBlock.prototype.isEmpty = function isEmpty(line) {
      return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
    };
    StateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {
      for (var max = this.lineMax; from < max; from++) {
        if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
          break;
        }
      }
      return from;
    };
    StateBlock.prototype.skipSpaces = function skipSpaces(pos) {
      var ch;
      for (var max = this.src.length; pos < max; pos++) {
        ch = this.src.charCodeAt(pos);
        if (!isSpace(ch)) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (!isSpace(this.src.charCodeAt(--pos))) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipChars = function skipChars(pos, code) {
      for (var max = this.src.length; pos < max; pos++) {
        if (this.src.charCodeAt(pos) !== code) {
          break;
        }
      }
      return pos;
    };
    StateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {
      if (pos <= min) {
        return pos;
      }
      while (pos > min) {
        if (code !== this.src.charCodeAt(--pos)) {
          return pos + 1;
        }
      }
      return pos;
    };
    StateBlock.prototype.getLines = function getLines(begin, end, indent2, keepLastLF) {
      var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
      if (begin >= end) {
        return "";
      }
      queue = new Array(end - begin);
      for (i = 0; line < end; line++, i++) {
        lineIndent = 0;
        lineStart = first = this.bMarks[line];
        if (line + 1 < end || keepLastLF) {
          last = this.eMarks[line] + 1;
        } else {
          last = this.eMarks[line];
        }
        while (first < last && lineIndent < indent2) {
          ch = this.src.charCodeAt(first);
          if (isSpace(ch)) {
            if (ch === 9) {
              lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
            } else {
              lineIndent++;
            }
          } else if (first - lineStart < this.tShift[line]) {
            lineIndent++;
          } else {
            break;
          }
          first++;
        }
        if (lineIndent > indent2) {
          queue[i] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last);
        } else {
          queue[i] = this.src.slice(first, last);
        }
      }
      return queue.join("");
    };
    StateBlock.prototype.Token = Token2;
    module.exports = StateBlock;
  }
});

// node_modules/markdown-it/lib/parser_block.js
var require_parser_block = __commonJS({
  "node_modules/markdown-it/lib/parser_block.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["table", require_table(), ["paragraph", "reference"]],
      ["code", require_code()],
      ["fence", require_fence(), ["paragraph", "reference", "blockquote", "list"]],
      ["blockquote", require_blockquote(), ["paragraph", "reference", "blockquote", "list"]],
      ["hr", require_hr(), ["paragraph", "reference", "blockquote", "list"]],
      ["list", require_list(), ["paragraph", "reference", "blockquote"]],
      ["reference", require_reference()],
      ["heading", require_heading(), ["paragraph", "reference", "blockquote"]],
      ["lheading", require_lheading()],
      ["html_block", require_html_block(), ["paragraph", "reference", "blockquote"]],
      ["paragraph", require_paragraph()]
    ];
    function ParserBlock() {
      this.ruler = new Ruler();
      for (var i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });
      }
    }
    ParserBlock.prototype.tokenize = function(state, startLine, endLine) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state.md.options.maxNesting;
      while (line < endLine) {
        state.line = line = state.skipEmptyLines(line);
        if (line >= endLine) {
          break;
        }
        if (state.sCount[line] < state.blkIndent) {
          break;
        }
        if (state.level >= maxNesting) {
          state.line = endLine;
          break;
        }
        for (i = 0; i < len; i++) {
          ok = rules[i](state, line, endLine, false);
          if (ok) {
            break;
          }
        }
        state.tight = !hasEmptyLines;
        if (state.isEmpty(state.line - 1)) {
          hasEmptyLines = true;
        }
        line = state.line;
        if (line < endLine && state.isEmpty(line)) {
          hasEmptyLines = true;
          line++;
          state.line = line;
        }
      }
    };
    ParserBlock.prototype.parse = function(src, md4, env, outTokens) {
      var state;
      if (!src) {
        return;
      }
      state = new this.State(src, md4, env, outTokens);
      this.tokenize(state, state.line, state.lineMax);
    };
    ParserBlock.prototype.State = require_state_block();
    module.exports = ParserBlock;
  }
});

// node_modules/markdown-it/lib/rules_inline/text.js
var require_text = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function isTerminatorChar(ch) {
      switch (ch) {
        case 10:
        case 33:
        case 35:
        case 36:
        case 37:
        case 38:
        case 42:
        case 43:
        case 45:
        case 58:
        case 60:
        case 61:
        case 62:
        case 64:
        case 91:
        case 92:
        case 93:
        case 94:
        case 95:
        case 96:
        case 123:
        case 125:
        case 126:
          return true;
        default:
          return false;
      }
    }
    module.exports = function text2(state, silent) {
      var pos = state.pos;
      while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {
        pos++;
      }
      if (pos === state.pos) {
        return false;
      }
      if (!silent) {
        state.pending += state.src.slice(state.pos, pos);
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/newline.js
var require_newline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/newline.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    module.exports = function newline(state, silent) {
      var pmax, max, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 10) {
        return false;
      }
      pmax = state.pending.length - 1;
      max = state.posMax;
      if (!silent) {
        if (pmax >= 0 && state.pending.charCodeAt(pmax) === 32) {
          if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 32) {
            state.pending = state.pending.replace(/ +$/, "");
            state.push("hardbreak", "br", 0);
          } else {
            state.pending = state.pending.slice(0, -1);
            state.push("softbreak", "br", 0);
          }
        } else {
          state.push("softbreak", "br", 0);
        }
      }
      pos++;
      while (pos < max && isSpace(state.src.charCodeAt(pos))) {
        pos++;
      }
      state.pos = pos;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/escape.js
var require_escape = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/escape.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var isSpace = require_utils().isSpace;
    var ESCAPED = [];
    for (i = 0; i < 256; i++) {
      ESCAPED.push(0);
    }
    var i;
    "\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
      ESCAPED[ch.charCodeAt(0)] = 1;
    });
    module.exports = function escape(state, silent) {
      var ch, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 92) {
        return false;
      }
      pos++;
      if (pos < max) {
        ch = state.src.charCodeAt(pos);
        if (ch < 256 && ESCAPED[ch] !== 0) {
          if (!silent) {
            state.pending += state.src[pos];
          }
          state.pos += 2;
          return true;
        }
        if (ch === 10) {
          if (!silent) {
            state.push("hardbreak", "br", 0);
          }
          pos++;
          while (pos < max) {
            ch = state.src.charCodeAt(pos);
            if (!isSpace(ch)) {
              break;
            }
            pos++;
          }
          state.pos = pos;
          return true;
        }
      }
      if (!silent) {
        state.pending += "\\";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/backticks.js
var require_backticks = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/backticks.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function backtick(state, silent) {
      var start, max, marker, matchStart, matchEnd, token, pos = state.pos, ch = state.src.charCodeAt(pos);
      if (ch !== 96) {
        return false;
      }
      start = pos;
      pos++;
      max = state.posMax;
      while (pos < max && state.src.charCodeAt(pos) === 96) {
        pos++;
      }
      marker = state.src.slice(start, pos);
      matchStart = matchEnd = pos;
      while ((matchStart = state.src.indexOf("`", matchEnd)) !== -1) {
        matchEnd = matchStart + 1;
        while (matchEnd < max && state.src.charCodeAt(matchEnd) === 96) {
          matchEnd++;
        }
        if (matchEnd - matchStart === marker.length) {
          if (!silent) {
            token = state.push("code_inline", "code", 0);
            token.markup = marker;
            token.content = state.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
          }
          state.pos = matchEnd;
          return true;
        }
      }
      if (!silent) {
        state.pending += marker;
      }
      state.pos += marker.length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/strikethrough.js
var require_strikethrough = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/strikethrough.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports.tokenize = function strikethrough(state, silent) {
      var i, scanned, token, len, ch, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 126) {
        return false;
      }
      scanned = state.scanDelims(state.pos, true);
      len = scanned.length;
      ch = String.fromCharCode(marker);
      if (len < 2) {
        return false;
      }
      if (len % 2) {
        token = state.push("text", "", 0);
        token.content = ch;
        len--;
      }
      for (i = 0; i < len; i += 2) {
        token = state.push("text", "", 0);
        token.content = ch + ch;
        state.delimiters.push({
          marker,
          length: 0,
          jump: i,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, j, startDelim, endDelim, token, loneMarkers = [], max = delimiters.length;
      for (i = 0; i < max; i++) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 126) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        token = state.tokens[startDelim.token];
        token.type = "s_open";
        token.tag = "s";
        token.nesting = 1;
        token.markup = "~~";
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = "s_close";
        token.tag = "s";
        token.nesting = -1;
        token.markup = "~~";
        token.content = "";
        if (state.tokens[endDelim.token - 1].type === "text" && state.tokens[endDelim.token - 1].content === "~") {
          loneMarkers.push(endDelim.token - 1);
        }
      }
      while (loneMarkers.length) {
        i = loneMarkers.pop();
        j = i + 1;
        while (j < state.tokens.length && state.tokens[j].type === "s_close") {
          j++;
        }
        j--;
        if (i !== j) {
          token = state.tokens[j];
          state.tokens[j] = state.tokens[i];
          state.tokens[i] = token;
        }
      }
    }
    module.exports.postProcess = function strikethrough(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/emphasis.js
var require_emphasis = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/emphasis.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports.tokenize = function emphasis(state, silent) {
      var i, scanned, token, start = state.pos, marker = state.src.charCodeAt(start);
      if (silent) {
        return false;
      }
      if (marker !== 95 && marker !== 42) {
        return false;
      }
      scanned = state.scanDelims(state.pos, marker === 42);
      for (i = 0; i < scanned.length; i++) {
        token = state.push("text", "", 0);
        token.content = String.fromCharCode(marker);
        state.delimiters.push({
          marker,
          length: scanned.length,
          jump: i,
          token: state.tokens.length - 1,
          end: -1,
          open: scanned.can_open,
          close: scanned.can_close
        });
      }
      state.pos += scanned.length;
      return true;
    };
    function postProcess(state, delimiters) {
      var i, startDelim, endDelim, token, ch, isStrong, max = delimiters.length;
      for (i = max - 1; i >= 0; i--) {
        startDelim = delimiters[i];
        if (startDelim.marker !== 95 && startDelim.marker !== 42) {
          continue;
        }
        if (startDelim.end === -1) {
          continue;
        }
        endDelim = delimiters[startDelim.end];
        isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;
        ch = String.fromCharCode(startDelim.marker);
        token = state.tokens[startDelim.token];
        token.type = isStrong ? "strong_open" : "em_open";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = 1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        token = state.tokens[endDelim.token];
        token.type = isStrong ? "strong_close" : "em_close";
        token.tag = isStrong ? "strong" : "em";
        token.nesting = -1;
        token.markup = isStrong ? ch + ch : ch;
        token.content = "";
        if (isStrong) {
          state.tokens[delimiters[i - 1].token].content = "";
          state.tokens[delimiters[startDelim.end + 1].token].content = "";
          i--;
        }
      }
    }
    module.exports.postProcess = function emphasis(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      postProcess(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          postProcess(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/link.js
var require_link = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/link.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function link(state, silent) {
      var attrs, code, label, labelEnd, labelStart, pos, res, ref, title, token, href = "", oldPos = state.pos, max = state.posMax, start = state.pos, parseReference = true;
      if (state.src.charCodeAt(state.pos) !== 91) {
        return false;
      }
      labelStart = state.pos + 1;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        parseReference = false;
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          parseReference = true;
        }
        pos++;
      }
      if (parseReference) {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        state.pos = labelStart;
        state.posMax = labelEnd;
        token = state.push("link_open", "a", 1);
        token.attrs = attrs = [["href", href]];
        if (title) {
          attrs.push(["title", title]);
        }
        state.md.inline.tokenize(state);
        token = state.push("link_close", "a", -1);
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/image.js
var require_image = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/image.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var normalizeReference = require_utils().normalizeReference;
    var isSpace = require_utils().isSpace;
    module.exports = function image(state, silent) {
      var attrs, code, content, label, labelEnd, labelStart, pos, ref, res, title, token, tokens, start, href = "", oldPos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(state.pos) !== 33) {
        return false;
      }
      if (state.src.charCodeAt(state.pos + 1) !== 91) {
        return false;
      }
      labelStart = state.pos + 2;
      labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);
      if (labelEnd < 0) {
        return false;
      }
      pos = labelEnd + 1;
      if (pos < max && state.src.charCodeAt(pos) === 40) {
        pos++;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        if (pos >= max) {
          return false;
        }
        start = pos;
        res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);
        if (res.ok) {
          href = state.md.normalizeLink(res.str);
          if (state.md.validateLink(href)) {
            pos = res.pos;
          } else {
            href = "";
          }
        }
        start = pos;
        for (; pos < max; pos++) {
          code = state.src.charCodeAt(pos);
          if (!isSpace(code) && code !== 10) {
            break;
          }
        }
        res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);
        if (pos < max && start !== pos && res.ok) {
          title = res.str;
          pos = res.pos;
          for (; pos < max; pos++) {
            code = state.src.charCodeAt(pos);
            if (!isSpace(code) && code !== 10) {
              break;
            }
          }
        } else {
          title = "";
        }
        if (pos >= max || state.src.charCodeAt(pos) !== 41) {
          state.pos = oldPos;
          return false;
        }
        pos++;
      } else {
        if (typeof state.env.references === "undefined") {
          return false;
        }
        if (pos < max && state.src.charCodeAt(pos) === 91) {
          start = pos + 1;
          pos = state.md.helpers.parseLinkLabel(state, pos);
          if (pos >= 0) {
            label = state.src.slice(start, pos++);
          } else {
            pos = labelEnd + 1;
          }
        } else {
          pos = labelEnd + 1;
        }
        if (!label) {
          label = state.src.slice(labelStart, labelEnd);
        }
        ref = state.env.references[normalizeReference(label)];
        if (!ref) {
          state.pos = oldPos;
          return false;
        }
        href = ref.href;
        title = ref.title;
      }
      if (!silent) {
        content = state.src.slice(labelStart, labelEnd);
        state.md.inline.parse(content, state.md, state.env, tokens = []);
        token = state.push("image", "img", 0);
        token.attrs = attrs = [["src", href], ["alt", ""]];
        token.children = tokens;
        token.content = content;
        if (title) {
          attrs.push(["title", title]);
        }
      }
      state.pos = pos;
      state.posMax = max;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/autolink.js
var require_autolink = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/autolink.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;
    var AUTOLINK_RE = /^<([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)>/;
    module.exports = function autolink(state, silent) {
      var tail, linkMatch, emailMatch, url, fullUrl, token, pos = state.pos;
      if (state.src.charCodeAt(pos) !== 60) {
        return false;
      }
      tail = state.src.slice(pos);
      if (tail.indexOf(">") < 0) {
        return false;
      }
      if (AUTOLINK_RE.test(tail)) {
        linkMatch = tail.match(AUTOLINK_RE);
        url = linkMatch[0].slice(1, -1);
        fullUrl = state.md.normalizeLink(url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += linkMatch[0].length;
        return true;
      }
      if (EMAIL_RE.test(tail)) {
        emailMatch = tail.match(EMAIL_RE);
        url = emailMatch[0].slice(1, -1);
        fullUrl = state.md.normalizeLink("mailto:" + url);
        if (!state.md.validateLink(fullUrl)) {
          return false;
        }
        if (!silent) {
          token = state.push("link_open", "a", 1);
          token.attrs = [["href", fullUrl]];
          token.markup = "autolink";
          token.info = "auto";
          token = state.push("text", "", 0);
          token.content = state.md.normalizeLinkText(url);
          token = state.push("link_close", "a", -1);
          token.markup = "autolink";
          token.info = "auto";
        }
        state.pos += emailMatch[0].length;
        return true;
      }
      return false;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/html_inline.js
var require_html_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/html_inline.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var HTML_TAG_RE = require_html_re().HTML_TAG_RE;
    function isLetter(ch) {
      var lc = ch | 32;
      return lc >= 97 && lc <= 122;
    }
    module.exports = function html_inline(state, silent) {
      var ch, match, max, token, pos = state.pos;
      if (!state.md.options.html) {
        return false;
      }
      max = state.posMax;
      if (state.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
        return false;
      }
      ch = state.src.charCodeAt(pos + 1);
      if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
        return false;
      }
      match = state.src.slice(pos).match(HTML_TAG_RE);
      if (!match) {
        return false;
      }
      if (!silent) {
        token = state.push("html_inline", "", 0);
        token.content = state.src.slice(pos, pos + match[0].length);
      }
      state.pos += match[0].length;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/entity.js
var require_entity = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/entity.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var entities = require_entities2();
    var has = require_utils().has;
    var isValidEntityCode = require_utils().isValidEntityCode;
    var fromCodePoint = require_utils().fromCodePoint;
    var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
    var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
    module.exports = function entity(state, silent) {
      var ch, code, match, pos = state.pos, max = state.posMax;
      if (state.src.charCodeAt(pos) !== 38) {
        return false;
      }
      if (pos + 1 < max) {
        ch = state.src.charCodeAt(pos + 1);
        if (ch === 35) {
          match = state.src.slice(pos).match(DIGITAL_RE);
          if (match) {
            if (!silent) {
              code = match[1][0].toLowerCase() === "x" ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);
              state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(65533);
            }
            state.pos += match[0].length;
            return true;
          }
        } else {
          match = state.src.slice(pos).match(NAMED_RE);
          if (match) {
            if (has(entities, match[1])) {
              if (!silent) {
                state.pending += entities[match[1]];
              }
              state.pos += match[0].length;
              return true;
            }
          }
        }
      }
      if (!silent) {
        state.pending += "&";
      }
      state.pos++;
      return true;
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/balance_pairs.js
var require_balance_pairs = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/balance_pairs.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function processDelimiters(state, delimiters) {
      var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
      for (closerIdx = 0; closerIdx < max; closerIdx++) {
        closer = delimiters[closerIdx];
        closer.length = closer.length || 0;
        if (!closer.close)
          continue;
        if (!openersBottom.hasOwnProperty(closer.marker)) {
          openersBottom[closer.marker] = [-1, -1, -1];
        }
        minOpenerIdx = openersBottom[closer.marker][closer.length % 3];
        newMinOpenerIdx = -1;
        openerIdx = closerIdx - closer.jump - 1;
        for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {
          opener = delimiters[openerIdx];
          if (opener.marker !== closer.marker)
            continue;
          if (newMinOpenerIdx === -1)
            newMinOpenerIdx = openerIdx;
          if (opener.open && opener.end < 0 && opener.level === closer.level) {
            isOddMatch = false;
            if (opener.close || closer.open) {
              if ((opener.length + closer.length) % 3 === 0) {
                if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
                  isOddMatch = true;
                }
              }
            }
            if (!isOddMatch) {
              lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? delimiters[openerIdx - 1].jump + 1 : 0;
              closer.jump = closerIdx - openerIdx + lastJump;
              closer.open = false;
              opener.end = closerIdx;
              opener.jump = lastJump;
              opener.close = false;
              newMinOpenerIdx = -1;
              break;
            }
          }
        }
        if (newMinOpenerIdx !== -1) {
          openersBottom[closer.marker][(closer.length || 0) % 3] = newMinOpenerIdx;
        }
      }
    }
    module.exports = function link_pairs(state) {
      var curr, tokens_meta = state.tokens_meta, max = state.tokens_meta.length;
      processDelimiters(state, state.delimiters);
      for (curr = 0; curr < max; curr++) {
        if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
          processDelimiters(state, tokens_meta[curr].delimiters);
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/text_collapse.js
var require_text_collapse = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/text_collapse.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function text_collapse(state) {
      var curr, last, level = 0, tokens = state.tokens, max = state.tokens.length;
      for (curr = last = 0; curr < max; curr++) {
        if (tokens[curr].nesting < 0)
          level--;
        tokens[curr].level = level;
        if (tokens[curr].nesting > 0)
          level++;
        if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
          tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
        } else {
          if (curr !== last) {
            tokens[last] = tokens[curr];
          }
          last++;
        }
      }
      if (curr !== last) {
        tokens.length = last;
      }
    };
  }
});

// node_modules/markdown-it/lib/rules_inline/state_inline.js
var require_state_inline = __commonJS({
  "node_modules/markdown-it/lib/rules_inline/state_inline.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Token2 = require_token();
    var isWhiteSpace = require_utils().isWhiteSpace;
    var isPunctChar = require_utils().isPunctChar;
    var isMdAsciiPunct = require_utils().isMdAsciiPunct;
    function StateInline(src, md4, env, outTokens) {
      this.src = src;
      this.env = env;
      this.md = md4;
      this.tokens = outTokens;
      this.tokens_meta = Array(outTokens.length);
      this.pos = 0;
      this.posMax = this.src.length;
      this.level = 0;
      this.pending = "";
      this.pendingLevel = 0;
      this.cache = {};
      this.delimiters = [];
      this._prev_delimiters = [];
    }
    StateInline.prototype.pushPending = function() {
      var token = new Token2("text", "", 0);
      token.content = this.pending;
      token.level = this.pendingLevel;
      this.tokens.push(token);
      this.pending = "";
      return token;
    };
    StateInline.prototype.push = function(type2, tag, nesting) {
      if (this.pending) {
        this.pushPending();
      }
      var token = new Token2(type2, tag, nesting);
      var token_meta = null;
      if (nesting < 0) {
        this.level--;
        this.delimiters = this._prev_delimiters.pop();
      }
      token.level = this.level;
      if (nesting > 0) {
        this.level++;
        this._prev_delimiters.push(this.delimiters);
        this.delimiters = [];
        token_meta = { delimiters: this.delimiters };
      }
      this.pendingLevel = this.level;
      this.tokens.push(token);
      this.tokens_meta.push(token_meta);
      return token;
    };
    StateInline.prototype.scanDelims = function(start, canSplitWord) {
      var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker = this.src.charCodeAt(start);
      lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
      while (pos < max && this.src.charCodeAt(pos) === marker) {
        pos++;
      }
      count = pos - start;
      nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
      isLastWhiteSpace = isWhiteSpace(lastChar);
      isNextWhiteSpace = isWhiteSpace(nextChar);
      if (isNextWhiteSpace) {
        left_flanking = false;
      } else if (isNextPunctChar) {
        if (!(isLastWhiteSpace || isLastPunctChar)) {
          left_flanking = false;
        }
      }
      if (isLastWhiteSpace) {
        right_flanking = false;
      } else if (isLastPunctChar) {
        if (!(isNextWhiteSpace || isNextPunctChar)) {
          right_flanking = false;
        }
      }
      if (!canSplitWord) {
        can_open = left_flanking && (!right_flanking || isLastPunctChar);
        can_close = right_flanking && (!left_flanking || isNextPunctChar);
      } else {
        can_open = left_flanking;
        can_close = right_flanking;
      }
      return {
        can_open,
        can_close,
        length: count
      };
    };
    StateInline.prototype.Token = Token2;
    module.exports = StateInline;
  }
});

// node_modules/markdown-it/lib/parser_inline.js
var require_parser_inline = __commonJS({
  "node_modules/markdown-it/lib/parser_inline.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Ruler = require_ruler();
    var _rules = [
      ["text", require_text()],
      ["newline", require_newline()],
      ["escape", require_escape()],
      ["backticks", require_backticks()],
      ["strikethrough", require_strikethrough().tokenize],
      ["emphasis", require_emphasis().tokenize],
      ["link", require_link()],
      ["image", require_image()],
      ["autolink", require_autolink()],
      ["html_inline", require_html_inline()],
      ["entity", require_entity()]
    ];
    var _rules2 = [
      ["balance_pairs", require_balance_pairs()],
      ["strikethrough", require_strikethrough().postProcess],
      ["emphasis", require_emphasis().postProcess],
      ["text_collapse", require_text_collapse()]
    ];
    function ParserInline() {
      var i;
      this.ruler = new Ruler();
      for (i = 0; i < _rules.length; i++) {
        this.ruler.push(_rules[i][0], _rules[i][1]);
      }
      this.ruler2 = new Ruler();
      for (i = 0; i < _rules2.length; i++) {
        this.ruler2.push(_rules2[i][0], _rules2[i][1]);
      }
    }
    ParserInline.prototype.skipToken = function(state) {
      var ok, i, pos = state.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state.md.options.maxNesting, cache = state.cache;
      if (typeof cache[pos] !== "undefined") {
        state.pos = cache[pos];
        return;
      }
      if (state.level < maxNesting) {
        for (i = 0; i < len; i++) {
          state.level++;
          ok = rules[i](state, true);
          state.level--;
          if (ok) {
            break;
          }
        }
      } else {
        state.pos = state.posMax;
      }
      if (!ok) {
        state.pos++;
      }
      cache[pos] = state.pos;
    };
    ParserInline.prototype.tokenize = function(state) {
      var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state.posMax, maxNesting = state.md.options.maxNesting;
      while (state.pos < end) {
        if (state.level < maxNesting) {
          for (i = 0; i < len; i++) {
            ok = rules[i](state, false);
            if (ok) {
              break;
            }
          }
        }
        if (ok) {
          if (state.pos >= end) {
            break;
          }
          continue;
        }
        state.pending += state.src[state.pos++];
      }
      if (state.pending) {
        state.pushPending();
      }
    };
    ParserInline.prototype.parse = function(str, md4, env, outTokens) {
      var i, rules, len;
      var state = new this.State(str, md4, env, outTokens);
      this.tokenize(state);
      rules = this.ruler2.getRules("");
      len = rules.length;
      for (i = 0; i < len; i++) {
        rules[i](state);
      }
    };
    ParserInline.prototype.State = require_state_inline();
    module.exports = ParserInline;
  }
});

// node_modules/linkify-it/lib/re.js
var require_re = __commonJS({
  "node_modules/linkify-it/lib/re.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = function(opts) {
      var re = {};
      re.src_Any = require_regex2().source;
      re.src_Cc = require_regex3().source;
      re.src_Z = require_regex5().source;
      re.src_P = require_regex().source;
      re.src_ZPCc = [re.src_Z, re.src_P, re.src_Cc].join("|");
      re.src_ZCc = [re.src_Z, re.src_Cc].join("|");
      var text_separators = "[><\uFF5C]";
      re.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re.src_ZPCc + ")" + re.src_Any + ")";
      re.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
      re.src_auth = "(?:(?:(?!" + re.src_ZCc + "|[@/\\[\\]()]).)+@)?";
      re.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
      re.src_host_terminator = "(?=$|" + text_separators + "|" + re.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re.src_ZPCc + "))";
      re.src_path = "(?:[/?#](?:(?!" + re.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-]).|\\[(?:(?!` + re.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re.src_ZCc + "|[']).)+\\'|\\'(?=" + re.src_pseudo_letter + "|[-]).|\\.{2,4}[a-zA-Z0-9%/]|\\.(?!" + re.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + re.src_ZCc + ").|\\!(?!" + re.src_ZCc + "|[!]).|\\?(?!" + re.src_ZCc + "|[?]).)+|\\/)?";
      re.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
      re.src_xn = "xn--[a-z0-9\\-]{1,59}";
      re.src_domain_root = "(?:" + re.src_xn + "|" + re.src_pseudo_letter + "{1,63})";
      re.src_domain = "(?:" + re.src_xn + "|(?:" + re.src_pseudo_letter + ")|(?:" + re.src_pseudo_letter + "(?:-|" + re.src_pseudo_letter + "){0,61}" + re.src_pseudo_letter + "))";
      re.src_host = "(?:(?:(?:(?:" + re.src_domain + ")\\.)*" + re.src_domain + "))";
      re.tpl_host_fuzzy = "(?:" + re.src_ip4 + "|(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%)))";
      re.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re.src_domain + ")\\.)+(?:%TLDS%))";
      re.src_host_strict = re.src_host + re.src_host_terminator;
      re.tpl_host_fuzzy_strict = re.tpl_host_fuzzy + re.src_host_terminator;
      re.src_host_port_strict = re.src_host + re.src_port + re.src_host_terminator;
      re.tpl_host_port_fuzzy_strict = re.tpl_host_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_port_no_ip_fuzzy_strict = re.tpl_host_no_ip_fuzzy + re.src_port + re.src_host_terminator;
      re.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re.src_ZPCc + "|>|$))";
      re.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re.src_ZCc + ")(" + re.src_email_name + "@" + re.tpl_host_fuzzy_strict + ")";
      re.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_fuzzy_strict + re.src_path + ")";
      re.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re.tpl_host_port_no_ip_fuzzy_strict + re.src_path + ")";
      return re;
    };
  }
});

// node_modules/linkify-it/index.js
var require_linkify_it = __commonJS({
  "node_modules/linkify-it/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function assign2(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      sources.forEach(function(source) {
        if (!source) {
          return;
        }
        Object.keys(source).forEach(function(key) {
          obj[key] = source[key];
        });
      });
      return obj;
    }
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function isString(obj) {
      return _class(obj) === "[object String]";
    }
    function isObject(obj) {
      return _class(obj) === "[object Object]";
    }
    function isRegExp(obj) {
      return _class(obj) === "[object RegExp]";
    }
    function isFunction(obj) {
      return _class(obj) === "[object Function]";
    }
    function escapeRE(str) {
      return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
    }
    var defaultOptions = {
      fuzzyLink: true,
      fuzzyEmail: true,
      fuzzyIP: false
    };
    function isOptionsObj(obj) {
      return Object.keys(obj || {}).reduce(function(acc, k) {
        return acc || defaultOptions.hasOwnProperty(k);
      }, false);
    }
    var defaultSchemas = {
      "http:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.http) {
            self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
          }
          if (self2.re.http.test(tail)) {
            return tail.match(self2.re.http)[0].length;
          }
          return 0;
        }
      },
      "https:": "http:",
      "ftp:": "http:",
      "//": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.no_http) {
            self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
          }
          if (self2.re.no_http.test(tail)) {
            if (pos >= 3 && text2[pos - 3] === ":") {
              return 0;
            }
            if (pos >= 3 && text2[pos - 3] === "/") {
              return 0;
            }
            return tail.match(self2.re.no_http)[0].length;
          }
          return 0;
        }
      },
      "mailto:": {
        validate: function(text2, pos, self2) {
          var tail = text2.slice(pos);
          if (!self2.re.mailto) {
            self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
          }
          if (self2.re.mailto.test(tail)) {
            return tail.match(self2.re.mailto)[0].length;
          }
          return 0;
        }
      }
    };
    var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
    var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
    function resetScanCache(self2) {
      self2.__index__ = -1;
      self2.__text_cache__ = "";
    }
    function createValidator(re) {
      return function(text2, pos) {
        var tail = text2.slice(pos);
        if (re.test(tail)) {
          return tail.match(re)[0].length;
        }
        return 0;
      };
    }
    function createNormalizer() {
      return function(match, self2) {
        self2.normalize(match);
      };
    }
    function compile(self2) {
      var re = self2.re = require_re()(self2.__opts__);
      var tlds = self2.__tlds__.slice();
      self2.onCompile();
      if (!self2.__tlds_replaced__) {
        tlds.push(tlds_2ch_src_re);
      }
      tlds.push(re.src_xn);
      re.src_tlds = tlds.join("|");
      function untpl(tpl) {
        return tpl.replace("%TLDS%", re.src_tlds);
      }
      re.email_fuzzy = RegExp(untpl(re.tpl_email_fuzzy), "i");
      re.link_fuzzy = RegExp(untpl(re.tpl_link_fuzzy), "i");
      re.link_no_ip_fuzzy = RegExp(untpl(re.tpl_link_no_ip_fuzzy), "i");
      re.host_fuzzy_test = RegExp(untpl(re.tpl_host_fuzzy_test), "i");
      var aliases = [];
      self2.__compiled__ = {};
      function schemaError(name2, val) {
        throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
      }
      Object.keys(self2.__schemas__).forEach(function(name2) {
        var val = self2.__schemas__[name2];
        if (val === null) {
          return;
        }
        var compiled = { validate: null, link: null };
        self2.__compiled__[name2] = compiled;
        if (isObject(val)) {
          if (isRegExp(val.validate)) {
            compiled.validate = createValidator(val.validate);
          } else if (isFunction(val.validate)) {
            compiled.validate = val.validate;
          } else {
            schemaError(name2, val);
          }
          if (isFunction(val.normalize)) {
            compiled.normalize = val.normalize;
          } else if (!val.normalize) {
            compiled.normalize = createNormalizer();
          } else {
            schemaError(name2, val);
          }
          return;
        }
        if (isString(val)) {
          aliases.push(name2);
          return;
        }
        schemaError(name2, val);
      });
      aliases.forEach(function(alias) {
        if (!self2.__compiled__[self2.__schemas__[alias]]) {
          return;
        }
        self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
        self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
      });
      self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
      var slist = Object.keys(self2.__compiled__).filter(function(name2) {
        return name2.length > 0 && self2.__compiled__[name2];
      }).map(escapeRE).join("|");
      self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "i");
      self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re.src_ZPCc + "))(" + slist + ")", "ig");
      self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
      resetScanCache(self2);
    }
    function Match(self2, shift) {
      var start = self2.__index__, end = self2.__last_index__, text2 = self2.__text_cache__.slice(start, end);
      this.schema = self2.__schema__.toLowerCase();
      this.index = start + shift;
      this.lastIndex = end + shift;
      this.raw = text2;
      this.text = text2;
      this.url = text2;
    }
    function createMatch(self2, shift) {
      var match = new Match(self2, shift);
      self2.__compiled__[match.schema].normalize(match, self2);
      return match;
    }
    function LinkifyIt(schemas, options) {
      if (!(this instanceof LinkifyIt)) {
        return new LinkifyIt(schemas, options);
      }
      if (!options) {
        if (isOptionsObj(schemas)) {
          options = schemas;
          schemas = {};
        }
      }
      this.__opts__ = assign2({}, defaultOptions, options);
      this.__index__ = -1;
      this.__last_index__ = -1;
      this.__schema__ = "";
      this.__text_cache__ = "";
      this.__schemas__ = assign2({}, defaultSchemas, schemas);
      this.__compiled__ = {};
      this.__tlds__ = tlds_default;
      this.__tlds_replaced__ = false;
      this.re = {};
      compile(this);
    }
    LinkifyIt.prototype.add = function add(schema, definition) {
      this.__schemas__[schema] = definition;
      compile(this);
      return this;
    };
    LinkifyIt.prototype.set = function set(options) {
      this.__opts__ = assign2(this.__opts__, options);
      return this;
    };
    LinkifyIt.prototype.test = function test(text2) {
      this.__text_cache__ = text2;
      this.__index__ = -1;
      if (!text2.length) {
        return false;
      }
      var m, ml, me, len, shift, next, re, tld_pos, at_pos;
      if (this.re.schema_test.test(text2)) {
        re = this.re.schema_search;
        re.lastIndex = 0;
        while ((m = re.exec(text2)) !== null) {
          len = this.testSchemaAt(text2, m[2], re.lastIndex);
          if (len) {
            this.__schema__ = m[2];
            this.__index__ = m.index + m[1].length;
            this.__last_index__ = m.index + m[0].length + len;
            break;
          }
        }
      }
      if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
        tld_pos = text2.search(this.re.host_fuzzy_test);
        if (tld_pos >= 0) {
          if (this.__index__ < 0 || tld_pos < this.__index__) {
            if ((ml = text2.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
              shift = ml.index + ml[1].length;
              if (this.__index__ < 0 || shift < this.__index__) {
                this.__schema__ = "";
                this.__index__ = shift;
                this.__last_index__ = ml.index + ml[0].length;
              }
            }
          }
        }
      }
      if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
        at_pos = text2.indexOf("@");
        if (at_pos >= 0) {
          if ((me = text2.match(this.re.email_fuzzy)) !== null) {
            shift = me.index + me[1].length;
            next = me.index + me[0].length;
            if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
              this.__schema__ = "mailto:";
              this.__index__ = shift;
              this.__last_index__ = next;
            }
          }
        }
      }
      return this.__index__ >= 0;
    };
    LinkifyIt.prototype.pretest = function pretest(text2) {
      return this.re.pretest.test(text2);
    };
    LinkifyIt.prototype.testSchemaAt = function testSchemaAt(text2, schema, pos) {
      if (!this.__compiled__[schema.toLowerCase()]) {
        return 0;
      }
      return this.__compiled__[schema.toLowerCase()].validate(text2, pos, this);
    };
    LinkifyIt.prototype.match = function match(text2) {
      var shift = 0, result = [];
      if (this.__index__ >= 0 && this.__text_cache__ === text2) {
        result.push(createMatch(this, shift));
        shift = this.__last_index__;
      }
      var tail = shift ? text2.slice(shift) : text2;
      while (this.test(tail)) {
        result.push(createMatch(this, shift));
        tail = tail.slice(this.__last_index__);
        shift += this.__last_index__;
      }
      if (result.length) {
        return result;
      }
      return null;
    };
    LinkifyIt.prototype.tlds = function tlds(list2, keepOld) {
      list2 = Array.isArray(list2) ? list2 : [list2];
      if (!keepOld) {
        this.__tlds__ = list2.slice();
        this.__tlds_replaced__ = true;
        compile(this);
        return this;
      }
      this.__tlds__ = this.__tlds__.concat(list2).sort().filter(function(el, idx, arr) {
        return el !== arr[idx - 1];
      }).reverse();
      compile(this);
      return this;
    };
    LinkifyIt.prototype.normalize = function normalize(match) {
      if (!match.schema) {
        match.url = "http://" + match.url;
      }
      if (match.schema === "mailto:" && !/^mailto:/i.test(match.url)) {
        match.url = "mailto:" + match.url;
      }
    };
    LinkifyIt.prototype.onCompile = function onCompile() {
    };
    module.exports = LinkifyIt;
  }
});

// node_modules/punycode/punycode.es6.js
var punycode_es6_exports = {};
__export(punycode_es6_exports, {
  decode: () => decode,
  default: () => punycode_es6_default,
  encode: () => encode,
  toASCII: () => toASCII,
  toUnicode: () => toUnicode,
  ucs2decode: () => ucs2decode,
  ucs2encode: () => ucs2encode
});
function error(type2) {
  throw new RangeError(errors[type2]);
}
function map(array, fn) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result + encoded;
}
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value = string.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
var maxInt, base, tMin, tMax, skew, damp, initialBias, initialN, delimiter, regexPunycode, regexNonASCII, regexSeparators, errors, baseMinusTMin, floor, stringFromCharCode, ucs2encode, basicToDigit, digitToBasic, adapt, decode, encode, toUnicode, toASCII, punycode, punycode_es6_default;
var init_punycode_es6 = __esm({
  "node_modules/punycode/punycode.es6.js"() {
    init_define_process_env();
    "use strict";
    maxInt = 2147483647;
    base = 36;
    tMin = 1;
    tMax = 26;
    skew = 38;
    damp = 700;
    initialBias = 72;
    initialN = 128;
    delimiter = "-";
    regexPunycode = /^xn--/;
    regexNonASCII = /[^\0-\x7E]/;
    regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    errors = {
      "overflow": "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    baseMinusTMin = base - tMin;
    floor = Math.floor;
    stringFromCharCode = String.fromCharCode;
    ucs2encode = (array) => String.fromCodePoint(...array);
    basicToDigit = function(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    digitToBasic = function(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    adapt = function(delta, numPoints, firstTime) {
      let k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    decode = function(input) {
      const output = [];
      const inputLength = input.length;
      let i = 0;
      let n = initialN;
      let bias = initialBias;
      let basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (let j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        let oldi = i;
        for (let w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          const digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t2) {
            break;
          }
          const baseMinusT = base - t2;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        const out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint(...output);
    };
    encode = function(input) {
      const output = [];
      input = ucs2decode(input);
      let inputLength = input.length;
      let n = initialN;
      let delta = 0;
      let bias = initialBias;
      for (const currentValue of input) {
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      let basicLength = output.length;
      let handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        let m = maxInt;
        for (const currentValue of input) {
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        const handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (const currentValue of input) {
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            let q = delta;
            for (let k = base; ; k += base) {
              const t2 = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t2) {
                break;
              }
              const qMinusT = q - t2;
              const baseMinusT = base - t2;
              output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    toUnicode = function(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    toASCII = function(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    punycode = {
      "version": "2.1.0",
      "ucs2": {
        "decode": ucs2decode,
        "encode": ucs2encode
      },
      "decode": decode,
      "encode": encode,
      "toASCII": toASCII,
      "toUnicode": toUnicode
    };
    punycode_es6_default = punycode;
  }
});

// node_modules/markdown-it/lib/presets/default.js
var require_default = __commonJS({
  "node_modules/markdown-it/lib/presets/default.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 100
      },
      components: {
        core: {},
        block: {},
        inline: {}
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/zero.js
var require_zero = __commonJS({
  "node_modules/markdown-it/lib/presets/zero.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = {
      options: {
        html: false,
        xhtmlOut: false,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "text"
          ],
          rules2: [
            "balance_pairs",
            "text_collapse"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/presets/commonmark.js
var require_commonmark = __commonJS({
  "node_modules/markdown-it/lib/presets/commonmark.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = {
      options: {
        html: true,
        xhtmlOut: true,
        breaks: false,
        langPrefix: "language-",
        linkify: false,
        typographer: false,
        quotes: "\u201C\u201D\u2018\u2019",
        highlight: null,
        maxNesting: 20
      },
      components: {
        core: {
          rules: [
            "normalize",
            "block",
            "inline"
          ]
        },
        block: {
          rules: [
            "blockquote",
            "code",
            "fence",
            "heading",
            "hr",
            "html_block",
            "lheading",
            "list",
            "reference",
            "paragraph"
          ]
        },
        inline: {
          rules: [
            "autolink",
            "backticks",
            "emphasis",
            "entity",
            "escape",
            "html_inline",
            "image",
            "link",
            "newline",
            "text"
          ],
          rules2: [
            "balance_pairs",
            "emphasis",
            "text_collapse"
          ]
        }
      }
    };
  }
});

// node_modules/markdown-it/lib/index.js
var require_lib = __commonJS({
  "node_modules/markdown-it/lib/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var utils = require_utils();
    var helpers = require_helpers();
    var Renderer = require_renderer();
    var ParserCore = require_parser_core();
    var ParserBlock = require_parser_block();
    var ParserInline = require_parser_inline();
    var LinkifyIt = require_linkify_it();
    var mdurl = require_mdurl();
    var punycode2 = (init_punycode_es6(), punycode_es6_exports);
    var config = {
      "default": require_default(),
      zero: require_zero(),
      commonmark: require_commonmark()
    };
    var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
    var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
    function validateLink(url) {
      var str = url.trim().toLowerCase();
      return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
    }
    var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
    function normalizeLink(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode2.toASCII(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.encode(mdurl.format(parsed));
    }
    function normalizeLinkText(url) {
      var parsed = mdurl.parse(url, true);
      if (parsed.hostname) {
        if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
          try {
            parsed.hostname = punycode2.toUnicode(parsed.hostname);
          } catch (er) {
          }
        }
      }
      return mdurl.decode(mdurl.format(parsed));
    }
    function MarkdownIt(presetName, options) {
      if (!(this instanceof MarkdownIt)) {
        return new MarkdownIt(presetName, options);
      }
      if (!options) {
        if (!utils.isString(presetName)) {
          options = presetName || {};
          presetName = "default";
        }
      }
      this.inline = new ParserInline();
      this.block = new ParserBlock();
      this.core = new ParserCore();
      this.renderer = new Renderer();
      this.linkify = new LinkifyIt();
      this.validateLink = validateLink;
      this.normalizeLink = normalizeLink;
      this.normalizeLinkText = normalizeLinkText;
      this.utils = utils;
      this.helpers = utils.assign({}, helpers);
      this.options = {};
      this.configure(presetName);
      if (options) {
        this.set(options);
      }
    }
    MarkdownIt.prototype.set = function(options) {
      utils.assign(this.options, options);
      return this;
    };
    MarkdownIt.prototype.configure = function(presets) {
      var self2 = this, presetName;
      if (utils.isString(presets)) {
        presetName = presets;
        presets = config[presetName];
        if (!presets) {
          throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
        }
      }
      if (!presets) {
        throw new Error("Wrong `markdown-it` preset, can't be empty");
      }
      if (presets.options) {
        self2.set(presets.options);
      }
      if (presets.components) {
        Object.keys(presets.components).forEach(function(name2) {
          if (presets.components[name2].rules) {
            self2[name2].ruler.enableOnly(presets.components[name2].rules);
          }
          if (presets.components[name2].rules2) {
            self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
          }
        });
      }
      return this;
    };
    MarkdownIt.prototype.enable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.enable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.enable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.disable = function(list2, ignoreInvalid) {
      var result = [];
      if (!Array.isArray(list2)) {
        list2 = [list2];
      }
      ["core", "block", "inline"].forEach(function(chain) {
        result = result.concat(this[chain].ruler.disable(list2, true));
      }, this);
      result = result.concat(this.inline.ruler2.disable(list2, true));
      var missed = list2.filter(function(name2) {
        return result.indexOf(name2) < 0;
      });
      if (missed.length && !ignoreInvalid) {
        throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
      }
      return this;
    };
    MarkdownIt.prototype.use = function(plugin) {
      var args = [this].concat(Array.prototype.slice.call(arguments, 1));
      plugin.apply(plugin, args);
      return this;
    };
    MarkdownIt.prototype.parse = function(src, env) {
      if (typeof src !== "string") {
        throw new Error("Input data should be a String");
      }
      var state = new this.core.State(src, this, env);
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.render = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parse(src, env), this.options, env);
    };
    MarkdownIt.prototype.parseInline = function(src, env) {
      var state = new this.core.State(src, this, env);
      state.inlineMode = true;
      this.core.process(state);
      return state.tokens;
    };
    MarkdownIt.prototype.renderInline = function(src, env) {
      env = env || {};
      return this.renderer.render(this.parseInline(src, env), this.options, env);
    };
    module.exports = MarkdownIt;
  }
});

// node_modules/markdown-it/index.js
var require_markdown_it = __commonJS({
  "node_modules/markdown-it/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = require_lib();
  }
});

// node_modules/codemirror/lib/codemirror.js
var require_codemirror = __commonJS({
  "node_modules/codemirror/lib/codemirror.js"(exports, module) {
    init_define_process_env();
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.CodeMirror = factory());
    })(exports, function() {
      "use strict";
      var userAgent = navigator.userAgent;
      var platform = navigator.platform;
      var gecko = /gecko\/\d/i.test(userAgent);
      var ie_upto10 = /MSIE \d/.test(userAgent);
      var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
      var edge = /Edge\/(\d+)/.exec(userAgent);
      var ie = ie_upto10 || ie_11up || edge;
      var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
      var webkit = !edge && /WebKit\//.test(userAgent);
      var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
      var chrome = !edge && /Chrome\//.test(userAgent);
      var presto = /Opera\//.test(userAgent);
      var safari = /Apple Computer/.test(navigator.vendor);
      var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
      var phantom = /PhantomJS/.test(userAgent);
      var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
      var android = /Android/.test(userAgent);
      var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
      var mac = ios || /Mac/.test(platform);
      var chromeOS = /\bCrOS\b/.test(userAgent);
      var windows = /win/i.test(platform);
      var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
      if (presto_version) {
        presto_version = Number(presto_version[1]);
      }
      if (presto_version && presto_version >= 15) {
        presto = false;
        webkit = true;
      }
      var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
      var captureRightClick = gecko || ie && ie_version >= 9;
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      var rmClass = function(node, cls) {
        var current = node.className;
        var match = classTest(cls).exec(current);
        if (match) {
          var after = current.slice(match.index + match[0].length);
          node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
        }
      };
      function removeChildren(e) {
        for (var count = e.childNodes.length; count > 0; --count) {
          e.removeChild(e.firstChild);
        }
        return e;
      }
      function removeChildrenAndAdd(parent, e) {
        return removeChildren(parent).appendChild(e);
      }
      function elt(tag, content, className, style) {
        var e = document.createElement(tag);
        if (className) {
          e.className = className;
        }
        if (style) {
          e.style.cssText = style;
        }
        if (typeof content == "string") {
          e.appendChild(document.createTextNode(content));
        } else if (content) {
          for (var i2 = 0; i2 < content.length; ++i2) {
            e.appendChild(content[i2]);
          }
        }
        return e;
      }
      function eltP(tag, content, className, style) {
        var e = elt(tag, content, className, style);
        e.setAttribute("role", "presentation");
        return e;
      }
      var range;
      if (document.createRange) {
        range = function(node, start, end, endNode) {
          var r = document.createRange();
          r.setEnd(endNode || node, end);
          r.setStart(node, start);
          return r;
        };
      } else {
        range = function(node, start, end) {
          var r = document.body.createTextRange();
          try {
            r.moveToElementText(node.parentNode);
          } catch (e) {
            return r;
          }
          r.collapse(true);
          r.moveEnd("character", end);
          r.moveStart("character", start);
          return r;
        };
      }
      function contains(parent, child) {
        if (child.nodeType == 3) {
          child = child.parentNode;
        }
        if (parent.contains) {
          return parent.contains(child);
        }
        do {
          if (child.nodeType == 11) {
            child = child.host;
          }
          if (child == parent) {
            return true;
          }
        } while (child = child.parentNode);
      }
      function activeElt() {
        var activeElement;
        try {
          activeElement = document.activeElement;
        } catch (e) {
          activeElement = document.body || null;
        }
        while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
          activeElement = activeElement.shadowRoot.activeElement;
        }
        return activeElement;
      }
      function addClass(node, cls) {
        var current = node.className;
        if (!classTest(cls).test(current)) {
          node.className += (current ? " " : "") + cls;
        }
      }
      function joinClasses(a, b) {
        var as = a.split(" ");
        for (var i2 = 0; i2 < as.length; i2++) {
          if (as[i2] && !classTest(as[i2]).test(b)) {
            b += " " + as[i2];
          }
        }
        return b;
      }
      var selectInput = function(node) {
        node.select();
      };
      if (ios) {
        selectInput = function(node) {
          node.selectionStart = 0;
          node.selectionEnd = node.value.length;
        };
      } else if (ie) {
        selectInput = function(node) {
          try {
            node.select();
          } catch (_e) {
          }
        };
      }
      function bind(f) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function() {
          return f.apply(null, args);
        };
      }
      function copyObj(obj, target, overwrite) {
        if (!target) {
          target = {};
        }
        for (var prop2 in obj) {
          if (obj.hasOwnProperty(prop2) && (overwrite !== false || !target.hasOwnProperty(prop2))) {
            target[prop2] = obj[prop2];
          }
        }
        return target;
      }
      function countColumn(string, end, tabSize, startIndex, startValue) {
        if (end == null) {
          end = string.search(/[^\s\u00a0]/);
          if (end == -1) {
            end = string.length;
          }
        }
        for (var i2 = startIndex || 0, n = startValue || 0; ; ) {
          var nextTab = string.indexOf("	", i2);
          if (nextTab < 0 || nextTab >= end) {
            return n + (end - i2);
          }
          n += nextTab - i2;
          n += tabSize - n % tabSize;
          i2 = nextTab + 1;
        }
      }
      var Delayed = function() {
        this.id = null;
        this.f = null;
        this.time = 0;
        this.handler = bind(this.onTimeout, this);
      };
      Delayed.prototype.onTimeout = function(self2) {
        self2.id = 0;
        if (self2.time <= +new Date()) {
          self2.f();
        } else {
          setTimeout(self2.handler, self2.time - +new Date());
        }
      };
      Delayed.prototype.set = function(ms, f) {
        this.f = f;
        var time = +new Date() + ms;
        if (!this.id || time < this.time) {
          clearTimeout(this.id);
          this.id = setTimeout(this.handler, ms);
          this.time = time;
        }
      };
      function indexOf(array, elt2) {
        for (var i2 = 0; i2 < array.length; ++i2) {
          if (array[i2] == elt2) {
            return i2;
          }
        }
        return -1;
      }
      var scrollerGap = 50;
      var Pass = { toString: function() {
        return "CodeMirror.Pass";
      } };
      var sel_dontScroll = { scroll: false }, sel_mouse = { origin: "*mouse" }, sel_move = { origin: "+move" };
      function findColumn(string, goal, tabSize) {
        for (var pos = 0, col = 0; ; ) {
          var nextTab = string.indexOf("	", pos);
          if (nextTab == -1) {
            nextTab = string.length;
          }
          var skipped = nextTab - pos;
          if (nextTab == string.length || col + skipped >= goal) {
            return pos + Math.min(skipped, goal - col);
          }
          col += nextTab - pos;
          col += tabSize - col % tabSize;
          pos = nextTab + 1;
          if (col >= goal) {
            return pos;
          }
        }
      }
      var spaceStrs = [""];
      function spaceStr(n) {
        while (spaceStrs.length <= n) {
          spaceStrs.push(lst(spaceStrs) + " ");
        }
        return spaceStrs[n];
      }
      function lst(arr) {
        return arr[arr.length - 1];
      }
      function map2(array, f) {
        var out = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          out[i2] = f(array[i2], i2);
        }
        return out;
      }
      function insertSorted(array, value, score) {
        var pos = 0, priority = score(value);
        while (pos < array.length && score(array[pos]) <= priority) {
          pos++;
        }
        array.splice(pos, 0, value);
      }
      function nothing() {
      }
      function createObj(base2, props) {
        var inst;
        if (Object.create) {
          inst = Object.create(base2);
        } else {
          nothing.prototype = base2;
          inst = new nothing();
        }
        if (props) {
          copyObj(props, inst);
        }
        return inst;
      }
      var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
      function isWordCharBasic(ch) {
        return /\w/.test(ch) || ch > "\x80" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch));
      }
      function isWordChar(ch, helper) {
        if (!helper) {
          return isWordCharBasic(ch);
        }
        if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) {
          return true;
        }
        return helper.test(ch);
      }
      function isEmpty(obj) {
        for (var n in obj) {
          if (obj.hasOwnProperty(n) && obj[n]) {
            return false;
          }
        }
        return true;
      }
      var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
      function isExtendingChar(ch) {
        return ch.charCodeAt(0) >= 768 && extendingChars.test(ch);
      }
      function skipExtendingChars(str, pos, dir) {
        while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) {
          pos += dir;
        }
        return pos;
      }
      function findFirst(pred, from, to) {
        var dir = from > to ? -1 : 1;
        for (; ; ) {
          if (from == to) {
            return from;
          }
          var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
          if (mid == from) {
            return pred(mid) ? from : to;
          }
          if (pred(mid)) {
            to = mid;
          } else {
            from = mid + dir;
          }
        }
      }
      function iterateBidiSections(order, from, to, f) {
        if (!order) {
          return f(from, to, "ltr", 0);
        }
        var found = false;
        for (var i2 = 0; i2 < order.length; ++i2) {
          var part = order[i2];
          if (part.from < to && part.to > from || from == to && part.to == from) {
            f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i2);
            found = true;
          }
        }
        if (!found) {
          f(from, to, "ltr");
        }
      }
      var bidiOther = null;
      function getBidiPartAt(order, ch, sticky) {
        var found;
        bidiOther = null;
        for (var i2 = 0; i2 < order.length; ++i2) {
          var cur = order[i2];
          if (cur.from < ch && cur.to > ch) {
            return i2;
          }
          if (cur.to == ch) {
            if (cur.from != cur.to && sticky == "before") {
              found = i2;
            } else {
              bidiOther = i2;
            }
          }
          if (cur.from == ch) {
            if (cur.from != cur.to && sticky != "before") {
              found = i2;
            } else {
              bidiOther = i2;
            }
          }
        }
        return found != null ? found : bidiOther;
      }
      var bidiOrdering = function() {
        var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
        var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
        function charType(code) {
          if (code <= 247) {
            return lowTypes.charAt(code);
          } else if (1424 <= code && code <= 1524) {
            return "R";
          } else if (1536 <= code && code <= 1785) {
            return arabicTypes.charAt(code - 1536);
          } else if (1774 <= code && code <= 2220) {
            return "r";
          } else if (8192 <= code && code <= 8203) {
            return "w";
          } else if (code == 8204) {
            return "b";
          } else {
            return "L";
          }
        }
        var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
        var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;
        function BidiSpan(level, from, to) {
          this.level = level;
          this.from = from;
          this.to = to;
        }
        return function(str, direction) {
          var outerType = direction == "ltr" ? "L" : "R";
          if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) {
            return false;
          }
          var len = str.length, types = [];
          for (var i2 = 0; i2 < len; ++i2) {
            types.push(charType(str.charCodeAt(i2)));
          }
          for (var i$12 = 0, prev = outerType; i$12 < len; ++i$12) {
            var type2 = types[i$12];
            if (type2 == "m") {
              types[i$12] = prev;
            } else {
              prev = type2;
            }
          }
          for (var i$22 = 0, cur = outerType; i$22 < len; ++i$22) {
            var type$1 = types[i$22];
            if (type$1 == "1" && cur == "r") {
              types[i$22] = "n";
            } else if (isStrong.test(type$1)) {
              cur = type$1;
              if (type$1 == "r") {
                types[i$22] = "R";
              }
            }
          }
          for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
            var type$2 = types[i$3];
            if (type$2 == "+" && prev$1 == "1" && types[i$3 + 1] == "1") {
              types[i$3] = "1";
            } else if (type$2 == "," && prev$1 == types[i$3 + 1] && (prev$1 == "1" || prev$1 == "n")) {
              types[i$3] = prev$1;
            }
            prev$1 = type$2;
          }
          for (var i$4 = 0; i$4 < len; ++i$4) {
            var type$3 = types[i$4];
            if (type$3 == ",") {
              types[i$4] = "N";
            } else if (type$3 == "%") {
              var end = void 0;
              for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {
              }
              var replace = i$4 && types[i$4 - 1] == "!" || end < len && types[end] == "1" ? "1" : "N";
              for (var j = i$4; j < end; ++j) {
                types[j] = replace;
              }
              i$4 = end - 1;
            }
          }
          for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
            var type$4 = types[i$5];
            if (cur$1 == "L" && type$4 == "1") {
              types[i$5] = "L";
            } else if (isStrong.test(type$4)) {
              cur$1 = type$4;
            }
          }
          for (var i$6 = 0; i$6 < len; ++i$6) {
            if (isNeutral.test(types[i$6])) {
              var end$1 = void 0;
              for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {
              }
              var before = (i$6 ? types[i$6 - 1] : outerType) == "L";
              var after = (end$1 < len ? types[end$1] : outerType) == "L";
              var replace$1 = before == after ? before ? "L" : "R" : outerType;
              for (var j$1 = i$6; j$1 < end$1; ++j$1) {
                types[j$1] = replace$1;
              }
              i$6 = end$1 - 1;
            }
          }
          var order = [], m;
          for (var i$7 = 0; i$7 < len; ) {
            if (countsAsLeft.test(types[i$7])) {
              var start = i$7;
              for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {
              }
              order.push(new BidiSpan(0, start, i$7));
            } else {
              var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
              for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {
              }
              for (var j$2 = pos; j$2 < i$7; ) {
                if (countsAsNum.test(types[j$2])) {
                  if (pos < j$2) {
                    order.splice(at, 0, new BidiSpan(1, pos, j$2));
                    at += isRTL;
                  }
                  var nstart = j$2;
                  for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {
                  }
                  order.splice(at, 0, new BidiSpan(2, nstart, j$2));
                  at += isRTL;
                  pos = j$2;
                } else {
                  ++j$2;
                }
              }
              if (pos < i$7) {
                order.splice(at, 0, new BidiSpan(1, pos, i$7));
              }
            }
          }
          if (direction == "ltr") {
            if (order[0].level == 1 && (m = str.match(/^\s+/))) {
              order[0].from = m[0].length;
              order.unshift(new BidiSpan(0, 0, m[0].length));
            }
            if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
              lst(order).to -= m[0].length;
              order.push(new BidiSpan(0, len - m[0].length, len));
            }
          }
          return direction == "rtl" ? order.reverse() : order;
        };
      }();
      function getOrder(line, direction) {
        var order = line.order;
        if (order == null) {
          order = line.order = bidiOrdering(line.text, direction);
        }
        return order;
      }
      var noHandlers = [];
      var on = function(emitter, type2, f) {
        if (emitter.addEventListener) {
          emitter.addEventListener(type2, f, false);
        } else if (emitter.attachEvent) {
          emitter.attachEvent("on" + type2, f);
        } else {
          var map3 = emitter._handlers || (emitter._handlers = {});
          map3[type2] = (map3[type2] || noHandlers).concat(f);
        }
      };
      function getHandlers(emitter, type2) {
        return emitter._handlers && emitter._handlers[type2] || noHandlers;
      }
      function off(emitter, type2, f) {
        if (emitter.removeEventListener) {
          emitter.removeEventListener(type2, f, false);
        } else if (emitter.detachEvent) {
          emitter.detachEvent("on" + type2, f);
        } else {
          var map3 = emitter._handlers, arr = map3 && map3[type2];
          if (arr) {
            var index = indexOf(arr, f);
            if (index > -1) {
              map3[type2] = arr.slice(0, index).concat(arr.slice(index + 1));
            }
          }
        }
      }
      function signal(emitter, type2) {
        var handlers = getHandlers(emitter, type2);
        if (!handlers.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2);
        for (var i2 = 0; i2 < handlers.length; ++i2) {
          handlers[i2].apply(null, args);
        }
      }
      function signalDOMEvent(cm, e, override) {
        if (typeof e == "string") {
          e = { type: e, preventDefault: function() {
            this.defaultPrevented = true;
          } };
        }
        signal(cm, override || e.type, cm, e);
        return e_defaultPrevented(e) || e.codemirrorIgnore;
      }
      function signalCursorActivity(cm) {
        var arr = cm._handlers && cm._handlers.cursorActivity;
        if (!arr) {
          return;
        }
        var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
        for (var i2 = 0; i2 < arr.length; ++i2) {
          if (indexOf(set, arr[i2]) == -1) {
            set.push(arr[i2]);
          }
        }
      }
      function hasHandler(emitter, type2) {
        return getHandlers(emitter, type2).length > 0;
      }
      function eventMixin(ctor) {
        ctor.prototype.on = function(type2, f) {
          on(this, type2, f);
        };
        ctor.prototype.off = function(type2, f) {
          off(this, type2, f);
        };
      }
      function e_preventDefault(e) {
        if (e.preventDefault) {
          e.preventDefault();
        } else {
          e.returnValue = false;
        }
      }
      function e_stopPropagation(e) {
        if (e.stopPropagation) {
          e.stopPropagation();
        } else {
          e.cancelBubble = true;
        }
      }
      function e_defaultPrevented(e) {
        return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false;
      }
      function e_stop(e) {
        e_preventDefault(e);
        e_stopPropagation(e);
      }
      function e_target(e) {
        return e.target || e.srcElement;
      }
      function e_button(e) {
        var b = e.which;
        if (b == null) {
          if (e.button & 1) {
            b = 1;
          } else if (e.button & 2) {
            b = 3;
          } else if (e.button & 4) {
            b = 2;
          }
        }
        if (mac && e.ctrlKey && b == 1) {
          b = 3;
        }
        return b;
      }
      var dragAndDrop = function() {
        if (ie && ie_version < 9) {
          return false;
        }
        var div = elt("div");
        return "draggable" in div || "dragDrop" in div;
      }();
      var zwspSupported;
      function zeroWidthElement(measure) {
        if (zwspSupported == null) {
          var test = elt("span", "\u200B");
          removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
          if (measure.firstChild.offsetHeight != 0) {
            zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8);
          }
        }
        var node = zwspSupported ? elt("span", "\u200B") : elt("span", "\xA0", null, "display: inline-block; width: 1px; margin-right: -1px");
        node.setAttribute("cm-text", "");
        return node;
      }
      var badBidiRects;
      function hasBadBidiRects(measure) {
        if (badBidiRects != null) {
          return badBidiRects;
        }
        var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062EA"));
        var r0 = range(txt, 0, 1).getBoundingClientRect();
        var r1 = range(txt, 1, 2).getBoundingClientRect();
        removeChildren(measure);
        if (!r0 || r0.left == r0.right) {
          return false;
        }
        return badBidiRects = r1.right - r0.right < 3;
      }
      var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function(string) {
        var pos = 0, result = [], l = string.length;
        while (pos <= l) {
          var nl = string.indexOf("\n", pos);
          if (nl == -1) {
            nl = string.length;
          }
          var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
          var rt = line.indexOf("\r");
          if (rt != -1) {
            result.push(line.slice(0, rt));
            pos += rt + 1;
          } else {
            result.push(line);
            pos = nl + 1;
          }
        }
        return result;
      } : function(string) {
        return string.split(/\r\n?|\n/);
      };
      var hasSelection = window.getSelection ? function(te) {
        try {
          return te.selectionStart != te.selectionEnd;
        } catch (e) {
          return false;
        }
      } : function(te) {
        var range2;
        try {
          range2 = te.ownerDocument.selection.createRange();
        } catch (e) {
        }
        if (!range2 || range2.parentElement() != te) {
          return false;
        }
        return range2.compareEndPoints("StartToEnd", range2) != 0;
      };
      var hasCopyEvent = function() {
        var e = elt("div");
        if ("oncopy" in e) {
          return true;
        }
        e.setAttribute("oncopy", "return;");
        return typeof e.oncopy == "function";
      }();
      var badZoomedRects = null;
      function hasBadZoomedRects(measure) {
        if (badZoomedRects != null) {
          return badZoomedRects;
        }
        var node = removeChildrenAndAdd(measure, elt("span", "x"));
        var normal = node.getBoundingClientRect();
        var fromRange = range(node, 0, 1).getBoundingClientRect();
        return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1;
      }
      var modes = {}, mimeModes = {};
      function defineMode(name2, mode) {
        if (arguments.length > 2) {
          mode.dependencies = Array.prototype.slice.call(arguments, 2);
        }
        modes[name2] = mode;
      }
      function defineMIME(mime, spec) {
        mimeModes[mime] = spec;
      }
      function resolveMode(spec) {
        if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
          spec = mimeModes[spec];
        } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
          var found = mimeModes[spec.name];
          if (typeof found == "string") {
            found = { name: found };
          }
          spec = createObj(found, spec);
          spec.name = found.name;
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
          return resolveMode("application/xml");
        } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
          return resolveMode("application/json");
        }
        if (typeof spec == "string") {
          return { name: spec };
        } else {
          return spec || { name: "null" };
        }
      }
      function getMode(options, spec) {
        spec = resolveMode(spec);
        var mfactory = modes[spec.name];
        if (!mfactory) {
          return getMode(options, "text/plain");
        }
        var modeObj = mfactory(options, spec);
        if (modeExtensions.hasOwnProperty(spec.name)) {
          var exts = modeExtensions[spec.name];
          for (var prop2 in exts) {
            if (!exts.hasOwnProperty(prop2)) {
              continue;
            }
            if (modeObj.hasOwnProperty(prop2)) {
              modeObj["_" + prop2] = modeObj[prop2];
            }
            modeObj[prop2] = exts[prop2];
          }
        }
        modeObj.name = spec.name;
        if (spec.helperType) {
          modeObj.helperType = spec.helperType;
        }
        if (spec.modeProps) {
          for (var prop$1 in spec.modeProps) {
            modeObj[prop$1] = spec.modeProps[prop$1];
          }
        }
        return modeObj;
      }
      var modeExtensions = {};
      function extendMode(mode, properties) {
        var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
        copyObj(properties, exts);
      }
      function copyState(mode, state) {
        if (state === true) {
          return state;
        }
        if (mode.copyState) {
          return mode.copyState(state);
        }
        var nstate = {};
        for (var n in state) {
          var val = state[n];
          if (val instanceof Array) {
            val = val.concat([]);
          }
          nstate[n] = val;
        }
        return nstate;
      }
      function innerMode(mode, state) {
        var info;
        while (mode.innerMode) {
          info = mode.innerMode(state);
          if (!info || info.mode == mode) {
            break;
          }
          state = info.state;
          mode = info.mode;
        }
        return info || { mode, state };
      }
      function startState(mode, a1, a2) {
        return mode.startState ? mode.startState(a1, a2) : true;
      }
      var StringStream = function(string, tabSize, lineOracle) {
        this.pos = this.start = 0;
        this.string = string;
        this.tabSize = tabSize || 8;
        this.lastColumnPos = this.lastColumnValue = 0;
        this.lineStart = 0;
        this.lineOracle = lineOracle;
      };
      StringStream.prototype.eol = function() {
        return this.pos >= this.string.length;
      };
      StringStream.prototype.sol = function() {
        return this.pos == this.lineStart;
      };
      StringStream.prototype.peek = function() {
        return this.string.charAt(this.pos) || void 0;
      };
      StringStream.prototype.next = function() {
        if (this.pos < this.string.length) {
          return this.string.charAt(this.pos++);
        }
      };
      StringStream.prototype.eat = function(match) {
        var ch = this.string.charAt(this.pos);
        var ok;
        if (typeof match == "string") {
          ok = ch == match;
        } else {
          ok = ch && (match.test ? match.test(ch) : match(ch));
        }
        if (ok) {
          ++this.pos;
          return ch;
        }
      };
      StringStream.prototype.eatWhile = function(match) {
        var start = this.pos;
        while (this.eat(match)) {
        }
        return this.pos > start;
      };
      StringStream.prototype.eatSpace = function() {
        var start = this.pos;
        while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) {
          ++this.pos;
        }
        return this.pos > start;
      };
      StringStream.prototype.skipToEnd = function() {
        this.pos = this.string.length;
      };
      StringStream.prototype.skipTo = function(ch) {
        var found = this.string.indexOf(ch, this.pos);
        if (found > -1) {
          this.pos = found;
          return true;
        }
      };
      StringStream.prototype.backUp = function(n) {
        this.pos -= n;
      };
      StringStream.prototype.column = function() {
        if (this.lastColumnPos < this.start) {
          this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
          this.lastColumnPos = this.start;
        }
        return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.indentation = function() {
        return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0);
      };
      StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
        if (typeof pattern == "string") {
          var cased = function(str) {
            return caseInsensitive ? str.toLowerCase() : str;
          };
          var substr = this.string.substr(this.pos, pattern.length);
          if (cased(substr) == cased(pattern)) {
            if (consume !== false) {
              this.pos += pattern.length;
            }
            return true;
          }
        } else {
          var match = this.string.slice(this.pos).match(pattern);
          if (match && match.index > 0) {
            return null;
          }
          if (match && consume !== false) {
            this.pos += match[0].length;
          }
          return match;
        }
      };
      StringStream.prototype.current = function() {
        return this.string.slice(this.start, this.pos);
      };
      StringStream.prototype.hideFirstChars = function(n, inner) {
        this.lineStart += n;
        try {
          return inner();
        } finally {
          this.lineStart -= n;
        }
      };
      StringStream.prototype.lookAhead = function(n) {
        var oracle = this.lineOracle;
        return oracle && oracle.lookAhead(n);
      };
      StringStream.prototype.baseToken = function() {
        var oracle = this.lineOracle;
        return oracle && oracle.baseToken(this.pos);
      };
      function getLine(doc, n) {
        n -= doc.first;
        if (n < 0 || n >= doc.size) {
          throw new Error("There is no line " + (n + doc.first) + " in the document.");
        }
        var chunk = doc;
        while (!chunk.lines) {
          for (var i2 = 0; ; ++i2) {
            var child = chunk.children[i2], sz = child.chunkSize();
            if (n < sz) {
              chunk = child;
              break;
            }
            n -= sz;
          }
        }
        return chunk.lines[n];
      }
      function getBetween(doc, start, end) {
        var out = [], n = start.line;
        doc.iter(start.line, end.line + 1, function(line) {
          var text2 = line.text;
          if (n == end.line) {
            text2 = text2.slice(0, end.ch);
          }
          if (n == start.line) {
            text2 = text2.slice(start.ch);
          }
          out.push(text2);
          ++n;
        });
        return out;
      }
      function getLines(doc, from, to) {
        var out = [];
        doc.iter(from, to, function(line) {
          out.push(line.text);
        });
        return out;
      }
      function updateLineHeight(line, height) {
        var diff2 = height - line.height;
        if (diff2) {
          for (var n = line; n; n = n.parent) {
            n.height += diff2;
          }
        }
      }
      function lineNo(line) {
        if (line.parent == null) {
          return null;
        }
        var cur = line.parent, no = indexOf(cur.lines, line);
        for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
          for (var i2 = 0; ; ++i2) {
            if (chunk.children[i2] == cur) {
              break;
            }
            no += chunk.children[i2].chunkSize();
          }
        }
        return no + cur.first;
      }
      function lineAtHeight(chunk, h) {
        var n = chunk.first;
        outer:
          do {
            for (var i$12 = 0; i$12 < chunk.children.length; ++i$12) {
              var child = chunk.children[i$12], ch = child.height;
              if (h < ch) {
                chunk = child;
                continue outer;
              }
              h -= ch;
              n += child.chunkSize();
            }
            return n;
          } while (!chunk.lines);
        var i2 = 0;
        for (; i2 < chunk.lines.length; ++i2) {
          var line = chunk.lines[i2], lh = line.height;
          if (h < lh) {
            break;
          }
          h -= lh;
        }
        return n + i2;
      }
      function isLine(doc, l) {
        return l >= doc.first && l < doc.first + doc.size;
      }
      function lineNumberFor(options, i2) {
        return String(options.lineNumberFormatter(i2 + options.firstLineNumber));
      }
      function Pos(line, ch, sticky) {
        if (sticky === void 0)
          sticky = null;
        if (!(this instanceof Pos)) {
          return new Pos(line, ch, sticky);
        }
        this.line = line;
        this.ch = ch;
        this.sticky = sticky;
      }
      function cmp(a, b) {
        return a.line - b.line || a.ch - b.ch;
      }
      function equalCursorPos(a, b) {
        return a.sticky == b.sticky && cmp(a, b) == 0;
      }
      function copyPos(x) {
        return Pos(x.line, x.ch);
      }
      function maxPos(a, b) {
        return cmp(a, b) < 0 ? b : a;
      }
      function minPos(a, b) {
        return cmp(a, b) < 0 ? a : b;
      }
      function clipLine(doc, n) {
        return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1));
      }
      function clipPos(doc, pos) {
        if (pos.line < doc.first) {
          return Pos(doc.first, 0);
        }
        var last = doc.first + doc.size - 1;
        if (pos.line > last) {
          return Pos(last, getLine(doc, last).text.length);
        }
        return clipToLen(pos, getLine(doc, pos.line).text.length);
      }
      function clipToLen(pos, linelen) {
        var ch = pos.ch;
        if (ch == null || ch > linelen) {
          return Pos(pos.line, linelen);
        } else if (ch < 0) {
          return Pos(pos.line, 0);
        } else {
          return pos;
        }
      }
      function clipPosArray(doc, array) {
        var out = [];
        for (var i2 = 0; i2 < array.length; i2++) {
          out[i2] = clipPos(doc, array[i2]);
        }
        return out;
      }
      var SavedContext = function(state, lookAhead) {
        this.state = state;
        this.lookAhead = lookAhead;
      };
      var Context = function(doc, state, line, lookAhead) {
        this.state = state;
        this.doc = doc;
        this.line = line;
        this.maxLookAhead = lookAhead || 0;
        this.baseTokens = null;
        this.baseTokenPos = 1;
      };
      Context.prototype.lookAhead = function(n) {
        var line = this.doc.getLine(this.line + n);
        if (line != null && n > this.maxLookAhead) {
          this.maxLookAhead = n;
        }
        return line;
      };
      Context.prototype.baseToken = function(n) {
        if (!this.baseTokens) {
          return null;
        }
        while (this.baseTokens[this.baseTokenPos] <= n) {
          this.baseTokenPos += 2;
        }
        var type2 = this.baseTokens[this.baseTokenPos + 1];
        return {
          type: type2 && type2.replace(/( |^)overlay .*/, ""),
          size: this.baseTokens[this.baseTokenPos] - n
        };
      };
      Context.prototype.nextLine = function() {
        this.line++;
        if (this.maxLookAhead > 0) {
          this.maxLookAhead--;
        }
      };
      Context.fromSaved = function(doc, saved, line) {
        if (saved instanceof SavedContext) {
          return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead);
        } else {
          return new Context(doc, copyState(doc.mode, saved), line);
        }
      };
      Context.prototype.save = function(copy) {
        var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
        return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state;
      };
      function highlightLine(cm, line, context, forceToEnd) {
        var st = [cm.state.modeGen], lineClasses = {};
        runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
          return st.push(end, style);
        }, lineClasses, forceToEnd);
        var state = context.state;
        var loop = function(o2) {
          context.baseTokens = st;
          var overlay = cm.state.overlays[o2], i2 = 1, at = 0;
          context.state = true;
          runMode(cm, line.text, overlay.mode, context, function(end, style) {
            var start = i2;
            while (at < end) {
              var i_end = st[i2];
              if (i_end > end) {
                st.splice(i2, 1, end, st[i2 + 1], i_end);
              }
              i2 += 2;
              at = Math.min(end, i_end);
            }
            if (!style) {
              return;
            }
            if (overlay.opaque) {
              st.splice(start, i2 - start, end, "overlay " + style);
              i2 = start + 2;
            } else {
              for (; start < i2; start += 2) {
                var cur = st[start + 1];
                st[start + 1] = (cur ? cur + " " : "") + "overlay " + style;
              }
            }
          }, lineClasses);
          context.state = state;
          context.baseTokens = null;
          context.baseTokenPos = 1;
        };
        for (var o = 0; o < cm.state.overlays.length; ++o)
          loop(o);
        return { styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null };
      }
      function getLineStyles(cm, line, updateFrontier) {
        if (!line.styles || line.styles[0] != cm.state.modeGen) {
          var context = getContextBefore(cm, lineNo(line));
          var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
          var result = highlightLine(cm, line, context);
          if (resetState) {
            context.state = resetState;
          }
          line.stateAfter = context.save(!resetState);
          line.styles = result.styles;
          if (result.classes) {
            line.styleClasses = result.classes;
          } else if (line.styleClasses) {
            line.styleClasses = null;
          }
          if (updateFrontier === cm.doc.highlightFrontier) {
            cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier);
          }
        }
        return line.styles;
      }
      function getContextBefore(cm, n, precise) {
        var doc = cm.doc, display = cm.display;
        if (!doc.mode.startState) {
          return new Context(doc, true, n);
        }
        var start = findStartLine(cm, n, precise);
        var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
        var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
        doc.iter(start, n, function(line) {
          processLine(cm, line.text, context);
          var pos = context.line;
          line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
          context.nextLine();
        });
        if (precise) {
          doc.modeFrontier = context.line;
        }
        return context;
      }
      function processLine(cm, text2, context, startAt) {
        var mode = cm.doc.mode;
        var stream = new StringStream(text2, cm.options.tabSize, context);
        stream.start = stream.pos = startAt || 0;
        if (text2 == "") {
          callBlankLine(mode, context.state);
        }
        while (!stream.eol()) {
          readToken2(mode, stream, context.state);
          stream.start = stream.pos;
        }
      }
      function callBlankLine(mode, state) {
        if (mode.blankLine) {
          return mode.blankLine(state);
        }
        if (!mode.innerMode) {
          return;
        }
        var inner = innerMode(mode, state);
        if (inner.mode.blankLine) {
          return inner.mode.blankLine(inner.state);
        }
      }
      function readToken2(mode, stream, state, inner) {
        for (var i2 = 0; i2 < 10; i2++) {
          if (inner) {
            inner[0] = innerMode(mode, state).mode;
          }
          var style = mode.token(stream, state);
          if (stream.pos > stream.start) {
            return style;
          }
        }
        throw new Error("Mode " + mode.name + " failed to advance stream.");
      }
      var Token2 = function(stream, type2, state) {
        this.start = stream.start;
        this.end = stream.pos;
        this.string = stream.current();
        this.type = type2 || null;
        this.state = state;
      };
      function takeToken(cm, pos, precise, asArray) {
        var doc = cm.doc, mode = doc.mode, style;
        pos = clipPos(doc, pos);
        var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
        var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
        if (asArray) {
          tokens = [];
        }
        while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
          stream.start = stream.pos;
          style = readToken2(mode, stream, context.state);
          if (asArray) {
            tokens.push(new Token2(stream, style, copyState(doc.mode, context.state)));
          }
        }
        return asArray ? tokens : new Token2(stream, style, context.state);
      }
      function extractLineClasses(type2, output) {
        if (type2) {
          for (; ; ) {
            var lineClass = type2.match(/(?:^|\s+)line-(background-)?(\S+)/);
            if (!lineClass) {
              break;
            }
            type2 = type2.slice(0, lineClass.index) + type2.slice(lineClass.index + lineClass[0].length);
            var prop2 = lineClass[1] ? "bgClass" : "textClass";
            if (output[prop2] == null) {
              output[prop2] = lineClass[2];
            } else if (!new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)").test(output[prop2])) {
              output[prop2] += " " + lineClass[2];
            }
          }
        }
        return type2;
      }
      function runMode(cm, text2, mode, context, f, lineClasses, forceToEnd) {
        var flattenSpans = mode.flattenSpans;
        if (flattenSpans == null) {
          flattenSpans = cm.options.flattenSpans;
        }
        var curStart = 0, curStyle = null;
        var stream = new StringStream(text2, cm.options.tabSize, context), style;
        var inner = cm.options.addModeClass && [null];
        if (text2 == "") {
          extractLineClasses(callBlankLine(mode, context.state), lineClasses);
        }
        while (!stream.eol()) {
          if (stream.pos > cm.options.maxHighlightLength) {
            flattenSpans = false;
            if (forceToEnd) {
              processLine(cm, text2, context, stream.pos);
            }
            stream.pos = text2.length;
            style = null;
          } else {
            style = extractLineClasses(readToken2(mode, stream, context.state, inner), lineClasses);
          }
          if (inner) {
            var mName = inner[0].name;
            if (mName) {
              style = "m-" + (style ? mName + " " + style : mName);
            }
          }
          if (!flattenSpans || curStyle != style) {
            while (curStart < stream.start) {
              curStart = Math.min(stream.start, curStart + 5e3);
              f(curStart, curStyle);
            }
            curStyle = style;
          }
          stream.start = stream.pos;
        }
        while (curStart < stream.pos) {
          var pos = Math.min(stream.pos, curStart + 5e3);
          f(pos, curStyle);
          curStart = pos;
        }
      }
      function findStartLine(cm, n, precise) {
        var minindent, minline, doc = cm.doc;
        var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100);
        for (var search = n; search > lim; --search) {
          if (search <= doc.first) {
            return doc.first;
          }
          var line = getLine(doc, search - 1), after = line.stateAfter;
          if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) {
            return search;
          }
          var indented = countColumn(line.text, null, cm.options.tabSize);
          if (minline == null || minindent > indented) {
            minline = search - 1;
            minindent = indented;
          }
        }
        return minline;
      }
      function retreatFrontier(doc, n) {
        doc.modeFrontier = Math.min(doc.modeFrontier, n);
        if (doc.highlightFrontier < n - 10) {
          return;
        }
        var start = doc.first;
        for (var line = n - 1; line > start; line--) {
          var saved = getLine(doc, line).stateAfter;
          if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
            start = line + 1;
            break;
          }
        }
        doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
      }
      var sawReadOnlySpans = false, sawCollapsedSpans = false;
      function seeReadOnlySpans() {
        sawReadOnlySpans = true;
      }
      function seeCollapsedSpans() {
        sawCollapsedSpans = true;
      }
      function MarkedSpan(marker, from, to) {
        this.marker = marker;
        this.from = from;
        this.to = to;
      }
      function getMarkedSpanFor(spans, marker) {
        if (spans) {
          for (var i2 = 0; i2 < spans.length; ++i2) {
            var span = spans[i2];
            if (span.marker == marker) {
              return span;
            }
          }
        }
      }
      function removeMarkedSpan(spans, span) {
        var r;
        for (var i2 = 0; i2 < spans.length; ++i2) {
          if (spans[i2] != span) {
            (r || (r = [])).push(spans[i2]);
          }
        }
        return r;
      }
      function addMarkedSpan(line, span, op) {
        var inThisOp = op && window.WeakSet && (op.markedSpans || (op.markedSpans = new WeakSet()));
        if (inThisOp && inThisOp.has(line.markedSpans)) {
          line.markedSpans.push(span);
        } else {
          line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
          if (inThisOp) {
            inThisOp.add(line.markedSpans);
          }
        }
        span.marker.attachLine(line);
      }
      function markedSpansBefore(old, startCh, isInsert) {
        var nw;
        if (old) {
          for (var i2 = 0; i2 < old.length; ++i2) {
            var span = old[i2], marker = span.marker;
            var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
            if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
              var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
            }
          }
        }
        return nw;
      }
      function markedSpansAfter(old, endCh, isInsert) {
        var nw;
        if (old) {
          for (var i2 = 0; i2 < old.length; ++i2) {
            var span = old[i2], marker = span.marker;
            var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
            if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
              var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
              (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, span.to == null ? null : span.to - endCh));
            }
          }
        }
        return nw;
      }
      function stretchSpansOverChange(doc, change) {
        if (change.full) {
          return null;
        }
        var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
        var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
        if (!oldFirst && !oldLast) {
          return null;
        }
        var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
        var first = markedSpansBefore(oldFirst, startCh, isInsert);
        var last = markedSpansAfter(oldLast, endCh, isInsert);
        var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
        if (first) {
          for (var i2 = 0; i2 < first.length; ++i2) {
            var span = first[i2];
            if (span.to == null) {
              var found = getMarkedSpanFor(last, span.marker);
              if (!found) {
                span.to = startCh;
              } else if (sameLine) {
                span.to = found.to == null ? null : found.to + offset;
              }
            }
          }
        }
        if (last) {
          for (var i$12 = 0; i$12 < last.length; ++i$12) {
            var span$1 = last[i$12];
            if (span$1.to != null) {
              span$1.to += offset;
            }
            if (span$1.from == null) {
              var found$1 = getMarkedSpanFor(first, span$1.marker);
              if (!found$1) {
                span$1.from = offset;
                if (sameLine) {
                  (first || (first = [])).push(span$1);
                }
              }
            } else {
              span$1.from += offset;
              if (sameLine) {
                (first || (first = [])).push(span$1);
              }
            }
          }
        }
        if (first) {
          first = clearEmptySpans(first);
        }
        if (last && last != first) {
          last = clearEmptySpans(last);
        }
        var newMarkers = [first];
        if (!sameLine) {
          var gap = change.text.length - 2, gapMarkers;
          if (gap > 0 && first) {
            for (var i$22 = 0; i$22 < first.length; ++i$22) {
              if (first[i$22].to == null) {
                (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$22].marker, null, null));
              }
            }
          }
          for (var i$3 = 0; i$3 < gap; ++i$3) {
            newMarkers.push(gapMarkers);
          }
          newMarkers.push(last);
        }
        return newMarkers;
      }
      function clearEmptySpans(spans) {
        for (var i2 = 0; i2 < spans.length; ++i2) {
          var span = spans[i2];
          if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false) {
            spans.splice(i2--, 1);
          }
        }
        if (!spans.length) {
          return null;
        }
        return spans;
      }
      function removeReadOnlyRanges(doc, from, to) {
        var markers = null;
        doc.iter(from.line, to.line + 1, function(line) {
          if (line.markedSpans) {
            for (var i3 = 0; i3 < line.markedSpans.length; ++i3) {
              var mark = line.markedSpans[i3].marker;
              if (mark.readOnly && (!markers || indexOf(markers, mark) == -1)) {
                (markers || (markers = [])).push(mark);
              }
            }
          }
        });
        if (!markers) {
          return null;
        }
        var parts = [{ from, to }];
        for (var i2 = 0; i2 < markers.length; ++i2) {
          var mk = markers[i2], m = mk.find(0);
          for (var j = 0; j < parts.length; ++j) {
            var p2 = parts[j];
            if (cmp(p2.to, m.from) < 0 || cmp(p2.from, m.to) > 0) {
              continue;
            }
            var newParts = [j, 1], dfrom = cmp(p2.from, m.from), dto = cmp(p2.to, m.to);
            if (dfrom < 0 || !mk.inclusiveLeft && !dfrom) {
              newParts.push({ from: p2.from, to: m.from });
            }
            if (dto > 0 || !mk.inclusiveRight && !dto) {
              newParts.push({ from: m.to, to: p2.to });
            }
            parts.splice.apply(parts, newParts);
            j += newParts.length - 3;
          }
        }
        return parts;
      }
      function detachMarkedSpans(line) {
        var spans = line.markedSpans;
        if (!spans) {
          return;
        }
        for (var i2 = 0; i2 < spans.length; ++i2) {
          spans[i2].marker.detachLine(line);
        }
        line.markedSpans = null;
      }
      function attachMarkedSpans(line, spans) {
        if (!spans) {
          return;
        }
        for (var i2 = 0; i2 < spans.length; ++i2) {
          spans[i2].marker.attachLine(line);
        }
        line.markedSpans = spans;
      }
      function extraLeft(marker) {
        return marker.inclusiveLeft ? -1 : 0;
      }
      function extraRight(marker) {
        return marker.inclusiveRight ? 1 : 0;
      }
      function compareCollapsedMarkers(a, b) {
        var lenDiff = a.lines.length - b.lines.length;
        if (lenDiff != 0) {
          return lenDiff;
        }
        var aPos = a.find(), bPos = b.find();
        var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
        if (fromCmp) {
          return -fromCmp;
        }
        var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
        if (toCmp) {
          return toCmp;
        }
        return b.id - a.id;
      }
      function collapsedSpanAtSide(line, start) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
            sp = sps[i2];
            if (sp.marker.collapsed && (start ? sp.from : sp.to) == null && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function collapsedSpanAtStart(line) {
        return collapsedSpanAtSide(line, true);
      }
      function collapsedSpanAtEnd(line) {
        return collapsedSpanAtSide(line, false);
      }
      function collapsedSpanAround(line, ch) {
        var sps = sawCollapsedSpans && line.markedSpans, found;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            var sp = sps[i2];
            if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) && (!found || compareCollapsedMarkers(found, sp.marker) < 0)) {
              found = sp.marker;
            }
          }
        }
        return found;
      }
      function conflictingCollapsedRange(doc, lineNo2, from, to, marker) {
        var line = getLine(doc, lineNo2);
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var i2 = 0; i2 < sps.length; ++i2) {
            var sp = sps[i2];
            if (!sp.marker.collapsed) {
              continue;
            }
            var found = sp.marker.find(0);
            var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
            var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
            if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) {
              continue;
            }
            if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0)) {
              return true;
            }
          }
        }
      }
      function visualLine(line) {
        var merged;
        while (merged = collapsedSpanAtStart(line)) {
          line = merged.find(-1, true).line;
        }
        return line;
      }
      function visualLineEnd(line) {
        var merged;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return line;
      }
      function visualLineContinued(line) {
        var merged, lines;
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
          (lines || (lines = [])).push(line);
        }
        return lines;
      }
      function visualLineNo(doc, lineN) {
        var line = getLine(doc, lineN), vis = visualLine(line);
        if (line == vis) {
          return lineN;
        }
        return lineNo(vis);
      }
      function visualLineEndNo(doc, lineN) {
        if (lineN > doc.lastLine()) {
          return lineN;
        }
        var line = getLine(doc, lineN), merged;
        if (!lineIsHidden(doc, line)) {
          return lineN;
        }
        while (merged = collapsedSpanAtEnd(line)) {
          line = merged.find(1, true).line;
        }
        return lineNo(line) + 1;
      }
      function lineIsHidden(doc, line) {
        var sps = sawCollapsedSpans && line.markedSpans;
        if (sps) {
          for (var sp = void 0, i2 = 0; i2 < sps.length; ++i2) {
            sp = sps[i2];
            if (!sp.marker.collapsed) {
              continue;
            }
            if (sp.from == null) {
              return true;
            }
            if (sp.marker.widgetNode) {
              continue;
            }
            if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) {
              return true;
            }
          }
        }
      }
      function lineIsHiddenInner(doc, line, span) {
        if (span.to == null) {
          var end = span.marker.find(1, true);
          return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker));
        }
        if (span.marker.inclusiveRight && span.to == line.text.length) {
          return true;
        }
        for (var sp = void 0, i2 = 0; i2 < line.markedSpans.length; ++i2) {
          sp = line.markedSpans[i2];
          if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (sp.to == null || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) {
            return true;
          }
        }
      }
      function heightAtLine(lineObj) {
        lineObj = visualLine(lineObj);
        var h = 0, chunk = lineObj.parent;
        for (var i2 = 0; i2 < chunk.lines.length; ++i2) {
          var line = chunk.lines[i2];
          if (line == lineObj) {
            break;
          } else {
            h += line.height;
          }
        }
        for (var p2 = chunk.parent; p2; chunk = p2, p2 = chunk.parent) {
          for (var i$12 = 0; i$12 < p2.children.length; ++i$12) {
            var cur = p2.children[i$12];
            if (cur == chunk) {
              break;
            } else {
              h += cur.height;
            }
          }
        }
        return h;
      }
      function lineLength(line) {
        if (line.height == 0) {
          return 0;
        }
        var len = line.text.length, merged, cur = line;
        while (merged = collapsedSpanAtStart(cur)) {
          var found = merged.find(0, true);
          cur = found.from.line;
          len += found.from.ch - found.to.ch;
        }
        cur = line;
        while (merged = collapsedSpanAtEnd(cur)) {
          var found$1 = merged.find(0, true);
          len -= cur.text.length - found$1.from.ch;
          cur = found$1.to.line;
          len += cur.text.length - found$1.to.ch;
        }
        return len;
      }
      function findMaxLine(cm) {
        var d = cm.display, doc = cm.doc;
        d.maxLine = getLine(doc, doc.first);
        d.maxLineLength = lineLength(d.maxLine);
        d.maxLineChanged = true;
        doc.iter(function(line) {
          var len = lineLength(line);
          if (len > d.maxLineLength) {
            d.maxLineLength = len;
            d.maxLine = line;
          }
        });
      }
      var Line = function(text2, markedSpans, estimateHeight2) {
        this.text = text2;
        attachMarkedSpans(this, markedSpans);
        this.height = estimateHeight2 ? estimateHeight2(this) : 1;
      };
      Line.prototype.lineNo = function() {
        return lineNo(this);
      };
      eventMixin(Line);
      function updateLine(line, text2, markedSpans, estimateHeight2) {
        line.text = text2;
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        if (line.styles) {
          line.styles = null;
        }
        if (line.order != null) {
          line.order = null;
        }
        detachMarkedSpans(line);
        attachMarkedSpans(line, markedSpans);
        var estHeight = estimateHeight2 ? estimateHeight2(line) : 1;
        if (estHeight != line.height) {
          updateLineHeight(line, estHeight);
        }
      }
      function cleanUpLine(line) {
        line.parent = null;
        detachMarkedSpans(line);
      }
      var styleToClassCache = {}, styleToClassCacheWithMode = {};
      function interpretTokenStyle(style, options) {
        if (!style || /^\s*$/.test(style)) {
          return null;
        }
        var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
        return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"));
      }
      function buildLineContent(cm, lineView) {
        var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
        var builder = {
          pre: eltP("pre", [content], "CodeMirror-line"),
          content,
          col: 0,
          pos: 0,
          cm,
          trailingSpace: false,
          splitSpaces: cm.getOption("lineWrapping")
        };
        lineView.measure = {};
        for (var i2 = 0; i2 <= (lineView.rest ? lineView.rest.length : 0); i2++) {
          var line = i2 ? lineView.rest[i2 - 1] : lineView.line, order = void 0;
          builder.pos = 0;
          builder.addToken = buildToken2;
          if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction))) {
            builder.addToken = buildTokenBadBidi(builder.addToken, order);
          }
          builder.map = [];
          var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
          insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
          if (line.styleClasses) {
            if (line.styleClasses.bgClass) {
              builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "");
            }
            if (line.styleClasses.textClass) {
              builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || "");
            }
          }
          if (builder.map.length == 0) {
            builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure)));
          }
          if (i2 == 0) {
            lineView.measure.map = builder.map;
            lineView.measure.cache = {};
          } else {
            (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map);
            (lineView.measure.caches || (lineView.measure.caches = [])).push({});
          }
        }
        if (webkit) {
          var last = builder.content.lastChild;
          if (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) {
            builder.content.className = "cm-tab-wrap-hack";
          }
        }
        signal(cm, "renderLine", cm, lineView.line, builder.pre);
        if (builder.pre.className) {
          builder.textClass = joinClasses(builder.pre.className, builder.textClass || "");
        }
        return builder;
      }
      function defaultSpecialCharPlaceholder(ch) {
        var token = elt("span", "\u2022", "cm-invalidchar");
        token.title = "\\u" + ch.charCodeAt(0).toString(16);
        token.setAttribute("aria-label", token.title);
        return token;
      }
      function buildToken2(builder, text2, style, startStyle, endStyle, css, attributes) {
        if (!text2) {
          return;
        }
        var displayText = builder.splitSpaces ? splitSpaces(text2, builder.trailingSpace) : text2;
        var special = builder.cm.state.specialChars, mustWrap = false;
        var content;
        if (!special.test(text2)) {
          builder.col += text2.length;
          content = document.createTextNode(displayText);
          builder.map.push(builder.pos, builder.pos + text2.length, content);
          if (ie && ie_version < 9) {
            mustWrap = true;
          }
          builder.pos += text2.length;
        } else {
          content = document.createDocumentFragment();
          var pos = 0;
          while (true) {
            special.lastIndex = pos;
            var m = special.exec(text2);
            var skipped = m ? m.index - pos : text2.length - pos;
            if (skipped) {
              var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt]));
              } else {
                content.appendChild(txt);
              }
              builder.map.push(builder.pos, builder.pos + skipped, txt);
              builder.col += skipped;
              builder.pos += skipped;
            }
            if (!m) {
              break;
            }
            pos += skipped + 1;
            var txt$1 = void 0;
            if (m[0] == "	") {
              var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
              txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
              txt$1.setAttribute("role", "presentation");
              txt$1.setAttribute("cm-text", "	");
              builder.col += tabWidth;
            } else if (m[0] == "\r" || m[0] == "\n") {
              txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240D" : "\u2424", "cm-invalidchar"));
              txt$1.setAttribute("cm-text", m[0]);
              builder.col += 1;
            } else {
              txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
              txt$1.setAttribute("cm-text", m[0]);
              if (ie && ie_version < 9) {
                content.appendChild(elt("span", [txt$1]));
              } else {
                content.appendChild(txt$1);
              }
              builder.col += 1;
            }
            builder.map.push(builder.pos, builder.pos + 1, txt$1);
            builder.pos++;
          }
        }
        builder.trailingSpace = displayText.charCodeAt(text2.length - 1) == 32;
        if (style || startStyle || endStyle || mustWrap || css || attributes) {
          var fullStyle = style || "";
          if (startStyle) {
            fullStyle += startStyle;
          }
          if (endStyle) {
            fullStyle += endStyle;
          }
          var token = elt("span", [content], fullStyle, css);
          if (attributes) {
            for (var attr in attributes) {
              if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class") {
                token.setAttribute(attr, attributes[attr]);
              }
            }
          }
          return builder.content.appendChild(token);
        }
        builder.content.appendChild(content);
      }
      function splitSpaces(text2, trailingBefore) {
        if (text2.length > 1 && !/  /.test(text2)) {
          return text2;
        }
        var spaceBefore = trailingBefore, result = "";
        for (var i2 = 0; i2 < text2.length; i2++) {
          var ch = text2.charAt(i2);
          if (ch == " " && spaceBefore && (i2 == text2.length - 1 || text2.charCodeAt(i2 + 1) == 32)) {
            ch = "\xA0";
          }
          result += ch;
          spaceBefore = ch == " ";
        }
        return result;
      }
      function buildTokenBadBidi(inner, order) {
        return function(builder, text2, style, startStyle, endStyle, css, attributes) {
          style = style ? style + " cm-force-border" : "cm-force-border";
          var start = builder.pos, end = start + text2.length;
          for (; ; ) {
            var part = void 0;
            for (var i2 = 0; i2 < order.length; i2++) {
              part = order[i2];
              if (part.to > start && part.from <= start) {
                break;
              }
            }
            if (part.to >= end) {
              return inner(builder, text2, style, startStyle, endStyle, css, attributes);
            }
            inner(builder, text2.slice(0, part.to - start), style, startStyle, null, css, attributes);
            startStyle = null;
            text2 = text2.slice(part.to - start);
            start = part.to;
          }
        };
      }
      function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
        var widget = !ignoreWidget && marker.widgetNode;
        if (widget) {
          builder.map.push(builder.pos, builder.pos + size, widget);
        }
        if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
          if (!widget) {
            widget = builder.content.appendChild(document.createElement("span"));
          }
          widget.setAttribute("cm-marker", marker.id);
        }
        if (widget) {
          builder.cm.display.input.setUneditable(widget);
          builder.content.appendChild(widget);
        }
        builder.pos += size;
        builder.trailingSpace = false;
      }
      function insertLineContent(line, builder, styles) {
        var spans = line.markedSpans, allText = line.text, at = 0;
        if (!spans) {
          for (var i$12 = 1; i$12 < styles.length; i$12 += 2) {
            builder.addToken(builder, allText.slice(at, at = styles[i$12]), interpretTokenStyle(styles[i$12 + 1], builder.cm.options));
          }
          return;
        }
        var len = allText.length, pos = 0, i2 = 1, text2 = "", style, css;
        var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
        for (; ; ) {
          if (nextChange == pos) {
            spanStyle = spanEndStyle = spanStartStyle = css = "";
            attributes = null;
            collapsed = null;
            nextChange = Infinity;
            var foundBookmarks = [], endStyles = void 0;
            for (var j = 0; j < spans.length; ++j) {
              var sp = spans[j], m = sp.marker;
              if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
                foundBookmarks.push(m);
              } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
                if (sp.to != null && sp.to != pos && nextChange > sp.to) {
                  nextChange = sp.to;
                  spanEndStyle = "";
                }
                if (m.className) {
                  spanStyle += " " + m.className;
                }
                if (m.css) {
                  css = (css ? css + ";" : "") + m.css;
                }
                if (m.startStyle && sp.from == pos) {
                  spanStartStyle += " " + m.startStyle;
                }
                if (m.endStyle && sp.to == nextChange) {
                  (endStyles || (endStyles = [])).push(m.endStyle, sp.to);
                }
                if (m.title) {
                  (attributes || (attributes = {})).title = m.title;
                }
                if (m.attributes) {
                  for (var attr in m.attributes) {
                    (attributes || (attributes = {}))[attr] = m.attributes[attr];
                  }
                }
                if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0)) {
                  collapsed = sp;
                }
              } else if (sp.from > pos && nextChange > sp.from) {
                nextChange = sp.from;
              }
            }
            if (endStyles) {
              for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) {
                if (endStyles[j$1 + 1] == nextChange) {
                  spanEndStyle += " " + endStyles[j$1];
                }
              }
            }
            if (!collapsed || collapsed.from == pos) {
              for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) {
                buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
              }
            }
            if (collapsed && (collapsed.from || 0) == pos) {
              buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos, collapsed.marker, collapsed.from == null);
              if (collapsed.to == null) {
                return;
              }
              if (collapsed.to == pos) {
                collapsed = false;
              }
            }
          }
          if (pos >= len) {
            break;
          }
          var upto = Math.min(len, nextChange);
          while (true) {
            if (text2) {
              var end = pos + text2.length;
              if (!collapsed) {
                var tokenText = end > upto ? text2.slice(0, upto - pos) : text2;
                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
              }
              if (end >= upto) {
                text2 = text2.slice(upto - pos);
                pos = upto;
                break;
              }
              pos = end;
              spanStartStyle = "";
            }
            text2 = allText.slice(at, at = styles[i2++]);
            style = interpretTokenStyle(styles[i2++], builder.cm.options);
          }
        }
      }
      function LineView(doc, line, lineN) {
        this.line = line;
        this.rest = visualLineContinued(line);
        this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
        this.node = this.text = null;
        this.hidden = lineIsHidden(doc, line);
      }
      function buildViewArray(cm, from, to) {
        var array = [], nextPos;
        for (var pos = from; pos < to; pos = nextPos) {
          var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
          nextPos = pos + view.size;
          array.push(view);
        }
        return array;
      }
      var operationGroup = null;
      function pushOperation(op) {
        if (operationGroup) {
          operationGroup.ops.push(op);
        } else {
          op.ownsGroup = operationGroup = {
            ops: [op],
            delayedCallbacks: []
          };
        }
      }
      function fireCallbacksForOps(group) {
        var callbacks = group.delayedCallbacks, i2 = 0;
        do {
          for (; i2 < callbacks.length; i2++) {
            callbacks[i2].call(null);
          }
          for (var j = 0; j < group.ops.length; j++) {
            var op = group.ops[j];
            if (op.cursorActivityHandlers) {
              while (op.cursorActivityCalled < op.cursorActivityHandlers.length) {
                op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm);
              }
            }
          }
        } while (i2 < callbacks.length);
      }
      function finishOperation(op, endCb) {
        var group = op.ownsGroup;
        if (!group) {
          return;
        }
        try {
          fireCallbacksForOps(group);
        } finally {
          operationGroup = null;
          endCb(group);
        }
      }
      var orphanDelayedCallbacks = null;
      function signalLater(emitter, type2) {
        var arr = getHandlers(emitter, type2);
        if (!arr.length) {
          return;
        }
        var args = Array.prototype.slice.call(arguments, 2), list2;
        if (operationGroup) {
          list2 = operationGroup.delayedCallbacks;
        } else if (orphanDelayedCallbacks) {
          list2 = orphanDelayedCallbacks;
        } else {
          list2 = orphanDelayedCallbacks = [];
          setTimeout(fireOrphanDelayed, 0);
        }
        var loop = function(i3) {
          list2.push(function() {
            return arr[i3].apply(null, args);
          });
        };
        for (var i2 = 0; i2 < arr.length; ++i2)
          loop(i2);
      }
      function fireOrphanDelayed() {
        var delayed = orphanDelayedCallbacks;
        orphanDelayedCallbacks = null;
        for (var i2 = 0; i2 < delayed.length; ++i2) {
          delayed[i2]();
        }
      }
      function updateLineForChanges(cm, lineView, lineN, dims) {
        for (var j = 0; j < lineView.changes.length; j++) {
          var type2 = lineView.changes[j];
          if (type2 == "text") {
            updateLineText(cm, lineView);
          } else if (type2 == "gutter") {
            updateLineGutter(cm, lineView, lineN, dims);
          } else if (type2 == "class") {
            updateLineClasses(cm, lineView);
          } else if (type2 == "widget") {
            updateLineWidgets(cm, lineView, dims);
          }
        }
        lineView.changes = null;
      }
      function ensureLineWrapped(lineView) {
        if (lineView.node == lineView.text) {
          lineView.node = elt("div", null, null, "position: relative");
          if (lineView.text.parentNode) {
            lineView.text.parentNode.replaceChild(lineView.node, lineView.text);
          }
          lineView.node.appendChild(lineView.text);
          if (ie && ie_version < 8) {
            lineView.node.style.zIndex = 2;
          }
        }
        return lineView.node;
      }
      function updateLineBackground(cm, lineView) {
        var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
        if (cls) {
          cls += " CodeMirror-linebackground";
        }
        if (lineView.background) {
          if (cls) {
            lineView.background.className = cls;
          } else {
            lineView.background.parentNode.removeChild(lineView.background);
            lineView.background = null;
          }
        } else if (cls) {
          var wrap2 = ensureLineWrapped(lineView);
          lineView.background = wrap2.insertBefore(elt("div", null, cls), wrap2.firstChild);
          cm.display.input.setUneditable(lineView.background);
        }
      }
      function getLineContent(cm, lineView) {
        var ext = cm.display.externalMeasured;
        if (ext && ext.line == lineView.line) {
          cm.display.externalMeasured = null;
          lineView.measure = ext.measure;
          return ext.built;
        }
        return buildLineContent(cm, lineView);
      }
      function updateLineText(cm, lineView) {
        var cls = lineView.text.className;
        var built = getLineContent(cm, lineView);
        if (lineView.text == lineView.node) {
          lineView.node = built.pre;
        }
        lineView.text.parentNode.replaceChild(built.pre, lineView.text);
        lineView.text = built.pre;
        if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
          lineView.bgClass = built.bgClass;
          lineView.textClass = built.textClass;
          updateLineClasses(cm, lineView);
        } else if (cls) {
          lineView.text.className = cls;
        }
      }
      function updateLineClasses(cm, lineView) {
        updateLineBackground(cm, lineView);
        if (lineView.line.wrapClass) {
          ensureLineWrapped(lineView).className = lineView.line.wrapClass;
        } else if (lineView.node != lineView.text) {
          lineView.node.className = "";
        }
        var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
        lineView.text.className = textClass || "";
      }
      function updateLineGutter(cm, lineView, lineN, dims) {
        if (lineView.gutter) {
          lineView.node.removeChild(lineView.gutter);
          lineView.gutter = null;
        }
        if (lineView.gutterBackground) {
          lineView.node.removeChild(lineView.gutterBackground);
          lineView.gutterBackground = null;
        }
        if (lineView.line.gutterClass) {
          var wrap2 = ensureLineWrapped(lineView);
          lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px");
          cm.display.input.setUneditable(lineView.gutterBackground);
          wrap2.insertBefore(lineView.gutterBackground, lineView.text);
        }
        var markers = lineView.line.gutterMarkers;
        if (cm.options.lineNumbers || markers) {
          var wrap$1 = ensureLineWrapped(lineView);
          var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
          gutterWrap.setAttribute("aria-hidden", "true");
          cm.display.input.setUneditable(gutterWrap);
          wrap$1.insertBefore(gutterWrap, lineView.text);
          if (lineView.line.gutterClass) {
            gutterWrap.className += " " + lineView.line.gutterClass;
          }
          if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"])) {
            lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"));
          }
          if (markers) {
            for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
              var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
              if (found) {
                gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"));
              }
            }
          }
        }
      }
      function updateLineWidgets(cm, lineView, dims) {
        if (lineView.alignable) {
          lineView.alignable = null;
        }
        var isWidget = classTest("CodeMirror-linewidget");
        for (var node = lineView.node.firstChild, next = void 0; node; node = next) {
          next = node.nextSibling;
          if (isWidget.test(node.className)) {
            lineView.node.removeChild(node);
          }
        }
        insertLineWidgets(cm, lineView, dims);
      }
      function buildLineElement(cm, lineView, lineN, dims) {
        var built = getLineContent(cm, lineView);
        lineView.text = lineView.node = built.pre;
        if (built.bgClass) {
          lineView.bgClass = built.bgClass;
        }
        if (built.textClass) {
          lineView.textClass = built.textClass;
        }
        updateLineClasses(cm, lineView);
        updateLineGutter(cm, lineView, lineN, dims);
        insertLineWidgets(cm, lineView, dims);
        return lineView.node;
      }
      function insertLineWidgets(cm, lineView, dims) {
        insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
        if (lineView.rest) {
          for (var i2 = 0; i2 < lineView.rest.length; i2++) {
            insertLineWidgetsFor(cm, lineView.rest[i2], lineView, dims, false);
          }
        }
      }
      function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
        if (!line.widgets) {
          return;
        }
        var wrap2 = ensureLineWrapped(lineView);
        for (var i2 = 0, ws = line.widgets; i2 < ws.length; ++i2) {
          var widget = ws[i2], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
          if (!widget.handleMouseEvents) {
            node.setAttribute("cm-ignore-events", "true");
          }
          positionLineWidget(widget, node, lineView, dims);
          cm.display.input.setUneditable(node);
          if (allowAbove && widget.above) {
            wrap2.insertBefore(node, lineView.gutter || lineView.text);
          } else {
            wrap2.appendChild(node);
          }
          signalLater(widget, "redraw");
        }
      }
      function positionLineWidget(widget, node, lineView, dims) {
        if (widget.noHScroll) {
          (lineView.alignable || (lineView.alignable = [])).push(node);
          var width = dims.wrapperWidth;
          node.style.left = dims.fixedPos + "px";
          if (!widget.coverGutter) {
            width -= dims.gutterTotalWidth;
            node.style.paddingLeft = dims.gutterTotalWidth + "px";
          }
          node.style.width = width + "px";
        }
        if (widget.coverGutter) {
          node.style.zIndex = 5;
          node.style.position = "relative";
          if (!widget.noHScroll) {
            node.style.marginLeft = -dims.gutterTotalWidth + "px";
          }
        }
      }
      function widgetHeight(widget) {
        if (widget.height != null) {
          return widget.height;
        }
        var cm = widget.doc.cm;
        if (!cm) {
          return 0;
        }
        if (!contains(document.body, widget.node)) {
          var parentStyle = "position: relative;";
          if (widget.coverGutter) {
            parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;";
          }
          if (widget.noHScroll) {
            parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;";
          }
          removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
        }
        return widget.height = widget.node.parentNode.offsetHeight;
      }
      function eventInWidget(display, e) {
        for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
          if (!n || n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true" || n.parentNode == display.sizer && n != display.mover) {
            return true;
          }
        }
      }
      function paddingTop(display) {
        return display.lineSpace.offsetTop;
      }
      function paddingVert(display) {
        return display.mover.offsetHeight - display.lineSpace.offsetHeight;
      }
      function paddingH(display) {
        if (display.cachedPaddingH) {
          return display.cachedPaddingH;
        }
        var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
        var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
        var data = { left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight) };
        if (!isNaN(data.left) && !isNaN(data.right)) {
          display.cachedPaddingH = data;
        }
        return data;
      }
      function scrollGap(cm) {
        return scrollerGap - cm.display.nativeBarWidth;
      }
      function displayWidth(cm) {
        return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth;
      }
      function displayHeight(cm) {
        return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight;
      }
      function ensureLineHeights(cm, lineView, rect) {
        var wrapping = cm.options.lineWrapping;
        var curWidth = wrapping && displayWidth(cm);
        if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
          var heights = lineView.measure.heights = [];
          if (wrapping) {
            lineView.measure.width = curWidth;
            var rects = lineView.text.firstChild.getClientRects();
            for (var i2 = 0; i2 < rects.length - 1; i2++) {
              var cur = rects[i2], next = rects[i2 + 1];
              if (Math.abs(cur.bottom - next.bottom) > 2) {
                heights.push((cur.bottom + next.top) / 2 - rect.top);
              }
            }
          }
          heights.push(rect.bottom - rect.top);
        }
      }
      function mapFromLineView(lineView, line, lineN) {
        if (lineView.line == line) {
          return { map: lineView.measure.map, cache: lineView.measure.cache };
        }
        for (var i2 = 0; i2 < lineView.rest.length; i2++) {
          if (lineView.rest[i2] == line) {
            return { map: lineView.measure.maps[i2], cache: lineView.measure.caches[i2] };
          }
        }
        for (var i$12 = 0; i$12 < lineView.rest.length; i$12++) {
          if (lineNo(lineView.rest[i$12]) > lineN) {
            return { map: lineView.measure.maps[i$12], cache: lineView.measure.caches[i$12], before: true };
          }
        }
      }
      function updateExternalMeasurement(cm, line) {
        line = visualLine(line);
        var lineN = lineNo(line);
        var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
        view.lineN = lineN;
        var built = view.built = buildLineContent(cm, view);
        view.text = built.pre;
        removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
        return view;
      }
      function measureChar(cm, line, ch, bias) {
        return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias);
      }
      function findViewForLine(cm, lineN) {
        if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) {
          return cm.display.view[findViewIndex(cm, lineN)];
        }
        var ext = cm.display.externalMeasured;
        if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size) {
          return ext;
        }
      }
      function prepareMeasureForLine(cm, line) {
        var lineN = lineNo(line);
        var view = findViewForLine(cm, lineN);
        if (view && !view.text) {
          view = null;
        } else if (view && view.changes) {
          updateLineForChanges(cm, view, lineN, getDimensions(cm));
          cm.curOp.forceUpdate = true;
        }
        if (!view) {
          view = updateExternalMeasurement(cm, line);
        }
        var info = mapFromLineView(view, line, lineN);
        return {
          line,
          view,
          rect: null,
          map: info.map,
          cache: info.cache,
          before: info.before,
          hasHeights: false
        };
      }
      function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
        if (prepared.before) {
          ch = -1;
        }
        var key = ch + (bias || ""), found;
        if (prepared.cache.hasOwnProperty(key)) {
          found = prepared.cache[key];
        } else {
          if (!prepared.rect) {
            prepared.rect = prepared.view.text.getBoundingClientRect();
          }
          if (!prepared.hasHeights) {
            ensureLineHeights(cm, prepared.view, prepared.rect);
            prepared.hasHeights = true;
          }
          found = measureCharInner(cm, prepared, ch, bias);
          if (!found.bogus) {
            prepared.cache[key] = found;
          }
        }
        return {
          left: found.left,
          right: found.right,
          top: varHeight ? found.rtop : found.top,
          bottom: varHeight ? found.rbottom : found.bottom
        };
      }
      var nullRect = { left: 0, right: 0, top: 0, bottom: 0 };
      function nodeAndOffsetInLineMap(map3, ch, bias) {
        var node, start, end, collapse, mStart, mEnd;
        for (var i2 = 0; i2 < map3.length; i2 += 3) {
          mStart = map3[i2];
          mEnd = map3[i2 + 1];
          if (ch < mStart) {
            start = 0;
            end = 1;
            collapse = "left";
          } else if (ch < mEnd) {
            start = ch - mStart;
            end = start + 1;
          } else if (i2 == map3.length - 3 || ch == mEnd && map3[i2 + 3] > ch) {
            end = mEnd - mStart;
            start = end - 1;
            if (ch >= mEnd) {
              collapse = "right";
            }
          }
          if (start != null) {
            node = map3[i2 + 2];
            if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right")) {
              collapse = bias;
            }
            if (bias == "left" && start == 0) {
              while (i2 && map3[i2 - 2] == map3[i2 - 3] && map3[i2 - 1].insertLeft) {
                node = map3[(i2 -= 3) + 2];
                collapse = "left";
              }
            }
            if (bias == "right" && start == mEnd - mStart) {
              while (i2 < map3.length - 3 && map3[i2 + 3] == map3[i2 + 4] && !map3[i2 + 5].insertLeft) {
                node = map3[(i2 += 3) + 2];
                collapse = "right";
              }
            }
            break;
          }
        }
        return { node, start, end, collapse, coverStart: mStart, coverEnd: mEnd };
      }
      function getUsefulRect(rects, bias) {
        var rect = nullRect;
        if (bias == "left") {
          for (var i2 = 0; i2 < rects.length; i2++) {
            if ((rect = rects[i2]).left != rect.right) {
              break;
            }
          }
        } else {
          for (var i$12 = rects.length - 1; i$12 >= 0; i$12--) {
            if ((rect = rects[i$12]).left != rect.right) {
              break;
            }
          }
        }
        return rect;
      }
      function measureCharInner(cm, prepared, ch, bias) {
        var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
        var node = place.node, start = place.start, end = place.end, collapse = place.collapse;
        var rect;
        if (node.nodeType == 3) {
          for (var i$12 = 0; i$12 < 4; i$12++) {
            while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) {
              --start;
            }
            while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) {
              ++end;
            }
            if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart) {
              rect = node.parentNode.getBoundingClientRect();
            } else {
              rect = getUsefulRect(range(node, start, end).getClientRects(), bias);
            }
            if (rect.left || rect.right || start == 0) {
              break;
            }
            end = start;
            start = start - 1;
            collapse = "right";
          }
          if (ie && ie_version < 11) {
            rect = maybeUpdateRectForZooming(cm.display.measure, rect);
          }
        } else {
          if (start > 0) {
            collapse = bias = "right";
          }
          var rects;
          if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1) {
            rect = rects[bias == "right" ? rects.length - 1 : 0];
          } else {
            rect = node.getBoundingClientRect();
          }
        }
        if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
          var rSpan = node.parentNode.getClientRects()[0];
          if (rSpan) {
            rect = { left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom };
          } else {
            rect = nullRect;
          }
        }
        var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
        var mid = (rtop + rbot) / 2;
        var heights = prepared.view.measure.heights;
        var i2 = 0;
        for (; i2 < heights.length - 1; i2++) {
          if (mid < heights[i2]) {
            break;
          }
        }
        var top = i2 ? heights[i2 - 1] : 0, bot = heights[i2];
        var result = {
          left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
          right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
          top,
          bottom: bot
        };
        if (!rect.left && !rect.right) {
          result.bogus = true;
        }
        if (!cm.options.singleCursorHeightPerLine) {
          result.rtop = rtop;
          result.rbottom = rbot;
        }
        return result;
      }
      function maybeUpdateRectForZooming(measure, rect) {
        if (!window.screen || screen.logicalXDPI == null || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) {
          return rect;
        }
        var scaleX = screen.logicalXDPI / screen.deviceXDPI;
        var scaleY = screen.logicalYDPI / screen.deviceYDPI;
        return {
          left: rect.left * scaleX,
          right: rect.right * scaleX,
          top: rect.top * scaleY,
          bottom: rect.bottom * scaleY
        };
      }
      function clearLineMeasurementCacheFor(lineView) {
        if (lineView.measure) {
          lineView.measure.cache = {};
          lineView.measure.heights = null;
          if (lineView.rest) {
            for (var i2 = 0; i2 < lineView.rest.length; i2++) {
              lineView.measure.caches[i2] = {};
            }
          }
        }
      }
      function clearLineMeasurementCache(cm) {
        cm.display.externalMeasure = null;
        removeChildren(cm.display.lineMeasure);
        for (var i2 = 0; i2 < cm.display.view.length; i2++) {
          clearLineMeasurementCacheFor(cm.display.view[i2]);
        }
      }
      function clearCaches(cm) {
        clearLineMeasurementCache(cm);
        cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
        if (!cm.options.lineWrapping) {
          cm.display.maxLineChanged = true;
        }
        cm.display.lineNumChars = null;
      }
      function pageScrollX() {
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft));
        }
        return window.pageXOffset || (document.documentElement || document.body).scrollLeft;
      }
      function pageScrollY() {
        if (chrome && android) {
          return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop));
        }
        return window.pageYOffset || (document.documentElement || document.body).scrollTop;
      }
      function widgetTopHeight(lineObj) {
        var height = 0;
        if (lineObj.widgets) {
          for (var i2 = 0; i2 < lineObj.widgets.length; ++i2) {
            if (lineObj.widgets[i2].above) {
              height += widgetHeight(lineObj.widgets[i2]);
            }
          }
        }
        return height;
      }
      function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
        if (!includeWidgets) {
          var height = widgetTopHeight(lineObj);
          rect.top += height;
          rect.bottom += height;
        }
        if (context == "line") {
          return rect;
        }
        if (!context) {
          context = "local";
        }
        var yOff = heightAtLine(lineObj);
        if (context == "local") {
          yOff += paddingTop(cm.display);
        } else {
          yOff -= cm.display.viewOffset;
        }
        if (context == "page" || context == "window") {
          var lOff = cm.display.lineSpace.getBoundingClientRect();
          yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
          var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
          rect.left += xOff;
          rect.right += xOff;
        }
        rect.top += yOff;
        rect.bottom += yOff;
        return rect;
      }
      function fromCoordSystem(cm, coords, context) {
        if (context == "div") {
          return coords;
        }
        var left = coords.left, top = coords.top;
        if (context == "page") {
          left -= pageScrollX();
          top -= pageScrollY();
        } else if (context == "local" || !context) {
          var localBox = cm.display.sizer.getBoundingClientRect();
          left += localBox.left;
          top += localBox.top;
        }
        var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
        return { left: left - lineSpaceBox.left, top: top - lineSpaceBox.top };
      }
      function charCoords(cm, pos, context, lineObj, bias) {
        if (!lineObj) {
          lineObj = getLine(cm.doc, pos.line);
        }
        return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context);
      }
      function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
        lineObj = lineObj || getLine(cm.doc, pos.line);
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        function get3(ch2, right) {
          var m = measureCharPrepared(cm, preparedMeasure, ch2, right ? "right" : "left", varHeight);
          if (right) {
            m.left = m.right;
          } else {
            m.right = m.left;
          }
          return intoCoordSystem(cm, lineObj, m, context);
        }
        var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
        if (ch >= lineObj.text.length) {
          ch = lineObj.text.length;
          sticky = "before";
        } else if (ch <= 0) {
          ch = 0;
          sticky = "after";
        }
        if (!order) {
          return get3(sticky == "before" ? ch - 1 : ch, sticky == "before");
        }
        function getBidi(ch2, partPos2, invert) {
          var part = order[partPos2], right = part.level == 1;
          return get3(invert ? ch2 - 1 : ch2, right != invert);
        }
        var partPos = getBidiPartAt(order, ch, sticky);
        var other = bidiOther;
        var val = getBidi(ch, partPos, sticky == "before");
        if (other != null) {
          val.other = getBidi(ch, other, sticky != "before");
        }
        return val;
      }
      function estimateCoords(cm, pos) {
        var left = 0;
        pos = clipPos(cm.doc, pos);
        if (!cm.options.lineWrapping) {
          left = charWidth(cm.display) * pos.ch;
        }
        var lineObj = getLine(cm.doc, pos.line);
        var top = heightAtLine(lineObj) + paddingTop(cm.display);
        return { left, right: left, top, bottom: top + lineObj.height };
      }
      function PosWithInfo(line, ch, sticky, outside, xRel) {
        var pos = Pos(line, ch, sticky);
        pos.xRel = xRel;
        if (outside) {
          pos.outside = outside;
        }
        return pos;
      }
      function coordsChar(cm, x, y) {
        var doc = cm.doc;
        y += cm.display.viewOffset;
        if (y < 0) {
          return PosWithInfo(doc.first, 0, null, -1, -1);
        }
        var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
        if (lineN > last) {
          return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1);
        }
        if (x < 0) {
          x = 0;
        }
        var lineObj = getLine(doc, lineN);
        for (; ; ) {
          var found = coordsCharInner(cm, lineObj, lineN, x, y);
          var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
          if (!collapsed) {
            return found;
          }
          var rangeEnd = collapsed.find(1);
          if (rangeEnd.line == lineN) {
            return rangeEnd;
          }
          lineObj = getLine(doc, lineN = rangeEnd.line);
        }
      }
      function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
        y -= widgetTopHeight(lineObj);
        var end = lineObj.text.length;
        var begin = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y;
        }, end, 0);
        end = findFirst(function(ch) {
          return measureCharPrepared(cm, preparedMeasure, ch).top > y;
        }, begin, end);
        return { begin, end };
      }
      function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
        if (!preparedMeasure) {
          preparedMeasure = prepareMeasureForLine(cm, lineObj);
        }
        var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
        return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop);
      }
      function boxIsAfter(box, x, y, left) {
        return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x;
      }
      function coordsCharInner(cm, lineObj, lineNo2, x, y) {
        y -= heightAtLine(lineObj);
        var preparedMeasure = prepareMeasureForLine(cm, lineObj);
        var widgetHeight2 = widgetTopHeight(lineObj);
        var begin = 0, end = lineObj.text.length, ltr = true;
        var order = getOrder(lineObj, cm.doc.direction);
        if (order) {
          var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo2, preparedMeasure, order, x, y);
          ltr = part.level != 1;
          begin = ltr ? part.from : part.to - 1;
          end = ltr ? part.to : part.from - 1;
        }
        var chAround = null, boxAround = null;
        var ch = findFirst(function(ch2) {
          var box = measureCharPrepared(cm, preparedMeasure, ch2);
          box.top += widgetHeight2;
          box.bottom += widgetHeight2;
          if (!boxIsAfter(box, x, y, false)) {
            return false;
          }
          if (box.top <= y && box.left <= x) {
            chAround = ch2;
            boxAround = box;
          }
          return true;
        }, begin, end);
        var baseX, sticky, outside = false;
        if (boxAround) {
          var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
          ch = chAround + (atStart ? 0 : 1);
          sticky = atStart ? "after" : "before";
          baseX = atLeft ? boxAround.left : boxAround.right;
        } else {
          if (!ltr && (ch == end || ch == begin)) {
            ch++;
          }
          sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight2 <= y == ltr ? "after" : "before";
          var coords = cursorCoords(cm, Pos(lineNo2, ch, sticky), "line", lineObj, preparedMeasure);
          baseX = coords.left;
          outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
        }
        ch = skipExtendingChars(lineObj.text, ch, 1);
        return PosWithInfo(lineNo2, ch, sticky, outside, x - baseX);
      }
      function coordsBidiPart(cm, lineObj, lineNo2, preparedMeasure, order, x, y) {
        var index = findFirst(function(i2) {
          var part2 = order[i2], ltr2 = part2.level != 1;
          return boxIsAfter(cursorCoords(cm, Pos(lineNo2, ltr2 ? part2.to : part2.from, ltr2 ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, true);
        }, 0, order.length - 1);
        var part = order[index];
        if (index > 0) {
          var ltr = part.level != 1;
          var start = cursorCoords(cm, Pos(lineNo2, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
          if (boxIsAfter(start, x, y, true) && start.top > y) {
            part = order[index - 1];
          }
        }
        return part;
      }
      function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
        var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
        var begin = ref.begin;
        var end = ref.end;
        if (/\s/.test(lineObj.text.charAt(end - 1))) {
          end--;
        }
        var part = null, closestDist = null;
        for (var i2 = 0; i2 < order.length; i2++) {
          var p2 = order[i2];
          if (p2.from >= end || p2.to <= begin) {
            continue;
          }
          var ltr = p2.level != 1;
          var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p2.to) - 1 : Math.max(begin, p2.from)).right;
          var dist = endX < x ? x - endX + 1e9 : endX - x;
          if (!part || closestDist > dist) {
            part = p2;
            closestDist = dist;
          }
        }
        if (!part) {
          part = order[order.length - 1];
        }
        if (part.from < begin) {
          part = { from: begin, to: part.to, level: part.level };
        }
        if (part.to > end) {
          part = { from: part.from, to: end, level: part.level };
        }
        return part;
      }
      var measureText;
      function textHeight(display) {
        if (display.cachedTextHeight != null) {
          return display.cachedTextHeight;
        }
        if (measureText == null) {
          measureText = elt("pre", null, "CodeMirror-line-like");
          for (var i2 = 0; i2 < 49; ++i2) {
            measureText.appendChild(document.createTextNode("x"));
            measureText.appendChild(elt("br"));
          }
          measureText.appendChild(document.createTextNode("x"));
        }
        removeChildrenAndAdd(display.measure, measureText);
        var height = measureText.offsetHeight / 50;
        if (height > 3) {
          display.cachedTextHeight = height;
        }
        removeChildren(display.measure);
        return height || 1;
      }
      function charWidth(display) {
        if (display.cachedCharWidth != null) {
          return display.cachedCharWidth;
        }
        var anchor = elt("span", "xxxxxxxxxx");
        var pre = elt("pre", [anchor], "CodeMirror-line-like");
        removeChildrenAndAdd(display.measure, pre);
        var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
        if (width > 2) {
          display.cachedCharWidth = width;
        }
        return width || 10;
      }
      function getDimensions(cm) {
        var d = cm.display, left = {}, width = {};
        var gutterLeft = d.gutters.clientLeft;
        for (var n = d.gutters.firstChild, i2 = 0; n; n = n.nextSibling, ++i2) {
          var id = cm.display.gutterSpecs[i2].className;
          left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
          width[id] = n.clientWidth;
        }
        return {
          fixedPos: compensateForHScroll(d),
          gutterTotalWidth: d.gutters.offsetWidth,
          gutterLeft: left,
          gutterWidth: width,
          wrapperWidth: d.wrapper.clientWidth
        };
      }
      function compensateForHScroll(display) {
        return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left;
      }
      function estimateHeight(cm) {
        var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
        var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
        return function(line) {
          if (lineIsHidden(cm.doc, line)) {
            return 0;
          }
          var widgetsHeight = 0;
          if (line.widgets) {
            for (var i2 = 0; i2 < line.widgets.length; i2++) {
              if (line.widgets[i2].height) {
                widgetsHeight += line.widgets[i2].height;
              }
            }
          }
          if (wrapping) {
            return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th;
          } else {
            return widgetsHeight + th;
          }
        };
      }
      function estimateLineHeights(cm) {
        var doc = cm.doc, est = estimateHeight(cm);
        doc.iter(function(line) {
          var estHeight = est(line);
          if (estHeight != line.height) {
            updateLineHeight(line, estHeight);
          }
        });
      }
      function posFromMouse(cm, e, liberal, forRect) {
        var display = cm.display;
        if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") {
          return null;
        }
        var x, y, space = display.lineSpace.getBoundingClientRect();
        try {
          x = e.clientX - space.left;
          y = e.clientY - space.top;
        } catch (e$1) {
          return null;
        }
        var coords = coordsChar(cm, x, y), line;
        if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
          var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
          coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
        }
        return coords;
      }
      function findViewIndex(cm, n) {
        if (n >= cm.display.viewTo) {
          return null;
        }
        n -= cm.display.viewFrom;
        if (n < 0) {
          return null;
        }
        var view = cm.display.view;
        for (var i2 = 0; i2 < view.length; i2++) {
          n -= view[i2].size;
          if (n < 0) {
            return i2;
          }
        }
      }
      function regChange(cm, from, to, lendiff) {
        if (from == null) {
          from = cm.doc.first;
        }
        if (to == null) {
          to = cm.doc.first + cm.doc.size;
        }
        if (!lendiff) {
          lendiff = 0;
        }
        var display = cm.display;
        if (lendiff && to < display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers > from)) {
          display.updateLineNumbers = from;
        }
        cm.curOp.viewChanged = true;
        if (from >= display.viewTo) {
          if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo) {
            resetView(cm);
          }
        } else if (to <= display.viewFrom) {
          if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
            resetView(cm);
          } else {
            display.viewFrom += lendiff;
            display.viewTo += lendiff;
          }
        } else if (from <= display.viewFrom && to >= display.viewTo) {
          resetView(cm);
        } else if (from <= display.viewFrom) {
          var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cut) {
            display.view = display.view.slice(cut.index);
            display.viewFrom = cut.lineN;
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        } else if (to >= display.viewTo) {
          var cut$1 = viewCuttingPoint(cm, from, from, -1);
          if (cut$1) {
            display.view = display.view.slice(0, cut$1.index);
            display.viewTo = cut$1.lineN;
          } else {
            resetView(cm);
          }
        } else {
          var cutTop = viewCuttingPoint(cm, from, from, -1);
          var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
          if (cutTop && cutBot) {
            display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index));
            display.viewTo += lendiff;
          } else {
            resetView(cm);
          }
        }
        var ext = display.externalMeasured;
        if (ext) {
          if (to < ext.lineN) {
            ext.lineN += lendiff;
          } else if (from < ext.lineN + ext.size) {
            display.externalMeasured = null;
          }
        }
      }
      function regLineChange(cm, line, type2) {
        cm.curOp.viewChanged = true;
        var display = cm.display, ext = cm.display.externalMeasured;
        if (ext && line >= ext.lineN && line < ext.lineN + ext.size) {
          display.externalMeasured = null;
        }
        if (line < display.viewFrom || line >= display.viewTo) {
          return;
        }
        var lineView = display.view[findViewIndex(cm, line)];
        if (lineView.node == null) {
          return;
        }
        var arr = lineView.changes || (lineView.changes = []);
        if (indexOf(arr, type2) == -1) {
          arr.push(type2);
        }
      }
      function resetView(cm) {
        cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
        cm.display.view = [];
        cm.display.viewOffset = 0;
      }
      function viewCuttingPoint(cm, oldN, newN, dir) {
        var index = findViewIndex(cm, oldN), diff2, view = cm.display.view;
        if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) {
          return { index, lineN: newN };
        }
        var n = cm.display.viewFrom;
        for (var i2 = 0; i2 < index; i2++) {
          n += view[i2].size;
        }
        if (n != oldN) {
          if (dir > 0) {
            if (index == view.length - 1) {
              return null;
            }
            diff2 = n + view[index].size - oldN;
            index++;
          } else {
            diff2 = n - oldN;
          }
          oldN += diff2;
          newN += diff2;
        }
        while (visualLineNo(cm.doc, newN) != newN) {
          if (index == (dir < 0 ? 0 : view.length - 1)) {
            return null;
          }
          newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
          index += dir;
        }
        return { index, lineN: newN };
      }
      function adjustView(cm, from, to) {
        var display = cm.display, view = display.view;
        if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
          display.view = buildViewArray(cm, from, to);
          display.viewFrom = from;
        } else {
          if (display.viewFrom > from) {
            display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view);
          } else if (display.viewFrom < from) {
            display.view = display.view.slice(findViewIndex(cm, from));
          }
          display.viewFrom = from;
          if (display.viewTo < to) {
            display.view = display.view.concat(buildViewArray(cm, display.viewTo, to));
          } else if (display.viewTo > to) {
            display.view = display.view.slice(0, findViewIndex(cm, to));
          }
        }
        display.viewTo = to;
      }
      function countDirtyView(cm) {
        var view = cm.display.view, dirty = 0;
        for (var i2 = 0; i2 < view.length; i2++) {
          var lineView = view[i2];
          if (!lineView.hidden && (!lineView.node || lineView.changes)) {
            ++dirty;
          }
        }
        return dirty;
      }
      function updateSelection(cm) {
        cm.display.input.showSelection(cm.display.input.prepareSelection());
      }
      function prepareSelection(cm, primary) {
        if (primary === void 0)
          primary = true;
        var doc = cm.doc, result = {};
        var curFragment = result.cursors = document.createDocumentFragment();
        var selFragment = result.selection = document.createDocumentFragment();
        for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
          if (!primary && i2 == doc.sel.primIndex) {
            continue;
          }
          var range2 = doc.sel.ranges[i2];
          if (range2.from().line >= cm.display.viewTo || range2.to().line < cm.display.viewFrom) {
            continue;
          }
          var collapsed = range2.empty();
          if (collapsed || cm.options.showCursorWhenSelecting) {
            drawSelectionCursor(cm, range2.head, curFragment);
          }
          if (!collapsed) {
            drawSelectionRange(cm, range2, selFragment);
          }
        }
        return result;
      }
      function drawSelectionCursor(cm, head, output) {
        var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);
        var cursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor"));
        cursor.style.left = pos.left + "px";
        cursor.style.top = pos.top + "px";
        cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";
        if (/\bcm-fat-cursor\b/.test(cm.getWrapperElement().className)) {
          var charPos = charCoords(cm, head, "div", null, null);
          if (charPos.right - charPos.left > 0) {
            cursor.style.width = charPos.right - charPos.left + "px";
          }
        }
        if (pos.other) {
          var otherCursor = output.appendChild(elt("div", "\xA0", "CodeMirror-cursor CodeMirror-secondarycursor"));
          otherCursor.style.display = "";
          otherCursor.style.left = pos.other.left + "px";
          otherCursor.style.top = pos.other.top + "px";
          otherCursor.style.height = (pos.other.bottom - pos.other.top) * 0.85 + "px";
        }
      }
      function cmpCoords(a, b) {
        return a.top - b.top || a.left - b.left;
      }
      function drawSelectionRange(cm, range2, output) {
        var display = cm.display, doc = cm.doc;
        var fragment = document.createDocumentFragment();
        var padding = paddingH(cm.display), leftSide = padding.left;
        var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
        var docLTR = doc.direction == "ltr";
        function add(left, top, width, bottom) {
          if (top < 0) {
            top = 0;
          }
          top = Math.round(top);
          bottom = Math.round(bottom);
          fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"));
        }
        function drawForLine(line, fromArg, toArg) {
          var lineObj = getLine(doc, line);
          var lineLen = lineObj.text.length;
          var start, end;
          function coords(ch, bias) {
            return charCoords(cm, Pos(line, ch), "div", lineObj, bias);
          }
          function wrapX(pos, dir, side) {
            var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
            var prop2 = dir == "ltr" == (side == "after") ? "left" : "right";
            var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
            return coords(ch, prop2)[prop2];
          }
          var order = getOrder(lineObj, doc.direction);
          iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function(from, to, dir, i2) {
            var ltr = dir == "ltr";
            var fromPos = coords(from, ltr ? "left" : "right");
            var toPos = coords(to - 1, ltr ? "right" : "left");
            var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
            var first = i2 == 0, last = !order || i2 == order.length - 1;
            if (toPos.top - fromPos.top <= 3) {
              var openLeft = (docLTR ? openStart : openEnd) && first;
              var openRight = (docLTR ? openEnd : openStart) && last;
              var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
              var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
              add(left, fromPos.top, right - left, fromPos.bottom);
            } else {
              var topLeft, topRight, botLeft, botRight;
              if (ltr) {
                topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
                topRight = docLTR ? rightSide : wrapX(from, dir, "before");
                botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
                botRight = docLTR && openEnd && last ? rightSide : toPos.right;
              } else {
                topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
                topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
                botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
                botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
              }
              add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
              if (fromPos.bottom < toPos.top) {
                add(leftSide, fromPos.bottom, null, toPos.top);
              }
              add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
            }
            if (!start || cmpCoords(fromPos, start) < 0) {
              start = fromPos;
            }
            if (cmpCoords(toPos, start) < 0) {
              start = toPos;
            }
            if (!end || cmpCoords(fromPos, end) < 0) {
              end = fromPos;
            }
            if (cmpCoords(toPos, end) < 0) {
              end = toPos;
            }
          });
          return { start, end };
        }
        var sFrom = range2.from(), sTo = range2.to();
        if (sFrom.line == sTo.line) {
          drawForLine(sFrom.line, sFrom.ch, sTo.ch);
        } else {
          var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
          var singleVLine = visualLine(fromLine) == visualLine(toLine);
          var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
          var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
          if (singleVLine) {
            if (leftEnd.top < rightStart.top - 2) {
              add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
              add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
            } else {
              add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
            }
          }
          if (leftEnd.bottom < rightStart.top) {
            add(leftSide, leftEnd.bottom, null, rightStart.top);
          }
        }
        output.appendChild(fragment);
      }
      function restartBlink(cm) {
        if (!cm.state.focused) {
          return;
        }
        var display = cm.display;
        clearInterval(display.blinker);
        var on2 = true;
        display.cursorDiv.style.visibility = "";
        if (cm.options.cursorBlinkRate > 0) {
          display.blinker = setInterval(function() {
            if (!cm.hasFocus()) {
              onBlur(cm);
            }
            display.cursorDiv.style.visibility = (on2 = !on2) ? "" : "hidden";
          }, cm.options.cursorBlinkRate);
        } else if (cm.options.cursorBlinkRate < 0) {
          display.cursorDiv.style.visibility = "hidden";
        }
      }
      function ensureFocus(cm) {
        if (!cm.hasFocus()) {
          cm.display.input.focus();
          if (!cm.state.focused) {
            onFocus(cm);
          }
        }
      }
      function delayBlurEvent(cm) {
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          if (cm.state.delayingBlurEvent) {
            cm.state.delayingBlurEvent = false;
            if (cm.state.focused) {
              onBlur(cm);
            }
          }
        }, 100);
      }
      function onFocus(cm, e) {
        if (cm.state.delayingBlurEvent && !cm.state.draggingText) {
          cm.state.delayingBlurEvent = false;
        }
        if (cm.options.readOnly == "nocursor") {
          return;
        }
        if (!cm.state.focused) {
          signal(cm, "focus", cm, e);
          cm.state.focused = true;
          addClass(cm.display.wrapper, "CodeMirror-focused");
          if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
            cm.display.input.reset();
            if (webkit) {
              setTimeout(function() {
                return cm.display.input.reset(true);
              }, 20);
            }
          }
          cm.display.input.receivedFocus();
        }
        restartBlink(cm);
      }
      function onBlur(cm, e) {
        if (cm.state.delayingBlurEvent) {
          return;
        }
        if (cm.state.focused) {
          signal(cm, "blur", cm, e);
          cm.state.focused = false;
          rmClass(cm.display.wrapper, "CodeMirror-focused");
        }
        clearInterval(cm.display.blinker);
        setTimeout(function() {
          if (!cm.state.focused) {
            cm.display.shift = false;
          }
        }, 150);
      }
      function updateHeightsInViewport(cm) {
        var display = cm.display;
        var prevBottom = display.lineDiv.offsetTop;
        var viewTop = Math.max(0, display.scroller.getBoundingClientRect().top);
        var oldHeight = display.lineDiv.getBoundingClientRect().top;
        var mustScroll = 0;
        for (var i2 = 0; i2 < display.view.length; i2++) {
          var cur = display.view[i2], wrapping = cm.options.lineWrapping;
          var height = void 0, width = 0;
          if (cur.hidden) {
            continue;
          }
          oldHeight += cur.line.height;
          if (ie && ie_version < 8) {
            var bot = cur.node.offsetTop + cur.node.offsetHeight;
            height = bot - prevBottom;
            prevBottom = bot;
          } else {
            var box = cur.node.getBoundingClientRect();
            height = box.bottom - box.top;
            if (!wrapping && cur.text.firstChild) {
              width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1;
            }
          }
          var diff2 = cur.line.height - height;
          if (diff2 > 5e-3 || diff2 < -5e-3) {
            if (oldHeight < viewTop) {
              mustScroll -= diff2;
            }
            updateLineHeight(cur.line, height);
            updateWidgetHeight(cur.line);
            if (cur.rest) {
              for (var j = 0; j < cur.rest.length; j++) {
                updateWidgetHeight(cur.rest[j]);
              }
            }
          }
          if (width > cm.display.sizerWidth) {
            var chWidth = Math.ceil(width / charWidth(cm.display));
            if (chWidth > cm.display.maxLineLength) {
              cm.display.maxLineLength = chWidth;
              cm.display.maxLine = cur.line;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (Math.abs(mustScroll) > 2) {
          display.scroller.scrollTop += mustScroll;
        }
      }
      function updateWidgetHeight(line) {
        if (line.widgets) {
          for (var i2 = 0; i2 < line.widgets.length; ++i2) {
            var w = line.widgets[i2], parent = w.node.parentNode;
            if (parent) {
              w.height = parent.offsetHeight;
            }
          }
        }
      }
      function visibleLines(display, doc, viewport) {
        var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
        top = Math.floor(top - paddingTop(display));
        var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;
        var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
        if (viewport && viewport.ensure) {
          var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
          if (ensureFrom < from) {
            from = ensureFrom;
            to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
          } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
            from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
            to = ensureTo;
          }
        }
        return { from, to: Math.max(to, from + 1) };
      }
      function maybeScrollWindow(cm, rect) {
        if (signalDOMEvent(cm, "scrollCursorIntoView")) {
          return;
        }
        var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
        if (rect.top + box.top < 0) {
          doScroll = true;
        } else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) {
          doScroll = false;
        }
        if (doScroll != null && !phantom) {
          var scrollNode = elt("div", "\u200B", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
          cm.display.lineSpace.appendChild(scrollNode);
          scrollNode.scrollIntoView(doScroll);
          cm.display.lineSpace.removeChild(scrollNode);
        }
      }
      function scrollPosIntoView(cm, pos, end, margin) {
        if (margin == null) {
          margin = 0;
        }
        var rect;
        if (!cm.options.lineWrapping && pos == end) {
          end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
          pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
        }
        for (var limit = 0; limit < 5; limit++) {
          var changed = false;
          var coords = cursorCoords(cm, pos);
          var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
          rect = {
            left: Math.min(coords.left, endCoords.left),
            top: Math.min(coords.top, endCoords.top) - margin,
            right: Math.max(coords.left, endCoords.left),
            bottom: Math.max(coords.bottom, endCoords.bottom) + margin
          };
          var scrollPos = calculateScrollPos(cm, rect);
          var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
          if (scrollPos.scrollTop != null) {
            updateScrollTop(cm, scrollPos.scrollTop);
            if (Math.abs(cm.doc.scrollTop - startTop) > 1) {
              changed = true;
            }
          }
          if (scrollPos.scrollLeft != null) {
            setScrollLeft(cm, scrollPos.scrollLeft);
            if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) {
              changed = true;
            }
          }
          if (!changed) {
            break;
          }
        }
        return rect;
      }
      function scrollIntoView(cm, rect) {
        var scrollPos = calculateScrollPos(cm, rect);
        if (scrollPos.scrollTop != null) {
          updateScrollTop(cm, scrollPos.scrollTop);
        }
        if (scrollPos.scrollLeft != null) {
          setScrollLeft(cm, scrollPos.scrollLeft);
        }
      }
      function calculateScrollPos(cm, rect) {
        var display = cm.display, snapMargin = textHeight(cm.display);
        if (rect.top < 0) {
          rect.top = 0;
        }
        var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
        var screen2 = displayHeight(cm), result = {};
        if (rect.bottom - rect.top > screen2) {
          rect.bottom = rect.top + screen2;
        }
        var docBottom = cm.doc.height + paddingVert(display);
        var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
        if (rect.top < screentop) {
          result.scrollTop = atTop ? 0 : rect.top;
        } else if (rect.bottom > screentop + screen2) {
          var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen2);
          if (newTop != screentop) {
            result.scrollTop = newTop;
          }
        }
        var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
        var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
        var screenw = displayWidth(cm) - display.gutters.offsetWidth;
        var tooWide = rect.right - rect.left > screenw;
        if (tooWide) {
          rect.right = rect.left + screenw;
        }
        if (rect.left < 10) {
          result.scrollLeft = 0;
        } else if (rect.left < screenleft) {
          result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10));
        } else if (rect.right > screenw + screenleft - 3) {
          result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw;
        }
        return result;
      }
      function addToScrollTop(cm, top) {
        if (top == null) {
          return;
        }
        resolveScrollToPos(cm);
        cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
      }
      function ensureCursorVisible(cm) {
        resolveScrollToPos(cm);
        var cur = cm.getCursor();
        cm.curOp.scrollToPos = { from: cur, to: cur, margin: cm.options.cursorScrollMargin };
      }
      function scrollToCoords(cm, x, y) {
        if (x != null || y != null) {
          resolveScrollToPos(cm);
        }
        if (x != null) {
          cm.curOp.scrollLeft = x;
        }
        if (y != null) {
          cm.curOp.scrollTop = y;
        }
      }
      function scrollToRange(cm, range2) {
        resolveScrollToPos(cm);
        cm.curOp.scrollToPos = range2;
      }
      function resolveScrollToPos(cm) {
        var range2 = cm.curOp.scrollToPos;
        if (range2) {
          cm.curOp.scrollToPos = null;
          var from = estimateCoords(cm, range2.from), to = estimateCoords(cm, range2.to);
          scrollToCoordsRange(cm, from, to, range2.margin);
        }
      }
      function scrollToCoordsRange(cm, from, to, margin) {
        var sPos = calculateScrollPos(cm, {
          left: Math.min(from.left, to.left),
          top: Math.min(from.top, to.top) - margin,
          right: Math.max(from.right, to.right),
          bottom: Math.max(from.bottom, to.bottom) + margin
        });
        scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
      }
      function updateScrollTop(cm, val) {
        if (Math.abs(cm.doc.scrollTop - val) < 2) {
          return;
        }
        if (!gecko) {
          updateDisplaySimple(cm, { top: val });
        }
        setScrollTop(cm, val, true);
        if (gecko) {
          updateDisplaySimple(cm);
        }
        startWorker(cm, 100);
      }
      function setScrollTop(cm, val, forceScroll) {
        val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
        if (cm.display.scroller.scrollTop == val && !forceScroll) {
          return;
        }
        cm.doc.scrollTop = val;
        cm.display.scrollbars.setScrollTop(val);
        if (cm.display.scroller.scrollTop != val) {
          cm.display.scroller.scrollTop = val;
        }
      }
      function setScrollLeft(cm, val, isScroller, forceScroll) {
        val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
        if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) {
          return;
        }
        cm.doc.scrollLeft = val;
        alignHorizontally(cm);
        if (cm.display.scroller.scrollLeft != val) {
          cm.display.scroller.scrollLeft = val;
        }
        cm.display.scrollbars.setScrollLeft(val);
      }
      function measureForScrollbars(cm) {
        var d = cm.display, gutterW = d.gutters.offsetWidth;
        var docH = Math.round(cm.doc.height + paddingVert(cm.display));
        return {
          clientHeight: d.scroller.clientHeight,
          viewHeight: d.wrapper.clientHeight,
          scrollWidth: d.scroller.scrollWidth,
          clientWidth: d.scroller.clientWidth,
          viewWidth: d.wrapper.clientWidth,
          barLeft: cm.options.fixedGutter ? gutterW : 0,
          docHeight: docH,
          scrollHeight: docH + scrollGap(cm) + d.barHeight,
          nativeBarWidth: d.nativeBarWidth,
          gutterWidth: gutterW
        };
      }
      var NativeScrollbars = function(place, scroll, cm) {
        this.cm = cm;
        var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
        var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
        vert.tabIndex = horiz.tabIndex = -1;
        place(vert);
        place(horiz);
        on(vert, "scroll", function() {
          if (vert.clientHeight) {
            scroll(vert.scrollTop, "vertical");
          }
        });
        on(horiz, "scroll", function() {
          if (horiz.clientWidth) {
            scroll(horiz.scrollLeft, "horizontal");
          }
        });
        this.checkedZeroWidth = false;
        if (ie && ie_version < 8) {
          this.horiz.style.minHeight = this.vert.style.minWidth = "18px";
        }
      };
      NativeScrollbars.prototype.update = function(measure) {
        var needsH = measure.scrollWidth > measure.clientWidth + 1;
        var needsV = measure.scrollHeight > measure.clientHeight + 1;
        var sWidth = measure.nativeBarWidth;
        if (needsV) {
          this.vert.style.display = "block";
          this.vert.style.bottom = needsH ? sWidth + "px" : "0";
          var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
          this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
        } else {
          this.vert.style.display = "";
          this.vert.firstChild.style.height = "0";
        }
        if (needsH) {
          this.horiz.style.display = "block";
          this.horiz.style.right = needsV ? sWidth + "px" : "0";
          this.horiz.style.left = measure.barLeft + "px";
          var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
          this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
        } else {
          this.horiz.style.display = "";
          this.horiz.firstChild.style.width = "0";
        }
        if (!this.checkedZeroWidth && measure.clientHeight > 0) {
          if (sWidth == 0) {
            this.zeroWidthHack();
          }
          this.checkedZeroWidth = true;
        }
        return { right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0 };
      };
      NativeScrollbars.prototype.setScrollLeft = function(pos) {
        if (this.horiz.scrollLeft != pos) {
          this.horiz.scrollLeft = pos;
        }
        if (this.disableHoriz) {
          this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz");
        }
      };
      NativeScrollbars.prototype.setScrollTop = function(pos) {
        if (this.vert.scrollTop != pos) {
          this.vert.scrollTop = pos;
        }
        if (this.disableVert) {
          this.enableZeroWidthBar(this.vert, this.disableVert, "vert");
        }
      };
      NativeScrollbars.prototype.zeroWidthHack = function() {
        var w = mac && !mac_geMountainLion ? "12px" : "18px";
        this.horiz.style.height = this.vert.style.width = w;
        this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
        this.disableHoriz = new Delayed();
        this.disableVert = new Delayed();
      };
      NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type2) {
        bar.style.pointerEvents = "auto";
        function maybeDisable() {
          var box = bar.getBoundingClientRect();
          var elt2 = type2 == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
          if (elt2 != bar) {
            bar.style.pointerEvents = "none";
          } else {
            delay.set(1e3, maybeDisable);
          }
        }
        delay.set(1e3, maybeDisable);
      };
      NativeScrollbars.prototype.clear = function() {
        var parent = this.horiz.parentNode;
        parent.removeChild(this.horiz);
        parent.removeChild(this.vert);
      };
      var NullScrollbars = function() {
      };
      NullScrollbars.prototype.update = function() {
        return { bottom: 0, right: 0 };
      };
      NullScrollbars.prototype.setScrollLeft = function() {
      };
      NullScrollbars.prototype.setScrollTop = function() {
      };
      NullScrollbars.prototype.clear = function() {
      };
      function updateScrollbars(cm, measure) {
        if (!measure) {
          measure = measureForScrollbars(cm);
        }
        var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
        updateScrollbarsInner(cm, measure);
        for (var i2 = 0; i2 < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i2++) {
          if (startWidth != cm.display.barWidth && cm.options.lineWrapping) {
            updateHeightsInViewport(cm);
          }
          updateScrollbarsInner(cm, measureForScrollbars(cm));
          startWidth = cm.display.barWidth;
          startHeight = cm.display.barHeight;
        }
      }
      function updateScrollbarsInner(cm, measure) {
        var d = cm.display;
        var sizes = d.scrollbars.update(measure);
        d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
        d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
        d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";
        if (sizes.right && sizes.bottom) {
          d.scrollbarFiller.style.display = "block";
          d.scrollbarFiller.style.height = sizes.bottom + "px";
          d.scrollbarFiller.style.width = sizes.right + "px";
        } else {
          d.scrollbarFiller.style.display = "";
        }
        if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
          d.gutterFiller.style.display = "block";
          d.gutterFiller.style.height = sizes.bottom + "px";
          d.gutterFiller.style.width = measure.gutterWidth + "px";
        } else {
          d.gutterFiller.style.display = "";
        }
      }
      var scrollbarModel = { "native": NativeScrollbars, "null": NullScrollbars };
      function initScrollbars(cm) {
        if (cm.display.scrollbars) {
          cm.display.scrollbars.clear();
          if (cm.display.scrollbars.addClass) {
            rmClass(cm.display.wrapper, cm.display.scrollbars.addClass);
          }
        }
        cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
          cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
          on(node, "mousedown", function() {
            if (cm.state.focused) {
              setTimeout(function() {
                return cm.display.input.focus();
              }, 0);
            }
          });
          node.setAttribute("cm-not-content", "true");
        }, function(pos, axis) {
          if (axis == "horizontal") {
            setScrollLeft(cm, pos);
          } else {
            updateScrollTop(cm, pos);
          }
        }, cm);
        if (cm.display.scrollbars.addClass) {
          addClass(cm.display.wrapper, cm.display.scrollbars.addClass);
        }
      }
      var nextOpId = 0;
      function startOperation(cm) {
        cm.curOp = {
          cm,
          viewChanged: false,
          startHeight: cm.doc.height,
          forceUpdate: false,
          updateInput: 0,
          typing: false,
          changeObjs: null,
          cursorActivityHandlers: null,
          cursorActivityCalled: 0,
          selectionChanged: false,
          updateMaxLine: false,
          scrollLeft: null,
          scrollTop: null,
          scrollToPos: null,
          focus: false,
          id: ++nextOpId,
          markArrays: null
        };
        pushOperation(cm.curOp);
      }
      function endOperation(cm) {
        var op = cm.curOp;
        if (op) {
          finishOperation(op, function(group) {
            for (var i2 = 0; i2 < group.ops.length; i2++) {
              group.ops[i2].cm.curOp = null;
            }
            endOperations(group);
          });
        }
      }
      function endOperations(group) {
        var ops = group.ops;
        for (var i2 = 0; i2 < ops.length; i2++) {
          endOperation_R1(ops[i2]);
        }
        for (var i$12 = 0; i$12 < ops.length; i$12++) {
          endOperation_W1(ops[i$12]);
        }
        for (var i$22 = 0; i$22 < ops.length; i$22++) {
          endOperation_R2(ops[i$22]);
        }
        for (var i$3 = 0; i$3 < ops.length; i$3++) {
          endOperation_W2(ops[i$3]);
        }
        for (var i$4 = 0; i$4 < ops.length; i$4++) {
          endOperation_finish(ops[i$4]);
        }
      }
      function endOperation_R1(op) {
        var cm = op.cm, display = cm.display;
        maybeClipScrollbars(cm);
        if (op.updateMaxLine) {
          findMaxLine(cm);
        }
        op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping;
        op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && { top: op.scrollTop, ensure: op.scrollToPos }, op.forceUpdate);
      }
      function endOperation_W1(op) {
        op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
      }
      function endOperation_R2(op) {
        var cm = op.cm, display = cm.display;
        if (op.updatedDisplay) {
          updateHeightsInViewport(cm);
        }
        op.barMeasure = measureForScrollbars(cm);
        if (display.maxLineChanged && !cm.options.lineWrapping) {
          op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
          cm.display.sizerWidth = op.adjustWidthTo;
          op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
          op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
        }
        if (op.updatedDisplay || op.selectionChanged) {
          op.preparedSelection = display.input.prepareSelection();
        }
      }
      function endOperation_W2(op) {
        var cm = op.cm;
        if (op.adjustWidthTo != null) {
          cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
          if (op.maxScrollLeft < cm.doc.scrollLeft) {
            setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true);
          }
          cm.display.maxLineChanged = false;
        }
        var takeFocus = op.focus && op.focus == activeElt();
        if (op.preparedSelection) {
          cm.display.input.showSelection(op.preparedSelection, takeFocus);
        }
        if (op.updatedDisplay || op.startHeight != cm.doc.height) {
          updateScrollbars(cm, op.barMeasure);
        }
        if (op.updatedDisplay) {
          setDocumentHeight(cm, op.barMeasure);
        }
        if (op.selectionChanged) {
          restartBlink(cm);
        }
        if (cm.state.focused && op.updateInput) {
          cm.display.input.reset(op.typing);
        }
        if (takeFocus) {
          ensureFocus(op.cm);
        }
      }
      function endOperation_finish(op) {
        var cm = op.cm, display = cm.display, doc = cm.doc;
        if (op.updatedDisplay) {
          postUpdateDisplay(cm, op.update);
        }
        if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos)) {
          display.wheelStartX = display.wheelStartY = null;
        }
        if (op.scrollTop != null) {
          setScrollTop(cm, op.scrollTop, op.forceScroll);
        }
        if (op.scrollLeft != null) {
          setScrollLeft(cm, op.scrollLeft, true, true);
        }
        if (op.scrollToPos) {
          var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from), clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
          maybeScrollWindow(cm, rect);
        }
        var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
        if (hidden) {
          for (var i2 = 0; i2 < hidden.length; ++i2) {
            if (!hidden[i2].lines.length) {
              signal(hidden[i2], "hide");
            }
          }
        }
        if (unhidden) {
          for (var i$12 = 0; i$12 < unhidden.length; ++i$12) {
            if (unhidden[i$12].lines.length) {
              signal(unhidden[i$12], "unhide");
            }
          }
        }
        if (display.wrapper.offsetHeight) {
          doc.scrollTop = cm.display.scroller.scrollTop;
        }
        if (op.changeObjs) {
          signal(cm, "changes", cm, op.changeObjs);
        }
        if (op.update) {
          op.update.finish();
        }
      }
      function runInOp(cm, f) {
        if (cm.curOp) {
          return f();
        }
        startOperation(cm);
        try {
          return f();
        } finally {
          endOperation(cm);
        }
      }
      function operation(cm, f) {
        return function() {
          if (cm.curOp) {
            return f.apply(cm, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(cm, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function methodOp(f) {
        return function() {
          if (this.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(this);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(this);
          }
        };
      }
      function docMethodOp(f) {
        return function() {
          var cm = this.cm;
          if (!cm || cm.curOp) {
            return f.apply(this, arguments);
          }
          startOperation(cm);
          try {
            return f.apply(this, arguments);
          } finally {
            endOperation(cm);
          }
        };
      }
      function startWorker(cm, time) {
        if (cm.doc.highlightFrontier < cm.display.viewTo) {
          cm.state.highlight.set(time, bind(highlightWorker, cm));
        }
      }
      function highlightWorker(cm) {
        var doc = cm.doc;
        if (doc.highlightFrontier >= cm.display.viewTo) {
          return;
        }
        var end = +new Date() + cm.options.workTime;
        var context = getContextBefore(cm, doc.highlightFrontier);
        var changedLines = [];
        doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
          if (context.line >= cm.display.viewFrom) {
            var oldStyles = line.styles;
            var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
            var highlighted = highlightLine(cm, line, context, true);
            if (resetState) {
              context.state = resetState;
            }
            line.styles = highlighted.styles;
            var oldCls = line.styleClasses, newCls = highlighted.classes;
            if (newCls) {
              line.styleClasses = newCls;
            } else if (oldCls) {
              line.styleClasses = null;
            }
            var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
            for (var i2 = 0; !ischange && i2 < oldStyles.length; ++i2) {
              ischange = oldStyles[i2] != line.styles[i2];
            }
            if (ischange) {
              changedLines.push(context.line);
            }
            line.stateAfter = context.save();
            context.nextLine();
          } else {
            if (line.text.length <= cm.options.maxHighlightLength) {
              processLine(cm, line.text, context);
            }
            line.stateAfter = context.line % 5 == 0 ? context.save() : null;
            context.nextLine();
          }
          if (+new Date() > end) {
            startWorker(cm, cm.options.workDelay);
            return true;
          }
        });
        doc.highlightFrontier = context.line;
        doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
        if (changedLines.length) {
          runInOp(cm, function() {
            for (var i2 = 0; i2 < changedLines.length; i2++) {
              regLineChange(cm, changedLines[i2], "text");
            }
          });
        }
      }
      var DisplayUpdate = function(cm, viewport, force) {
        var display = cm.display;
        this.viewport = viewport;
        this.visible = visibleLines(display, cm.doc, viewport);
        this.editorIsHidden = !display.wrapper.offsetWidth;
        this.wrapperHeight = display.wrapper.clientHeight;
        this.wrapperWidth = display.wrapper.clientWidth;
        this.oldDisplayWidth = displayWidth(cm);
        this.force = force;
        this.dims = getDimensions(cm);
        this.events = [];
      };
      DisplayUpdate.prototype.signal = function(emitter, type2) {
        if (hasHandler(emitter, type2)) {
          this.events.push(arguments);
        }
      };
      DisplayUpdate.prototype.finish = function() {
        for (var i2 = 0; i2 < this.events.length; i2++) {
          signal.apply(null, this.events[i2]);
        }
      };
      function maybeClipScrollbars(cm) {
        var display = cm.display;
        if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
          display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
          display.heightForcer.style.height = scrollGap(cm) + "px";
          display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
          display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
          display.scrollbarsClipped = true;
        }
      }
      function selectionSnapshot(cm) {
        if (cm.hasFocus()) {
          return null;
        }
        var active = activeElt();
        if (!active || !contains(cm.display.lineDiv, active)) {
          return null;
        }
        var result = { activeElt: active };
        if (window.getSelection) {
          var sel = window.getSelection();
          if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
            result.anchorNode = sel.anchorNode;
            result.anchorOffset = sel.anchorOffset;
            result.focusNode = sel.focusNode;
            result.focusOffset = sel.focusOffset;
          }
        }
        return result;
      }
      function restoreSelection(snapshot) {
        if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) {
          return;
        }
        snapshot.activeElt.focus();
        if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) && snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
          var sel = window.getSelection(), range2 = document.createRange();
          range2.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
          range2.collapse(false);
          sel.removeAllRanges();
          sel.addRange(range2);
          sel.extend(snapshot.focusNode, snapshot.focusOffset);
        }
      }
      function updateDisplayIfNeeded(cm, update) {
        var display = cm.display, doc = cm.doc;
        if (update.editorIsHidden) {
          resetView(cm);
          return false;
        }
        if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && countDirtyView(cm) == 0) {
          return false;
        }
        if (maybeUpdateLineNumberWidth(cm)) {
          resetView(cm);
          update.dims = getDimensions(cm);
        }
        var end = doc.first + doc.size;
        var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
        var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
        if (display.viewFrom < from && from - display.viewFrom < 20) {
          from = Math.max(doc.first, display.viewFrom);
        }
        if (display.viewTo > to && display.viewTo - to < 20) {
          to = Math.min(end, display.viewTo);
        }
        if (sawCollapsedSpans) {
          from = visualLineNo(cm.doc, from);
          to = visualLineEndNo(cm.doc, to);
        }
        var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
        adjustView(cm, from, to);
        display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
        cm.display.mover.style.top = display.viewOffset + "px";
        var toUpdate = countDirtyView(cm);
        if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view && (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo)) {
          return false;
        }
        var selSnapshot = selectionSnapshot(cm);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "none";
        }
        patchDisplay(cm, display.updateLineNumbers, update.dims);
        if (toUpdate > 4) {
          display.lineDiv.style.display = "";
        }
        display.renderedView = display.view;
        restoreSelection(selSnapshot);
        removeChildren(display.cursorDiv);
        removeChildren(display.selectionDiv);
        display.gutters.style.height = display.sizer.style.minHeight = 0;
        if (different) {
          display.lastWrapHeight = update.wrapperHeight;
          display.lastWrapWidth = update.wrapperWidth;
          startWorker(cm, 400);
        }
        display.updateLineNumbers = null;
        return true;
      }
      function postUpdateDisplay(cm, update) {
        var viewport = update.viewport;
        for (var first = true; ; first = false) {
          if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
            if (viewport && viewport.top != null) {
              viewport = { top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top) };
            }
            update.visible = visibleLines(cm.display, cm.doc, viewport);
            if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo) {
              break;
            }
          } else if (first) {
            update.visible = visibleLines(cm.display, cm.doc, viewport);
          }
          if (!updateDisplayIfNeeded(cm, update)) {
            break;
          }
          updateHeightsInViewport(cm);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.force = false;
        }
        update.signal(cm, "update", cm);
        if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
          update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
          cm.display.reportedViewFrom = cm.display.viewFrom;
          cm.display.reportedViewTo = cm.display.viewTo;
        }
      }
      function updateDisplaySimple(cm, viewport) {
        var update = new DisplayUpdate(cm, viewport);
        if (updateDisplayIfNeeded(cm, update)) {
          updateHeightsInViewport(cm);
          postUpdateDisplay(cm, update);
          var barMeasure = measureForScrollbars(cm);
          updateSelection(cm);
          updateScrollbars(cm, barMeasure);
          setDocumentHeight(cm, barMeasure);
          update.finish();
        }
      }
      function patchDisplay(cm, updateNumbersFrom, dims) {
        var display = cm.display, lineNumbers = cm.options.lineNumbers;
        var container = display.lineDiv, cur = container.firstChild;
        function rm(node2) {
          var next = node2.nextSibling;
          if (webkit && mac && cm.display.currentWheelTarget == node2) {
            node2.style.display = "none";
          } else {
            node2.parentNode.removeChild(node2);
          }
          return next;
        }
        var view = display.view, lineN = display.viewFrom;
        for (var i2 = 0; i2 < view.length; i2++) {
          var lineView = view[i2];
          if (lineView.hidden)
            ;
          else if (!lineView.node || lineView.node.parentNode != container) {
            var node = buildLineElement(cm, lineView, lineN, dims);
            container.insertBefore(node, cur);
          } else {
            while (cur != lineView.node) {
              cur = rm(cur);
            }
            var updateNumber = lineNumbers && updateNumbersFrom != null && updateNumbersFrom <= lineN && lineView.lineNumber;
            if (lineView.changes) {
              if (indexOf(lineView.changes, "gutter") > -1) {
                updateNumber = false;
              }
              updateLineForChanges(cm, lineView, lineN, dims);
            }
            if (updateNumber) {
              removeChildren(lineView.lineNumber);
              lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
            }
            cur = lineView.node.nextSibling;
          }
          lineN += lineView.size;
        }
        while (cur) {
          cur = rm(cur);
        }
      }
      function updateGutterSpace(display) {
        var width = display.gutters.offsetWidth;
        display.sizer.style.marginLeft = width + "px";
        signalLater(display, "gutterChanged", display);
      }
      function setDocumentHeight(cm, measure) {
        cm.display.sizer.style.minHeight = measure.docHeight + "px";
        cm.display.heightForcer.style.top = measure.docHeight + "px";
        cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px";
      }
      function alignHorizontally(cm) {
        var display = cm.display, view = display.view;
        if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) {
          return;
        }
        var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
        var gutterW = display.gutters.offsetWidth, left = comp + "px";
        for (var i2 = 0; i2 < view.length; i2++) {
          if (!view[i2].hidden) {
            if (cm.options.fixedGutter) {
              if (view[i2].gutter) {
                view[i2].gutter.style.left = left;
              }
              if (view[i2].gutterBackground) {
                view[i2].gutterBackground.style.left = left;
              }
            }
            var align = view[i2].alignable;
            if (align) {
              for (var j = 0; j < align.length; j++) {
                align[j].style.left = left;
              }
            }
          }
        }
        if (cm.options.fixedGutter) {
          display.gutters.style.left = comp + gutterW + "px";
        }
      }
      function maybeUpdateLineNumberWidth(cm) {
        if (!cm.options.lineNumbers) {
          return false;
        }
        var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
        if (last.length != display.lineNumChars) {
          var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt"));
          var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
          display.lineGutter.style.width = "";
          display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
          display.lineNumWidth = display.lineNumInnerWidth + padding;
          display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
          display.lineGutter.style.width = display.lineNumWidth + "px";
          updateGutterSpace(cm.display);
          return true;
        }
        return false;
      }
      function getGutters(gutters, lineNumbers) {
        var result = [], sawLineNumbers = false;
        for (var i2 = 0; i2 < gutters.length; i2++) {
          var name2 = gutters[i2], style = null;
          if (typeof name2 != "string") {
            style = name2.style;
            name2 = name2.className;
          }
          if (name2 == "CodeMirror-linenumbers") {
            if (!lineNumbers) {
              continue;
            } else {
              sawLineNumbers = true;
            }
          }
          result.push({ className: name2, style });
        }
        if (lineNumbers && !sawLineNumbers) {
          result.push({ className: "CodeMirror-linenumbers", style: null });
        }
        return result;
      }
      function renderGutters(display) {
        var gutters = display.gutters, specs = display.gutterSpecs;
        removeChildren(gutters);
        display.lineGutter = null;
        for (var i2 = 0; i2 < specs.length; ++i2) {
          var ref = specs[i2];
          var className = ref.className;
          var style = ref.style;
          var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
          if (style) {
            gElt.style.cssText = style;
          }
          if (className == "CodeMirror-linenumbers") {
            display.lineGutter = gElt;
            gElt.style.width = (display.lineNumWidth || 1) + "px";
          }
        }
        gutters.style.display = specs.length ? "" : "none";
        updateGutterSpace(display);
      }
      function updateGutters(cm) {
        renderGutters(cm.display);
        regChange(cm);
        alignHorizontally(cm);
      }
      function Display(place, doc, input, options) {
        var d = this;
        this.input = input;
        d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
        d.scrollbarFiller.setAttribute("cm-not-content", "true");
        d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
        d.gutterFiller.setAttribute("cm-not-content", "true");
        d.lineDiv = eltP("div", null, "CodeMirror-code");
        d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
        d.cursorDiv = elt("div", null, "CodeMirror-cursors");
        d.measure = elt("div", null, "CodeMirror-measure");
        d.lineMeasure = elt("div", null, "CodeMirror-measure");
        d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
        var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
        d.mover = elt("div", [lines], null, "position: relative");
        d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
        d.sizerWidth = null;
        d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
        d.gutters = elt("div", null, "CodeMirror-gutters");
        d.lineGutter = null;
        d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
        d.scroller.setAttribute("tabIndex", "-1");
        d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");
        d.wrapper.setAttribute("translate", "no");
        if (ie && ie_version < 8) {
          d.gutters.style.zIndex = -1;
          d.scroller.style.paddingRight = 0;
        }
        if (!webkit && !(gecko && mobile)) {
          d.scroller.draggable = true;
        }
        if (place) {
          if (place.appendChild) {
            place.appendChild(d.wrapper);
          } else {
            place(d.wrapper);
          }
        }
        d.viewFrom = d.viewTo = doc.first;
        d.reportedViewFrom = d.reportedViewTo = doc.first;
        d.view = [];
        d.renderedView = null;
        d.externalMeasured = null;
        d.viewOffset = 0;
        d.lastWrapHeight = d.lastWrapWidth = 0;
        d.updateLineNumbers = null;
        d.nativeBarWidth = d.barHeight = d.barWidth = 0;
        d.scrollbarsClipped = false;
        d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
        d.alignWidgets = false;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.maxLine = null;
        d.maxLineLength = 0;
        d.maxLineChanged = false;
        d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;
        d.shift = false;
        d.selForContextMenu = null;
        d.activeTouch = null;
        d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
        renderGutters(d);
        input.init(d);
      }
      var wheelSamples = 0, wheelPixelsPerUnit = null;
      if (ie) {
        wheelPixelsPerUnit = -0.53;
      } else if (gecko) {
        wheelPixelsPerUnit = 15;
      } else if (chrome) {
        wheelPixelsPerUnit = -0.7;
      } else if (safari) {
        wheelPixelsPerUnit = -1 / 3;
      }
      function wheelEventDelta(e) {
        var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
        if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) {
          dx = e.detail;
        }
        if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) {
          dy = e.detail;
        } else if (dy == null) {
          dy = e.wheelDelta;
        }
        return { x: dx, y: dy };
      }
      function wheelEventPixels(e) {
        var delta = wheelEventDelta(e);
        delta.x *= wheelPixelsPerUnit;
        delta.y *= wheelPixelsPerUnit;
        return delta;
      }
      function onScrollWheel(cm, e) {
        var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;
        var pixelsPerUnit = wheelPixelsPerUnit;
        if (e.deltaMode === 0) {
          dx = e.deltaX;
          dy = e.deltaY;
          pixelsPerUnit = 1;
        }
        var display = cm.display, scroll = display.scroller;
        var canScrollX = scroll.scrollWidth > scroll.clientWidth;
        var canScrollY = scroll.scrollHeight > scroll.clientHeight;
        if (!(dx && canScrollX || dy && canScrollY)) {
          return;
        }
        if (dy && mac && webkit) {
          outer:
            for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
              for (var i2 = 0; i2 < view.length; i2++) {
                if (view[i2].node == cur) {
                  cm.display.currentWheelTarget = cur;
                  break outer;
                }
              }
            }
        }
        if (dx && !gecko && !presto && pixelsPerUnit != null) {
          if (dy && canScrollY) {
            updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * pixelsPerUnit));
          }
          setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * pixelsPerUnit));
          if (!dy || dy && canScrollY) {
            e_preventDefault(e);
          }
          display.wheelStartX = null;
          return;
        }
        if (dy && pixelsPerUnit != null) {
          var pixels = dy * pixelsPerUnit;
          var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
          if (pixels < 0) {
            top = Math.max(0, top + pixels - 50);
          } else {
            bot = Math.min(cm.doc.height, bot + pixels + 50);
          }
          updateDisplaySimple(cm, { top, bottom: bot });
        }
        if (wheelSamples < 20 && e.deltaMode !== 0) {
          if (display.wheelStartX == null) {
            display.wheelStartX = scroll.scrollLeft;
            display.wheelStartY = scroll.scrollTop;
            display.wheelDX = dx;
            display.wheelDY = dy;
            setTimeout(function() {
              if (display.wheelStartX == null) {
                return;
              }
              var movedX = scroll.scrollLeft - display.wheelStartX;
              var movedY = scroll.scrollTop - display.wheelStartY;
              var sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
              display.wheelStartX = display.wheelStartY = null;
              if (!sample) {
                return;
              }
              wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
              ++wheelSamples;
            }, 200);
          } else {
            display.wheelDX += dx;
            display.wheelDY += dy;
          }
        }
      }
      var Selection = function(ranges, primIndex) {
        this.ranges = ranges;
        this.primIndex = primIndex;
      };
      Selection.prototype.primary = function() {
        return this.ranges[this.primIndex];
      };
      Selection.prototype.equals = function(other) {
        if (other == this) {
          return true;
        }
        if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) {
          return false;
        }
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          var here = this.ranges[i2], there = other.ranges[i2];
          if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) {
            return false;
          }
        }
        return true;
      };
      Selection.prototype.deepCopy = function() {
        var out = [];
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          out[i2] = new Range3(copyPos(this.ranges[i2].anchor), copyPos(this.ranges[i2].head));
        }
        return new Selection(out, this.primIndex);
      };
      Selection.prototype.somethingSelected = function() {
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          if (!this.ranges[i2].empty()) {
            return true;
          }
        }
        return false;
      };
      Selection.prototype.contains = function(pos, end) {
        if (!end) {
          end = pos;
        }
        for (var i2 = 0; i2 < this.ranges.length; i2++) {
          var range2 = this.ranges[i2];
          if (cmp(end, range2.from()) >= 0 && cmp(pos, range2.to()) <= 0) {
            return i2;
          }
        }
        return -1;
      };
      var Range3 = function(anchor, head) {
        this.anchor = anchor;
        this.head = head;
      };
      Range3.prototype.from = function() {
        return minPos(this.anchor, this.head);
      };
      Range3.prototype.to = function() {
        return maxPos(this.anchor, this.head);
      };
      Range3.prototype.empty = function() {
        return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch;
      };
      function normalizeSelection(cm, ranges, primIndex) {
        var mayTouch = cm && cm.options.selectionsMayTouch;
        var prim = ranges[primIndex];
        ranges.sort(function(a, b) {
          return cmp(a.from(), b.from());
        });
        primIndex = indexOf(ranges, prim);
        for (var i2 = 1; i2 < ranges.length; i2++) {
          var cur = ranges[i2], prev = ranges[i2 - 1];
          var diff2 = cmp(prev.to(), cur.from());
          if (mayTouch && !cur.empty() ? diff2 > 0 : diff2 >= 0) {
            var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
            var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
            if (i2 <= primIndex) {
              --primIndex;
            }
            ranges.splice(--i2, 2, new Range3(inv ? to : from, inv ? from : to));
          }
        }
        return new Selection(ranges, primIndex);
      }
      function simpleSelection(anchor, head) {
        return new Selection([new Range3(anchor, head || anchor)], 0);
      }
      function changeEnd(change) {
        if (!change.text) {
          return change.to;
        }
        return Pos(change.from.line + change.text.length - 1, lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0));
      }
      function adjustForChange(pos, change) {
        if (cmp(pos, change.from) < 0) {
          return pos;
        }
        if (cmp(pos, change.to) <= 0) {
          return changeEnd(change);
        }
        var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
        if (pos.line == change.to.line) {
          ch += changeEnd(change).ch - change.to.ch;
        }
        return Pos(line, ch);
      }
      function computeSelAfterChange(doc, change) {
        var out = [];
        for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
          var range2 = doc.sel.ranges[i2];
          out.push(new Range3(adjustForChange(range2.anchor, change), adjustForChange(range2.head, change)));
        }
        return normalizeSelection(doc.cm, out, doc.sel.primIndex);
      }
      function offsetPos(pos, old, nw) {
        if (pos.line == old.line) {
          return Pos(nw.line, pos.ch - old.ch + nw.ch);
        } else {
          return Pos(nw.line + (pos.line - old.line), pos.ch);
        }
      }
      function computeReplacedSel(doc, changes, hint) {
        var out = [];
        var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
        for (var i2 = 0; i2 < changes.length; i2++) {
          var change = changes[i2];
          var from = offsetPos(change.from, oldPrev, newPrev);
          var to = offsetPos(changeEnd(change), oldPrev, newPrev);
          oldPrev = change.to;
          newPrev = to;
          if (hint == "around") {
            var range2 = doc.sel.ranges[i2], inv = cmp(range2.head, range2.anchor) < 0;
            out[i2] = new Range3(inv ? to : from, inv ? from : to);
          } else {
            out[i2] = new Range3(from, from);
          }
        }
        return new Selection(out, doc.sel.primIndex);
      }
      function loadMode(cm) {
        cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
        resetModeState(cm);
      }
      function resetModeState(cm) {
        cm.doc.iter(function(line) {
          if (line.stateAfter) {
            line.stateAfter = null;
          }
          if (line.styles) {
            line.styles = null;
          }
        });
        cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
        startWorker(cm, 100);
        cm.state.modeGen++;
        if (cm.curOp) {
          regChange(cm);
        }
      }
      function isWholeLineUpdate(doc, change) {
        return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" && (!doc.cm || doc.cm.options.wholeLineUpdateBefore);
      }
      function updateDoc(doc, change, markedSpans, estimateHeight2) {
        function spansFor(n) {
          return markedSpans ? markedSpans[n] : null;
        }
        function update(line, text3, spans) {
          updateLine(line, text3, spans, estimateHeight2);
          signalLater(line, "change", line, change);
        }
        function linesFor(start, end) {
          var result = [];
          for (var i2 = start; i2 < end; ++i2) {
            result.push(new Line(text2[i2], spansFor(i2), estimateHeight2));
          }
          return result;
        }
        var from = change.from, to = change.to, text2 = change.text;
        var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
        var lastText = lst(text2), lastSpans = spansFor(text2.length - 1), nlines = to.line - from.line;
        if (change.full) {
          doc.insert(0, linesFor(0, text2.length));
          doc.remove(text2.length, doc.size - text2.length);
        } else if (isWholeLineUpdate(doc, change)) {
          var added = linesFor(0, text2.length - 1);
          update(lastLine, lastLine.text, lastSpans);
          if (nlines) {
            doc.remove(from.line, nlines);
          }
          if (added.length) {
            doc.insert(from.line, added);
          }
        } else if (firstLine == lastLine) {
          if (text2.length == 1) {
            update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
          } else {
            var added$1 = linesFor(1, text2.length - 1);
            added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight2));
            update(firstLine, firstLine.text.slice(0, from.ch) + text2[0], spansFor(0));
            doc.insert(from.line + 1, added$1);
          }
        } else if (text2.length == 1) {
          update(firstLine, firstLine.text.slice(0, from.ch) + text2[0] + lastLine.text.slice(to.ch), spansFor(0));
          doc.remove(from.line + 1, nlines);
        } else {
          update(firstLine, firstLine.text.slice(0, from.ch) + text2[0], spansFor(0));
          update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
          var added$2 = linesFor(1, text2.length - 1);
          if (nlines > 1) {
            doc.remove(from.line + 1, nlines - 1);
          }
          doc.insert(from.line + 1, added$2);
        }
        signalLater(doc, "change", doc, change);
      }
      function linkedDocs(doc, f, sharedHistOnly) {
        function propagate(doc2, skip, sharedHist) {
          if (doc2.linked) {
            for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
              var rel = doc2.linked[i2];
              if (rel.doc == skip) {
                continue;
              }
              var shared = sharedHist && rel.sharedHist;
              if (sharedHistOnly && !shared) {
                continue;
              }
              f(rel.doc, shared);
              propagate(rel.doc, doc2, shared);
            }
          }
        }
        propagate(doc, null, true);
      }
      function attachDoc(cm, doc) {
        if (doc.cm) {
          throw new Error("This document is already in use.");
        }
        cm.doc = doc;
        doc.cm = cm;
        estimateLineHeights(cm);
        loadMode(cm);
        setDirectionClass(cm);
        cm.options.direction = doc.direction;
        if (!cm.options.lineWrapping) {
          findMaxLine(cm);
        }
        cm.options.mode = doc.modeOption;
        regChange(cm);
      }
      function setDirectionClass(cm) {
        (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
      }
      function directionChanged(cm) {
        runInOp(cm, function() {
          setDirectionClass(cm);
          regChange(cm);
        });
      }
      function History(prev) {
        this.done = [];
        this.undone = [];
        this.undoDepth = prev ? prev.undoDepth : Infinity;
        this.lastModTime = this.lastSelTime = 0;
        this.lastOp = this.lastSelOp = null;
        this.lastOrigin = this.lastSelOrigin = null;
        this.generation = this.maxGeneration = prev ? prev.maxGeneration : 1;
      }
      function historyChangeFromChange(doc, change) {
        var histChange = { from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to) };
        attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
        linkedDocs(doc, function(doc2) {
          return attachLocalSpans(doc2, histChange, change.from.line, change.to.line + 1);
        }, true);
        return histChange;
      }
      function clearSelectionEvents(array) {
        while (array.length) {
          var last = lst(array);
          if (last.ranges) {
            array.pop();
          } else {
            break;
          }
        }
      }
      function lastChangeEvent(hist, force) {
        if (force) {
          clearSelectionEvents(hist.done);
          return lst(hist.done);
        } else if (hist.done.length && !lst(hist.done).ranges) {
          return lst(hist.done);
        } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
          hist.done.pop();
          return lst(hist.done);
        }
      }
      function addChangeToHistory(doc, change, selAfter, opId) {
        var hist = doc.history;
        hist.undone.length = 0;
        var time = +new Date(), cur;
        var last;
        if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && (change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || change.origin.charAt(0) == "*")) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
          last = lst(cur.changes);
          if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
            last.to = changeEnd(change);
          } else {
            cur.changes.push(historyChangeFromChange(doc, change));
          }
        } else {
          var before = lst(hist.done);
          if (!before || !before.ranges) {
            pushSelectionToHistory(doc.sel, hist.done);
          }
          cur = {
            changes: [historyChangeFromChange(doc, change)],
            generation: hist.generation
          };
          hist.done.push(cur);
          while (hist.done.length > hist.undoDepth) {
            hist.done.shift();
            if (!hist.done[0].ranges) {
              hist.done.shift();
            }
          }
        }
        hist.done.push(selAfter);
        hist.generation = ++hist.maxGeneration;
        hist.lastModTime = hist.lastSelTime = time;
        hist.lastOp = hist.lastSelOp = opId;
        hist.lastOrigin = hist.lastSelOrigin = change.origin;
        if (!last) {
          signal(doc, "historyAdded");
        }
      }
      function selectionEventCanBeMerged(doc, origin, prev, sel) {
        var ch = origin.charAt(0);
        return ch == "*" || ch == "+" && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date() - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500);
      }
      function addSelectionToHistory(doc, sel, opId, options) {
        var hist = doc.history, origin = options && options.origin;
        if (opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))) {
          hist.done[hist.done.length - 1] = sel;
        } else {
          pushSelectionToHistory(sel, hist.done);
        }
        hist.lastSelTime = +new Date();
        hist.lastSelOrigin = origin;
        hist.lastSelOp = opId;
        if (options && options.clearRedo !== false) {
          clearSelectionEvents(hist.undone);
        }
      }
      function pushSelectionToHistory(sel, dest) {
        var top = lst(dest);
        if (!(top && top.ranges && top.equals(sel))) {
          dest.push(sel);
        }
      }
      function attachLocalSpans(doc, change, from, to) {
        var existing = change["spans_" + doc.id], n = 0;
        doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
          if (line.markedSpans) {
            (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans;
          }
          ++n;
        });
      }
      function removeClearedSpans(spans) {
        if (!spans) {
          return null;
        }
        var out;
        for (var i2 = 0; i2 < spans.length; ++i2) {
          if (spans[i2].marker.explicitlyCleared) {
            if (!out) {
              out = spans.slice(0, i2);
            }
          } else if (out) {
            out.push(spans[i2]);
          }
        }
        return !out ? spans : out.length ? out : null;
      }
      function getOldSpans(doc, change) {
        var found = change["spans_" + doc.id];
        if (!found) {
          return null;
        }
        var nw = [];
        for (var i2 = 0; i2 < change.text.length; ++i2) {
          nw.push(removeClearedSpans(found[i2]));
        }
        return nw;
      }
      function mergeOldSpans(doc, change) {
        var old = getOldSpans(doc, change);
        var stretched = stretchSpansOverChange(doc, change);
        if (!old) {
          return stretched;
        }
        if (!stretched) {
          return old;
        }
        for (var i2 = 0; i2 < old.length; ++i2) {
          var oldCur = old[i2], stretchCur = stretched[i2];
          if (oldCur && stretchCur) {
            spans:
              for (var j = 0; j < stretchCur.length; ++j) {
                var span = stretchCur[j];
                for (var k = 0; k < oldCur.length; ++k) {
                  if (oldCur[k].marker == span.marker) {
                    continue spans;
                  }
                }
                oldCur.push(span);
              }
          } else if (stretchCur) {
            old[i2] = stretchCur;
          }
        }
        return old;
      }
      function copyHistoryArray(events, newGroup, instantiateSel) {
        var copy = [];
        for (var i2 = 0; i2 < events.length; ++i2) {
          var event = events[i2];
          if (event.ranges) {
            copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
            continue;
          }
          var changes = event.changes, newChanges = [];
          copy.push({ changes: newChanges });
          for (var j = 0; j < changes.length; ++j) {
            var change = changes[j], m = void 0;
            newChanges.push({ from: change.from, to: change.to, text: change.text });
            if (newGroup) {
              for (var prop2 in change) {
                if (m = prop2.match(/^spans_(\d+)$/)) {
                  if (indexOf(newGroup, Number(m[1])) > -1) {
                    lst(newChanges)[prop2] = change[prop2];
                    delete change[prop2];
                  }
                }
              }
            }
          }
        }
        return copy;
      }
      function extendRange(range2, head, other, extend) {
        if (extend) {
          var anchor = range2.anchor;
          if (other) {
            var posBefore = cmp(head, anchor) < 0;
            if (posBefore != cmp(other, anchor) < 0) {
              anchor = head;
              head = other;
            } else if (posBefore != cmp(head, other) < 0) {
              head = other;
            }
          }
          return new Range3(anchor, head);
        } else {
          return new Range3(other || head, head);
        }
      }
      function extendSelection(doc, head, other, options, extend) {
        if (extend == null) {
          extend = doc.cm && (doc.cm.display.shift || doc.extend);
        }
        setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
      }
      function extendSelections(doc, heads, options) {
        var out = [];
        var extend = doc.cm && (doc.cm.display.shift || doc.extend);
        for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
          out[i2] = extendRange(doc.sel.ranges[i2], heads[i2], null, extend);
        }
        var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
        setSelection(doc, newSel, options);
      }
      function replaceOneSelection(doc, i2, range2, options) {
        var ranges = doc.sel.ranges.slice(0);
        ranges[i2] = range2;
        setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
      }
      function setSimpleSelection(doc, anchor, head, options) {
        setSelection(doc, simpleSelection(anchor, head), options);
      }
      function filterSelectionChange(doc, sel, options) {
        var obj = {
          ranges: sel.ranges,
          update: function(ranges) {
            this.ranges = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              this.ranges[i2] = new Range3(clipPos(doc, ranges[i2].anchor), clipPos(doc, ranges[i2].head));
            }
          },
          origin: options && options.origin
        };
        signal(doc, "beforeSelectionChange", doc, obj);
        if (doc.cm) {
          signal(doc.cm, "beforeSelectionChange", doc.cm, obj);
        }
        if (obj.ranges != sel.ranges) {
          return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1);
        } else {
          return sel;
        }
      }
      function setSelectionReplaceHistory(doc, sel, options) {
        var done = doc.history.done, last = lst(done);
        if (last && last.ranges) {
          done[done.length - 1] = sel;
          setSelectionNoUndo(doc, sel, options);
        } else {
          setSelection(doc, sel, options);
        }
      }
      function setSelection(doc, sel, options) {
        setSelectionNoUndo(doc, sel, options);
        addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
      }
      function setSelectionNoUndo(doc, sel, options) {
        if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) {
          sel = filterSelectionChange(doc, sel, options);
        }
        var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
        setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));
        if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor") {
          ensureCursorVisible(doc.cm);
        }
      }
      function setSelectionInner(doc, sel) {
        if (sel.equals(doc.sel)) {
          return;
        }
        doc.sel = sel;
        if (doc.cm) {
          doc.cm.curOp.updateInput = 1;
          doc.cm.curOp.selectionChanged = true;
          signalCursorActivity(doc.cm);
        }
        signalLater(doc, "cursorActivity", doc);
      }
      function reCheckSelection(doc) {
        setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
      }
      function skipAtomicInSelection(doc, sel, bias, mayClear) {
        var out;
        for (var i2 = 0; i2 < sel.ranges.length; i2++) {
          var range2 = sel.ranges[i2];
          var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i2];
          var newAnchor = skipAtomic(doc, range2.anchor, old && old.anchor, bias, mayClear);
          var newHead = skipAtomic(doc, range2.head, old && old.head, bias, mayClear);
          if (out || newAnchor != range2.anchor || newHead != range2.head) {
            if (!out) {
              out = sel.ranges.slice(0, i2);
            }
            out[i2] = new Range3(newAnchor, newHead);
          }
        }
        return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel;
      }
      function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
        var line = getLine(doc, pos.line);
        if (line.markedSpans) {
          for (var i2 = 0; i2 < line.markedSpans.length; ++i2) {
            var sp = line.markedSpans[i2], m = sp.marker;
            var preventCursorLeft = "selectLeft" in m ? !m.selectLeft : m.inclusiveLeft;
            var preventCursorRight = "selectRight" in m ? !m.selectRight : m.inclusiveRight;
            if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
              if (mayClear) {
                signal(m, "beforeCursorEnter");
                if (m.explicitlyCleared) {
                  if (!line.markedSpans) {
                    break;
                  } else {
                    --i2;
                    continue;
                  }
                }
              }
              if (!m.atomic) {
                continue;
              }
              if (oldPos) {
                var near = m.find(dir < 0 ? 1 : -1), diff2 = void 0;
                if (dir < 0 ? preventCursorRight : preventCursorLeft) {
                  near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null);
                }
                if (near && near.line == pos.line && (diff2 = cmp(near, oldPos)) && (dir < 0 ? diff2 < 0 : diff2 > 0)) {
                  return skipAtomicInner(doc, near, pos, dir, mayClear);
                }
              }
              var far = m.find(dir < 0 ? -1 : 1);
              if (dir < 0 ? preventCursorLeft : preventCursorRight) {
                far = movePos(doc, far, dir, far.line == pos.line ? line : null);
              }
              return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null;
            }
          }
        }
        return pos;
      }
      function skipAtomic(doc, pos, oldPos, bias, mayClear) {
        var dir = bias || 1;
        var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, true) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true);
        if (!found) {
          doc.cantEdit = true;
          return Pos(doc.first, 0);
        }
        return found;
      }
      function movePos(doc, pos, dir, line) {
        if (dir < 0 && pos.ch == 0) {
          if (pos.line > doc.first) {
            return clipPos(doc, Pos(pos.line - 1));
          } else {
            return null;
          }
        } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
          if (pos.line < doc.first + doc.size - 1) {
            return Pos(pos.line + 1, 0);
          } else {
            return null;
          }
        } else {
          return new Pos(pos.line, pos.ch + dir);
        }
      }
      function selectAll(cm) {
        cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
      }
      function filterChange(doc, change, update) {
        var obj = {
          canceled: false,
          from: change.from,
          to: change.to,
          text: change.text,
          origin: change.origin,
          cancel: function() {
            return obj.canceled = true;
          }
        };
        if (update) {
          obj.update = function(from, to, text2, origin) {
            if (from) {
              obj.from = clipPos(doc, from);
            }
            if (to) {
              obj.to = clipPos(doc, to);
            }
            if (text2) {
              obj.text = text2;
            }
            if (origin !== void 0) {
              obj.origin = origin;
            }
          };
        }
        signal(doc, "beforeChange", doc, obj);
        if (doc.cm) {
          signal(doc.cm, "beforeChange", doc.cm, obj);
        }
        if (obj.canceled) {
          if (doc.cm) {
            doc.cm.curOp.updateInput = 2;
          }
          return null;
        }
        return { from: obj.from, to: obj.to, text: obj.text, origin: obj.origin };
      }
      function makeChange(doc, change, ignoreReadOnly) {
        if (doc.cm) {
          if (!doc.cm.curOp) {
            return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
          }
          if (doc.cm.state.suppressEdits) {
            return;
          }
        }
        if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
          change = filterChange(doc, change, true);
          if (!change) {
            return;
          }
        }
        var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
        if (split) {
          for (var i2 = split.length - 1; i2 >= 0; --i2) {
            makeChangeInner(doc, { from: split[i2].from, to: split[i2].to, text: i2 ? [""] : change.text, origin: change.origin });
          }
        } else {
          makeChangeInner(doc, change);
        }
      }
      function makeChangeInner(doc, change) {
        if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) {
          return;
        }
        var selAfter = computeSelAfterChange(doc, change);
        addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);
        makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
        var rebased = [];
        linkedDocs(doc, function(doc2, sharedHist) {
          if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
            rebaseHist(doc2.history, change);
            rebased.push(doc2.history);
          }
          makeChangeSingleDoc(doc2, change, null, stretchSpansOverChange(doc2, change));
        });
      }
      function makeChangeFromHistory(doc, type2, allowSelectionOnly) {
        var suppress = doc.cm && doc.cm.state.suppressEdits;
        if (suppress && !allowSelectionOnly) {
          return;
        }
        var hist = doc.history, event, selAfter = doc.sel;
        var source = type2 == "undo" ? hist.done : hist.undone, dest = type2 == "undo" ? hist.undone : hist.done;
        var i2 = 0;
        for (; i2 < source.length; i2++) {
          event = source[i2];
          if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges) {
            break;
          }
        }
        if (i2 == source.length) {
          return;
        }
        hist.lastOrigin = hist.lastSelOrigin = null;
        for (; ; ) {
          event = source.pop();
          if (event.ranges) {
            pushSelectionToHistory(event, dest);
            if (allowSelectionOnly && !event.equals(doc.sel)) {
              setSelection(doc, event, { clearRedo: false });
              return;
            }
            selAfter = event;
          } else if (suppress) {
            source.push(event);
            return;
          } else {
            break;
          }
        }
        var antiChanges = [];
        pushSelectionToHistory(selAfter, dest);
        dest.push({ changes: antiChanges, generation: hist.generation });
        hist.generation = event.generation || ++hist.maxGeneration;
        var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");
        var loop = function(i3) {
          var change = event.changes[i3];
          change.origin = type2;
          if (filter && !filterChange(doc, change, false)) {
            source.length = 0;
            return {};
          }
          antiChanges.push(historyChangeFromChange(doc, change));
          var after = i3 ? computeSelAfterChange(doc, change) : lst(source);
          makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
          if (!i3 && doc.cm) {
            doc.cm.scrollIntoView({ from: change.from, to: changeEnd(change) });
          }
          var rebased = [];
          linkedDocs(doc, function(doc2, sharedHist) {
            if (!sharedHist && indexOf(rebased, doc2.history) == -1) {
              rebaseHist(doc2.history, change);
              rebased.push(doc2.history);
            }
            makeChangeSingleDoc(doc2, change, null, mergeOldSpans(doc2, change));
          });
        };
        for (var i$12 = event.changes.length - 1; i$12 >= 0; --i$12) {
          var returned = loop(i$12);
          if (returned)
            return returned.v;
        }
      }
      function shiftDoc(doc, distance) {
        if (distance == 0) {
          return;
        }
        doc.first += distance;
        doc.sel = new Selection(map2(doc.sel.ranges, function(range2) {
          return new Range3(Pos(range2.anchor.line + distance, range2.anchor.ch), Pos(range2.head.line + distance, range2.head.ch));
        }), doc.sel.primIndex);
        if (doc.cm) {
          regChange(doc.cm, doc.first, doc.first - distance, distance);
          for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) {
            regLineChange(doc.cm, l, "gutter");
          }
        }
      }
      function makeChangeSingleDoc(doc, change, selAfter, spans) {
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
        }
        if (change.to.line < doc.first) {
          shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
          return;
        }
        if (change.from.line > doc.lastLine()) {
          return;
        }
        if (change.from.line < doc.first) {
          var shift = change.text.length - 1 - (doc.first - change.from.line);
          shiftDoc(doc, shift);
          change = {
            from: Pos(doc.first, 0),
            to: Pos(change.to.line + shift, change.to.ch),
            text: [lst(change.text)],
            origin: change.origin
          };
        }
        var last = doc.lastLine();
        if (change.to.line > last) {
          change = {
            from: change.from,
            to: Pos(last, getLine(doc, last).text.length),
            text: [change.text[0]],
            origin: change.origin
          };
        }
        change.removed = getBetween(doc, change.from, change.to);
        if (!selAfter) {
          selAfter = computeSelAfterChange(doc, change);
        }
        if (doc.cm) {
          makeChangeSingleDocInEditor(doc.cm, change, spans);
        } else {
          updateDoc(doc, change, spans);
        }
        setSelectionNoUndo(doc, selAfter, sel_dontScroll);
        if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0))) {
          doc.cantEdit = false;
        }
      }
      function makeChangeSingleDocInEditor(cm, change, spans) {
        var doc = cm.doc, display = cm.display, from = change.from, to = change.to;
        var recomputeMaxLength = false, checkWidthStart = from.line;
        if (!cm.options.lineWrapping) {
          checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
          doc.iter(checkWidthStart, to.line + 1, function(line) {
            if (line == display.maxLine) {
              recomputeMaxLength = true;
              return true;
            }
          });
        }
        if (doc.sel.contains(change.from, change.to) > -1) {
          signalCursorActivity(cm);
        }
        updateDoc(doc, change, spans, estimateHeight(cm));
        if (!cm.options.lineWrapping) {
          doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
            var len = lineLength(line);
            if (len > display.maxLineLength) {
              display.maxLine = line;
              display.maxLineLength = len;
              display.maxLineChanged = true;
              recomputeMaxLength = false;
            }
          });
          if (recomputeMaxLength) {
            cm.curOp.updateMaxLine = true;
          }
        }
        retreatFrontier(doc, from.line);
        startWorker(cm, 400);
        var lendiff = change.text.length - (to.line - from.line) - 1;
        if (change.full) {
          regChange(cm);
        } else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change)) {
          regLineChange(cm, from.line, "text");
        } else {
          regChange(cm, from.line, to.line + 1, lendiff);
        }
        var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
        if (changeHandler || changesHandler) {
          var obj = {
            from,
            to,
            text: change.text,
            removed: change.removed,
            origin: change.origin
          };
          if (changeHandler) {
            signalLater(cm, "change", cm, obj);
          }
          if (changesHandler) {
            (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj);
          }
        }
        cm.display.selForContextMenu = null;
      }
      function replaceRange(doc, code, from, to, origin) {
        var assign2;
        if (!to) {
          to = from;
        }
        if (cmp(to, from) < 0) {
          assign2 = [to, from], from = assign2[0], to = assign2[1];
        }
        if (typeof code == "string") {
          code = doc.splitLines(code);
        }
        makeChange(doc, { from, to, text: code, origin });
      }
      function rebaseHistSelSingle(pos, from, to, diff2) {
        if (to < pos.line) {
          pos.line += diff2;
        } else if (from < pos.line) {
          pos.line = from;
          pos.ch = 0;
        }
      }
      function rebaseHistArray(array, from, to, diff2) {
        for (var i2 = 0; i2 < array.length; ++i2) {
          var sub = array[i2], ok = true;
          if (sub.ranges) {
            if (!sub.copied) {
              sub = array[i2] = sub.deepCopy();
              sub.copied = true;
            }
            for (var j = 0; j < sub.ranges.length; j++) {
              rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff2);
              rebaseHistSelSingle(sub.ranges[j].head, from, to, diff2);
            }
            continue;
          }
          for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
            var cur = sub.changes[j$1];
            if (to < cur.from.line) {
              cur.from = Pos(cur.from.line + diff2, cur.from.ch);
              cur.to = Pos(cur.to.line + diff2, cur.to.ch);
            } else if (from <= cur.to.line) {
              ok = false;
              break;
            }
          }
          if (!ok) {
            array.splice(0, i2 + 1);
            i2 = 0;
          }
        }
      }
      function rebaseHist(hist, change) {
        var from = change.from.line, to = change.to.line, diff2 = change.text.length - (to - from) - 1;
        rebaseHistArray(hist.done, from, to, diff2);
        rebaseHistArray(hist.undone, from, to, diff2);
      }
      function changeLine(doc, handle, changeType, op) {
        var no = handle, line = handle;
        if (typeof handle == "number") {
          line = getLine(doc, clipLine(doc, handle));
        } else {
          no = lineNo(handle);
        }
        if (no == null) {
          return null;
        }
        if (op(line, no) && doc.cm) {
          regLineChange(doc.cm, no, changeType);
        }
        return line;
      }
      function LeafChunk(lines) {
        this.lines = lines;
        this.parent = null;
        var height = 0;
        for (var i2 = 0; i2 < lines.length; ++i2) {
          lines[i2].parent = this;
          height += lines[i2].height;
        }
        this.height = height;
      }
      LeafChunk.prototype = {
        chunkSize: function() {
          return this.lines.length;
        },
        removeInner: function(at, n) {
          for (var i2 = at, e = at + n; i2 < e; ++i2) {
            var line = this.lines[i2];
            this.height -= line.height;
            cleanUpLine(line);
            signalLater(line, "delete");
          }
          this.lines.splice(at, n);
        },
        collapse: function(lines) {
          lines.push.apply(lines, this.lines);
        },
        insertInner: function(at, lines, height) {
          this.height += height;
          this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
          for (var i2 = 0; i2 < lines.length; ++i2) {
            lines[i2].parent = this;
          }
        },
        iterN: function(at, n, op) {
          for (var e = at + n; at < e; ++at) {
            if (op(this.lines[at])) {
              return true;
            }
          }
        }
      };
      function BranchChunk(children) {
        this.children = children;
        var size = 0, height = 0;
        for (var i2 = 0; i2 < children.length; ++i2) {
          var ch = children[i2];
          size += ch.chunkSize();
          height += ch.height;
          ch.parent = this;
        }
        this.size = size;
        this.height = height;
        this.parent = null;
      }
      BranchChunk.prototype = {
        chunkSize: function() {
          return this.size;
        },
        removeInner: function(at, n) {
          this.size -= n;
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at < sz) {
              var rm = Math.min(n, sz - at), oldHeight = child.height;
              child.removeInner(at, rm);
              this.height -= oldHeight - child.height;
              if (sz == rm) {
                this.children.splice(i2--, 1);
                child.parent = null;
              }
              if ((n -= rm) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
          if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
            var lines = [];
            this.collapse(lines);
            this.children = [new LeafChunk(lines)];
            this.children[0].parent = this;
          }
        },
        collapse: function(lines) {
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            this.children[i2].collapse(lines);
          }
        },
        insertInner: function(at, lines, height) {
          this.size += lines.length;
          this.height += height;
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at <= sz) {
              child.insertInner(at, lines, height);
              if (child.lines && child.lines.length > 50) {
                var remaining = child.lines.length % 25 + 25;
                for (var pos = remaining; pos < child.lines.length; ) {
                  var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                  child.height -= leaf.height;
                  this.children.splice(++i2, 0, leaf);
                  leaf.parent = this;
                }
                child.lines = child.lines.slice(0, remaining);
                this.maybeSpill();
              }
              break;
            }
            at -= sz;
          }
        },
        maybeSpill: function() {
          if (this.children.length <= 10) {
            return;
          }
          var me = this;
          do {
            var spilled = me.children.splice(me.children.length - 5, 5);
            var sibling = new BranchChunk(spilled);
            if (!me.parent) {
              var copy = new BranchChunk(me.children);
              copy.parent = me;
              me.children = [copy, sibling];
              me = copy;
            } else {
              me.size -= sibling.size;
              me.height -= sibling.height;
              var myIndex = indexOf(me.parent.children, me);
              me.parent.children.splice(myIndex + 1, 0, sibling);
            }
            sibling.parent = me.parent;
          } while (me.children.length > 10);
          me.parent.maybeSpill();
        },
        iterN: function(at, n, op) {
          for (var i2 = 0; i2 < this.children.length; ++i2) {
            var child = this.children[i2], sz = child.chunkSize();
            if (at < sz) {
              var used = Math.min(n, sz - at);
              if (child.iterN(at, used, op)) {
                return true;
              }
              if ((n -= used) == 0) {
                break;
              }
              at = 0;
            } else {
              at -= sz;
            }
          }
        }
      };
      var LineWidget = function(doc, node, options) {
        if (options) {
          for (var opt2 in options) {
            if (options.hasOwnProperty(opt2)) {
              this[opt2] = options[opt2];
            }
          }
        }
        this.doc = doc;
        this.node = node;
      };
      LineWidget.prototype.clear = function() {
        var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
        if (no == null || !ws) {
          return;
        }
        for (var i2 = 0; i2 < ws.length; ++i2) {
          if (ws[i2] == this) {
            ws.splice(i2--, 1);
          }
        }
        if (!ws.length) {
          line.widgets = null;
        }
        var height = widgetHeight(this);
        updateLineHeight(line, Math.max(0, line.height - height));
        if (cm) {
          runInOp(cm, function() {
            adjustScrollWhenAboveVisible(cm, line, -height);
            regLineChange(cm, no, "widget");
          });
          signalLater(cm, "lineWidgetCleared", cm, this, no);
        }
      };
      LineWidget.prototype.changed = function() {
        var this$1 = this;
        var oldH = this.height, cm = this.doc.cm, line = this.line;
        this.height = null;
        var diff2 = widgetHeight(this) - oldH;
        if (!diff2) {
          return;
        }
        if (!lineIsHidden(this.doc, line)) {
          updateLineHeight(line, line.height + diff2);
        }
        if (cm) {
          runInOp(cm, function() {
            cm.curOp.forceUpdate = true;
            adjustScrollWhenAboveVisible(cm, line, diff2);
            signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
          });
        }
      };
      eventMixin(LineWidget);
      function adjustScrollWhenAboveVisible(cm, line, diff2) {
        if (heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop)) {
          addToScrollTop(cm, diff2);
        }
      }
      function addLineWidget(doc, handle, node, options) {
        var widget = new LineWidget(doc, node, options);
        var cm = doc.cm;
        if (cm && widget.noHScroll) {
          cm.display.alignWidgets = true;
        }
        changeLine(doc, handle, "widget", function(line) {
          var widgets = line.widgets || (line.widgets = []);
          if (widget.insertAt == null) {
            widgets.push(widget);
          } else {
            widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget);
          }
          widget.line = line;
          if (cm && !lineIsHidden(doc, line)) {
            var aboveVisible = heightAtLine(line) < doc.scrollTop;
            updateLineHeight(line, line.height + widgetHeight(widget));
            if (aboveVisible) {
              addToScrollTop(cm, widget.height);
            }
            cm.curOp.forceUpdate = true;
          }
          return true;
        });
        if (cm) {
          signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle));
        }
        return widget;
      }
      var nextMarkerId = 0;
      var TextMarker = function(doc, type2) {
        this.lines = [];
        this.type = type2;
        this.doc = doc;
        this.id = ++nextMarkerId;
      };
      TextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        var cm = this.doc.cm, withOp = cm && !cm.curOp;
        if (withOp) {
          startOperation(cm);
        }
        if (hasHandler(this, "clear")) {
          var found = this.find();
          if (found) {
            signalLater(this, "clear", found.from, found.to);
          }
        }
        var min = null, max = null;
        for (var i2 = 0; i2 < this.lines.length; ++i2) {
          var line = this.lines[i2];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (cm && !this.collapsed) {
            regLineChange(cm, lineNo(line), "text");
          } else if (cm) {
            if (span.to != null) {
              max = lineNo(line);
            }
            if (span.from != null) {
              min = lineNo(line);
            }
          }
          line.markedSpans = removeMarkedSpan(line.markedSpans, span);
          if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm) {
            updateLineHeight(line, textHeight(cm.display));
          }
        }
        if (cm && this.collapsed && !cm.options.lineWrapping) {
          for (var i$12 = 0; i$12 < this.lines.length; ++i$12) {
            var visual = visualLine(this.lines[i$12]), len = lineLength(visual);
            if (len > cm.display.maxLineLength) {
              cm.display.maxLine = visual;
              cm.display.maxLineLength = len;
              cm.display.maxLineChanged = true;
            }
          }
        }
        if (min != null && cm && this.collapsed) {
          regChange(cm, min, max + 1);
        }
        this.lines.length = 0;
        this.explicitlyCleared = true;
        if (this.atomic && this.doc.cantEdit) {
          this.doc.cantEdit = false;
          if (cm) {
            reCheckSelection(cm.doc);
          }
        }
        if (cm) {
          signalLater(cm, "markerCleared", cm, this, min, max);
        }
        if (withOp) {
          endOperation(cm);
        }
        if (this.parent) {
          this.parent.clear();
        }
      };
      TextMarker.prototype.find = function(side, lineObj) {
        if (side == null && this.type == "bookmark") {
          side = 1;
        }
        var from, to;
        for (var i2 = 0; i2 < this.lines.length; ++i2) {
          var line = this.lines[i2];
          var span = getMarkedSpanFor(line.markedSpans, this);
          if (span.from != null) {
            from = Pos(lineObj ? line : lineNo(line), span.from);
            if (side == -1) {
              return from;
            }
          }
          if (span.to != null) {
            to = Pos(lineObj ? line : lineNo(line), span.to);
            if (side == 1) {
              return to;
            }
          }
        }
        return from && { from, to };
      };
      TextMarker.prototype.changed = function() {
        var this$1 = this;
        var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
        if (!pos || !cm) {
          return;
        }
        runInOp(cm, function() {
          var line = pos.line, lineN = lineNo(pos.line);
          var view = findViewForLine(cm, lineN);
          if (view) {
            clearLineMeasurementCacheFor(view);
            cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
          }
          cm.curOp.updateMaxLine = true;
          if (!lineIsHidden(widget.doc, line) && widget.height != null) {
            var oldHeight = widget.height;
            widget.height = null;
            var dHeight = widgetHeight(widget) - oldHeight;
            if (dHeight) {
              updateLineHeight(line, line.height + dHeight);
            }
          }
          signalLater(cm, "markerChanged", cm, this$1);
        });
      };
      TextMarker.prototype.attachLine = function(line) {
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1) {
            (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this);
          }
        }
        this.lines.push(line);
      };
      TextMarker.prototype.detachLine = function(line) {
        this.lines.splice(indexOf(this.lines, line), 1);
        if (!this.lines.length && this.doc.cm) {
          var op = this.doc.cm.curOp;
          (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
        }
      };
      eventMixin(TextMarker);
      function markText(doc, from, to, options, type2) {
        if (options && options.shared) {
          return markTextShared(doc, from, to, options, type2);
        }
        if (doc.cm && !doc.cm.curOp) {
          return operation(doc.cm, markText)(doc, from, to, options, type2);
        }
        var marker = new TextMarker(doc, type2), diff2 = cmp(from, to);
        if (options) {
          copyObj(options, marker, false);
        }
        if (diff2 > 0 || diff2 == 0 && marker.clearWhenEmpty !== false) {
          return marker;
        }
        if (marker.replacedWith) {
          marker.collapsed = true;
          marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
          if (!options.handleMouseEvents) {
            marker.widgetNode.setAttribute("cm-ignore-events", "true");
          }
          if (options.insertLeft) {
            marker.widgetNode.insertLeft = true;
          }
        }
        if (marker.collapsed) {
          if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) {
            throw new Error("Inserting collapsed marker partially overlapping an existing one");
          }
          seeCollapsedSpans();
        }
        if (marker.addToHistory) {
          addChangeToHistory(doc, { from, to, origin: "markText" }, doc.sel, NaN);
        }
        var curLine = from.line, cm = doc.cm, updateMaxLine;
        doc.iter(curLine, to.line + 1, function(line) {
          if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine) {
            updateMaxLine = true;
          }
          if (marker.collapsed && curLine != from.line) {
            updateLineHeight(line, 0);
          }
          addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null), doc.cm && doc.cm.curOp);
          ++curLine;
        });
        if (marker.collapsed) {
          doc.iter(from.line, to.line + 1, function(line) {
            if (lineIsHidden(doc, line)) {
              updateLineHeight(line, 0);
            }
          });
        }
        if (marker.clearOnEnter) {
          on(marker, "beforeCursorEnter", function() {
            return marker.clear();
          });
        }
        if (marker.readOnly) {
          seeReadOnlySpans();
          if (doc.history.done.length || doc.history.undone.length) {
            doc.clearHistory();
          }
        }
        if (marker.collapsed) {
          marker.id = ++nextMarkerId;
          marker.atomic = true;
        }
        if (cm) {
          if (updateMaxLine) {
            cm.curOp.updateMaxLine = true;
          }
          if (marker.collapsed) {
            regChange(cm, from.line, to.line + 1);
          } else if (marker.className || marker.startStyle || marker.endStyle || marker.css || marker.attributes || marker.title) {
            for (var i2 = from.line; i2 <= to.line; i2++) {
              regLineChange(cm, i2, "text");
            }
          }
          if (marker.atomic) {
            reCheckSelection(cm.doc);
          }
          signalLater(cm, "markerAdded", cm, marker);
        }
        return marker;
      }
      var SharedTextMarker = function(markers, primary) {
        this.markers = markers;
        this.primary = primary;
        for (var i2 = 0; i2 < markers.length; ++i2) {
          markers[i2].parent = this;
        }
      };
      SharedTextMarker.prototype.clear = function() {
        if (this.explicitlyCleared) {
          return;
        }
        this.explicitlyCleared = true;
        for (var i2 = 0; i2 < this.markers.length; ++i2) {
          this.markers[i2].clear();
        }
        signalLater(this, "clear");
      };
      SharedTextMarker.prototype.find = function(side, lineObj) {
        return this.primary.find(side, lineObj);
      };
      eventMixin(SharedTextMarker);
      function markTextShared(doc, from, to, options, type2) {
        options = copyObj(options);
        options.shared = false;
        var markers = [markText(doc, from, to, options, type2)], primary = markers[0];
        var widget = options.widgetNode;
        linkedDocs(doc, function(doc2) {
          if (widget) {
            options.widgetNode = widget.cloneNode(true);
          }
          markers.push(markText(doc2, clipPos(doc2, from), clipPos(doc2, to), options, type2));
          for (var i2 = 0; i2 < doc2.linked.length; ++i2) {
            if (doc2.linked[i2].isParent) {
              return;
            }
          }
          primary = lst(markers);
        });
        return new SharedTextMarker(markers, primary);
      }
      function findSharedMarkers(doc) {
        return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
          return m.parent;
        });
      }
      function copySharedMarkers(doc, markers) {
        for (var i2 = 0; i2 < markers.length; i2++) {
          var marker = markers[i2], pos = marker.find();
          var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
          if (cmp(mFrom, mTo)) {
            var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
            marker.markers.push(subMark);
            subMark.parent = marker;
          }
        }
      }
      function detachSharedMarkers(markers) {
        var loop = function(i3) {
          var marker = markers[i3], linked = [marker.primary.doc];
          linkedDocs(marker.primary.doc, function(d) {
            return linked.push(d);
          });
          for (var j = 0; j < marker.markers.length; j++) {
            var subMarker = marker.markers[j];
            if (indexOf(linked, subMarker.doc) == -1) {
              subMarker.parent = null;
              marker.markers.splice(j--, 1);
            }
          }
        };
        for (var i2 = 0; i2 < markers.length; i2++)
          loop(i2);
      }
      var nextDocId = 0;
      var Doc = function(text2, mode, firstLine, lineSep, direction) {
        if (!(this instanceof Doc)) {
          return new Doc(text2, mode, firstLine, lineSep, direction);
        }
        if (firstLine == null) {
          firstLine = 0;
        }
        BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
        this.first = firstLine;
        this.scrollTop = this.scrollLeft = 0;
        this.cantEdit = false;
        this.cleanGeneration = 1;
        this.modeFrontier = this.highlightFrontier = firstLine;
        var start = Pos(firstLine, 0);
        this.sel = simpleSelection(start);
        this.history = new History(null);
        this.id = ++nextDocId;
        this.modeOption = mode;
        this.lineSep = lineSep;
        this.direction = direction == "rtl" ? "rtl" : "ltr";
        this.extend = false;
        if (typeof text2 == "string") {
          text2 = this.splitLines(text2);
        }
        updateDoc(this, { from: start, to: start, text: text2 });
        setSelection(this, simpleSelection(start), sel_dontScroll);
      };
      Doc.prototype = createObj(BranchChunk.prototype, {
        constructor: Doc,
        iter: function(from, to, op) {
          if (op) {
            this.iterN(from - this.first, to - from, op);
          } else {
            this.iterN(this.first, this.first + this.size, from);
          }
        },
        insert: function(at, lines) {
          var height = 0;
          for (var i2 = 0; i2 < lines.length; ++i2) {
            height += lines[i2].height;
          }
          this.insertInner(at - this.first, lines, height);
        },
        remove: function(at, n) {
          this.removeInner(at - this.first, n);
        },
        getValue: function(lineSep) {
          var lines = getLines(this, this.first, this.first + this.size);
          if (lineSep === false) {
            return lines;
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        setValue: docMethodOp(function(code) {
          var top = Pos(this.first, 0), last = this.first + this.size - 1;
          makeChange(this, {
            from: top,
            to: Pos(last, getLine(this, last).text.length),
            text: this.splitLines(code),
            origin: "setValue",
            full: true
          }, true);
          if (this.cm) {
            scrollToCoords(this.cm, 0, 0);
          }
          setSelection(this, simpleSelection(top), sel_dontScroll);
        }),
        replaceRange: function(code, from, to, origin) {
          from = clipPos(this, from);
          to = to ? clipPos(this, to) : from;
          replaceRange(this, code, from, to, origin);
        },
        getRange: function(from, to, lineSep) {
          var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
          if (lineSep === false) {
            return lines;
          }
          if (lineSep === "") {
            return lines.join("");
          }
          return lines.join(lineSep || this.lineSeparator());
        },
        getLine: function(line) {
          var l = this.getLineHandle(line);
          return l && l.text;
        },
        getLineHandle: function(line) {
          if (isLine(this, line)) {
            return getLine(this, line);
          }
        },
        getLineNumber: function(line) {
          return lineNo(line);
        },
        getLineHandleVisualStart: function(line) {
          if (typeof line == "number") {
            line = getLine(this, line);
          }
          return visualLine(line);
        },
        lineCount: function() {
          return this.size;
        },
        firstLine: function() {
          return this.first;
        },
        lastLine: function() {
          return this.first + this.size - 1;
        },
        clipPos: function(pos) {
          return clipPos(this, pos);
        },
        getCursor: function(start) {
          var range2 = this.sel.primary(), pos;
          if (start == null || start == "head") {
            pos = range2.head;
          } else if (start == "anchor") {
            pos = range2.anchor;
          } else if (start == "end" || start == "to" || start === false) {
            pos = range2.to();
          } else {
            pos = range2.from();
          }
          return pos;
        },
        listSelections: function() {
          return this.sel.ranges;
        },
        somethingSelected: function() {
          return this.sel.somethingSelected();
        },
        setCursor: docMethodOp(function(line, ch, options) {
          setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
        }),
        setSelection: docMethodOp(function(anchor, head, options) {
          setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
        }),
        extendSelection: docMethodOp(function(head, other, options) {
          extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
        }),
        extendSelections: docMethodOp(function(heads, options) {
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        extendSelectionsBy: docMethodOp(function(f, options) {
          var heads = map2(this.sel.ranges, f);
          extendSelections(this, clipPosArray(this, heads), options);
        }),
        setSelections: docMethodOp(function(ranges, primary, options) {
          if (!ranges.length) {
            return;
          }
          var out = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            out[i2] = new Range3(clipPos(this, ranges[i2].anchor), clipPos(this, ranges[i2].head || ranges[i2].anchor));
          }
          if (primary == null) {
            primary = Math.min(ranges.length - 1, this.sel.primIndex);
          }
          setSelection(this, normalizeSelection(this.cm, out, primary), options);
        }),
        addSelection: docMethodOp(function(anchor, head, options) {
          var ranges = this.sel.ranges.slice(0);
          ranges.push(new Range3(clipPos(this, anchor), clipPos(this, head || anchor)));
          setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
        }),
        getSelection: function(lineSep) {
          var ranges = this.sel.ranges, lines;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
            lines = lines ? lines.concat(sel) : sel;
          }
          if (lineSep === false) {
            return lines;
          } else {
            return lines.join(lineSep || this.lineSeparator());
          }
        },
        getSelections: function(lineSep) {
          var parts = [], ranges = this.sel.ranges;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var sel = getBetween(this, ranges[i2].from(), ranges[i2].to());
            if (lineSep !== false) {
              sel = sel.join(lineSep || this.lineSeparator());
            }
            parts[i2] = sel;
          }
          return parts;
        },
        replaceSelection: function(code, collapse, origin) {
          var dup = [];
          for (var i2 = 0; i2 < this.sel.ranges.length; i2++) {
            dup[i2] = code;
          }
          this.replaceSelections(dup, collapse, origin || "+input");
        },
        replaceSelections: docMethodOp(function(code, collapse, origin) {
          var changes = [], sel = this.sel;
          for (var i2 = 0; i2 < sel.ranges.length; i2++) {
            var range2 = sel.ranges[i2];
            changes[i2] = { from: range2.from(), to: range2.to(), text: this.splitLines(code[i2]), origin };
          }
          var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
          for (var i$12 = changes.length - 1; i$12 >= 0; i$12--) {
            makeChange(this, changes[i$12]);
          }
          if (newSel) {
            setSelectionReplaceHistory(this, newSel);
          } else if (this.cm) {
            ensureCursorVisible(this.cm);
          }
        }),
        undo: docMethodOp(function() {
          makeChangeFromHistory(this, "undo");
        }),
        redo: docMethodOp(function() {
          makeChangeFromHistory(this, "redo");
        }),
        undoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "undo", true);
        }),
        redoSelection: docMethodOp(function() {
          makeChangeFromHistory(this, "redo", true);
        }),
        setExtending: function(val) {
          this.extend = val;
        },
        getExtending: function() {
          return this.extend;
        },
        historySize: function() {
          var hist = this.history, done = 0, undone = 0;
          for (var i2 = 0; i2 < hist.done.length; i2++) {
            if (!hist.done[i2].ranges) {
              ++done;
            }
          }
          for (var i$12 = 0; i$12 < hist.undone.length; i$12++) {
            if (!hist.undone[i$12].ranges) {
              ++undone;
            }
          }
          return { undo: done, redo: undone };
        },
        clearHistory: function() {
          var this$1 = this;
          this.history = new History(this.history);
          linkedDocs(this, function(doc) {
            return doc.history = this$1.history;
          }, true);
        },
        markClean: function() {
          this.cleanGeneration = this.changeGeneration(true);
        },
        changeGeneration: function(forceSplit) {
          if (forceSplit) {
            this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null;
          }
          return this.history.generation;
        },
        isClean: function(gen) {
          return this.history.generation == (gen || this.cleanGeneration);
        },
        getHistory: function() {
          return {
            done: copyHistoryArray(this.history.done),
            undone: copyHistoryArray(this.history.undone)
          };
        },
        setHistory: function(histData) {
          var hist = this.history = new History(this.history);
          hist.done = copyHistoryArray(histData.done.slice(0), null, true);
          hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
        },
        setGutterMarker: docMethodOp(function(line, gutterID, value) {
          return changeLine(this, line, "gutter", function(line2) {
            var markers = line2.gutterMarkers || (line2.gutterMarkers = {});
            markers[gutterID] = value;
            if (!value && isEmpty(markers)) {
              line2.gutterMarkers = null;
            }
            return true;
          });
        }),
        clearGutter: docMethodOp(function(gutterID) {
          var this$1 = this;
          this.iter(function(line) {
            if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
              changeLine(this$1, line, "gutter", function() {
                line.gutterMarkers[gutterID] = null;
                if (isEmpty(line.gutterMarkers)) {
                  line.gutterMarkers = null;
                }
                return true;
              });
            }
          });
        }),
        lineInfo: function(line) {
          var n;
          if (typeof line == "number") {
            if (!isLine(this, line)) {
              return null;
            }
            n = line;
            line = getLine(this, line);
            if (!line) {
              return null;
            }
          } else {
            n = lineNo(line);
            if (n == null) {
              return null;
            }
          }
          return {
            line: n,
            handle: line,
            text: line.text,
            gutterMarkers: line.gutterMarkers,
            textClass: line.textClass,
            bgClass: line.bgClass,
            wrapClass: line.wrapClass,
            widgets: line.widgets
          };
        },
        addLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            if (!line[prop2]) {
              line[prop2] = cls;
            } else if (classTest(cls).test(line[prop2])) {
              return false;
            } else {
              line[prop2] += " " + cls;
            }
            return true;
          });
        }),
        removeLineClass: docMethodOp(function(handle, where, cls) {
          return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function(line) {
            var prop2 = where == "text" ? "textClass" : where == "background" ? "bgClass" : where == "gutter" ? "gutterClass" : "wrapClass";
            var cur = line[prop2];
            if (!cur) {
              return false;
            } else if (cls == null) {
              line[prop2] = null;
            } else {
              var found = cur.match(classTest(cls));
              if (!found) {
                return false;
              }
              var end = found.index + found[0].length;
              line[prop2] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
            }
            return true;
          });
        }),
        addLineWidget: docMethodOp(function(handle, node, options) {
          return addLineWidget(this, handle, node, options);
        }),
        removeLineWidget: function(widget) {
          widget.clear();
        },
        markText: function(from, to, options) {
          return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range");
        },
        setBookmark: function(pos, options) {
          var realOpts = {
            replacedWith: options && (options.nodeType == null ? options.widget : options),
            insertLeft: options && options.insertLeft,
            clearWhenEmpty: false,
            shared: options && options.shared,
            handleMouseEvents: options && options.handleMouseEvents
          };
          pos = clipPos(this, pos);
          return markText(this, pos, pos, realOpts, "bookmark");
        },
        findMarksAt: function(pos) {
          pos = clipPos(this, pos);
          var markers = [], spans = getLine(this, pos.line).markedSpans;
          if (spans) {
            for (var i2 = 0; i2 < spans.length; ++i2) {
              var span = spans[i2];
              if ((span.from == null || span.from <= pos.ch) && (span.to == null || span.to >= pos.ch)) {
                markers.push(span.marker.parent || span.marker);
              }
            }
          }
          return markers;
        },
        findMarks: function(from, to, filter) {
          from = clipPos(this, from);
          to = clipPos(this, to);
          var found = [], lineNo2 = from.line;
          this.iter(from.line, to.line + 1, function(line) {
            var spans = line.markedSpans;
            if (spans) {
              for (var i2 = 0; i2 < spans.length; i2++) {
                var span = spans[i2];
                if (!(span.to != null && lineNo2 == from.line && from.ch >= span.to || span.from == null && lineNo2 != from.line || span.from != null && lineNo2 == to.line && span.from >= to.ch) && (!filter || filter(span.marker))) {
                  found.push(span.marker.parent || span.marker);
                }
              }
            }
            ++lineNo2;
          });
          return found;
        },
        getAllMarks: function() {
          var markers = [];
          this.iter(function(line) {
            var sps = line.markedSpans;
            if (sps) {
              for (var i2 = 0; i2 < sps.length; ++i2) {
                if (sps[i2].from != null) {
                  markers.push(sps[i2].marker);
                }
              }
            }
          });
          return markers;
        },
        posFromIndex: function(off2) {
          var ch, lineNo2 = this.first, sepSize = this.lineSeparator().length;
          this.iter(function(line) {
            var sz = line.text.length + sepSize;
            if (sz > off2) {
              ch = off2;
              return true;
            }
            off2 -= sz;
            ++lineNo2;
          });
          return clipPos(this, Pos(lineNo2, ch));
        },
        indexFromPos: function(coords) {
          coords = clipPos(this, coords);
          var index = coords.ch;
          if (coords.line < this.first || coords.ch < 0) {
            return 0;
          }
          var sepSize = this.lineSeparator().length;
          this.iter(this.first, coords.line, function(line) {
            index += line.text.length + sepSize;
          });
          return index;
        },
        copy: function(copyHistory) {
          var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
          doc.scrollTop = this.scrollTop;
          doc.scrollLeft = this.scrollLeft;
          doc.sel = this.sel;
          doc.extend = false;
          if (copyHistory) {
            doc.history.undoDepth = this.history.undoDepth;
            doc.setHistory(this.getHistory());
          }
          return doc;
        },
        linkedDoc: function(options) {
          if (!options) {
            options = {};
          }
          var from = this.first, to = this.first + this.size;
          if (options.from != null && options.from > from) {
            from = options.from;
          }
          if (options.to != null && options.to < to) {
            to = options.to;
          }
          var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
          if (options.sharedHist) {
            copy.history = this.history;
          }
          (this.linked || (this.linked = [])).push({ doc: copy, sharedHist: options.sharedHist });
          copy.linked = [{ doc: this, isParent: true, sharedHist: options.sharedHist }];
          copySharedMarkers(copy, findSharedMarkers(this));
          return copy;
        },
        unlinkDoc: function(other) {
          if (other instanceof CodeMirror2) {
            other = other.doc;
          }
          if (this.linked) {
            for (var i2 = 0; i2 < this.linked.length; ++i2) {
              var link = this.linked[i2];
              if (link.doc != other) {
                continue;
              }
              this.linked.splice(i2, 1);
              other.unlinkDoc(this);
              detachSharedMarkers(findSharedMarkers(this));
              break;
            }
          }
          if (other.history == this.history) {
            var splitIds = [other.id];
            linkedDocs(other, function(doc) {
              return splitIds.push(doc.id);
            }, true);
            other.history = new History(null);
            other.history.done = copyHistoryArray(this.history.done, splitIds);
            other.history.undone = copyHistoryArray(this.history.undone, splitIds);
          }
        },
        iterLinkedDocs: function(f) {
          linkedDocs(this, f);
        },
        getMode: function() {
          return this.mode;
        },
        getEditor: function() {
          return this.cm;
        },
        splitLines: function(str) {
          if (this.lineSep) {
            return str.split(this.lineSep);
          }
          return splitLinesAuto(str);
        },
        lineSeparator: function() {
          return this.lineSep || "\n";
        },
        setDirection: docMethodOp(function(dir) {
          if (dir != "rtl") {
            dir = "ltr";
          }
          if (dir == this.direction) {
            return;
          }
          this.direction = dir;
          this.iter(function(line) {
            return line.order = null;
          });
          if (this.cm) {
            directionChanged(this.cm);
          }
        })
      });
      Doc.prototype.eachLine = Doc.prototype.iter;
      var lastDrop = 0;
      function onDrop(e) {
        var cm = this;
        clearDragCursor(cm);
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e_preventDefault(e);
        if (ie) {
          lastDrop = +new Date();
        }
        var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
        if (!pos || cm.isReadOnly()) {
          return;
        }
        if (files && files.length && window.FileReader && window.File) {
          var n = files.length, text2 = Array(n), read = 0;
          var markAsReadAndPasteIfAllFilesAreRead = function() {
            if (++read == n) {
              operation(cm, function() {
                pos = clipPos(cm.doc, pos);
                var change = {
                  from: pos,
                  to: pos,
                  text: cm.doc.splitLines(text2.filter(function(t2) {
                    return t2 != null;
                  }).join(cm.doc.lineSeparator())),
                  origin: "paste"
                };
                makeChange(cm.doc, change);
                setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
              })();
            }
          };
          var readTextFromFile = function(file, i3) {
            if (cm.options.allowDropFileTypes && indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
              markAsReadAndPasteIfAllFilesAreRead();
              return;
            }
            var reader = new FileReader();
            reader.onerror = function() {
              return markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.onload = function() {
              var content = reader.result;
              if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
                markAsReadAndPasteIfAllFilesAreRead();
                return;
              }
              text2[i3] = content;
              markAsReadAndPasteIfAllFilesAreRead();
            };
            reader.readAsText(file);
          };
          for (var i2 = 0; i2 < files.length; i2++) {
            readTextFromFile(files[i2], i2);
          }
        } else {
          if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
            cm.state.draggingText(e);
            setTimeout(function() {
              return cm.display.input.focus();
            }, 20);
            return;
          }
          try {
            var text$1 = e.dataTransfer.getData("Text");
            if (text$1) {
              var selected;
              if (cm.state.draggingText && !cm.state.draggingText.copy) {
                selected = cm.listSelections();
              }
              setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
              if (selected) {
                for (var i$12 = 0; i$12 < selected.length; ++i$12) {
                  replaceRange(cm.doc, "", selected[i$12].anchor, selected[i$12].head, "drag");
                }
              }
              cm.replaceSelection(text$1, "around", "paste");
              cm.display.input.focus();
            }
          } catch (e$1) {
          }
        }
      }
      function onDragStart(cm, e) {
        if (ie && (!cm.state.draggingText || +new Date() - lastDrop < 100)) {
          e_stop(e);
          return;
        }
        if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) {
          return;
        }
        e.dataTransfer.setData("Text", cm.getSelection());
        e.dataTransfer.effectAllowed = "copyMove";
        if (e.dataTransfer.setDragImage && !safari) {
          var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
          img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
          if (presto) {
            img.width = img.height = 1;
            cm.display.wrapper.appendChild(img);
            img._top = img.offsetTop;
          }
          e.dataTransfer.setDragImage(img, 0, 0);
          if (presto) {
            img.parentNode.removeChild(img);
          }
        }
      }
      function onDragOver(cm, e) {
        var pos = posFromMouse(cm, e);
        if (!pos) {
          return;
        }
        var frag = document.createDocumentFragment();
        drawSelectionCursor(cm, pos, frag);
        if (!cm.display.dragCursor) {
          cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
          cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
        }
        removeChildrenAndAdd(cm.display.dragCursor, frag);
      }
      function clearDragCursor(cm) {
        if (cm.display.dragCursor) {
          cm.display.lineSpace.removeChild(cm.display.dragCursor);
          cm.display.dragCursor = null;
        }
      }
      function forEachCodeMirror(f) {
        if (!document.getElementsByClassName) {
          return;
        }
        var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
        for (var i2 = 0; i2 < byClass.length; i2++) {
          var cm = byClass[i2].CodeMirror;
          if (cm) {
            editors.push(cm);
          }
        }
        if (editors.length) {
          editors[0].operation(function() {
            for (var i3 = 0; i3 < editors.length; i3++) {
              f(editors[i3]);
            }
          });
        }
      }
      var globalsRegistered = false;
      function ensureGlobalHandlers() {
        if (globalsRegistered) {
          return;
        }
        registerGlobalHandlers();
        globalsRegistered = true;
      }
      function registerGlobalHandlers() {
        var resizeTimer;
        on(window, "resize", function() {
          if (resizeTimer == null) {
            resizeTimer = setTimeout(function() {
              resizeTimer = null;
              forEachCodeMirror(onResize);
            }, 100);
          }
        });
        on(window, "blur", function() {
          return forEachCodeMirror(onBlur);
        });
      }
      function onResize(cm) {
        var d = cm.display;
        d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
        d.scrollbarsClipped = false;
        cm.setSize();
      }
      var keyNames = {
        3: "Pause",
        8: "Backspace",
        9: "Tab",
        13: "Enter",
        16: "Shift",
        17: "Ctrl",
        18: "Alt",
        19: "Pause",
        20: "CapsLock",
        27: "Esc",
        32: "Space",
        33: "PageUp",
        34: "PageDown",
        35: "End",
        36: "Home",
        37: "Left",
        38: "Up",
        39: "Right",
        40: "Down",
        44: "PrintScrn",
        45: "Insert",
        46: "Delete",
        59: ";",
        61: "=",
        91: "Mod",
        92: "Mod",
        93: "Mod",
        106: "*",
        107: "=",
        109: "-",
        110: ".",
        111: "/",
        145: "ScrollLock",
        173: "-",
        186: ";",
        187: "=",
        188: ",",
        189: "-",
        190: ".",
        191: "/",
        192: "`",
        219: "[",
        220: "\\",
        221: "]",
        222: "'",
        224: "Mod",
        63232: "Up",
        63233: "Down",
        63234: "Left",
        63235: "Right",
        63272: "Delete",
        63273: "Home",
        63275: "End",
        63276: "PageUp",
        63277: "PageDown",
        63302: "Insert"
      };
      for (var i = 0; i < 10; i++) {
        keyNames[i + 48] = keyNames[i + 96] = String(i);
      }
      for (var i$1 = 65; i$1 <= 90; i$1++) {
        keyNames[i$1] = String.fromCharCode(i$1);
      }
      for (var i$2 = 1; i$2 <= 12; i$2++) {
        keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
      }
      var keyMap2 = {};
      keyMap2.basic = {
        "Left": "goCharLeft",
        "Right": "goCharRight",
        "Up": "goLineUp",
        "Down": "goLineDown",
        "End": "goLineEnd",
        "Home": "goLineStartSmart",
        "PageUp": "goPageUp",
        "PageDown": "goPageDown",
        "Delete": "delCharAfter",
        "Backspace": "delCharBefore",
        "Shift-Backspace": "delCharBefore",
        "Tab": "defaultTab",
        "Shift-Tab": "indentAuto",
        "Enter": "newlineAndIndent",
        "Insert": "toggleOverwrite",
        "Esc": "singleSelection"
      };
      keyMap2.pcDefault = {
        "Ctrl-A": "selectAll",
        "Ctrl-D": "deleteLine",
        "Ctrl-Z": "undo",
        "Shift-Ctrl-Z": "redo",
        "Ctrl-Y": "redo",
        "Ctrl-Home": "goDocStart",
        "Ctrl-End": "goDocEnd",
        "Ctrl-Up": "goLineUp",
        "Ctrl-Down": "goLineDown",
        "Ctrl-Left": "goGroupLeft",
        "Ctrl-Right": "goGroupRight",
        "Alt-Left": "goLineStart",
        "Alt-Right": "goLineEnd",
        "Ctrl-Backspace": "delGroupBefore",
        "Ctrl-Delete": "delGroupAfter",
        "Ctrl-S": "save",
        "Ctrl-F": "find",
        "Ctrl-G": "findNext",
        "Shift-Ctrl-G": "findPrev",
        "Shift-Ctrl-F": "replace",
        "Shift-Ctrl-R": "replaceAll",
        "Ctrl-[": "indentLess",
        "Ctrl-]": "indentMore",
        "Ctrl-U": "undoSelection",
        "Shift-Ctrl-U": "redoSelection",
        "Alt-U": "redoSelection",
        "fallthrough": "basic"
      };
      keyMap2.emacsy = {
        "Ctrl-F": "goCharRight",
        "Ctrl-B": "goCharLeft",
        "Ctrl-P": "goLineUp",
        "Ctrl-N": "goLineDown",
        "Ctrl-A": "goLineStart",
        "Ctrl-E": "goLineEnd",
        "Ctrl-V": "goPageDown",
        "Shift-Ctrl-V": "goPageUp",
        "Ctrl-D": "delCharAfter",
        "Ctrl-H": "delCharBefore",
        "Alt-Backspace": "delWordBefore",
        "Ctrl-K": "killLine",
        "Ctrl-T": "transposeChars",
        "Ctrl-O": "openLine"
      };
      keyMap2.macDefault = {
        "Cmd-A": "selectAll",
        "Cmd-D": "deleteLine",
        "Cmd-Z": "undo",
        "Shift-Cmd-Z": "redo",
        "Cmd-Y": "redo",
        "Cmd-Home": "goDocStart",
        "Cmd-Up": "goDocStart",
        "Cmd-End": "goDocEnd",
        "Cmd-Down": "goDocEnd",
        "Alt-Left": "goGroupLeft",
        "Alt-Right": "goGroupRight",
        "Cmd-Left": "goLineLeft",
        "Cmd-Right": "goLineRight",
        "Alt-Backspace": "delGroupBefore",
        "Ctrl-Alt-Backspace": "delGroupAfter",
        "Alt-Delete": "delGroupAfter",
        "Cmd-S": "save",
        "Cmd-F": "find",
        "Cmd-G": "findNext",
        "Shift-Cmd-G": "findPrev",
        "Cmd-Alt-F": "replace",
        "Shift-Cmd-Alt-F": "replaceAll",
        "Cmd-[": "indentLess",
        "Cmd-]": "indentMore",
        "Cmd-Backspace": "delWrappedLineLeft",
        "Cmd-Delete": "delWrappedLineRight",
        "Cmd-U": "undoSelection",
        "Shift-Cmd-U": "redoSelection",
        "Ctrl-Up": "goDocStart",
        "Ctrl-Down": "goDocEnd",
        "fallthrough": ["basic", "emacsy"]
      };
      keyMap2["default"] = mac ? keyMap2.macDefault : keyMap2.pcDefault;
      function normalizeKeyName(name2) {
        var parts = name2.split(/-(?!$)/);
        name2 = parts[parts.length - 1];
        var alt, ctrl, shift, cmd;
        for (var i2 = 0; i2 < parts.length - 1; i2++) {
          var mod = parts[i2];
          if (/^(cmd|meta|m)$/i.test(mod)) {
            cmd = true;
          } else if (/^a(lt)?$/i.test(mod)) {
            alt = true;
          } else if (/^(c|ctrl|control)$/i.test(mod)) {
            ctrl = true;
          } else if (/^s(hift)?$/i.test(mod)) {
            shift = true;
          } else {
            throw new Error("Unrecognized modifier name: " + mod);
          }
        }
        if (alt) {
          name2 = "Alt-" + name2;
        }
        if (ctrl) {
          name2 = "Ctrl-" + name2;
        }
        if (cmd) {
          name2 = "Cmd-" + name2;
        }
        if (shift) {
          name2 = "Shift-" + name2;
        }
        return name2;
      }
      function normalizeKeyMap(keymap) {
        var copy = {};
        for (var keyname in keymap) {
          if (keymap.hasOwnProperty(keyname)) {
            var value = keymap[keyname];
            if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) {
              continue;
            }
            if (value == "...") {
              delete keymap[keyname];
              continue;
            }
            var keys = map2(keyname.split(" "), normalizeKeyName);
            for (var i2 = 0; i2 < keys.length; i2++) {
              var val = void 0, name2 = void 0;
              if (i2 == keys.length - 1) {
                name2 = keys.join(" ");
                val = value;
              } else {
                name2 = keys.slice(0, i2 + 1).join(" ");
                val = "...";
              }
              var prev = copy[name2];
              if (!prev) {
                copy[name2] = val;
              } else if (prev != val) {
                throw new Error("Inconsistent bindings for " + name2);
              }
            }
            delete keymap[keyname];
          }
        }
        for (var prop2 in copy) {
          keymap[prop2] = copy[prop2];
        }
        return keymap;
      }
      function lookupKey(key, map3, handle, context) {
        map3 = getKeyMap(map3);
        var found = map3.call ? map3.call(key, context) : map3[key];
        if (found === false) {
          return "nothing";
        }
        if (found === "...") {
          return "multi";
        }
        if (found != null && handle(found)) {
          return "handled";
        }
        if (map3.fallthrough) {
          if (Object.prototype.toString.call(map3.fallthrough) != "[object Array]") {
            return lookupKey(key, map3.fallthrough, handle, context);
          }
          for (var i2 = 0; i2 < map3.fallthrough.length; i2++) {
            var result = lookupKey(key, map3.fallthrough[i2], handle, context);
            if (result) {
              return result;
            }
          }
        }
      }
      function isModifierKey(value) {
        var name2 = typeof value == "string" ? value : keyNames[value.keyCode];
        return name2 == "Ctrl" || name2 == "Alt" || name2 == "Shift" || name2 == "Mod";
      }
      function addModifierNames(name2, event, noShift) {
        var base2 = name2;
        if (event.altKey && base2 != "Alt") {
          name2 = "Alt-" + name2;
        }
        if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base2 != "Ctrl") {
          name2 = "Ctrl-" + name2;
        }
        if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base2 != "Mod") {
          name2 = "Cmd-" + name2;
        }
        if (!noShift && event.shiftKey && base2 != "Shift") {
          name2 = "Shift-" + name2;
        }
        return name2;
      }
      function keyName(event, noShift) {
        if (presto && event.keyCode == 34 && event["char"]) {
          return false;
        }
        var name2 = keyNames[event.keyCode];
        if (name2 == null || event.altGraphKey) {
          return false;
        }
        if (event.keyCode == 3 && event.code) {
          name2 = event.code;
        }
        return addModifierNames(name2, event, noShift);
      }
      function getKeyMap(val) {
        return typeof val == "string" ? keyMap2[val] : val;
      }
      function deleteNearSelection(cm, compute) {
        var ranges = cm.doc.sel.ranges, kill = [];
        for (var i2 = 0; i2 < ranges.length; i2++) {
          var toKill = compute(ranges[i2]);
          while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
            var replaced = kill.pop();
            if (cmp(replaced.from, toKill.from) < 0) {
              toKill.from = replaced.from;
              break;
            }
          }
          kill.push(toKill);
        }
        runInOp(cm, function() {
          for (var i3 = kill.length - 1; i3 >= 0; i3--) {
            replaceRange(cm.doc, "", kill[i3].from, kill[i3].to, "+delete");
          }
          ensureCursorVisible(cm);
        });
      }
      function moveCharLogically(line, ch, dir) {
        var target = skipExtendingChars(line.text, ch + dir, dir);
        return target < 0 || target > line.text.length ? null : target;
      }
      function moveLogically(line, start, dir) {
        var ch = moveCharLogically(line, start.ch, dir);
        return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before");
      }
      function endOfLine(visually, cm, lineObj, lineNo2, dir) {
        if (visually) {
          if (cm.doc.direction == "rtl") {
            dir = -dir;
          }
          var order = getOrder(lineObj, cm.doc.direction);
          if (order) {
            var part = dir < 0 ? lst(order) : order[0];
            var moveInStorageOrder = dir < 0 == (part.level == 1);
            var sticky = moveInStorageOrder ? "after" : "before";
            var ch;
            if (part.level > 0 || cm.doc.direction == "rtl") {
              var prep = prepareMeasureForLine(cm, lineObj);
              ch = dir < 0 ? lineObj.text.length - 1 : 0;
              var targetTop = measureCharPrepared(cm, prep, ch).top;
              ch = findFirst(function(ch2) {
                return measureCharPrepared(cm, prep, ch2).top == targetTop;
              }, dir < 0 == (part.level == 1) ? part.from : part.to - 1, ch);
              if (sticky == "before") {
                ch = moveCharLogically(lineObj, ch, 1);
              }
            } else {
              ch = dir < 0 ? part.to : part.from;
            }
            return new Pos(lineNo2, ch, sticky);
          }
        }
        return new Pos(lineNo2, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after");
      }
      function moveVisually(cm, line, start, dir) {
        var bidi = getOrder(line, cm.doc.direction);
        if (!bidi) {
          return moveLogically(line, start, dir);
        }
        if (start.ch >= line.text.length) {
          start.ch = line.text.length;
          start.sticky = "before";
        } else if (start.ch <= 0) {
          start.ch = 0;
          start.sticky = "after";
        }
        var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
        if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
          return moveLogically(line, start, dir);
        }
        var mv = function(pos, dir2) {
          return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir2);
        };
        var prep;
        var getWrappedLineExtent = function(ch2) {
          if (!cm.options.lineWrapping) {
            return { begin: 0, end: line.text.length };
          }
          prep = prep || prepareMeasureForLine(cm, line);
          return wrappedLineExtentChar(cm, line, prep, ch2);
        };
        var wrappedLineExtent2 = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);
        if (cm.doc.direction == "rtl" || part.level == 1) {
          var moveInStorageOrder = part.level == 1 == dir < 0;
          var ch = mv(start, moveInStorageOrder ? 1 : -1);
          if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent2.begin : ch <= part.to && ch <= wrappedLineExtent2.end)) {
            var sticky = moveInStorageOrder ? "before" : "after";
            return new Pos(start.line, ch, sticky);
          }
        }
        var searchInVisualLine = function(partPos2, dir2, wrappedLineExtent3) {
          var getRes = function(ch3, moveInStorageOrder3) {
            return moveInStorageOrder3 ? new Pos(start.line, mv(ch3, 1), "before") : new Pos(start.line, ch3, "after");
          };
          for (; partPos2 >= 0 && partPos2 < bidi.length; partPos2 += dir2) {
            var part2 = bidi[partPos2];
            var moveInStorageOrder2 = dir2 > 0 == (part2.level != 1);
            var ch2 = moveInStorageOrder2 ? wrappedLineExtent3.begin : mv(wrappedLineExtent3.end, -1);
            if (part2.from <= ch2 && ch2 < part2.to) {
              return getRes(ch2, moveInStorageOrder2);
            }
            ch2 = moveInStorageOrder2 ? part2.from : mv(part2.to, -1);
            if (wrappedLineExtent3.begin <= ch2 && ch2 < wrappedLineExtent3.end) {
              return getRes(ch2, moveInStorageOrder2);
            }
          }
        };
        var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent2);
        if (res) {
          return res;
        }
        var nextCh = dir > 0 ? wrappedLineExtent2.end : mv(wrappedLineExtent2.begin, -1);
        if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
          res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
          if (res) {
            return res;
          }
        }
        return null;
      }
      var commands = {
        selectAll,
        singleSelection: function(cm) {
          return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll);
        },
        killLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            if (range2.empty()) {
              var len = getLine(cm.doc, range2.head.line).text.length;
              if (range2.head.ch == len && range2.head.line < cm.lastLine()) {
                return { from: range2.head, to: Pos(range2.head.line + 1, 0) };
              } else {
                return { from: range2.head, to: Pos(range2.head.line, len) };
              }
            } else {
              return { from: range2.from(), to: range2.to() };
            }
          });
        },
        deleteLine: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: clipPos(cm.doc, Pos(range2.to().line + 1, 0))
            };
          });
        },
        delLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            return {
              from: Pos(range2.from().line, 0),
              to: range2.from()
            };
          });
        },
        delWrappedLineLeft: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var leftPos = cm.coordsChar({ left: 0, top }, "div");
            return { from: leftPos, to: range2.from() };
          });
        },
        delWrappedLineRight: function(cm) {
          return deleteNearSelection(cm, function(range2) {
            var top = cm.charCoords(range2.head, "div").top + 5;
            var rightPos = cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
            return { from: range2.from(), to: rightPos };
          });
        },
        undo: function(cm) {
          return cm.undo();
        },
        redo: function(cm) {
          return cm.redo();
        },
        undoSelection: function(cm) {
          return cm.undoSelection();
        },
        redoSelection: function(cm) {
          return cm.redoSelection();
        },
        goDocStart: function(cm) {
          return cm.extendSelection(Pos(cm.firstLine(), 0));
        },
        goDocEnd: function(cm) {
          return cm.extendSelection(Pos(cm.lastLine()));
        },
        goLineStart: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            return lineStart(cm, range2.head.line);
          }, { origin: "+move", bias: 1 });
        },
        goLineStartSmart: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            return lineStartSmart(cm, range2.head);
          }, { origin: "+move", bias: 1 });
        },
        goLineEnd: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            return lineEnd(cm, range2.head.line);
          }, { origin: "+move", bias: -1 });
        },
        goLineRight: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: cm.display.lineDiv.offsetWidth + 100, top }, "div");
          }, sel_move);
        },
        goLineLeft: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            return cm.coordsChar({ left: 0, top }, "div");
          }, sel_move);
        },
        goLineLeftSmart: function(cm) {
          return cm.extendSelectionsBy(function(range2) {
            var top = cm.cursorCoords(range2.head, "div").top + 5;
            var pos = cm.coordsChar({ left: 0, top }, "div");
            if (pos.ch < cm.getLine(pos.line).search(/\S/)) {
              return lineStartSmart(cm, range2.head);
            }
            return pos;
          }, sel_move);
        },
        goLineUp: function(cm) {
          return cm.moveV(-1, "line");
        },
        goLineDown: function(cm) {
          return cm.moveV(1, "line");
        },
        goPageUp: function(cm) {
          return cm.moveV(-1, "page");
        },
        goPageDown: function(cm) {
          return cm.moveV(1, "page");
        },
        goCharLeft: function(cm) {
          return cm.moveH(-1, "char");
        },
        goCharRight: function(cm) {
          return cm.moveH(1, "char");
        },
        goColumnLeft: function(cm) {
          return cm.moveH(-1, "column");
        },
        goColumnRight: function(cm) {
          return cm.moveH(1, "column");
        },
        goWordLeft: function(cm) {
          return cm.moveH(-1, "word");
        },
        goGroupRight: function(cm) {
          return cm.moveH(1, "group");
        },
        goGroupLeft: function(cm) {
          return cm.moveH(-1, "group");
        },
        goWordRight: function(cm) {
          return cm.moveH(1, "word");
        },
        delCharBefore: function(cm) {
          return cm.deleteH(-1, "codepoint");
        },
        delCharAfter: function(cm) {
          return cm.deleteH(1, "char");
        },
        delWordBefore: function(cm) {
          return cm.deleteH(-1, "word");
        },
        delWordAfter: function(cm) {
          return cm.deleteH(1, "word");
        },
        delGroupBefore: function(cm) {
          return cm.deleteH(-1, "group");
        },
        delGroupAfter: function(cm) {
          return cm.deleteH(1, "group");
        },
        indentAuto: function(cm) {
          return cm.indentSelection("smart");
        },
        indentMore: function(cm) {
          return cm.indentSelection("add");
        },
        indentLess: function(cm) {
          return cm.indentSelection("subtract");
        },
        insertTab: function(cm) {
          return cm.replaceSelection("	");
        },
        insertSoftTab: function(cm) {
          var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var pos = ranges[i2].from();
            var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
            spaces.push(spaceStr(tabSize - col % tabSize));
          }
          cm.replaceSelections(spaces);
        },
        defaultTab: function(cm) {
          if (cm.somethingSelected()) {
            cm.indentSelection("add");
          } else {
            cm.execCommand("insertTab");
          }
        },
        transposeChars: function(cm) {
          return runInOp(cm, function() {
            var ranges = cm.listSelections(), newSel = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              if (!ranges[i2].empty()) {
                continue;
              }
              var cur = ranges[i2].head, line = getLine(cm.doc, cur.line).text;
              if (line) {
                if (cur.ch == line.length) {
                  cur = new Pos(cur.line, cur.ch - 1);
                }
                if (cur.ch > 0) {
                  cur = new Pos(cur.line, cur.ch + 1);
                  cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                } else if (cur.line > cm.doc.first) {
                  var prev = getLine(cm.doc, cur.line - 1).text;
                  if (prev) {
                    cur = new Pos(cur.line, 1);
                    cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
                  }
                }
              }
              newSel.push(new Range3(cur, cur));
            }
            cm.setSelections(newSel);
          });
        },
        newlineAndIndent: function(cm) {
          return runInOp(cm, function() {
            var sels = cm.listSelections();
            for (var i2 = sels.length - 1; i2 >= 0; i2--) {
              cm.replaceRange(cm.doc.lineSeparator(), sels[i2].anchor, sels[i2].head, "+input");
            }
            sels = cm.listSelections();
            for (var i$12 = 0; i$12 < sels.length; i$12++) {
              cm.indentLine(sels[i$12].from().line, null, true);
            }
            ensureCursorVisible(cm);
          });
        },
        openLine: function(cm) {
          return cm.replaceSelection("\n", "start");
        },
        toggleOverwrite: function(cm) {
          return cm.toggleOverwrite();
        }
      };
      function lineStart(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLine(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, visual, lineN, 1);
      }
      function lineEnd(cm, lineN) {
        var line = getLine(cm.doc, lineN);
        var visual = visualLineEnd(line);
        if (visual != line) {
          lineN = lineNo(visual);
        }
        return endOfLine(true, cm, line, lineN, -1);
      }
      function lineStartSmart(cm, pos) {
        var start = lineStart(cm, pos.line);
        var line = getLine(cm.doc, start.line);
        var order = getOrder(line, cm.doc.direction);
        if (!order || order[0].level == 0) {
          var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
          var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
          return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky);
        }
        return start;
      }
      function doHandleBinding(cm, bound, dropShift) {
        if (typeof bound == "string") {
          bound = commands[bound];
          if (!bound) {
            return false;
          }
        }
        cm.display.input.ensurePolled();
        var prevShift = cm.display.shift, done = false;
        try {
          if (cm.isReadOnly()) {
            cm.state.suppressEdits = true;
          }
          if (dropShift) {
            cm.display.shift = false;
          }
          done = bound(cm) != Pass;
        } finally {
          cm.display.shift = prevShift;
          cm.state.suppressEdits = false;
        }
        return done;
      }
      function lookupKeyForEditor(cm, name2, handle) {
        for (var i2 = 0; i2 < cm.state.keyMaps.length; i2++) {
          var result = lookupKey(name2, cm.state.keyMaps[i2], handle, cm);
          if (result) {
            return result;
          }
        }
        return cm.options.extraKeys && lookupKey(name2, cm.options.extraKeys, handle, cm) || lookupKey(name2, cm.options.keyMap, handle, cm);
      }
      var stopSeq = new Delayed();
      function dispatchKey(cm, name2, e, handle) {
        var seq = cm.state.keySeq;
        if (seq) {
          if (isModifierKey(name2)) {
            return "handled";
          }
          if (/\'$/.test(name2)) {
            cm.state.keySeq = null;
          } else {
            stopSeq.set(50, function() {
              if (cm.state.keySeq == seq) {
                cm.state.keySeq = null;
                cm.display.input.reset();
              }
            });
          }
          if (dispatchKeyInner(cm, seq + " " + name2, e, handle)) {
            return true;
          }
        }
        return dispatchKeyInner(cm, name2, e, handle);
      }
      function dispatchKeyInner(cm, name2, e, handle) {
        var result = lookupKeyForEditor(cm, name2, handle);
        if (result == "multi") {
          cm.state.keySeq = name2;
        }
        if (result == "handled") {
          signalLater(cm, "keyHandled", cm, name2, e);
        }
        if (result == "handled" || result == "multi") {
          e_preventDefault(e);
          restartBlink(cm);
        }
        return !!result;
      }
      function handleKeyBinding(cm, e) {
        var name2 = keyName(e, true);
        if (!name2) {
          return false;
        }
        if (e.shiftKey && !cm.state.keySeq) {
          return dispatchKey(cm, "Shift-" + name2, e, function(b) {
            return doHandleBinding(cm, b, true);
          }) || dispatchKey(cm, name2, e, function(b) {
            if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion) {
              return doHandleBinding(cm, b);
            }
          });
        } else {
          return dispatchKey(cm, name2, e, function(b) {
            return doHandleBinding(cm, b);
          });
        }
      }
      function handleCharBinding(cm, e, ch) {
        return dispatchKey(cm, "'" + ch + "'", e, function(b) {
          return doHandleBinding(cm, b, true);
        });
      }
      var lastStoppedKey = null;
      function onKeyDown(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }
        cm.curOp.focus = activeElt();
        if (signalDOMEvent(cm, e)) {
          return;
        }
        if (ie && ie_version < 11 && e.keyCode == 27) {
          e.returnValue = false;
        }
        var code = e.keyCode;
        cm.display.shift = code == 16 || e.shiftKey;
        var handled = handleKeyBinding(cm, e);
        if (presto) {
          lastStoppedKey = handled ? code : null;
          if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey)) {
            cm.replaceSelection("", null, "cut");
          }
        }
        if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand) {
          document.execCommand("cut");
        }
        if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className)) {
          showCrossHair(cm);
        }
      }
      function showCrossHair(cm) {
        var lineDiv = cm.display.lineDiv;
        addClass(lineDiv, "CodeMirror-crosshair");
        function up(e) {
          if (e.keyCode == 18 || !e.altKey) {
            rmClass(lineDiv, "CodeMirror-crosshair");
            off(document, "keyup", up);
            off(document, "mouseover", up);
          }
        }
        on(document, "keyup", up);
        on(document, "mouseover", up);
      }
      function onKeyUp(e) {
        if (e.keyCode == 16) {
          this.doc.sel.shift = false;
        }
        signalDOMEvent(this, e);
      }
      function onKeyPress(e) {
        var cm = this;
        if (e.target && e.target != cm.display.input.getField()) {
          return;
        }
        if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) {
          return;
        }
        var keyCode = e.keyCode, charCode = e.charCode;
        if (presto && keyCode == lastStoppedKey) {
          lastStoppedKey = null;
          e_preventDefault(e);
          return;
        }
        if (presto && (!e.which || e.which < 10) && handleKeyBinding(cm, e)) {
          return;
        }
        var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
        if (ch == "\b") {
          return;
        }
        if (handleCharBinding(cm, e, ch)) {
          return;
        }
        cm.display.input.onKeyPress(e);
      }
      var DOUBLECLICK_DELAY = 400;
      var PastClick = function(time, pos, button) {
        this.time = time;
        this.pos = pos;
        this.button = button;
      };
      PastClick.prototype.compare = function(time, pos, button) {
        return this.time + DOUBLECLICK_DELAY > time && cmp(pos, this.pos) == 0 && button == this.button;
      };
      var lastClick, lastDoubleClick;
      function clickRepeat(pos, button) {
        var now = +new Date();
        if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
          lastClick = lastDoubleClick = null;
          return "triple";
        } else if (lastClick && lastClick.compare(now, pos, button)) {
          lastDoubleClick = new PastClick(now, pos, button);
          lastClick = null;
          return "double";
        } else {
          lastClick = new PastClick(now, pos, button);
          lastDoubleClick = null;
          return "single";
        }
      }
      function onMouseDown(e) {
        var cm = this, display = cm.display;
        if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) {
          return;
        }
        display.input.ensurePolled();
        display.shift = e.shiftKey;
        if (eventInWidget(display, e)) {
          if (!webkit) {
            display.scroller.draggable = false;
            setTimeout(function() {
              return display.scroller.draggable = true;
            }, 100);
          }
          return;
        }
        if (clickInGutter(cm, e)) {
          return;
        }
        var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
        window.focus();
        if (button == 1 && cm.state.selectingText) {
          cm.state.selectingText(e);
        }
        if (pos && handleMappedButton(cm, button, pos, repeat, e)) {
          return;
        }
        if (button == 1) {
          if (pos) {
            leftButtonDown(cm, pos, repeat, e);
          } else if (e_target(e) == display.scroller) {
            e_preventDefault(e);
          }
        } else if (button == 2) {
          if (pos) {
            extendSelection(cm.doc, pos);
          }
          setTimeout(function() {
            return display.input.focus();
          }, 20);
        } else if (button == 3) {
          if (captureRightClick) {
            cm.display.input.onContextMenu(e);
          } else {
            delayBlurEvent(cm);
          }
        }
      }
      function handleMappedButton(cm, button, pos, repeat, event) {
        var name2 = "Click";
        if (repeat == "double") {
          name2 = "Double" + name2;
        } else if (repeat == "triple") {
          name2 = "Triple" + name2;
        }
        name2 = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name2;
        return dispatchKey(cm, addModifierNames(name2, event), event, function(bound) {
          if (typeof bound == "string") {
            bound = commands[bound];
          }
          if (!bound) {
            return false;
          }
          var done = false;
          try {
            if (cm.isReadOnly()) {
              cm.state.suppressEdits = true;
            }
            done = bound(cm, pos) != Pass;
          } finally {
            cm.state.suppressEdits = false;
          }
          return done;
        });
      }
      function configureMouse(cm, repeat, event) {
        var option = cm.getOption("configureMouse");
        var value = option ? option(cm, repeat, event) : {};
        if (value.unit == null) {
          var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
          value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
        }
        if (value.extend == null || cm.doc.extend) {
          value.extend = cm.doc.extend || event.shiftKey;
        }
        if (value.addNew == null) {
          value.addNew = mac ? event.metaKey : event.ctrlKey;
        }
        if (value.moveOnDrag == null) {
          value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey);
        }
        return value;
      }
      function leftButtonDown(cm, pos, repeat, event) {
        if (ie) {
          setTimeout(bind(ensureFocus, cm), 0);
        } else {
          cm.curOp.focus = activeElt();
        }
        var behavior = configureMouse(cm, repeat, event);
        var sel = cm.doc.sel, contained;
        if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && repeat == "single" && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0)) {
          leftButtonStartDrag(cm, event, pos, behavior);
        } else {
          leftButtonSelect(cm, event, pos, behavior);
        }
      }
      function leftButtonStartDrag(cm, event, pos, behavior) {
        var display = cm.display, moved = false;
        var dragEnd = operation(cm, function(e) {
          if (webkit) {
            display.scroller.draggable = false;
          }
          cm.state.draggingText = false;
          if (cm.state.delayingBlurEvent) {
            if (cm.hasFocus()) {
              cm.state.delayingBlurEvent = false;
            } else {
              delayBlurEvent(cm);
            }
          }
          off(display.wrapper.ownerDocument, "mouseup", dragEnd);
          off(display.wrapper.ownerDocument, "mousemove", mouseMove);
          off(display.scroller, "dragstart", dragStart);
          off(display.scroller, "drop", dragEnd);
          if (!moved) {
            e_preventDefault(e);
            if (!behavior.addNew) {
              extendSelection(cm.doc, pos, null, null, behavior.extend);
            }
            if (webkit && !safari || ie && ie_version == 9) {
              setTimeout(function() {
                display.wrapper.ownerDocument.body.focus({ preventScroll: true });
                display.input.focus();
              }, 20);
            } else {
              display.input.focus();
            }
          }
        });
        var mouseMove = function(e2) {
          moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
        };
        var dragStart = function() {
          return moved = true;
        };
        if (webkit) {
          display.scroller.draggable = true;
        }
        cm.state.draggingText = dragEnd;
        dragEnd.copy = !behavior.moveOnDrag;
        on(display.wrapper.ownerDocument, "mouseup", dragEnd);
        on(display.wrapper.ownerDocument, "mousemove", mouseMove);
        on(display.scroller, "dragstart", dragStart);
        on(display.scroller, "drop", dragEnd);
        cm.state.delayingBlurEvent = true;
        setTimeout(function() {
          return display.input.focus();
        }, 20);
        if (display.scroller.dragDrop) {
          display.scroller.dragDrop();
        }
      }
      function rangeForUnit(cm, pos, unit) {
        if (unit == "char") {
          return new Range3(pos, pos);
        }
        if (unit == "word") {
          return cm.findWordAt(pos);
        }
        if (unit == "line") {
          return new Range3(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
        }
        var result = unit(cm, pos);
        return new Range3(result.from, result.to);
      }
      function leftButtonSelect(cm, event, start, behavior) {
        if (ie) {
          delayBlurEvent(cm);
        }
        var display = cm.display, doc = cm.doc;
        e_preventDefault(event);
        var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
        if (behavior.addNew && !behavior.extend) {
          ourIndex = doc.sel.contains(start);
          if (ourIndex > -1) {
            ourRange = ranges[ourIndex];
          } else {
            ourRange = new Range3(start, start);
          }
        } else {
          ourRange = doc.sel.primary();
          ourIndex = doc.sel.primIndex;
        }
        if (behavior.unit == "rectangle") {
          if (!behavior.addNew) {
            ourRange = new Range3(start, start);
          }
          start = posFromMouse(cm, event, true, true);
          ourIndex = -1;
        } else {
          var range2 = rangeForUnit(cm, start, behavior.unit);
          if (behavior.extend) {
            ourRange = extendRange(ourRange, range2.anchor, range2.head, behavior.extend);
          } else {
            ourRange = range2;
          }
        }
        if (!behavior.addNew) {
          ourIndex = 0;
          setSelection(doc, new Selection([ourRange], 0), sel_mouse);
          startSel = doc.sel;
        } else if (ourIndex == -1) {
          ourIndex = ranges.length;
          setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex), { scroll: false, origin: "*mouse" });
        } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
          setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), { scroll: false, origin: "*mouse" });
          startSel = doc.sel;
        } else {
          replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
        }
        var lastPos = start;
        function extendTo(pos) {
          if (cmp(lastPos, pos) == 0) {
            return;
          }
          lastPos = pos;
          if (behavior.unit == "rectangle") {
            var ranges2 = [], tabSize = cm.options.tabSize;
            var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
            var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
            var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
            for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
              var text2 = getLine(doc, line).text, leftPos = findColumn(text2, left, tabSize);
              if (left == right) {
                ranges2.push(new Range3(Pos(line, leftPos), Pos(line, leftPos)));
              } else if (text2.length > leftPos) {
                ranges2.push(new Range3(Pos(line, leftPos), Pos(line, findColumn(text2, right, tabSize))));
              }
            }
            if (!ranges2.length) {
              ranges2.push(new Range3(start, start));
            }
            setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges2), ourIndex), { origin: "*mouse", scroll: false });
            cm.scrollIntoView(pos);
          } else {
            var oldRange = ourRange;
            var range3 = rangeForUnit(cm, pos, behavior.unit);
            var anchor = oldRange.anchor, head;
            if (cmp(range3.anchor, anchor) > 0) {
              head = range3.head;
              anchor = minPos(oldRange.from(), range3.anchor);
            } else {
              head = range3.anchor;
              anchor = maxPos(oldRange.to(), range3.head);
            }
            var ranges$1 = startSel.ranges.slice(0);
            ranges$1[ourIndex] = bidiSimplify(cm, new Range3(clipPos(doc, anchor), head));
            setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
          }
        }
        var editorSize = display.wrapper.getBoundingClientRect();
        var counter = 0;
        function extend(e) {
          var curCount = ++counter;
          var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
          if (!cur) {
            return;
          }
          if (cmp(cur, lastPos) != 0) {
            cm.curOp.focus = activeElt();
            extendTo(cur);
            var visible = visibleLines(display, doc);
            if (cur.line >= visible.to || cur.line < visible.from) {
              setTimeout(operation(cm, function() {
                if (counter == curCount) {
                  extend(e);
                }
              }), 150);
            }
          } else {
            var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
            if (outside) {
              setTimeout(operation(cm, function() {
                if (counter != curCount) {
                  return;
                }
                display.scroller.scrollTop += outside;
                extend(e);
              }), 50);
            }
          }
        }
        function done(e) {
          cm.state.selectingText = false;
          counter = Infinity;
          if (e) {
            e_preventDefault(e);
            display.input.focus();
          }
          off(display.wrapper.ownerDocument, "mousemove", move);
          off(display.wrapper.ownerDocument, "mouseup", up);
          doc.history.lastSelOrigin = null;
        }
        var move = operation(cm, function(e) {
          if (e.buttons === 0 || !e_button(e)) {
            done(e);
          } else {
            extend(e);
          }
        });
        var up = operation(cm, done);
        cm.state.selectingText = up;
        on(display.wrapper.ownerDocument, "mousemove", move);
        on(display.wrapper.ownerDocument, "mouseup", up);
      }
      function bidiSimplify(cm, range2) {
        var anchor = range2.anchor;
        var head = range2.head;
        var anchorLine = getLine(cm.doc, anchor.line);
        if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) {
          return range2;
        }
        var order = getOrder(anchorLine);
        if (!order) {
          return range2;
        }
        var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
        if (part.from != anchor.ch && part.to != anchor.ch) {
          return range2;
        }
        var boundary = index + (part.from == anchor.ch == (part.level != 1) ? 0 : 1);
        if (boundary == 0 || boundary == order.length) {
          return range2;
        }
        var leftSide;
        if (head.line != anchor.line) {
          leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
        } else {
          var headIndex = getBidiPartAt(order, head.ch, head.sticky);
          var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
          if (headIndex == boundary - 1 || headIndex == boundary) {
            leftSide = dir < 0;
          } else {
            leftSide = dir > 0;
          }
        }
        var usePart = order[boundary + (leftSide ? -1 : 0)];
        var from = leftSide == (usePart.level == 1);
        var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
        return anchor.ch == ch && anchor.sticky == sticky ? range2 : new Range3(new Pos(anchor.line, ch, sticky), head);
      }
      function gutterEvent(cm, e, type2, prevent) {
        var mX, mY;
        if (e.touches) {
          mX = e.touches[0].clientX;
          mY = e.touches[0].clientY;
        } else {
          try {
            mX = e.clientX;
            mY = e.clientY;
          } catch (e$1) {
            return false;
          }
        }
        if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) {
          return false;
        }
        if (prevent) {
          e_preventDefault(e);
        }
        var display = cm.display;
        var lineBox = display.lineDiv.getBoundingClientRect();
        if (mY > lineBox.bottom || !hasHandler(cm, type2)) {
          return e_defaultPrevented(e);
        }
        mY -= lineBox.top - display.viewOffset;
        for (var i2 = 0; i2 < cm.display.gutterSpecs.length; ++i2) {
          var g = display.gutters.childNodes[i2];
          if (g && g.getBoundingClientRect().right >= mX) {
            var line = lineAtHeight(cm.doc, mY);
            var gutter = cm.display.gutterSpecs[i2];
            signal(cm, type2, cm, line, gutter.className, e);
            return e_defaultPrevented(e);
          }
        }
      }
      function clickInGutter(cm, e) {
        return gutterEvent(cm, e, "gutterClick", true);
      }
      function onContextMenu(cm, e) {
        if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) {
          return;
        }
        if (signalDOMEvent(cm, e, "contextmenu")) {
          return;
        }
        if (!captureRightClick) {
          cm.display.input.onContextMenu(e);
        }
      }
      function contextMenuInGutter(cm, e) {
        if (!hasHandler(cm, "gutterContextMenu")) {
          return false;
        }
        return gutterEvent(cm, e, "gutterContextMenu", false);
      }
      function themeChanged(cm) {
        cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
        clearCaches(cm);
      }
      var Init = { toString: function() {
        return "CodeMirror.Init";
      } };
      var defaults = {};
      var optionHandlers = {};
      function defineOptions(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        function option(name2, deflt, handle, notOnInit) {
          CodeMirror3.defaults[name2] = deflt;
          if (handle) {
            optionHandlers2[name2] = notOnInit ? function(cm, val, old) {
              if (old != Init) {
                handle(cm, val, old);
              }
            } : handle;
          }
        }
        CodeMirror3.defineOption = option;
        CodeMirror3.Init = Init;
        option("value", "", function(cm, val) {
          return cm.setValue(val);
        }, true);
        option("mode", null, function(cm, val) {
          cm.doc.modeOption = val;
          loadMode(cm);
        }, true);
        option("indentUnit", 2, loadMode, true);
        option("indentWithTabs", false);
        option("smartIndent", true);
        option("tabSize", 4, function(cm) {
          resetModeState(cm);
          clearCaches(cm);
          regChange(cm);
        }, true);
        option("lineSeparator", null, function(cm, val) {
          cm.doc.lineSep = val;
          if (!val) {
            return;
          }
          var newBreaks = [], lineNo2 = cm.doc.first;
          cm.doc.iter(function(line) {
            for (var pos = 0; ; ) {
              var found = line.text.indexOf(val, pos);
              if (found == -1) {
                break;
              }
              pos = found + val.length;
              newBreaks.push(Pos(lineNo2, found));
            }
            lineNo2++;
          });
          for (var i2 = newBreaks.length - 1; i2 >= 0; i2--) {
            replaceRange(cm.doc, val, newBreaks[i2], Pos(newBreaks[i2].line, newBreaks[i2].ch + val.length));
          }
        });
        option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function(cm, val, old) {
          cm.state.specialChars = new RegExp(val.source + (val.test("	") ? "" : "|	"), "g");
          if (old != Init) {
            cm.refresh();
          }
        });
        option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
          return cm.refresh();
        }, true);
        option("electricChars", true);
        option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
          throw new Error("inputStyle can not (yet) be changed in a running editor");
        }, true);
        option("spellcheck", false, function(cm, val) {
          return cm.getInputField().spellcheck = val;
        }, true);
        option("autocorrect", false, function(cm, val) {
          return cm.getInputField().autocorrect = val;
        }, true);
        option("autocapitalize", false, function(cm, val) {
          return cm.getInputField().autocapitalize = val;
        }, true);
        option("rtlMoveVisually", !windows);
        option("wholeLineUpdateBefore", true);
        option("theme", "default", function(cm) {
          themeChanged(cm);
          updateGutters(cm);
        }, true);
        option("keyMap", "default", function(cm, val, old) {
          var next = getKeyMap(val);
          var prev = old != Init && getKeyMap(old);
          if (prev && prev.detach) {
            prev.detach(cm, next);
          }
          if (next.attach) {
            next.attach(cm, prev || null);
          }
        });
        option("extraKeys", null);
        option("configureMouse", null);
        option("lineWrapping", false, wrappingChanged, true);
        option("gutters", [], function(cm, val) {
          cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
          updateGutters(cm);
        }, true);
        option("fixedGutter", true, function(cm, val) {
          cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
          cm.refresh();
        }, true);
        option("coverGutterNextToScrollbar", false, function(cm) {
          return updateScrollbars(cm);
        }, true);
        option("scrollbarStyle", "native", function(cm) {
          initScrollbars(cm);
          updateScrollbars(cm);
          cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
          cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
        }, true);
        option("lineNumbers", false, function(cm, val) {
          cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
          updateGutters(cm);
        }, true);
        option("firstLineNumber", 1, updateGutters, true);
        option("lineNumberFormatter", function(integer2) {
          return integer2;
        }, updateGutters, true);
        option("showCursorWhenSelecting", false, updateSelection, true);
        option("resetSelectionOnContextMenu", true);
        option("lineWiseCopyCut", true);
        option("pasteLinesPerSelection", true);
        option("selectionsMayTouch", false);
        option("readOnly", false, function(cm, val) {
          if (val == "nocursor") {
            onBlur(cm);
            cm.display.input.blur();
          }
          cm.display.input.readOnlyChanged(val);
        });
        option("screenReaderLabel", null, function(cm, val) {
          val = val === "" ? null : val;
          cm.display.input.screenReaderLabelChanged(val);
        });
        option("disableInput", false, function(cm, val) {
          if (!val) {
            cm.display.input.reset();
          }
        }, true);
        option("dragDrop", true, dragDropChanged);
        option("allowDropFileTypes", null);
        option("cursorBlinkRate", 530);
        option("cursorScrollMargin", 0);
        option("cursorHeight", 1, updateSelection, true);
        option("singleCursorHeightPerLine", true, updateSelection, true);
        option("workTime", 100);
        option("workDelay", 100);
        option("flattenSpans", true, resetModeState, true);
        option("addModeClass", false, resetModeState, true);
        option("pollInterval", 100);
        option("undoDepth", 200, function(cm, val) {
          return cm.doc.history.undoDepth = val;
        });
        option("historyEventDelay", 1250);
        option("viewportMargin", 10, function(cm) {
          return cm.refresh();
        }, true);
        option("maxHighlightLength", 1e4, resetModeState, true);
        option("moveInputWithCursor", true, function(cm, val) {
          if (!val) {
            cm.display.input.resetPosition();
          }
        });
        option("tabindex", null, function(cm, val) {
          return cm.display.input.getField().tabIndex = val || "";
        });
        option("autofocus", null);
        option("direction", "ltr", function(cm, val) {
          return cm.doc.setDirection(val);
        }, true);
        option("phrases", null);
      }
      function dragDropChanged(cm, value, old) {
        var wasOn = old && old != Init;
        if (!value != !wasOn) {
          var funcs = cm.display.dragFunctions;
          var toggle = value ? on : off;
          toggle(cm.display.scroller, "dragstart", funcs.start);
          toggle(cm.display.scroller, "dragenter", funcs.enter);
          toggle(cm.display.scroller, "dragover", funcs.over);
          toggle(cm.display.scroller, "dragleave", funcs.leave);
          toggle(cm.display.scroller, "drop", funcs.drop);
        }
      }
      function wrappingChanged(cm) {
        if (cm.options.lineWrapping) {
          addClass(cm.display.wrapper, "CodeMirror-wrap");
          cm.display.sizer.style.minWidth = "";
          cm.display.sizerWidth = null;
        } else {
          rmClass(cm.display.wrapper, "CodeMirror-wrap");
          findMaxLine(cm);
        }
        estimateLineHeights(cm);
        regChange(cm);
        clearCaches(cm);
        setTimeout(function() {
          return updateScrollbars(cm);
        }, 100);
      }
      function CodeMirror2(place, options) {
        var this$1 = this;
        if (!(this instanceof CodeMirror2)) {
          return new CodeMirror2(place, options);
        }
        this.options = options = options ? copyObj(options) : {};
        copyObj(defaults, options, false);
        var doc = options.value;
        if (typeof doc == "string") {
          doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction);
        } else if (options.mode) {
          doc.modeOption = options.mode;
        }
        this.doc = doc;
        var input = new CodeMirror2.inputStyles[options.inputStyle](this);
        var display = this.display = new Display(place, doc, input, options);
        display.wrapper.CodeMirror = this;
        themeChanged(this);
        if (options.lineWrapping) {
          this.display.wrapper.className += " CodeMirror-wrap";
        }
        initScrollbars(this);
        this.state = {
          keyMaps: [],
          overlays: [],
          modeGen: 0,
          overwrite: false,
          delayingBlurEvent: false,
          focused: false,
          suppressEdits: false,
          pasteIncoming: -1,
          cutIncoming: -1,
          selectingText: false,
          draggingText: false,
          highlight: new Delayed(),
          keySeq: null,
          specialChars: null
        };
        if (options.autofocus && !mobile) {
          display.input.focus();
        }
        if (ie && ie_version < 11) {
          setTimeout(function() {
            return this$1.display.input.reset(true);
          }, 20);
        }
        registerEventHandlers(this);
        ensureGlobalHandlers();
        startOperation(this);
        this.curOp.forceUpdate = true;
        attachDoc(this, doc);
        if (options.autofocus && !mobile || this.hasFocus()) {
          setTimeout(function() {
            if (this$1.hasFocus() && !this$1.state.focused) {
              onFocus(this$1);
            }
          }, 20);
        } else {
          onBlur(this);
        }
        for (var opt2 in optionHandlers) {
          if (optionHandlers.hasOwnProperty(opt2)) {
            optionHandlers[opt2](this, options[opt2], Init);
          }
        }
        maybeUpdateLineNumberWidth(this);
        if (options.finishInit) {
          options.finishInit(this);
        }
        for (var i2 = 0; i2 < initHooks.length; ++i2) {
          initHooks[i2](this);
        }
        endOperation(this);
        if (webkit && options.lineWrapping && getComputedStyle(display.lineDiv).textRendering == "optimizelegibility") {
          display.lineDiv.style.textRendering = "auto";
        }
      }
      CodeMirror2.defaults = defaults;
      CodeMirror2.optionHandlers = optionHandlers;
      function registerEventHandlers(cm) {
        var d = cm.display;
        on(d.scroller, "mousedown", operation(cm, onMouseDown));
        if (ie && ie_version < 11) {
          on(d.scroller, "dblclick", operation(cm, function(e) {
            if (signalDOMEvent(cm, e)) {
              return;
            }
            var pos = posFromMouse(cm, e);
            if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) {
              return;
            }
            e_preventDefault(e);
            var word2 = cm.findWordAt(pos);
            extendSelection(cm.doc, word2.anchor, word2.head);
          }));
        } else {
          on(d.scroller, "dblclick", function(e) {
            return signalDOMEvent(cm, e) || e_preventDefault(e);
          });
        }
        on(d.scroller, "contextmenu", function(e) {
          return onContextMenu(cm, e);
        });
        on(d.input.getField(), "contextmenu", function(e) {
          if (!d.scroller.contains(e.target)) {
            onContextMenu(cm, e);
          }
        });
        var touchFinished, prevTouch = { end: 0 };
        function finishTouch() {
          if (d.activeTouch) {
            touchFinished = setTimeout(function() {
              return d.activeTouch = null;
            }, 1e3);
            prevTouch = d.activeTouch;
            prevTouch.end = +new Date();
          }
        }
        function isMouseLikeTouchEvent(e) {
          if (e.touches.length != 1) {
            return false;
          }
          var touch = e.touches[0];
          return touch.radiusX <= 1 && touch.radiusY <= 1;
        }
        function farAway(touch, other) {
          if (other.left == null) {
            return true;
          }
          var dx = other.left - touch.left, dy = other.top - touch.top;
          return dx * dx + dy * dy > 20 * 20;
        }
        on(d.scroller, "touchstart", function(e) {
          if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
            d.input.ensurePolled();
            clearTimeout(touchFinished);
            var now = +new Date();
            d.activeTouch = {
              start: now,
              moved: false,
              prev: now - prevTouch.end <= 300 ? prevTouch : null
            };
            if (e.touches.length == 1) {
              d.activeTouch.left = e.touches[0].pageX;
              d.activeTouch.top = e.touches[0].pageY;
            }
          }
        });
        on(d.scroller, "touchmove", function() {
          if (d.activeTouch) {
            d.activeTouch.moved = true;
          }
        });
        on(d.scroller, "touchend", function(e) {
          var touch = d.activeTouch;
          if (touch && !eventInWidget(d, e) && touch.left != null && !touch.moved && new Date() - touch.start < 300) {
            var pos = cm.coordsChar(d.activeTouch, "page"), range2;
            if (!touch.prev || farAway(touch, touch.prev)) {
              range2 = new Range3(pos, pos);
            } else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) {
              range2 = cm.findWordAt(pos);
            } else {
              range2 = new Range3(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0)));
            }
            cm.setSelection(range2.anchor, range2.head);
            cm.focus();
            e_preventDefault(e);
          }
          finishTouch();
        });
        on(d.scroller, "touchcancel", finishTouch);
        on(d.scroller, "scroll", function() {
          if (d.scroller.clientHeight) {
            updateScrollTop(cm, d.scroller.scrollTop);
            setScrollLeft(cm, d.scroller.scrollLeft, true);
            signal(cm, "scroll", cm);
          }
        });
        on(d.scroller, "mousewheel", function(e) {
          return onScrollWheel(cm, e);
        });
        on(d.scroller, "DOMMouseScroll", function(e) {
          return onScrollWheel(cm, e);
        });
        on(d.wrapper, "scroll", function() {
          return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0;
        });
        d.dragFunctions = {
          enter: function(e) {
            if (!signalDOMEvent(cm, e)) {
              e_stop(e);
            }
          },
          over: function(e) {
            if (!signalDOMEvent(cm, e)) {
              onDragOver(cm, e);
              e_stop(e);
            }
          },
          start: function(e) {
            return onDragStart(cm, e);
          },
          drop: operation(cm, onDrop),
          leave: function(e) {
            if (!signalDOMEvent(cm, e)) {
              clearDragCursor(cm);
            }
          }
        };
        var inp = d.input.getField();
        on(inp, "keyup", function(e) {
          return onKeyUp.call(cm, e);
        });
        on(inp, "keydown", operation(cm, onKeyDown));
        on(inp, "keypress", operation(cm, onKeyPress));
        on(inp, "focus", function(e) {
          return onFocus(cm, e);
        });
        on(inp, "blur", function(e) {
          return onBlur(cm, e);
        });
      }
      var initHooks = [];
      CodeMirror2.defineInitHook = function(f) {
        return initHooks.push(f);
      };
      function indentLine(cm, n, how, aggressive) {
        var doc = cm.doc, state;
        if (how == null) {
          how = "add";
        }
        if (how == "smart") {
          if (!doc.mode.indent) {
            how = "prev";
          } else {
            state = getContextBefore(cm, n).state;
          }
        }
        var tabSize = cm.options.tabSize;
        var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
        if (line.stateAfter) {
          line.stateAfter = null;
        }
        var curSpaceString = line.text.match(/^\s*/)[0], indentation;
        if (!aggressive && !/\S/.test(line.text)) {
          indentation = 0;
          how = "not";
        } else if (how == "smart") {
          indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
          if (indentation == Pass || indentation > 150) {
            if (!aggressive) {
              return;
            }
            how = "prev";
          }
        }
        if (how == "prev") {
          if (n > doc.first) {
            indentation = countColumn(getLine(doc, n - 1).text, null, tabSize);
          } else {
            indentation = 0;
          }
        } else if (how == "add") {
          indentation = curSpace + cm.options.indentUnit;
        } else if (how == "subtract") {
          indentation = curSpace - cm.options.indentUnit;
        } else if (typeof how == "number") {
          indentation = curSpace + how;
        }
        indentation = Math.max(0, indentation);
        var indentString = "", pos = 0;
        if (cm.options.indentWithTabs) {
          for (var i2 = Math.floor(indentation / tabSize); i2; --i2) {
            pos += tabSize;
            indentString += "	";
          }
        }
        if (pos < indentation) {
          indentString += spaceStr(indentation - pos);
        }
        if (indentString != curSpaceString) {
          replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
          line.stateAfter = null;
          return true;
        } else {
          for (var i$12 = 0; i$12 < doc.sel.ranges.length; i$12++) {
            var range2 = doc.sel.ranges[i$12];
            if (range2.head.line == n && range2.head.ch < curSpaceString.length) {
              var pos$1 = Pos(n, curSpaceString.length);
              replaceOneSelection(doc, i$12, new Range3(pos$1, pos$1));
              break;
            }
          }
        }
      }
      var lastCopied = null;
      function setLastCopied(newLastCopied) {
        lastCopied = newLastCopied;
      }
      function applyTextInput(cm, inserted, deleted, sel, origin) {
        var doc = cm.doc;
        cm.display.shift = false;
        if (!sel) {
          sel = doc.sel;
        }
        var recent = +new Date() - 200;
        var paste = origin == "paste" || cm.state.pasteIncoming > recent;
        var textLines = splitLinesAuto(inserted), multiPaste = null;
        if (paste && sel.ranges.length > 1) {
          if (lastCopied && lastCopied.text.join("\n") == inserted) {
            if (sel.ranges.length % lastCopied.text.length == 0) {
              multiPaste = [];
              for (var i2 = 0; i2 < lastCopied.text.length; i2++) {
                multiPaste.push(doc.splitLines(lastCopied.text[i2]));
              }
            }
          } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
            multiPaste = map2(textLines, function(l) {
              return [l];
            });
          }
        }
        var updateInput = cm.curOp.updateInput;
        for (var i$12 = sel.ranges.length - 1; i$12 >= 0; i$12--) {
          var range2 = sel.ranges[i$12];
          var from = range2.from(), to = range2.to();
          if (range2.empty()) {
            if (deleted && deleted > 0) {
              from = Pos(from.line, from.ch - deleted);
            } else if (cm.state.overwrite && !paste) {
              to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length));
            } else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n")) {
              from = to = Pos(from.line, 0);
            }
          }
          var changeEvent = {
            from,
            to,
            text: multiPaste ? multiPaste[i$12 % multiPaste.length] : textLines,
            origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")
          };
          makeChange(cm.doc, changeEvent);
          signalLater(cm, "inputRead", cm, changeEvent);
        }
        if (inserted && !paste) {
          triggerElectric(cm, inserted);
        }
        ensureCursorVisible(cm);
        if (cm.curOp.updateInput < 2) {
          cm.curOp.updateInput = updateInput;
        }
        cm.curOp.typing = true;
        cm.state.pasteIncoming = cm.state.cutIncoming = -1;
      }
      function handlePaste(e, cm) {
        var pasted = e.clipboardData && e.clipboardData.getData("Text");
        if (pasted) {
          e.preventDefault();
          if (!cm.isReadOnly() && !cm.options.disableInput) {
            runInOp(cm, function() {
              return applyTextInput(cm, pasted, 0, null, "paste");
            });
          }
          return true;
        }
      }
      function triggerElectric(cm, inserted) {
        if (!cm.options.electricChars || !cm.options.smartIndent) {
          return;
        }
        var sel = cm.doc.sel;
        for (var i2 = sel.ranges.length - 1; i2 >= 0; i2--) {
          var range2 = sel.ranges[i2];
          if (range2.head.ch > 100 || i2 && sel.ranges[i2 - 1].head.line == range2.head.line) {
            continue;
          }
          var mode = cm.getModeAt(range2.head);
          var indented = false;
          if (mode.electricChars) {
            for (var j = 0; j < mode.electricChars.length; j++) {
              if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                indented = indentLine(cm, range2.head.line, "smart");
                break;
              }
            }
          } else if (mode.electricInput) {
            if (mode.electricInput.test(getLine(cm.doc, range2.head.line).text.slice(0, range2.head.ch))) {
              indented = indentLine(cm, range2.head.line, "smart");
            }
          }
          if (indented) {
            signalLater(cm, "electricInput", cm, range2.head.line);
          }
        }
      }
      function copyableRanges(cm) {
        var text2 = [], ranges = [];
        for (var i2 = 0; i2 < cm.doc.sel.ranges.length; i2++) {
          var line = cm.doc.sel.ranges[i2].head.line;
          var lineRange = { anchor: Pos(line, 0), head: Pos(line + 1, 0) };
          ranges.push(lineRange);
          text2.push(cm.getRange(lineRange.anchor, lineRange.head));
        }
        return { text: text2, ranges };
      }
      function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
        field.setAttribute("autocorrect", autocorrect ? "" : "off");
        field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
        field.setAttribute("spellcheck", !!spellcheck);
      }
      function hiddenTextarea() {
        var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; min-height: 1em; outline: none");
        var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
        if (webkit) {
          te.style.width = "1000px";
        } else {
          te.setAttribute("wrap", "off");
        }
        if (ios) {
          te.style.border = "1px solid black";
        }
        disableBrowserMagic(te);
        return div;
      }
      function addEditorMethods(CodeMirror3) {
        var optionHandlers2 = CodeMirror3.optionHandlers;
        var helpers = CodeMirror3.helpers = {};
        CodeMirror3.prototype = {
          constructor: CodeMirror3,
          focus: function() {
            window.focus();
            this.display.input.focus();
          },
          setOption: function(option, value) {
            var options = this.options, old = options[option];
            if (options[option] == value && option != "mode") {
              return;
            }
            options[option] = value;
            if (optionHandlers2.hasOwnProperty(option)) {
              operation(this, optionHandlers2[option])(this, value, old);
            }
            signal(this, "optionChange", this, option);
          },
          getOption: function(option) {
            return this.options[option];
          },
          getDoc: function() {
            return this.doc;
          },
          addKeyMap: function(map3, bottom) {
            this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map3));
          },
          removeKeyMap: function(map3) {
            var maps = this.state.keyMaps;
            for (var i2 = 0; i2 < maps.length; ++i2) {
              if (maps[i2] == map3 || maps[i2].name == map3) {
                maps.splice(i2, 1);
                return true;
              }
            }
          },
          addOverlay: methodOp(function(spec, options) {
            var mode = spec.token ? spec : CodeMirror3.getMode(this.options, spec);
            if (mode.startState) {
              throw new Error("Overlays may not be stateful.");
            }
            insertSorted(this.state.overlays, {
              mode,
              modeSpec: spec,
              opaque: options && options.opaque,
              priority: options && options.priority || 0
            }, function(overlay) {
              return overlay.priority;
            });
            this.state.modeGen++;
            regChange(this);
          }),
          removeOverlay: methodOp(function(spec) {
            var overlays = this.state.overlays;
            for (var i2 = 0; i2 < overlays.length; ++i2) {
              var cur = overlays[i2].modeSpec;
              if (cur == spec || typeof spec == "string" && cur.name == spec) {
                overlays.splice(i2, 1);
                this.state.modeGen++;
                regChange(this);
                return;
              }
            }
          }),
          indentLine: methodOp(function(n, dir, aggressive) {
            if (typeof dir != "string" && typeof dir != "number") {
              if (dir == null) {
                dir = this.options.smartIndent ? "smart" : "prev";
              } else {
                dir = dir ? "add" : "subtract";
              }
            }
            if (isLine(this.doc, n)) {
              indentLine(this, n, dir, aggressive);
            }
          }),
          indentSelection: methodOp(function(how) {
            var ranges = this.doc.sel.ranges, end = -1;
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var range2 = ranges[i2];
              if (!range2.empty()) {
                var from = range2.from(), to = range2.to();
                var start = Math.max(end, from.line);
                end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                for (var j = start; j < end; ++j) {
                  indentLine(this, j, how);
                }
                var newRanges = this.doc.sel.ranges;
                if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i2].from().ch > 0) {
                  replaceOneSelection(this.doc, i2, new Range3(from, newRanges[i2].to()), sel_dontScroll);
                }
              } else if (range2.head.line > end) {
                indentLine(this, range2.head.line, how, true);
                end = range2.head.line;
                if (i2 == this.doc.sel.primIndex) {
                  ensureCursorVisible(this);
                }
              }
            }
          }),
          getTokenAt: function(pos, precise) {
            return takeToken(this, pos, precise);
          },
          getLineTokens: function(line, precise) {
            return takeToken(this, Pos(line), precise, true);
          },
          getTokenTypeAt: function(pos) {
            pos = clipPos(this.doc, pos);
            var styles = getLineStyles(this, getLine(this.doc, pos.line));
            var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
            var type2;
            if (ch == 0) {
              type2 = styles[2];
            } else {
              for (; ; ) {
                var mid = before + after >> 1;
                if ((mid ? styles[mid * 2 - 1] : 0) >= ch) {
                  after = mid;
                } else if (styles[mid * 2 + 1] < ch) {
                  before = mid + 1;
                } else {
                  type2 = styles[mid * 2 + 2];
                  break;
                }
              }
            }
            var cut = type2 ? type2.indexOf("overlay ") : -1;
            return cut < 0 ? type2 : cut == 0 ? null : type2.slice(0, cut - 1);
          },
          getModeAt: function(pos) {
            var mode = this.doc.mode;
            if (!mode.innerMode) {
              return mode;
            }
            return CodeMirror3.innerMode(mode, this.getTokenAt(pos).state).mode;
          },
          getHelper: function(pos, type2) {
            return this.getHelpers(pos, type2)[0];
          },
          getHelpers: function(pos, type2) {
            var found = [];
            if (!helpers.hasOwnProperty(type2)) {
              return found;
            }
            var help = helpers[type2], mode = this.getModeAt(pos);
            if (typeof mode[type2] == "string") {
              if (help[mode[type2]]) {
                found.push(help[mode[type2]]);
              }
            } else if (mode[type2]) {
              for (var i2 = 0; i2 < mode[type2].length; i2++) {
                var val = help[mode[type2][i2]];
                if (val) {
                  found.push(val);
                }
              }
            } else if (mode.helperType && help[mode.helperType]) {
              found.push(help[mode.helperType]);
            } else if (help[mode.name]) {
              found.push(help[mode.name]);
            }
            for (var i$12 = 0; i$12 < help._global.length; i$12++) {
              var cur = help._global[i$12];
              if (cur.pred(mode, this) && indexOf(found, cur.val) == -1) {
                found.push(cur.val);
              }
            }
            return found;
          },
          getStateAfter: function(line, precise) {
            var doc = this.doc;
            line = clipLine(doc, line == null ? doc.first + doc.size - 1 : line);
            return getContextBefore(this, line + 1, precise).state;
          },
          cursorCoords: function(start, mode) {
            var pos, range2 = this.doc.sel.primary();
            if (start == null) {
              pos = range2.head;
            } else if (typeof start == "object") {
              pos = clipPos(this.doc, start);
            } else {
              pos = start ? range2.from() : range2.to();
            }
            return cursorCoords(this, pos, mode || "page");
          },
          charCoords: function(pos, mode) {
            return charCoords(this, clipPos(this.doc, pos), mode || "page");
          },
          coordsChar: function(coords, mode) {
            coords = fromCoordSystem(this, coords, mode || "page");
            return coordsChar(this, coords.left, coords.top);
          },
          lineAtHeight: function(height, mode) {
            height = fromCoordSystem(this, { top: height, left: 0 }, mode || "page").top;
            return lineAtHeight(this.doc, height + this.display.viewOffset);
          },
          heightAtLine: function(line, mode, includeWidgets) {
            var end = false, lineObj;
            if (typeof line == "number") {
              var last = this.doc.first + this.doc.size - 1;
              if (line < this.doc.first) {
                line = this.doc.first;
              } else if (line > last) {
                line = last;
                end = true;
              }
              lineObj = getLine(this.doc, line);
            } else {
              lineObj = line;
            }
            return intoCoordSystem(this, lineObj, { top: 0, left: 0 }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - heightAtLine(lineObj) : 0);
          },
          defaultTextHeight: function() {
            return textHeight(this.display);
          },
          defaultCharWidth: function() {
            return charWidth(this.display);
          },
          getViewport: function() {
            return { from: this.display.viewFrom, to: this.display.viewTo };
          },
          addWidget: function(pos, node, scroll, vert, horiz) {
            var display = this.display;
            pos = cursorCoords(this, clipPos(this.doc, pos));
            var top = pos.bottom, left = pos.left;
            node.style.position = "absolute";
            node.setAttribute("cm-ignore-events", "true");
            this.display.input.setUneditable(node);
            display.sizer.appendChild(node);
            if (vert == "over") {
              top = pos.top;
            } else if (vert == "above" || vert == "near") {
              var vspace = Math.max(display.wrapper.clientHeight, this.doc.height), hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
              if ((vert == "above" || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight) {
                top = pos.top - node.offsetHeight;
              } else if (pos.bottom + node.offsetHeight <= vspace) {
                top = pos.bottom;
              }
              if (left + node.offsetWidth > hspace) {
                left = hspace - node.offsetWidth;
              }
            }
            node.style.top = top + "px";
            node.style.left = node.style.right = "";
            if (horiz == "right") {
              left = display.sizer.clientWidth - node.offsetWidth;
              node.style.right = "0px";
            } else {
              if (horiz == "left") {
                left = 0;
              } else if (horiz == "middle") {
                left = (display.sizer.clientWidth - node.offsetWidth) / 2;
              }
              node.style.left = left + "px";
            }
            if (scroll) {
              scrollIntoView(this, { left, top, right: left + node.offsetWidth, bottom: top + node.offsetHeight });
            }
          },
          triggerOnKeyDown: methodOp(onKeyDown),
          triggerOnKeyPress: methodOp(onKeyPress),
          triggerOnKeyUp: onKeyUp,
          triggerOnMouseDown: methodOp(onMouseDown),
          execCommand: function(cmd) {
            if (commands.hasOwnProperty(cmd)) {
              return commands[cmd].call(null, this);
            }
          },
          triggerElectric: methodOp(function(text2) {
            triggerElectric(this, text2);
          }),
          findPosH: function(from, amount, unit, visually) {
            var dir = 1;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i2 = 0; i2 < amount; ++i2) {
              cur = findPosH(this.doc, cur, dir, unit, visually);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveH: methodOp(function(dir, unit) {
            var this$1 = this;
            this.extendSelectionsBy(function(range2) {
              if (this$1.display.shift || this$1.doc.extend || range2.empty()) {
                return findPosH(this$1.doc, range2.head, dir, unit, this$1.options.rtlMoveVisually);
              } else {
                return dir < 0 ? range2.from() : range2.to();
              }
            }, sel_move);
          }),
          deleteH: methodOp(function(dir, unit) {
            var sel = this.doc.sel, doc = this.doc;
            if (sel.somethingSelected()) {
              doc.replaceSelection("", null, "+delete");
            } else {
              deleteNearSelection(this, function(range2) {
                var other = findPosH(doc, range2.head, dir, unit, false);
                return dir < 0 ? { from: other, to: range2.head } : { from: range2.head, to: other };
              });
            }
          }),
          findPosV: function(from, amount, unit, goalColumn) {
            var dir = 1, x = goalColumn;
            if (amount < 0) {
              dir = -1;
              amount = -amount;
            }
            var cur = clipPos(this.doc, from);
            for (var i2 = 0; i2 < amount; ++i2) {
              var coords = cursorCoords(this, cur, "div");
              if (x == null) {
                x = coords.left;
              } else {
                coords.left = x;
              }
              cur = findPosV(this, coords, dir, unit);
              if (cur.hitSide) {
                break;
              }
            }
            return cur;
          },
          moveV: methodOp(function(dir, unit) {
            var this$1 = this;
            var doc = this.doc, goals = [];
            var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
            doc.extendSelectionsBy(function(range2) {
              if (collapse) {
                return dir < 0 ? range2.from() : range2.to();
              }
              var headPos = cursorCoords(this$1, range2.head, "div");
              if (range2.goalColumn != null) {
                headPos.left = range2.goalColumn;
              }
              goals.push(headPos.left);
              var pos = findPosV(this$1, headPos, dir, unit);
              if (unit == "page" && range2 == doc.sel.primary()) {
                addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top);
              }
              return pos;
            }, sel_move);
            if (goals.length) {
              for (var i2 = 0; i2 < doc.sel.ranges.length; i2++) {
                doc.sel.ranges[i2].goalColumn = goals[i2];
              }
            }
          }),
          findWordAt: function(pos) {
            var doc = this.doc, line = getLine(doc, pos.line).text;
            var start = pos.ch, end = pos.ch;
            if (line) {
              var helper = this.getHelper(pos, "wordChars");
              if ((pos.sticky == "before" || end == line.length) && start) {
                --start;
              } else {
                ++end;
              }
              var startChar = line.charAt(start);
              var check = isWordChar(startChar, helper) ? function(ch) {
                return isWordChar(ch, helper);
              } : /\s/.test(startChar) ? function(ch) {
                return /\s/.test(ch);
              } : function(ch) {
                return !/\s/.test(ch) && !isWordChar(ch);
              };
              while (start > 0 && check(line.charAt(start - 1))) {
                --start;
              }
              while (end < line.length && check(line.charAt(end))) {
                ++end;
              }
            }
            return new Range3(Pos(pos.line, start), Pos(pos.line, end));
          },
          toggleOverwrite: function(value) {
            if (value != null && value == this.state.overwrite) {
              return;
            }
            if (this.state.overwrite = !this.state.overwrite) {
              addClass(this.display.cursorDiv, "CodeMirror-overwrite");
            } else {
              rmClass(this.display.cursorDiv, "CodeMirror-overwrite");
            }
            signal(this, "overwriteToggle", this, this.state.overwrite);
          },
          hasFocus: function() {
            return this.display.input.getField() == activeElt();
          },
          isReadOnly: function() {
            return !!(this.options.readOnly || this.doc.cantEdit);
          },
          scrollTo: methodOp(function(x, y) {
            scrollToCoords(this, x, y);
          }),
          getScrollInfo: function() {
            var scroller = this.display.scroller;
            return {
              left: scroller.scrollLeft,
              top: scroller.scrollTop,
              height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
              width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
              clientHeight: displayHeight(this),
              clientWidth: displayWidth(this)
            };
          },
          scrollIntoView: methodOp(function(range2, margin) {
            if (range2 == null) {
              range2 = { from: this.doc.sel.primary().head, to: null };
              if (margin == null) {
                margin = this.options.cursorScrollMargin;
              }
            } else if (typeof range2 == "number") {
              range2 = { from: Pos(range2, 0), to: null };
            } else if (range2.from == null) {
              range2 = { from: range2, to: null };
            }
            if (!range2.to) {
              range2.to = range2.from;
            }
            range2.margin = margin || 0;
            if (range2.from.line != null) {
              scrollToRange(this, range2);
            } else {
              scrollToCoordsRange(this, range2.from, range2.to, range2.margin);
            }
          }),
          setSize: methodOp(function(width, height) {
            var this$1 = this;
            var interpret = function(val) {
              return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val;
            };
            if (width != null) {
              this.display.wrapper.style.width = interpret(width);
            }
            if (height != null) {
              this.display.wrapper.style.height = interpret(height);
            }
            if (this.options.lineWrapping) {
              clearLineMeasurementCache(this);
            }
            var lineNo2 = this.display.viewFrom;
            this.doc.iter(lineNo2, this.display.viewTo, function(line) {
              if (line.widgets) {
                for (var i2 = 0; i2 < line.widgets.length; i2++) {
                  if (line.widgets[i2].noHScroll) {
                    regLineChange(this$1, lineNo2, "widget");
                    break;
                  }
                }
              }
              ++lineNo2;
            });
            this.curOp.forceUpdate = true;
            signal(this, "refresh", this);
          }),
          operation: function(f) {
            return runInOp(this, f);
          },
          startOperation: function() {
            return startOperation(this);
          },
          endOperation: function() {
            return endOperation(this);
          },
          refresh: methodOp(function() {
            var oldHeight = this.display.cachedTextHeight;
            regChange(this);
            this.curOp.forceUpdate = true;
            clearCaches(this);
            scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
            updateGutterSpace(this.display);
            if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > 0.5 || this.options.lineWrapping) {
              estimateLineHeights(this);
            }
            signal(this, "refresh", this);
          }),
          swapDoc: methodOp(function(doc) {
            var old = this.doc;
            old.cm = null;
            if (this.state.selectingText) {
              this.state.selectingText();
            }
            attachDoc(this, doc);
            clearCaches(this);
            this.display.input.reset();
            scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
            this.curOp.forceScroll = true;
            signalLater(this, "swapDoc", this, old);
            return old;
          }),
          phrase: function(phraseText) {
            var phrases = this.options.phrases;
            return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText;
          },
          getInputField: function() {
            return this.display.input.getField();
          },
          getWrapperElement: function() {
            return this.display.wrapper;
          },
          getScrollerElement: function() {
            return this.display.scroller;
          },
          getGutterElement: function() {
            return this.display.gutters;
          }
        };
        eventMixin(CodeMirror3);
        CodeMirror3.registerHelper = function(type2, name2, value) {
          if (!helpers.hasOwnProperty(type2)) {
            helpers[type2] = CodeMirror3[type2] = { _global: [] };
          }
          helpers[type2][name2] = value;
        };
        CodeMirror3.registerGlobalHelper = function(type2, name2, predicate, value) {
          CodeMirror3.registerHelper(type2, name2, value);
          helpers[type2]._global.push({ pred: predicate, val: value });
        };
      }
      function findPosH(doc, pos, dir, unit, visually) {
        var oldPos = pos;
        var origDir = dir;
        var lineObj = getLine(doc, pos.line);
        var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
        function findNextLine() {
          var l = pos.line + lineDir;
          if (l < doc.first || l >= doc.first + doc.size) {
            return false;
          }
          pos = new Pos(l, pos.ch, pos.sticky);
          return lineObj = getLine(doc, l);
        }
        function moveOnce(boundToLine) {
          var next;
          if (unit == "codepoint") {
            var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
            if (isNaN(ch)) {
              next = null;
            } else {
              var astral = dir > 0 ? ch >= 55296 && ch < 56320 : ch >= 56320 && ch < 57343;
              next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
            }
          } else if (visually) {
            next = moveVisually(doc.cm, lineObj, pos, dir);
          } else {
            next = moveLogically(lineObj, pos, dir);
          }
          if (next == null) {
            if (!boundToLine && findNextLine()) {
              pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir);
            } else {
              return false;
            }
          } else {
            pos = next;
          }
          return true;
        }
        if (unit == "char" || unit == "codepoint") {
          moveOnce();
        } else if (unit == "column") {
          moveOnce(true);
        } else if (unit == "word" || unit == "group") {
          var sawType = null, group = unit == "group";
          var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
          for (var first = true; ; first = false) {
            if (dir < 0 && !moveOnce(!first)) {
              break;
            }
            var cur = lineObj.text.charAt(pos.ch) || "\n";
            var type2 = isWordChar(cur, helper) ? "w" : group && cur == "\n" ? "n" : !group || /\s/.test(cur) ? null : "p";
            if (group && !first && !type2) {
              type2 = "s";
            }
            if (sawType && sawType != type2) {
              if (dir < 0) {
                dir = 1;
                moveOnce();
                pos.sticky = "after";
              }
              break;
            }
            if (type2) {
              sawType = type2;
            }
            if (dir > 0 && !moveOnce(!first)) {
              break;
            }
          }
        }
        var result = skipAtomic(doc, pos, oldPos, origDir, true);
        if (equalCursorPos(oldPos, result)) {
          result.hitSide = true;
        }
        return result;
      }
      function findPosV(cm, pos, dir, unit) {
        var doc = cm.doc, x = pos.left, y;
        if (unit == "page") {
          var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
          var moveAmount = Math.max(pageSize - 0.5 * textHeight(cm.display), 3);
          y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;
        } else if (unit == "line") {
          y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
        }
        var target;
        for (; ; ) {
          target = coordsChar(cm, x, y);
          if (!target.outside) {
            break;
          }
          if (dir < 0 ? y <= 0 : y >= doc.height) {
            target.hitSide = true;
            break;
          }
          y += dir * 5;
        }
        return target;
      }
      var ContentEditableInput = function(cm) {
        this.cm = cm;
        this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
        this.polling = new Delayed();
        this.composing = null;
        this.gracePeriod = false;
        this.readDOMTimeout = null;
      };
      ContentEditableInput.prototype.init = function(display) {
        var this$1 = this;
        var input = this, cm = input.cm;
        var div = input.div = display.lineDiv;
        div.contentEditable = true;
        disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);
        function belongsToInput(e) {
          for (var t2 = e.target; t2; t2 = t2.parentNode) {
            if (t2 == div) {
              return true;
            }
            if (/\bCodeMirror-(?:line)?widget\b/.test(t2.className)) {
              break;
            }
          }
          return false;
        }
        on(div, "paste", function(e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }
          if (ie_version <= 11) {
            setTimeout(operation(cm, function() {
              return this$1.updateFromDOM();
            }), 20);
          }
        });
        on(div, "compositionstart", function(e) {
          this$1.composing = { data: e.data, done: false };
        });
        on(div, "compositionupdate", function(e) {
          if (!this$1.composing) {
            this$1.composing = { data: e.data, done: false };
          }
        });
        on(div, "compositionend", function(e) {
          if (this$1.composing) {
            if (e.data != this$1.composing.data) {
              this$1.readFromDOMSoon();
            }
            this$1.composing.done = true;
          }
        });
        on(div, "touchstart", function() {
          return input.forceCompositionEnd();
        });
        on(div, "input", function() {
          if (!this$1.composing) {
            this$1.readFromDOMSoon();
          }
        });
        function onCopyCut(e) {
          if (!belongsToInput(e) || signalDOMEvent(cm, e)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
            if (e.type == "cut") {
              cm.replaceSelection("", null, "cut");
            }
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e.type == "cut") {
              cm.operation(function() {
                cm.setSelections(ranges.ranges, 0, sel_dontScroll);
                cm.replaceSelection("", null, "cut");
              });
            }
          }
          if (e.clipboardData) {
            e.clipboardData.clearData();
            var content = lastCopied.text.join("\n");
            e.clipboardData.setData("Text", content);
            if (e.clipboardData.getData("Text") == content) {
              e.preventDefault();
              return;
            }
          }
          var kludge = hiddenTextarea(), te = kludge.firstChild;
          cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
          te.value = lastCopied.text.join("\n");
          var hadFocus = activeElt();
          selectInput(te);
          setTimeout(function() {
            cm.display.lineSpace.removeChild(kludge);
            hadFocus.focus();
            if (hadFocus == div) {
              input.showPrimarySelection();
            }
          }, 50);
        }
        on(div, "copy", onCopyCut);
        on(div, "cut", onCopyCut);
      };
      ContentEditableInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.div.setAttribute("aria-label", label);
        } else {
          this.div.removeAttribute("aria-label");
        }
      };
      ContentEditableInput.prototype.prepareSelection = function() {
        var result = prepareSelection(this.cm, false);
        result.focus = activeElt() == this.div;
        return result;
      };
      ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
        if (!info || !this.cm.display.view.length) {
          return;
        }
        if (info.focus || takeFocus) {
          this.showPrimarySelection();
        }
        this.showMultipleSelections(info);
      };
      ContentEditableInput.prototype.getSelection = function() {
        return this.cm.display.wrapper.ownerDocument.getSelection();
      };
      ContentEditableInput.prototype.showPrimarySelection = function() {
        var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
        var from = prim.from(), to = prim.to();
        if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
          sel.removeAllRanges();
          return;
        }
        var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad && cmp(minPos(curAnchor, curFocus), from) == 0 && cmp(maxPos(curAnchor, curFocus), to) == 0) {
          return;
        }
        var view = cm.display.view;
        var start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || { node: view[0].measure.map[2], offset: 0 };
        var end = to.line < cm.display.viewTo && posToDOM(cm, to);
        if (!end) {
          var measure = view[view.length - 1].measure;
          var map3 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
          end = { node: map3[map3.length - 1], offset: map3[map3.length - 2] - map3[map3.length - 3] };
        }
        if (!start || !end) {
          sel.removeAllRanges();
          return;
        }
        var old = sel.rangeCount && sel.getRangeAt(0), rng;
        try {
          rng = range(start.node, start.offset, end.offset, end.node);
        } catch (e) {
        }
        if (rng) {
          if (!gecko && cm.state.focused) {
            sel.collapse(start.node, start.offset);
            if (!rng.collapsed) {
              sel.removeAllRanges();
              sel.addRange(rng);
            }
          } else {
            sel.removeAllRanges();
            sel.addRange(rng);
          }
          if (old && sel.anchorNode == null) {
            sel.addRange(old);
          } else if (gecko) {
            this.startGracePeriod();
          }
        }
        this.rememberSelection();
      };
      ContentEditableInput.prototype.startGracePeriod = function() {
        var this$1 = this;
        clearTimeout(this.gracePeriod);
        this.gracePeriod = setTimeout(function() {
          this$1.gracePeriod = false;
          if (this$1.selectionChanged()) {
            this$1.cm.operation(function() {
              return this$1.cm.curOp.selectionChanged = true;
            });
          }
        }, 20);
      };
      ContentEditableInput.prototype.showMultipleSelections = function(info) {
        removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
        removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
      };
      ContentEditableInput.prototype.rememberSelection = function() {
        var sel = this.getSelection();
        this.lastAnchorNode = sel.anchorNode;
        this.lastAnchorOffset = sel.anchorOffset;
        this.lastFocusNode = sel.focusNode;
        this.lastFocusOffset = sel.focusOffset;
      };
      ContentEditableInput.prototype.selectionInEditor = function() {
        var sel = this.getSelection();
        if (!sel.rangeCount) {
          return false;
        }
        var node = sel.getRangeAt(0).commonAncestorContainer;
        return contains(this.div, node);
      };
      ContentEditableInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor") {
          if (!this.selectionInEditor() || activeElt() != this.div) {
            this.showSelection(this.prepareSelection(), true);
          }
          this.div.focus();
        }
      };
      ContentEditableInput.prototype.blur = function() {
        this.div.blur();
      };
      ContentEditableInput.prototype.getField = function() {
        return this.div;
      };
      ContentEditableInput.prototype.supportsTouch = function() {
        return true;
      };
      ContentEditableInput.prototype.receivedFocus = function() {
        var this$1 = this;
        var input = this;
        if (this.selectionInEditor()) {
          setTimeout(function() {
            return this$1.pollSelection();
          }, 20);
        } else {
          runInOp(this.cm, function() {
            return input.cm.curOp.selectionChanged = true;
          });
        }
        function poll() {
          if (input.cm.state.focused) {
            input.pollSelection();
            input.polling.set(input.cm.options.pollInterval, poll);
          }
        }
        this.polling.set(this.cm.options.pollInterval, poll);
      };
      ContentEditableInput.prototype.selectionChanged = function() {
        var sel = this.getSelection();
        return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset;
      };
      ContentEditableInput.prototype.pollSelection = function() {
        if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) {
          return;
        }
        var sel = this.getSelection(), cm = this.cm;
        if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
          this.cm.triggerOnKeyDown({ type: "keydown", keyCode: 8, preventDefault: Math.abs });
          this.blur();
          this.focus();
          return;
        }
        if (this.composing) {
          return;
        }
        this.rememberSelection();
        var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
        var head = domToPos(cm, sel.focusNode, sel.focusOffset);
        if (anchor && head) {
          runInOp(cm, function() {
            setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
            if (anchor.bad || head.bad) {
              cm.curOp.selectionChanged = true;
            }
          });
        }
      };
      ContentEditableInput.prototype.pollContent = function() {
        if (this.readDOMTimeout != null) {
          clearTimeout(this.readDOMTimeout);
          this.readDOMTimeout = null;
        }
        var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
        var from = sel.from(), to = sel.to();
        if (from.ch == 0 && from.line > cm.firstLine()) {
          from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length);
        }
        if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine()) {
          to = Pos(to.line + 1, 0);
        }
        if (from.line < display.viewFrom || to.line > display.viewTo - 1) {
          return false;
        }
        var fromIndex, fromLine, fromNode;
        if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
          fromLine = lineNo(display.view[0].line);
          fromNode = display.view[0].node;
        } else {
          fromLine = lineNo(display.view[fromIndex].line);
          fromNode = display.view[fromIndex - 1].node.nextSibling;
        }
        var toIndex = findViewIndex(cm, to.line);
        var toLine, toNode;
        if (toIndex == display.view.length - 1) {
          toLine = display.viewTo - 1;
          toNode = display.lineDiv.lastChild;
        } else {
          toLine = lineNo(display.view[toIndex + 1].line) - 1;
          toNode = display.view[toIndex + 1].node.previousSibling;
        }
        if (!fromNode) {
          return false;
        }
        var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
        var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
        while (newText.length > 1 && oldText.length > 1) {
          if (lst(newText) == lst(oldText)) {
            newText.pop();
            oldText.pop();
            toLine--;
          } else if (newText[0] == oldText[0]) {
            newText.shift();
            oldText.shift();
            fromLine++;
          } else {
            break;
          }
        }
        var cutFront = 0, cutEnd = 0;
        var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
        while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront)) {
          ++cutFront;
        }
        var newBot = lst(newText), oldBot = lst(oldText);
        var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0), oldBot.length - (oldText.length == 1 ? cutFront : 0));
        while (cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
          ++cutEnd;
        }
        if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
          while (cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
            cutFront--;
            cutEnd++;
          }
        }
        newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
        newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
        var chFrom = Pos(fromLine, cutFront);
        var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
        if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
          replaceRange(cm.doc, newText, chFrom, chTo, "+input");
          return true;
        }
      };
      ContentEditableInput.prototype.ensurePolled = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.reset = function() {
        this.forceCompositionEnd();
      };
      ContentEditableInput.prototype.forceCompositionEnd = function() {
        if (!this.composing) {
          return;
        }
        clearTimeout(this.readDOMTimeout);
        this.composing = null;
        this.updateFromDOM();
        this.div.blur();
        this.div.focus();
      };
      ContentEditableInput.prototype.readFromDOMSoon = function() {
        var this$1 = this;
        if (this.readDOMTimeout != null) {
          return;
        }
        this.readDOMTimeout = setTimeout(function() {
          this$1.readDOMTimeout = null;
          if (this$1.composing) {
            if (this$1.composing.done) {
              this$1.composing = null;
            } else {
              return;
            }
          }
          this$1.updateFromDOM();
        }, 80);
      };
      ContentEditableInput.prototype.updateFromDOM = function() {
        var this$1 = this;
        if (this.cm.isReadOnly() || !this.pollContent()) {
          runInOp(this.cm, function() {
            return regChange(this$1.cm);
          });
        }
      };
      ContentEditableInput.prototype.setUneditable = function(node) {
        node.contentEditable = "false";
      };
      ContentEditableInput.prototype.onKeyPress = function(e) {
        if (e.charCode == 0 || this.composing) {
          return;
        }
        e.preventDefault();
        if (!this.cm.isReadOnly()) {
          operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0);
        }
      };
      ContentEditableInput.prototype.readOnlyChanged = function(val) {
        this.div.contentEditable = String(val != "nocursor");
      };
      ContentEditableInput.prototype.onContextMenu = function() {
      };
      ContentEditableInput.prototype.resetPosition = function() {
      };
      ContentEditableInput.prototype.needsContentAttribute = true;
      function posToDOM(cm, pos) {
        var view = findViewForLine(cm, pos.line);
        if (!view || view.hidden) {
          return null;
        }
        var line = getLine(cm.doc, pos.line);
        var info = mapFromLineView(view, line, pos.line);
        var order = getOrder(line, cm.doc.direction), side = "left";
        if (order) {
          var partPos = getBidiPartAt(order, pos.ch);
          side = partPos % 2 ? "right" : "left";
        }
        var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
        result.offset = result.collapse == "right" ? result.end : result.start;
        return result;
      }
      function isInGutter(node) {
        for (var scan = node; scan; scan = scan.parentNode) {
          if (/CodeMirror-gutter-wrapper/.test(scan.className)) {
            return true;
          }
        }
        return false;
      }
      function badPos(pos, bad) {
        if (bad) {
          pos.bad = true;
        }
        return pos;
      }
      function domTextBetween(cm, from, to, fromLine, toLine) {
        var text2 = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
        function recognizeMarker(id) {
          return function(marker) {
            return marker.id == id;
          };
        }
        function close() {
          if (closing) {
            text2 += lineSep;
            if (extraLinebreak) {
              text2 += lineSep;
            }
            closing = extraLinebreak = false;
          }
        }
        function addText(str) {
          if (str) {
            close();
            text2 += str;
          }
        }
        function walk(node) {
          if (node.nodeType == 1) {
            var cmText = node.getAttribute("cm-text");
            if (cmText) {
              addText(cmText);
              return;
            }
            var markerID = node.getAttribute("cm-marker"), range2;
            if (markerID) {
              var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
              if (found.length && (range2 = found[0].find(0))) {
                addText(getBetween(cm.doc, range2.from, range2.to).join(lineSep));
              }
              return;
            }
            if (node.getAttribute("contenteditable") == "false") {
              return;
            }
            var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
            if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) {
              return;
            }
            if (isBlock) {
              close();
            }
            for (var i2 = 0; i2 < node.childNodes.length; i2++) {
              walk(node.childNodes[i2]);
            }
            if (/^(pre|p)$/i.test(node.nodeName)) {
              extraLinebreak = true;
            }
            if (isBlock) {
              closing = true;
            }
          } else if (node.nodeType == 3) {
            addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
          }
        }
        for (; ; ) {
          walk(from);
          if (from == to) {
            break;
          }
          from = from.nextSibling;
          extraLinebreak = false;
        }
        return text2;
      }
      function domToPos(cm, node, offset) {
        var lineNode;
        if (node == cm.display.lineDiv) {
          lineNode = cm.display.lineDiv.childNodes[offset];
          if (!lineNode) {
            return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true);
          }
          node = null;
          offset = 0;
        } else {
          for (lineNode = node; ; lineNode = lineNode.parentNode) {
            if (!lineNode || lineNode == cm.display.lineDiv) {
              return null;
            }
            if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) {
              break;
            }
          }
        }
        for (var i2 = 0; i2 < cm.display.view.length; i2++) {
          var lineView = cm.display.view[i2];
          if (lineView.node == lineNode) {
            return locateNodeInLineView(lineView, node, offset);
          }
        }
      }
      function locateNodeInLineView(lineView, node, offset) {
        var wrapper = lineView.text.firstChild, bad = false;
        if (!node || !contains(wrapper, node)) {
          return badPos(Pos(lineNo(lineView.line), 0), true);
        }
        if (node == wrapper) {
          bad = true;
          node = wrapper.childNodes[offset];
          offset = 0;
          if (!node) {
            var line = lineView.rest ? lst(lineView.rest) : lineView.line;
            return badPos(Pos(lineNo(line), line.text.length), bad);
          }
        }
        var textNode = node.nodeType == 3 ? node : null, topNode = node;
        if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
          textNode = node.firstChild;
          if (offset) {
            offset = textNode.nodeValue.length;
          }
        }
        while (topNode.parentNode != wrapper) {
          topNode = topNode.parentNode;
        }
        var measure = lineView.measure, maps = measure.maps;
        function find4(textNode2, topNode2, offset2) {
          for (var i2 = -1; i2 < (maps ? maps.length : 0); i2++) {
            var map3 = i2 < 0 ? measure.map : maps[i2];
            for (var j = 0; j < map3.length; j += 3) {
              var curNode = map3[j + 2];
              if (curNode == textNode2 || curNode == topNode2) {
                var line2 = lineNo(i2 < 0 ? lineView.line : lineView.rest[i2]);
                var ch = map3[j] + offset2;
                if (offset2 < 0 || curNode != textNode2) {
                  ch = map3[j + (offset2 ? 1 : 0)];
                }
                return Pos(line2, ch);
              }
            }
          }
        }
        var found = find4(textNode, topNode, offset);
        if (found) {
          return badPos(found, bad);
        }
        for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
          found = find4(after, after.firstChild, 0);
          if (found) {
            return badPos(Pos(found.line, found.ch - dist), bad);
          } else {
            dist += after.textContent.length;
          }
        }
        for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
          found = find4(before, before.firstChild, -1);
          if (found) {
            return badPos(Pos(found.line, found.ch + dist$1), bad);
          } else {
            dist$1 += before.textContent.length;
          }
        }
      }
      var TextareaInput = function(cm) {
        this.cm = cm;
        this.prevInput = "";
        this.pollingFast = false;
        this.polling = new Delayed();
        this.hasSelection = false;
        this.composing = null;
      };
      TextareaInput.prototype.init = function(display) {
        var this$1 = this;
        var input = this, cm = this.cm;
        this.createField(display);
        var te = this.textarea;
        display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);
        if (ios) {
          te.style.width = "0px";
        }
        on(te, "input", function() {
          if (ie && ie_version >= 9 && this$1.hasSelection) {
            this$1.hasSelection = null;
          }
          input.poll();
        });
        on(te, "paste", function(e) {
          if (signalDOMEvent(cm, e) || handlePaste(e, cm)) {
            return;
          }
          cm.state.pasteIncoming = +new Date();
          input.fastPoll();
        });
        function prepareCopyCut(e) {
          if (signalDOMEvent(cm, e)) {
            return;
          }
          if (cm.somethingSelected()) {
            setLastCopied({ lineWise: false, text: cm.getSelections() });
          } else if (!cm.options.lineWiseCopyCut) {
            return;
          } else {
            var ranges = copyableRanges(cm);
            setLastCopied({ lineWise: true, text: ranges.text });
            if (e.type == "cut") {
              cm.setSelections(ranges.ranges, null, sel_dontScroll);
            } else {
              input.prevInput = "";
              te.value = ranges.text.join("\n");
              selectInput(te);
            }
          }
          if (e.type == "cut") {
            cm.state.cutIncoming = +new Date();
          }
        }
        on(te, "cut", prepareCopyCut);
        on(te, "copy", prepareCopyCut);
        on(display.scroller, "paste", function(e) {
          if (eventInWidget(display, e) || signalDOMEvent(cm, e)) {
            return;
          }
          if (!te.dispatchEvent) {
            cm.state.pasteIncoming = +new Date();
            input.focus();
            return;
          }
          var event = new Event("paste");
          event.clipboardData = e.clipboardData;
          te.dispatchEvent(event);
        });
        on(display.lineSpace, "selectstart", function(e) {
          if (!eventInWidget(display, e)) {
            e_preventDefault(e);
          }
        });
        on(te, "compositionstart", function() {
          var start = cm.getCursor("from");
          if (input.composing) {
            input.composing.range.clear();
          }
          input.composing = {
            start,
            range: cm.markText(start, cm.getCursor("to"), { className: "CodeMirror-composing" })
          };
        });
        on(te, "compositionend", function() {
          if (input.composing) {
            input.poll();
            input.composing.range.clear();
            input.composing = null;
          }
        });
      };
      TextareaInput.prototype.createField = function(_display) {
        this.wrapper = hiddenTextarea();
        this.textarea = this.wrapper.firstChild;
      };
      TextareaInput.prototype.screenReaderLabelChanged = function(label) {
        if (label) {
          this.textarea.setAttribute("aria-label", label);
        } else {
          this.textarea.removeAttribute("aria-label");
        }
      };
      TextareaInput.prototype.prepareSelection = function() {
        var cm = this.cm, display = cm.display, doc = cm.doc;
        var result = prepareSelection(cm);
        if (cm.options.moveInputWithCursor) {
          var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
          var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
          result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top));
          result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left));
        }
        return result;
      };
      TextareaInput.prototype.showSelection = function(drawn) {
        var cm = this.cm, display = cm.display;
        removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
        removeChildrenAndAdd(display.selectionDiv, drawn.selection);
        if (drawn.teTop != null) {
          this.wrapper.style.top = drawn.teTop + "px";
          this.wrapper.style.left = drawn.teLeft + "px";
        }
      };
      TextareaInput.prototype.reset = function(typing) {
        if (this.contextMenuPending || this.composing) {
          return;
        }
        var cm = this.cm;
        if (cm.somethingSelected()) {
          this.prevInput = "";
          var content = cm.getSelection();
          this.textarea.value = content;
          if (cm.state.focused) {
            selectInput(this.textarea);
          }
          if (ie && ie_version >= 9) {
            this.hasSelection = content;
          }
        } else if (!typing) {
          this.prevInput = this.textarea.value = "";
          if (ie && ie_version >= 9) {
            this.hasSelection = null;
          }
        }
      };
      TextareaInput.prototype.getField = function() {
        return this.textarea;
      };
      TextareaInput.prototype.supportsTouch = function() {
        return false;
      };
      TextareaInput.prototype.focus = function() {
        if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
          try {
            this.textarea.focus();
          } catch (e) {
          }
        }
      };
      TextareaInput.prototype.blur = function() {
        this.textarea.blur();
      };
      TextareaInput.prototype.resetPosition = function() {
        this.wrapper.style.top = this.wrapper.style.left = 0;
      };
      TextareaInput.prototype.receivedFocus = function() {
        this.slowPoll();
      };
      TextareaInput.prototype.slowPoll = function() {
        var this$1 = this;
        if (this.pollingFast) {
          return;
        }
        this.polling.set(this.cm.options.pollInterval, function() {
          this$1.poll();
          if (this$1.cm.state.focused) {
            this$1.slowPoll();
          }
        });
      };
      TextareaInput.prototype.fastPoll = function() {
        var missed = false, input = this;
        input.pollingFast = true;
        function p2() {
          var changed = input.poll();
          if (!changed && !missed) {
            missed = true;
            input.polling.set(60, p2);
          } else {
            input.pollingFast = false;
            input.slowPoll();
          }
        }
        input.polling.set(20, p2);
      };
      TextareaInput.prototype.poll = function() {
        var this$1 = this;
        var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
        if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) {
          return false;
        }
        var text2 = input.value;
        if (text2 == prevInput && !cm.somethingSelected()) {
          return false;
        }
        if (ie && ie_version >= 9 && this.hasSelection === text2 || mac && /[\uf700-\uf7ff]/.test(text2)) {
          cm.display.input.reset();
          return false;
        }
        if (cm.doc.sel == cm.display.selForContextMenu) {
          var first = text2.charCodeAt(0);
          if (first == 8203 && !prevInput) {
            prevInput = "\u200B";
          }
          if (first == 8666) {
            this.reset();
            return this.cm.execCommand("undo");
          }
        }
        var same = 0, l = Math.min(prevInput.length, text2.length);
        while (same < l && prevInput.charCodeAt(same) == text2.charCodeAt(same)) {
          ++same;
        }
        runInOp(cm, function() {
          applyTextInput(cm, text2.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null);
          if (text2.length > 1e3 || text2.indexOf("\n") > -1) {
            input.value = this$1.prevInput = "";
          } else {
            this$1.prevInput = text2;
          }
          if (this$1.composing) {
            this$1.composing.range.clear();
            this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), { className: "CodeMirror-composing" });
          }
        });
        return true;
      };
      TextareaInput.prototype.ensurePolled = function() {
        if (this.pollingFast && this.poll()) {
          this.pollingFast = false;
        }
      };
      TextareaInput.prototype.onKeyPress = function() {
        if (ie && ie_version >= 9) {
          this.hasSelection = null;
        }
        this.fastPoll();
      };
      TextareaInput.prototype.onContextMenu = function(e) {
        var input = this, cm = input.cm, display = cm.display, te = input.textarea;
        if (input.contextMenuPending) {
          input.contextMenuPending();
        }
        var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
        if (!pos || presto) {
          return;
        }
        var reset = cm.options.resetSelectionOnContextMenu;
        if (reset && cm.doc.sel.contains(pos) == -1) {
          operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
        }
        var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
        var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
        input.wrapper.style.cssText = "position: static";
        te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
        var oldScrollY;
        if (webkit) {
          oldScrollY = window.scrollY;
        }
        display.input.focus();
        if (webkit) {
          window.scrollTo(null, oldScrollY);
        }
        display.input.reset();
        if (!cm.somethingSelected()) {
          te.value = input.prevInput = " ";
        }
        input.contextMenuPending = rehide;
        display.selForContextMenu = cm.doc.sel;
        clearTimeout(display.detectingSelectAll);
        function prepareSelectAllHack() {
          if (te.selectionStart != null) {
            var selected = cm.somethingSelected();
            var extval = "\u200B" + (selected ? te.value : "");
            te.value = "\u21DA";
            te.value = extval;
            input.prevInput = selected ? "" : "\u200B";
            te.selectionStart = 1;
            te.selectionEnd = extval.length;
            display.selForContextMenu = cm.doc.sel;
          }
        }
        function rehide() {
          if (input.contextMenuPending != rehide) {
            return;
          }
          input.contextMenuPending = false;
          input.wrapper.style.cssText = oldWrapperCSS;
          te.style.cssText = oldCSS;
          if (ie && ie_version < 9) {
            display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos);
          }
          if (te.selectionStart != null) {
            if (!ie || ie && ie_version < 9) {
              prepareSelectAllHack();
            }
            var i2 = 0, poll = function() {
              if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 && te.selectionEnd > 0 && input.prevInput == "\u200B") {
                operation(cm, selectAll)(cm);
              } else if (i2++ < 10) {
                display.detectingSelectAll = setTimeout(poll, 500);
              } else {
                display.selForContextMenu = null;
                display.input.reset();
              }
            };
            display.detectingSelectAll = setTimeout(poll, 200);
          }
        }
        if (ie && ie_version >= 9) {
          prepareSelectAllHack();
        }
        if (captureRightClick) {
          e_stop(e);
          var mouseup = function() {
            off(window, "mouseup", mouseup);
            setTimeout(rehide, 20);
          };
          on(window, "mouseup", mouseup);
        } else {
          setTimeout(rehide, 50);
        }
      };
      TextareaInput.prototype.readOnlyChanged = function(val) {
        if (!val) {
          this.reset();
        }
        this.textarea.disabled = val == "nocursor";
        this.textarea.readOnly = !!val;
      };
      TextareaInput.prototype.setUneditable = function() {
      };
      TextareaInput.prototype.needsContentAttribute = false;
      function fromTextArea(textarea, options) {
        options = options ? copyObj(options) : {};
        options.value = textarea.value;
        if (!options.tabindex && textarea.tabIndex) {
          options.tabindex = textarea.tabIndex;
        }
        if (!options.placeholder && textarea.placeholder) {
          options.placeholder = textarea.placeholder;
        }
        if (options.autofocus == null) {
          var hasFocus = activeElt();
          options.autofocus = hasFocus == textarea || textarea.getAttribute("autofocus") != null && hasFocus == document.body;
        }
        function save() {
          textarea.value = cm.getValue();
        }
        var realSubmit;
        if (textarea.form) {
          on(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone) {
            var form = textarea.form;
            realSubmit = form.submit;
            try {
              var wrappedSubmit = form.submit = function() {
                save();
                form.submit = realSubmit;
                form.submit();
                form.submit = wrappedSubmit;
              };
            } catch (e) {
            }
          }
        }
        options.finishInit = function(cm2) {
          cm2.save = save;
          cm2.getTextArea = function() {
            return textarea;
          };
          cm2.toTextArea = function() {
            cm2.toTextArea = isNaN;
            save();
            textarea.parentNode.removeChild(cm2.getWrapperElement());
            textarea.style.display = "";
            if (textarea.form) {
              off(textarea.form, "submit", save);
              if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function") {
                textarea.form.submit = realSubmit;
              }
            }
          };
        };
        textarea.style.display = "none";
        var cm = CodeMirror2(function(node) {
          return textarea.parentNode.insertBefore(node, textarea.nextSibling);
        }, options);
        return cm;
      }
      function addLegacyProps(CodeMirror3) {
        CodeMirror3.off = off;
        CodeMirror3.on = on;
        CodeMirror3.wheelEventPixels = wheelEventPixels;
        CodeMirror3.Doc = Doc;
        CodeMirror3.splitLines = splitLinesAuto;
        CodeMirror3.countColumn = countColumn;
        CodeMirror3.findColumn = findColumn;
        CodeMirror3.isWordChar = isWordCharBasic;
        CodeMirror3.Pass = Pass;
        CodeMirror3.signal = signal;
        CodeMirror3.Line = Line;
        CodeMirror3.changeEnd = changeEnd;
        CodeMirror3.scrollbarModel = scrollbarModel;
        CodeMirror3.Pos = Pos;
        CodeMirror3.cmpPos = cmp;
        CodeMirror3.modes = modes;
        CodeMirror3.mimeModes = mimeModes;
        CodeMirror3.resolveMode = resolveMode;
        CodeMirror3.getMode = getMode;
        CodeMirror3.modeExtensions = modeExtensions;
        CodeMirror3.extendMode = extendMode;
        CodeMirror3.copyState = copyState;
        CodeMirror3.startState = startState;
        CodeMirror3.innerMode = innerMode;
        CodeMirror3.commands = commands;
        CodeMirror3.keyMap = keyMap2;
        CodeMirror3.keyName = keyName;
        CodeMirror3.isModifierKey = isModifierKey;
        CodeMirror3.lookupKey = lookupKey;
        CodeMirror3.normalizeKeyMap = normalizeKeyMap;
        CodeMirror3.StringStream = StringStream;
        CodeMirror3.SharedTextMarker = SharedTextMarker;
        CodeMirror3.TextMarker = TextMarker;
        CodeMirror3.LineWidget = LineWidget;
        CodeMirror3.e_preventDefault = e_preventDefault;
        CodeMirror3.e_stopPropagation = e_stopPropagation;
        CodeMirror3.e_stop = e_stop;
        CodeMirror3.addClass = addClass;
        CodeMirror3.contains = contains;
        CodeMirror3.rmClass = rmClass;
        CodeMirror3.keyNames = keyNames;
      }
      defineOptions(CodeMirror2);
      addEditorMethods(CodeMirror2);
      var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
      for (var prop in Doc.prototype) {
        if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0) {
          CodeMirror2.prototype[prop] = function(method) {
            return function() {
              return method.apply(this.doc, arguments);
            };
          }(Doc.prototype[prop]);
        }
      }
      eventMixin(Doc);
      CodeMirror2.inputStyles = { "textarea": TextareaInput, "contenteditable": ContentEditableInput };
      CodeMirror2.defineMode = function(name2) {
        if (!CodeMirror2.defaults.mode && name2 != "null") {
          CodeMirror2.defaults.mode = name2;
        }
        defineMode.apply(this, arguments);
      };
      CodeMirror2.defineMIME = defineMIME;
      CodeMirror2.defineMode("null", function() {
        return { token: function(stream) {
          return stream.skipToEnd();
        } };
      });
      CodeMirror2.defineMIME("text/plain", "null");
      CodeMirror2.defineExtension = function(name2, func) {
        CodeMirror2.prototype[name2] = func;
      };
      CodeMirror2.defineDocExtension = function(name2, func) {
        Doc.prototype[name2] = func;
      };
      CodeMirror2.fromTextArea = fromTextArea;
      addLegacyProps(CodeMirror2);
      CodeMirror2.version = "5.63.3";
      return CodeMirror2;
    });
  }
});

// node_modules/codemirror/addon/hint/show-hint.js
var require_show_hint = __commonJS({
  "node_modules/codemirror/addon/hint/show-hint.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      var HINT_ELEMENT_CLASS = "CodeMirror-hint";
      var ACTIVE_HINT_ELEMENT_CLASS = "CodeMirror-hint-active";
      CodeMirror2.showHint = function(cm, getHints, options) {
        if (!getHints)
          return cm.showHint(options);
        if (options && options.async)
          getHints.async = true;
        var newOpts = { hint: getHints };
        if (options)
          for (var prop in options)
            newOpts[prop] = options[prop];
        return cm.showHint(newOpts);
      };
      CodeMirror2.defineExtension("showHint", function(options) {
        options = parseOptions(this, this.getCursor("start"), options);
        var selections = this.listSelections();
        if (selections.length > 1)
          return;
        if (this.somethingSelected()) {
          if (!options.hint.supportsSelection)
            return;
          for (var i = 0; i < selections.length; i++)
            if (selections[i].head.line != selections[i].anchor.line)
              return;
        }
        if (this.state.completionActive)
          this.state.completionActive.close();
        var completion = this.state.completionActive = new Completion(this, options);
        if (!completion.options.hint)
          return;
        CodeMirror2.signal(this, "startCompletion", this);
        completion.update(true);
      });
      CodeMirror2.defineExtension("closeHint", function() {
        if (this.state.completionActive)
          this.state.completionActive.close();
      });
      function Completion(cm, options) {
        this.cm = cm;
        this.options = options;
        this.widget = null;
        this.debounce = 0;
        this.tick = 0;
        this.startPos = this.cm.getCursor("start");
        this.startLen = this.cm.getLine(this.startPos.line).length - this.cm.getSelection().length;
        if (this.options.updateOnCursorActivity) {
          var self2 = this;
          cm.on("cursorActivity", this.activityFunc = function() {
            self2.cursorActivity();
          });
        }
      }
      var requestAnimationFrame = window.requestAnimationFrame || function(fn) {
        return setTimeout(fn, 1e3 / 60);
      };
      var cancelAnimationFrame = window.cancelAnimationFrame || clearTimeout;
      Completion.prototype = {
        close: function() {
          if (!this.active())
            return;
          this.cm.state.completionActive = null;
          this.tick = null;
          if (this.options.updateOnCursorActivity) {
            this.cm.off("cursorActivity", this.activityFunc);
          }
          if (this.widget && this.data)
            CodeMirror2.signal(this.data, "close");
          if (this.widget)
            this.widget.close();
          CodeMirror2.signal(this.cm, "endCompletion", this.cm);
        },
        active: function() {
          return this.cm.state.completionActive == this;
        },
        pick: function(data, i) {
          var completion = data.list[i], self2 = this;
          this.cm.operation(function() {
            if (completion.hint)
              completion.hint(self2.cm, data, completion);
            else
              self2.cm.replaceRange(getText(completion), completion.from || data.from, completion.to || data.to, "complete");
            CodeMirror2.signal(data, "pick", completion);
            self2.cm.scrollIntoView();
          });
          if (this.options.closeOnPick) {
            this.close();
          }
        },
        cursorActivity: function() {
          if (this.debounce) {
            cancelAnimationFrame(this.debounce);
            this.debounce = 0;
          }
          var identStart = this.startPos;
          if (this.data) {
            identStart = this.data.from;
          }
          var pos = this.cm.getCursor(), line = this.cm.getLine(pos.line);
          if (pos.line != this.startPos.line || line.length - pos.ch != this.startLen - this.startPos.ch || pos.ch < identStart.ch || this.cm.somethingSelected() || (!pos.ch || this.options.closeCharacters.test(line.charAt(pos.ch - 1)))) {
            this.close();
          } else {
            var self2 = this;
            this.debounce = requestAnimationFrame(function() {
              self2.update();
            });
            if (this.widget)
              this.widget.disable();
          }
        },
        update: function(first) {
          if (this.tick == null)
            return;
          var self2 = this, myTick = ++this.tick;
          fetchHints(this.options.hint, this.cm, this.options, function(data) {
            if (self2.tick == myTick)
              self2.finishUpdate(data, first);
          });
        },
        finishUpdate: function(data, first) {
          if (this.data)
            CodeMirror2.signal(this.data, "update");
          var picked = this.widget && this.widget.picked || first && this.options.completeSingle;
          if (this.widget)
            this.widget.close();
          this.data = data;
          if (data && data.list.length) {
            if (picked && data.list.length == 1) {
              this.pick(data, 0);
            } else {
              this.widget = new Widget(this, data);
              CodeMirror2.signal(data, "shown");
            }
          }
        }
      };
      function parseOptions(cm, pos, options) {
        var editor = cm.options.hintOptions;
        var out = {};
        for (var prop in defaultOptions)
          out[prop] = defaultOptions[prop];
        if (editor) {
          for (var prop in editor)
            if (editor[prop] !== void 0)
              out[prop] = editor[prop];
        }
        if (options) {
          for (var prop in options)
            if (options[prop] !== void 0)
              out[prop] = options[prop];
        }
        if (out.hint.resolve)
          out.hint = out.hint.resolve(cm, pos);
        return out;
      }
      function getText(completion) {
        if (typeof completion == "string")
          return completion;
        else
          return completion.text;
      }
      function buildKeyMap(completion, handle) {
        var baseMap = {
          Up: function() {
            handle.moveFocus(-1);
          },
          Down: function() {
            handle.moveFocus(1);
          },
          PageUp: function() {
            handle.moveFocus(-handle.menuSize() + 1, true);
          },
          PageDown: function() {
            handle.moveFocus(handle.menuSize() - 1, true);
          },
          Home: function() {
            handle.setFocus(0);
          },
          End: function() {
            handle.setFocus(handle.length - 1);
          },
          Enter: handle.pick,
          Tab: handle.pick,
          Esc: handle.close
        };
        var mac = /Mac/.test(navigator.platform);
        if (mac) {
          baseMap["Ctrl-P"] = function() {
            handle.moveFocus(-1);
          };
          baseMap["Ctrl-N"] = function() {
            handle.moveFocus(1);
          };
        }
        var custom = completion.options.customKeys;
        var ourMap = custom ? {} : baseMap;
        function addBinding(key2, val) {
          var bound;
          if (typeof val != "string")
            bound = function(cm) {
              return val(cm, handle);
            };
          else if (baseMap.hasOwnProperty(val))
            bound = baseMap[val];
          else
            bound = val;
          ourMap[key2] = bound;
        }
        if (custom) {
          for (var key in custom)
            if (custom.hasOwnProperty(key))
              addBinding(key, custom[key]);
        }
        var extra = completion.options.extraKeys;
        if (extra) {
          for (var key in extra)
            if (extra.hasOwnProperty(key))
              addBinding(key, extra[key]);
        }
        return ourMap;
      }
      function getHintElement(hintsElement, el) {
        while (el && el != hintsElement) {
          if (el.nodeName.toUpperCase() === "LI" && el.parentNode == hintsElement)
            return el;
          el = el.parentNode;
        }
      }
      function Widget(completion, data) {
        this.id = "cm-complete-" + Math.floor(Math.random(1e6));
        this.completion = completion;
        this.data = data;
        this.picked = false;
        var widget = this, cm = completion.cm;
        var ownerDocument = cm.getInputField().ownerDocument;
        var parentWindow = ownerDocument.defaultView || ownerDocument.parentWindow;
        var hints = this.hints = ownerDocument.createElement("ul");
        hints.setAttribute("role", "listbox");
        hints.setAttribute("aria-expanded", "true");
        hints.id = this.id;
        var theme = completion.cm.options.theme;
        hints.className = "CodeMirror-hints " + theme;
        this.selectedHint = data.selectedHint || 0;
        var completions = data.list;
        for (var i = 0; i < completions.length; ++i) {
          var elt = hints.appendChild(ownerDocument.createElement("li")), cur = completions[i];
          var className = HINT_ELEMENT_CLASS + (i != this.selectedHint ? "" : " " + ACTIVE_HINT_ELEMENT_CLASS);
          if (cur.className != null)
            className = cur.className + " " + className;
          elt.className = className;
          if (i == this.selectedHint)
            elt.setAttribute("aria-selected", "true");
          elt.id = this.id + "-" + i;
          elt.setAttribute("role", "option");
          if (cur.render)
            cur.render(elt, data, cur);
          else
            elt.appendChild(ownerDocument.createTextNode(cur.displayText || getText(cur)));
          elt.hintId = i;
        }
        var container = completion.options.container || ownerDocument.body;
        var pos = cm.cursorCoords(completion.options.alignWithWord ? data.from : null);
        var left = pos.left, top = pos.bottom, below = true;
        var offsetLeft = 0, offsetTop = 0;
        if (container !== ownerDocument.body) {
          var isContainerPositioned = ["absolute", "relative", "fixed"].indexOf(parentWindow.getComputedStyle(container).position) !== -1;
          var offsetParent = isContainerPositioned ? container : container.offsetParent;
          var offsetParentPosition = offsetParent.getBoundingClientRect();
          var bodyPosition = ownerDocument.body.getBoundingClientRect();
          offsetLeft = offsetParentPosition.left - bodyPosition.left - offsetParent.scrollLeft;
          offsetTop = offsetParentPosition.top - bodyPosition.top - offsetParent.scrollTop;
        }
        hints.style.left = left - offsetLeft + "px";
        hints.style.top = top - offsetTop + "px";
        var winW = parentWindow.innerWidth || Math.max(ownerDocument.body.offsetWidth, ownerDocument.documentElement.offsetWidth);
        var winH = parentWindow.innerHeight || Math.max(ownerDocument.body.offsetHeight, ownerDocument.documentElement.offsetHeight);
        container.appendChild(hints);
        cm.getInputField().setAttribute("aria-autocomplete", "list");
        cm.getInputField().setAttribute("aria-owns", this.id);
        cm.getInputField().setAttribute("aria-activedescendant", this.id + "-" + this.selectedHint);
        var box = completion.options.moveOnOverlap ? hints.getBoundingClientRect() : new DOMRect();
        var scrolls = completion.options.paddingForScrollbar ? hints.scrollHeight > hints.clientHeight + 1 : false;
        var startScroll;
        setTimeout(function() {
          startScroll = cm.getScrollInfo();
        });
        var overlapY = box.bottom - winH;
        if (overlapY > 0) {
          var height = box.bottom - box.top, curTop = pos.top - (pos.bottom - box.top);
          if (curTop - height > 0) {
            hints.style.top = (top = pos.top - height - offsetTop) + "px";
            below = false;
          } else if (height > winH) {
            hints.style.height = winH - 5 + "px";
            hints.style.top = (top = pos.bottom - box.top - offsetTop) + "px";
            var cursor = cm.getCursor();
            if (data.from.ch != cursor.ch) {
              pos = cm.cursorCoords(cursor);
              hints.style.left = (left = pos.left - offsetLeft) + "px";
              box = hints.getBoundingClientRect();
            }
          }
        }
        var overlapX = box.right - winW;
        if (scrolls)
          overlapX += cm.display.nativeBarWidth;
        if (overlapX > 0) {
          if (box.right - box.left > winW) {
            hints.style.width = winW - 5 + "px";
            overlapX -= box.right - box.left - winW;
          }
          hints.style.left = (left = pos.left - overlapX - offsetLeft) + "px";
        }
        if (scrolls)
          for (var node = hints.firstChild; node; node = node.nextSibling)
            node.style.paddingRight = cm.display.nativeBarWidth + "px";
        cm.addKeyMap(this.keyMap = buildKeyMap(completion, {
          moveFocus: function(n, avoidWrap) {
            widget.changeActive(widget.selectedHint + n, avoidWrap);
          },
          setFocus: function(n) {
            widget.changeActive(n);
          },
          menuSize: function() {
            return widget.screenAmount();
          },
          length: completions.length,
          close: function() {
            completion.close();
          },
          pick: function() {
            widget.pick();
          },
          data
        }));
        if (completion.options.closeOnUnfocus) {
          var closingOnBlur;
          cm.on("blur", this.onBlur = function() {
            closingOnBlur = setTimeout(function() {
              completion.close();
            }, 100);
          });
          cm.on("focus", this.onFocus = function() {
            clearTimeout(closingOnBlur);
          });
        }
        cm.on("scroll", this.onScroll = function() {
          var curScroll = cm.getScrollInfo(), editor = cm.getWrapperElement().getBoundingClientRect();
          if (!startScroll)
            startScroll = cm.getScrollInfo();
          var newTop = top + startScroll.top - curScroll.top;
          var point = newTop - (parentWindow.pageYOffset || (ownerDocument.documentElement || ownerDocument.body).scrollTop);
          if (!below)
            point += hints.offsetHeight;
          if (point <= editor.top || point >= editor.bottom)
            return completion.close();
          hints.style.top = newTop + "px";
          hints.style.left = left + startScroll.left - curScroll.left + "px";
        });
        CodeMirror2.on(hints, "dblclick", function(e) {
          var t2 = getHintElement(hints, e.target || e.srcElement);
          if (t2 && t2.hintId != null) {
            widget.changeActive(t2.hintId);
            widget.pick();
          }
        });
        CodeMirror2.on(hints, "click", function(e) {
          var t2 = getHintElement(hints, e.target || e.srcElement);
          if (t2 && t2.hintId != null) {
            widget.changeActive(t2.hintId);
            if (completion.options.completeOnSingleClick)
              widget.pick();
          }
        });
        CodeMirror2.on(hints, "mousedown", function() {
          setTimeout(function() {
            cm.focus();
          }, 20);
        });
        var selectedHintRange = this.getSelectedHintRange();
        if (selectedHintRange.from !== 0 || selectedHintRange.to !== 0) {
          this.scrollToActive();
        }
        CodeMirror2.signal(data, "select", completions[this.selectedHint], hints.childNodes[this.selectedHint]);
        return true;
      }
      Widget.prototype = {
        close: function() {
          if (this.completion.widget != this)
            return;
          this.completion.widget = null;
          if (this.hints.parentNode)
            this.hints.parentNode.removeChild(this.hints);
          this.completion.cm.removeKeyMap(this.keyMap);
          var input = this.completion.cm.getInputField();
          input.removeAttribute("aria-activedescendant");
          input.removeAttribute("aria-owns");
          var cm = this.completion.cm;
          if (this.completion.options.closeOnUnfocus) {
            cm.off("blur", this.onBlur);
            cm.off("focus", this.onFocus);
          }
          cm.off("scroll", this.onScroll);
        },
        disable: function() {
          this.completion.cm.removeKeyMap(this.keyMap);
          var widget = this;
          this.keyMap = { Enter: function() {
            widget.picked = true;
          } };
          this.completion.cm.addKeyMap(this.keyMap);
        },
        pick: function() {
          this.completion.pick(this.data, this.selectedHint);
        },
        changeActive: function(i, avoidWrap) {
          if (i >= this.data.list.length)
            i = avoidWrap ? this.data.list.length - 1 : 0;
          else if (i < 0)
            i = avoidWrap ? 0 : this.data.list.length - 1;
          if (this.selectedHint == i)
            return;
          var node = this.hints.childNodes[this.selectedHint];
          if (node) {
            node.className = node.className.replace(" " + ACTIVE_HINT_ELEMENT_CLASS, "");
            node.removeAttribute("aria-selected");
          }
          node = this.hints.childNodes[this.selectedHint = i];
          node.className += " " + ACTIVE_HINT_ELEMENT_CLASS;
          node.setAttribute("aria-selected", "true");
          this.completion.cm.getInputField().setAttribute("aria-activedescendant", node.id);
          this.scrollToActive();
          CodeMirror2.signal(this.data, "select", this.data.list[this.selectedHint], node);
        },
        scrollToActive: function() {
          var selectedHintRange = this.getSelectedHintRange();
          var node1 = this.hints.childNodes[selectedHintRange.from];
          var node2 = this.hints.childNodes[selectedHintRange.to];
          var firstNode = this.hints.firstChild;
          if (node1.offsetTop < this.hints.scrollTop)
            this.hints.scrollTop = node1.offsetTop - firstNode.offsetTop;
          else if (node2.offsetTop + node2.offsetHeight > this.hints.scrollTop + this.hints.clientHeight)
            this.hints.scrollTop = node2.offsetTop + node2.offsetHeight - this.hints.clientHeight + firstNode.offsetTop;
        },
        screenAmount: function() {
          return Math.floor(this.hints.clientHeight / this.hints.firstChild.offsetHeight) || 1;
        },
        getSelectedHintRange: function() {
          var margin = this.completion.options.scrollMargin || 0;
          return {
            from: Math.max(0, this.selectedHint - margin),
            to: Math.min(this.data.list.length - 1, this.selectedHint + margin)
          };
        }
      };
      function applicableHelpers(cm, helpers) {
        if (!cm.somethingSelected())
          return helpers;
        var result = [];
        for (var i = 0; i < helpers.length; i++)
          if (helpers[i].supportsSelection)
            result.push(helpers[i]);
        return result;
      }
      function fetchHints(hint, cm, options, callback) {
        if (hint.async) {
          hint(cm, callback, options);
        } else {
          var result = hint(cm, options);
          if (result && result.then)
            result.then(callback);
          else
            callback(result);
        }
      }
      function resolveAutoHints(cm, pos) {
        var helpers = cm.getHelpers(pos, "hint"), words;
        if (helpers.length) {
          var resolved = function(cm2, callback, options) {
            var app = applicableHelpers(cm2, helpers);
            function run(i) {
              if (i == app.length)
                return callback(null);
              fetchHints(app[i], cm2, options, function(result) {
                if (result && result.list.length > 0)
                  callback(result);
                else
                  run(i + 1);
              });
            }
            run(0);
          };
          resolved.async = true;
          resolved.supportsSelection = true;
          return resolved;
        } else if (words = cm.getHelper(cm.getCursor(), "hintWords")) {
          return function(cm2) {
            return CodeMirror2.hint.fromList(cm2, { words });
          };
        } else if (CodeMirror2.hint.anyword) {
          return function(cm2, options) {
            return CodeMirror2.hint.anyword(cm2, options);
          };
        } else {
          return function() {
          };
        }
      }
      CodeMirror2.registerHelper("hint", "auto", {
        resolve: resolveAutoHints
      });
      CodeMirror2.registerHelper("hint", "fromList", function(cm, options) {
        var cur = cm.getCursor(), token = cm.getTokenAt(cur);
        var term, from = CodeMirror2.Pos(cur.line, token.start), to = cur;
        if (token.start < cur.ch && /\w/.test(token.string.charAt(cur.ch - token.start - 1))) {
          term = token.string.substr(0, cur.ch - token.start);
        } else {
          term = "";
          from = cur;
        }
        var found = [];
        for (var i = 0; i < options.words.length; i++) {
          var word2 = options.words[i];
          if (word2.slice(0, term.length) == term)
            found.push(word2);
        }
        if (found.length)
          return { list: found, from, to };
      });
      CodeMirror2.commands.autocomplete = CodeMirror2.showHint;
      var defaultOptions = {
        hint: CodeMirror2.hint.auto,
        completeSingle: true,
        alignWithWord: true,
        closeCharacters: /[\s()\[\]{};:>,]/,
        closeOnPick: true,
        closeOnUnfocus: true,
        updateOnCursorActivity: true,
        completeOnSingleClick: true,
        container: null,
        customKeys: null,
        extraKeys: null,
        paddingForScrollbar: true,
        moveOnOverlap: true
      };
      CodeMirror2.defineOption("hintOptions", null);
    });
  }
});

// node_modules/codemirror/addon/comment/comment.js
var require_comment = __commonJS({
  "node_modules/codemirror/addon/comment/comment.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      var noOptions = {};
      var nonWS = /[^\s\u00a0]/;
      var Pos = CodeMirror2.Pos, cmp = CodeMirror2.cmpPos;
      function firstNonWS(str) {
        var found = str.search(nonWS);
        return found == -1 ? 0 : found;
      }
      CodeMirror2.commands.toggleComment = function(cm) {
        cm.toggleComment();
      };
      CodeMirror2.defineExtension("toggleComment", function(options) {
        if (!options)
          options = noOptions;
        var cm = this;
        var minLine = Infinity, ranges = this.listSelections(), mode = null;
        for (var i = ranges.length - 1; i >= 0; i--) {
          var from = ranges[i].from(), to = ranges[i].to();
          if (from.line >= minLine)
            continue;
          if (to.line >= minLine)
            to = Pos(minLine, 0);
          minLine = from.line;
          if (mode == null) {
            if (cm.uncomment(from, to, options))
              mode = "un";
            else {
              cm.lineComment(from, to, options);
              mode = "line";
            }
          } else if (mode == "un") {
            cm.uncomment(from, to, options);
          } else {
            cm.lineComment(from, to, options);
          }
        }
      });
      function probablyInsideString(cm, pos, line) {
        return /\bstring\b/.test(cm.getTokenTypeAt(Pos(pos.line, 0))) && !/^[\'\"\`]/.test(line);
      }
      function getMode(cm, pos) {
        var mode = cm.getMode();
        return mode.useInnerComments === false || !mode.innerMode ? mode : cm.getModeAt(pos);
      }
      CodeMirror2.defineExtension("lineComment", function(from, to, options) {
        if (!options)
          options = noOptions;
        var self2 = this, mode = getMode(self2, from);
        var firstLine = self2.getLine(from.line);
        if (firstLine == null || probablyInsideString(self2, from, firstLine))
          return;
        var commentString = options.lineComment || mode.lineComment;
        if (!commentString) {
          if (options.blockCommentStart || mode.blockCommentStart) {
            options.fullLines = true;
            self2.blockComment(from, to, options);
          }
          return;
        }
        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line + 1 : to.line, self2.lastLine() + 1);
        var pad = options.padding == null ? " " : options.padding;
        var blankLines = options.commentBlankLines || from.line == to.line;
        self2.operation(function() {
          if (options.indent) {
            var baseString = null;
            for (var i = from.line; i < end; ++i) {
              var line = self2.getLine(i);
              var whitespace2 = line.slice(0, firstNonWS(line));
              if (baseString == null || baseString.length > whitespace2.length) {
                baseString = whitespace2;
              }
            }
            for (var i = from.line; i < end; ++i) {
              var line = self2.getLine(i), cut = baseString.length;
              if (!blankLines && !nonWS.test(line))
                continue;
              if (line.slice(0, cut) != baseString)
                cut = firstNonWS(line);
              self2.replaceRange(baseString + commentString + pad, Pos(i, 0), Pos(i, cut));
            }
          } else {
            for (var i = from.line; i < end; ++i) {
              if (blankLines || nonWS.test(self2.getLine(i)))
                self2.replaceRange(commentString + pad, Pos(i, 0));
            }
          }
        });
      });
      CodeMirror2.defineExtension("blockComment", function(from, to, options) {
        if (!options)
          options = noOptions;
        var self2 = this, mode = getMode(self2, from);
        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;
        if (!startString || !endString) {
          if ((options.lineComment || mode.lineComment) && options.fullLines != false)
            self2.lineComment(from, to, options);
          return;
        }
        if (/\bcomment\b/.test(self2.getTokenTypeAt(Pos(from.line, 0))))
          return;
        var end = Math.min(to.line, self2.lastLine());
        if (end != from.line && to.ch == 0 && nonWS.test(self2.getLine(end)))
          --end;
        var pad = options.padding == null ? " " : options.padding;
        if (from.line > end)
          return;
        self2.operation(function() {
          if (options.fullLines != false) {
            var lastLineHasText = nonWS.test(self2.getLine(end));
            self2.replaceRange(pad + endString, Pos(end));
            self2.replaceRange(startString + pad, Pos(from.line, 0));
            var lead = options.blockCommentLead || mode.blockCommentLead;
            if (lead != null) {
              for (var i = from.line + 1; i <= end; ++i)
                if (i != end || lastLineHasText)
                  self2.replaceRange(lead + pad, Pos(i, 0));
            }
          } else {
            var atCursor = cmp(self2.getCursor("to"), to) == 0, empty = !self2.somethingSelected();
            self2.replaceRange(endString, to);
            if (atCursor)
              self2.setSelection(empty ? to : self2.getCursor("from"), to);
            self2.replaceRange(startString, from);
          }
        });
      });
      CodeMirror2.defineExtension("uncomment", function(from, to, options) {
        if (!options)
          options = noOptions;
        var self2 = this, mode = getMode(self2, from);
        var end = Math.min(to.ch != 0 || to.line == from.line ? to.line : to.line - 1, self2.lastLine()), start = Math.min(from.line, end);
        var lineString = options.lineComment || mode.lineComment, lines = [];
        var pad = options.padding == null ? " " : options.padding, didSomething;
        lineComment: {
          if (!lineString)
            break lineComment;
          for (var i = start; i <= end; ++i) {
            var line = self2.getLine(i);
            var found = line.indexOf(lineString);
            if (found > -1 && !/comment/.test(self2.getTokenTypeAt(Pos(i, found + 1))))
              found = -1;
            if (found == -1 && nonWS.test(line))
              break lineComment;
            if (found > -1 && nonWS.test(line.slice(0, found)))
              break lineComment;
            lines.push(line);
          }
          self2.operation(function() {
            for (var i2 = start; i2 <= end; ++i2) {
              var line2 = lines[i2 - start];
              var pos = line2.indexOf(lineString), endPos = pos + lineString.length;
              if (pos < 0)
                continue;
              if (line2.slice(endPos, endPos + pad.length) == pad)
                endPos += pad.length;
              didSomething = true;
              self2.replaceRange("", Pos(i2, pos), Pos(i2, endPos));
            }
          });
          if (didSomething)
            return true;
        }
        var startString = options.blockCommentStart || mode.blockCommentStart;
        var endString = options.blockCommentEnd || mode.blockCommentEnd;
        if (!startString || !endString)
          return false;
        var lead = options.blockCommentLead || mode.blockCommentLead;
        var startLine = self2.getLine(start), open = startLine.indexOf(startString);
        if (open == -1)
          return false;
        var endLine = end == start ? startLine : self2.getLine(end);
        var close = endLine.indexOf(endString, end == start ? open + startString.length : 0);
        var insideStart = Pos(start, open + 1), insideEnd = Pos(end, close + 1);
        if (close == -1 || !/comment/.test(self2.getTokenTypeAt(insideStart)) || !/comment/.test(self2.getTokenTypeAt(insideEnd)) || self2.getRange(insideStart, insideEnd, "\n").indexOf(endString) > -1)
          return false;
        var lastStart = startLine.lastIndexOf(startString, from.ch);
        var firstEnd = lastStart == -1 ? -1 : startLine.slice(0, from.ch).indexOf(endString, lastStart + startString.length);
        if (lastStart != -1 && firstEnd != -1 && firstEnd + endString.length != from.ch)
          return false;
        firstEnd = endLine.indexOf(endString, to.ch);
        var almostLastStart = endLine.slice(to.ch).lastIndexOf(startString, firstEnd - to.ch);
        lastStart = firstEnd == -1 || almostLastStart == -1 ? -1 : to.ch + almostLastStart;
        if (firstEnd != -1 && lastStart != -1 && lastStart != to.ch)
          return false;
        self2.operation(function() {
          self2.replaceRange("", Pos(end, close - (pad && endLine.slice(close - pad.length, close) == pad ? pad.length : 0)), Pos(end, close + endString.length));
          var openEnd = open + startString.length;
          if (pad && startLine.slice(openEnd, openEnd + pad.length) == pad)
            openEnd += pad.length;
          self2.replaceRange("", Pos(start, open), Pos(start, openEnd));
          if (lead)
            for (var i2 = start + 1; i2 <= end; ++i2) {
              var line2 = self2.getLine(i2), found2 = line2.indexOf(lead);
              if (found2 == -1 || nonWS.test(line2.slice(0, found2)))
                continue;
              var foundEnd = found2 + lead.length;
              if (pad && line2.slice(foundEnd, foundEnd + pad.length) == pad)
                foundEnd += pad.length;
              self2.replaceRange("", Pos(i2, found2), Pos(i2, foundEnd));
            }
        });
        return true;
      });
    });
  }
});

// node_modules/codemirror/addon/edit/matchbrackets.js
var require_matchbrackets = __commonJS({
  "node_modules/codemirror/addon/edit/matchbrackets.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      var ie_lt8 = /MSIE \d/.test(navigator.userAgent) && (document.documentMode == null || document.documentMode < 8);
      var Pos = CodeMirror2.Pos;
      var matching = { "(": ")>", ")": "(<", "[": "]>", "]": "[<", "{": "}>", "}": "{<", "<": ">>", ">": "<<" };
      function bracketRegex(config) {
        return config && config.bracketRegex || /[(){}[\]]/;
      }
      function findMatchingBracket(cm, where, config) {
        var line = cm.getLineHandle(where.line), pos = where.ch - 1;
        var afterCursor = config && config.afterCursor;
        if (afterCursor == null)
          afterCursor = /(^| )cm-fat-cursor($| )/.test(cm.getWrapperElement().className);
        var re = bracketRegex(config);
        var match = !afterCursor && pos >= 0 && re.test(line.text.charAt(pos)) && matching[line.text.charAt(pos)] || re.test(line.text.charAt(pos + 1)) && matching[line.text.charAt(++pos)];
        if (!match)
          return null;
        var dir = match.charAt(1) == ">" ? 1 : -1;
        if (config && config.strict && dir > 0 != (pos == where.ch))
          return null;
        var style = cm.getTokenTypeAt(Pos(where.line, pos + 1));
        var found = scanForBracket(cm, Pos(where.line, pos + (dir > 0 ? 1 : 0)), dir, style, config);
        if (found == null)
          return null;
        return {
          from: Pos(where.line, pos),
          to: found && found.pos,
          match: found && found.ch == match.charAt(0),
          forward: dir > 0
        };
      }
      function scanForBracket(cm, where, dir, style, config) {
        var maxScanLen = config && config.maxScanLineLength || 1e4;
        var maxScanLines = config && config.maxScanLines || 1e3;
        var stack = [];
        var re = bracketRegex(config);
        var lineEnd = dir > 0 ? Math.min(where.line + maxScanLines, cm.lastLine() + 1) : Math.max(cm.firstLine() - 1, where.line - maxScanLines);
        for (var lineNo = where.line; lineNo != lineEnd; lineNo += dir) {
          var line = cm.getLine(lineNo);
          if (!line)
            continue;
          var pos = dir > 0 ? 0 : line.length - 1, end = dir > 0 ? line.length : -1;
          if (line.length > maxScanLen)
            continue;
          if (lineNo == where.line)
            pos = where.ch - (dir < 0 ? 1 : 0);
          for (; pos != end; pos += dir) {
            var ch = line.charAt(pos);
            if (re.test(ch) && (style === void 0 || (cm.getTokenTypeAt(Pos(lineNo, pos + 1)) || "") == (style || ""))) {
              var match = matching[ch];
              if (match && match.charAt(1) == ">" == dir > 0)
                stack.push(ch);
              else if (!stack.length)
                return { pos: Pos(lineNo, pos), ch };
              else
                stack.pop();
            }
          }
        }
        return lineNo - dir == (dir > 0 ? cm.lastLine() : cm.firstLine()) ? false : null;
      }
      function matchBrackets(cm, autoclear, config) {
        var maxHighlightLen = cm.state.matchBrackets.maxHighlightLineLength || 1e3, highlightNonMatching = config && config.highlightNonMatching;
        var marks = [], ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          var match = ranges[i].empty() && findMatchingBracket(cm, ranges[i].head, config);
          if (match && (match.match || highlightNonMatching !== false) && cm.getLine(match.from.line).length <= maxHighlightLen) {
            var style = match.match ? "CodeMirror-matchingbracket" : "CodeMirror-nonmatchingbracket";
            marks.push(cm.markText(match.from, Pos(match.from.line, match.from.ch + 1), { className: style }));
            if (match.to && cm.getLine(match.to.line).length <= maxHighlightLen)
              marks.push(cm.markText(match.to, Pos(match.to.line, match.to.ch + 1), { className: style }));
          }
        }
        if (marks.length) {
          if (ie_lt8 && cm.state.focused)
            cm.focus();
          var clear = function() {
            cm.operation(function() {
              for (var i2 = 0; i2 < marks.length; i2++)
                marks[i2].clear();
            });
          };
          if (autoclear)
            setTimeout(clear, 800);
          else
            return clear;
        }
      }
      function doMatchBrackets(cm) {
        cm.operation(function() {
          if (cm.state.matchBrackets.currentlyHighlighted) {
            cm.state.matchBrackets.currentlyHighlighted();
            cm.state.matchBrackets.currentlyHighlighted = null;
          }
          cm.state.matchBrackets.currentlyHighlighted = matchBrackets(cm, false, cm.state.matchBrackets);
        });
      }
      function clearHighlighted(cm) {
        if (cm.state.matchBrackets && cm.state.matchBrackets.currentlyHighlighted) {
          cm.state.matchBrackets.currentlyHighlighted();
          cm.state.matchBrackets.currentlyHighlighted = null;
        }
      }
      CodeMirror2.defineOption("matchBrackets", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          cm.off("cursorActivity", doMatchBrackets);
          cm.off("focus", doMatchBrackets);
          cm.off("blur", clearHighlighted);
          clearHighlighted(cm);
        }
        if (val) {
          cm.state.matchBrackets = typeof val == "object" ? val : {};
          cm.on("cursorActivity", doMatchBrackets);
          cm.on("focus", doMatchBrackets);
          cm.on("blur", clearHighlighted);
        }
      });
      CodeMirror2.defineExtension("matchBrackets", function() {
        matchBrackets(this, true);
      });
      CodeMirror2.defineExtension("findMatchingBracket", function(pos, config, oldConfig) {
        if (oldConfig || typeof config == "boolean") {
          if (!oldConfig) {
            config = config ? { strict: true } : null;
          } else {
            oldConfig.strict = config;
            config = oldConfig;
          }
        }
        return findMatchingBracket(this, pos, config);
      });
      CodeMirror2.defineExtension("scanForBracket", function(pos, dir, style, config) {
        return scanForBracket(this, pos, dir, style, config);
      });
    });
  }
});

// node_modules/codemirror/addon/edit/closebrackets.js
var require_closebrackets = __commonJS({
  "node_modules/codemirror/addon/edit/closebrackets.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      var defaults = {
        pairs: `()[]{}''""`,
        closeBefore: `)]}'":;>`,
        triples: "",
        explode: "[]{}"
      };
      var Pos = CodeMirror2.Pos;
      CodeMirror2.defineOption("autoCloseBrackets", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          cm.removeKeyMap(keyMap2);
          cm.state.closeBrackets = null;
        }
        if (val) {
          ensureBound(getOption(val, "pairs"));
          cm.state.closeBrackets = val;
          cm.addKeyMap(keyMap2);
        }
      });
      function getOption(conf, name2) {
        if (name2 == "pairs" && typeof conf == "string")
          return conf;
        if (typeof conf == "object" && conf[name2] != null)
          return conf[name2];
        return defaults[name2];
      }
      var keyMap2 = { Backspace: handleBackspace, Enter: handleEnter };
      function ensureBound(chars) {
        for (var i = 0; i < chars.length; i++) {
          var ch = chars.charAt(i), key = "'" + ch + "'";
          if (!keyMap2[key])
            keyMap2[key] = handler(ch);
        }
      }
      ensureBound(defaults.pairs + "`");
      function handler(ch) {
        return function(cm) {
          return handleChar(cm, ch);
        };
      }
      function getConfig(cm) {
        var deflt = cm.state.closeBrackets;
        if (!deflt || deflt.override)
          return deflt;
        var mode = cm.getModeAt(cm.getCursor());
        return mode.closeBrackets || deflt;
      }
      function handleBackspace(cm) {
        var conf = getConfig(cm);
        if (!conf || cm.getOption("disableInput"))
          return CodeMirror2.Pass;
        var pairs = getOption(conf, "pairs");
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty())
            return CodeMirror2.Pass;
          var around = charsAround(cm, ranges[i].head);
          if (!around || pairs.indexOf(around) % 2 != 0)
            return CodeMirror2.Pass;
        }
        for (var i = ranges.length - 1; i >= 0; i--) {
          var cur = ranges[i].head;
          cm.replaceRange("", Pos(cur.line, cur.ch - 1), Pos(cur.line, cur.ch + 1), "+delete");
        }
      }
      function handleEnter(cm) {
        var conf = getConfig(cm);
        var explode = conf && getOption(conf, "explode");
        if (!explode || cm.getOption("disableInput"))
          return CodeMirror2.Pass;
        var ranges = cm.listSelections();
        for (var i = 0; i < ranges.length; i++) {
          if (!ranges[i].empty())
            return CodeMirror2.Pass;
          var around = charsAround(cm, ranges[i].head);
          if (!around || explode.indexOf(around) % 2 != 0)
            return CodeMirror2.Pass;
        }
        cm.operation(function() {
          var linesep = cm.lineSeparator() || "\n";
          cm.replaceSelection(linesep + linesep, null);
          moveSel(cm, -1);
          ranges = cm.listSelections();
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var line = ranges[i2].head.line;
            cm.indentLine(line, null, true);
            cm.indentLine(line + 1, null, true);
          }
        });
      }
      function moveSel(cm, dir) {
        var newRanges = [], ranges = cm.listSelections(), primary = 0;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (range.head == cm.getCursor())
            primary = i;
          var pos = range.head.ch || dir > 0 ? { line: range.head.line, ch: range.head.ch + dir } : { line: range.head.line - 1 };
          newRanges.push({ anchor: pos, head: pos });
        }
        cm.setSelections(newRanges, primary);
      }
      function contractSelection(sel) {
        var inverted = CodeMirror2.cmpPos(sel.anchor, sel.head) > 0;
        return {
          anchor: new Pos(sel.anchor.line, sel.anchor.ch + (inverted ? -1 : 1)),
          head: new Pos(sel.head.line, sel.head.ch + (inverted ? 1 : -1))
        };
      }
      function handleChar(cm, ch) {
        var conf = getConfig(cm);
        if (!conf || cm.getOption("disableInput"))
          return CodeMirror2.Pass;
        var pairs = getOption(conf, "pairs");
        var pos = pairs.indexOf(ch);
        if (pos == -1)
          return CodeMirror2.Pass;
        var closeBefore = getOption(conf, "closeBefore");
        var triples = getOption(conf, "triples");
        var identical = pairs.charAt(pos + 1) == ch;
        var ranges = cm.listSelections();
        var opening = pos % 2 == 0;
        var type2;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], cur = range.head, curType;
          var next = cm.getRange(cur, Pos(cur.line, cur.ch + 1));
          if (opening && !range.empty()) {
            curType = "surround";
          } else if ((identical || !opening) && next == ch) {
            if (identical && stringStartsAfter(cm, cur))
              curType = "both";
            else if (triples.indexOf(ch) >= 0 && cm.getRange(cur, Pos(cur.line, cur.ch + 3)) == ch + ch + ch)
              curType = "skipThree";
            else
              curType = "skip";
          } else if (identical && cur.ch > 1 && triples.indexOf(ch) >= 0 && cm.getRange(Pos(cur.line, cur.ch - 2), cur) == ch + ch) {
            if (cur.ch > 2 && /\bstring/.test(cm.getTokenTypeAt(Pos(cur.line, cur.ch - 2))))
              return CodeMirror2.Pass;
            curType = "addFour";
          } else if (identical) {
            var prev = cur.ch == 0 ? " " : cm.getRange(Pos(cur.line, cur.ch - 1), cur);
            if (!CodeMirror2.isWordChar(next) && prev != ch && !CodeMirror2.isWordChar(prev))
              curType = "both";
            else
              return CodeMirror2.Pass;
          } else if (opening && (next.length === 0 || /\s/.test(next) || closeBefore.indexOf(next) > -1)) {
            curType = "both";
          } else {
            return CodeMirror2.Pass;
          }
          if (!type2)
            type2 = curType;
          else if (type2 != curType)
            return CodeMirror2.Pass;
        }
        var left = pos % 2 ? pairs.charAt(pos - 1) : ch;
        var right = pos % 2 ? ch : pairs.charAt(pos + 1);
        cm.operation(function() {
          if (type2 == "skip") {
            moveSel(cm, 1);
          } else if (type2 == "skipThree") {
            moveSel(cm, 3);
          } else if (type2 == "surround") {
            var sels = cm.getSelections();
            for (var i2 = 0; i2 < sels.length; i2++)
              sels[i2] = left + sels[i2] + right;
            cm.replaceSelections(sels, "around");
            sels = cm.listSelections().slice();
            for (var i2 = 0; i2 < sels.length; i2++)
              sels[i2] = contractSelection(sels[i2]);
            cm.setSelections(sels);
          } else if (type2 == "both") {
            cm.replaceSelection(left + right, null);
            cm.triggerElectric(left + right);
            moveSel(cm, -1);
          } else if (type2 == "addFour") {
            cm.replaceSelection(left + left + left + left, "before");
            moveSel(cm, 1);
          }
        });
      }
      function charsAround(cm, pos) {
        var str = cm.getRange(Pos(pos.line, pos.ch - 1), Pos(pos.line, pos.ch + 1));
        return str.length == 2 ? str : null;
      }
      function stringStartsAfter(cm, pos) {
        var token = cm.getTokenAt(Pos(pos.line, pos.ch + 1));
        return /\bstring/.test(token.type) && token.start == pos.ch && (pos.ch == 0 || !/\bstring/.test(cm.getTokenTypeAt(pos)));
      }
    });
  }
});

// node_modules/codemirror/addon/fold/foldcode.js
var require_foldcode = __commonJS({
  "node_modules/codemirror/addon/fold/foldcode.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      function doFold(cm, pos, options, force) {
        if (options && options.call) {
          var finder = options;
          options = null;
        } else {
          var finder = getOption(cm, options, "rangeFinder");
        }
        if (typeof pos == "number")
          pos = CodeMirror2.Pos(pos, 0);
        var minSize = getOption(cm, options, "minFoldSize");
        function getRange3(allowFolded) {
          var range2 = finder(cm, pos);
          if (!range2 || range2.to.line - range2.from.line < minSize)
            return null;
          if (force === "fold")
            return range2;
          var marks = cm.findMarksAt(range2.from);
          for (var i = 0; i < marks.length; ++i) {
            if (marks[i].__isFold) {
              if (!allowFolded)
                return null;
              range2.cleared = true;
              marks[i].clear();
            }
          }
          return range2;
        }
        var range = getRange3(true);
        if (getOption(cm, options, "scanUp"))
          while (!range && pos.line > cm.firstLine()) {
            pos = CodeMirror2.Pos(pos.line - 1, 0);
            range = getRange3(false);
          }
        if (!range || range.cleared || force === "unfold")
          return;
        var myWidget = makeWidget(cm, options, range);
        CodeMirror2.on(myWidget, "mousedown", function(e) {
          myRange.clear();
          CodeMirror2.e_preventDefault(e);
        });
        var myRange = cm.markText(range.from, range.to, {
          replacedWith: myWidget,
          clearOnEnter: getOption(cm, options, "clearOnEnter"),
          __isFold: true
        });
        myRange.on("clear", function(from, to) {
          CodeMirror2.signal(cm, "unfold", cm, from, to);
        });
        CodeMirror2.signal(cm, "fold", cm, range.from, range.to);
      }
      function makeWidget(cm, options, range) {
        var widget = getOption(cm, options, "widget");
        if (typeof widget == "function") {
          widget = widget(range.from, range.to);
        }
        if (typeof widget == "string") {
          var text2 = document.createTextNode(widget);
          widget = document.createElement("span");
          widget.appendChild(text2);
          widget.className = "CodeMirror-foldmarker";
        } else if (widget) {
          widget = widget.cloneNode(true);
        }
        return widget;
      }
      CodeMirror2.newFoldFunction = function(rangeFinder, widget) {
        return function(cm, pos) {
          doFold(cm, pos, { rangeFinder, widget });
        };
      };
      CodeMirror2.defineExtension("foldCode", function(pos, options, force) {
        doFold(this, pos, options, force);
      });
      CodeMirror2.defineExtension("isFolded", function(pos) {
        var marks = this.findMarksAt(pos);
        for (var i = 0; i < marks.length; ++i)
          if (marks[i].__isFold)
            return true;
      });
      CodeMirror2.commands.toggleFold = function(cm) {
        cm.foldCode(cm.getCursor());
      };
      CodeMirror2.commands.fold = function(cm) {
        cm.foldCode(cm.getCursor(), null, "fold");
      };
      CodeMirror2.commands.unfold = function(cm) {
        cm.foldCode(cm.getCursor(), { scanUp: false }, "unfold");
      };
      CodeMirror2.commands.foldAll = function(cm) {
        cm.operation(function() {
          for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
            cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "fold");
        });
      };
      CodeMirror2.commands.unfoldAll = function(cm) {
        cm.operation(function() {
          for (var i = cm.firstLine(), e = cm.lastLine(); i <= e; i++)
            cm.foldCode(CodeMirror2.Pos(i, 0), { scanUp: false }, "unfold");
        });
      };
      CodeMirror2.registerHelper("fold", "combine", function() {
        var funcs = Array.prototype.slice.call(arguments, 0);
        return function(cm, start) {
          for (var i = 0; i < funcs.length; ++i) {
            var found = funcs[i](cm, start);
            if (found)
              return found;
          }
        };
      });
      CodeMirror2.registerHelper("fold", "auto", function(cm, start) {
        var helpers = cm.getHelpers(start, "fold");
        for (var i = 0; i < helpers.length; i++) {
          var cur = helpers[i](cm, start);
          if (cur)
            return cur;
        }
      });
      var defaultOptions = {
        rangeFinder: CodeMirror2.fold.auto,
        widget: "\u2194",
        minFoldSize: 0,
        scanUp: false,
        clearOnEnter: true
      };
      CodeMirror2.defineOption("foldOptions", null);
      function getOption(cm, options, name2) {
        if (options && options[name2] !== void 0)
          return options[name2];
        var editorOptions = cm.options.foldOptions;
        if (editorOptions && editorOptions[name2] !== void 0)
          return editorOptions[name2];
        return defaultOptions[name2];
      }
      CodeMirror2.defineExtension("foldOption", function(options, name2) {
        return getOption(this, options, name2);
      });
    });
  }
});

// node_modules/codemirror/addon/fold/foldgutter.js
var require_foldgutter = __commonJS({
  "node_modules/codemirror/addon/fold/foldgutter.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror(), require_foldcode());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror", "./foldcode"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineOption("foldGutter", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          cm.clearGutter(cm.state.foldGutter.options.gutter);
          cm.state.foldGutter = null;
          cm.off("gutterClick", onGutterClick);
          cm.off("changes", onChange);
          cm.off("viewportChange", onViewportChange);
          cm.off("fold", onFold);
          cm.off("unfold", onFold);
          cm.off("swapDoc", onChange);
        }
        if (val) {
          cm.state.foldGutter = new State(parseOptions(val));
          updateInViewport(cm);
          cm.on("gutterClick", onGutterClick);
          cm.on("changes", onChange);
          cm.on("viewportChange", onViewportChange);
          cm.on("fold", onFold);
          cm.on("unfold", onFold);
          cm.on("swapDoc", onChange);
        }
      });
      var Pos = CodeMirror2.Pos;
      function State(options) {
        this.options = options;
        this.from = this.to = 0;
      }
      function parseOptions(opts) {
        if (opts === true)
          opts = {};
        if (opts.gutter == null)
          opts.gutter = "CodeMirror-foldgutter";
        if (opts.indicatorOpen == null)
          opts.indicatorOpen = "CodeMirror-foldgutter-open";
        if (opts.indicatorFolded == null)
          opts.indicatorFolded = "CodeMirror-foldgutter-folded";
        return opts;
      }
      function isFolded(cm, line) {
        var marks = cm.findMarks(Pos(line, 0), Pos(line + 1, 0));
        for (var i = 0; i < marks.length; ++i) {
          if (marks[i].__isFold) {
            var fromPos = marks[i].find(-1);
            if (fromPos && fromPos.line === line)
              return marks[i];
          }
        }
      }
      function marker(spec) {
        if (typeof spec == "string") {
          var elt = document.createElement("div");
          elt.className = spec + " CodeMirror-guttermarker-subtle";
          return elt;
        } else {
          return spec.cloneNode(true);
        }
      }
      function updateFoldInfo(cm, from, to) {
        var opts = cm.state.foldGutter.options, cur = from - 1;
        var minSize = cm.foldOption(opts, "minFoldSize");
        var func = cm.foldOption(opts, "rangeFinder");
        var clsFolded = typeof opts.indicatorFolded == "string" && classTest(opts.indicatorFolded);
        var clsOpen = typeof opts.indicatorOpen == "string" && classTest(opts.indicatorOpen);
        cm.eachLine(from, to, function(line) {
          ++cur;
          var mark = null;
          var old = line.gutterMarkers;
          if (old)
            old = old[opts.gutter];
          if (isFolded(cm, cur)) {
            if (clsFolded && old && clsFolded.test(old.className))
              return;
            mark = marker(opts.indicatorFolded);
          } else {
            var pos = Pos(cur, 0);
            var range = func && func(cm, pos);
            if (range && range.to.line - range.from.line >= minSize) {
              if (clsOpen && old && clsOpen.test(old.className))
                return;
              mark = marker(opts.indicatorOpen);
            }
          }
          if (!mark && !old)
            return;
          cm.setGutterMarker(line, opts.gutter, mark);
        });
      }
      function classTest(cls) {
        return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*");
      }
      function updateInViewport(cm) {
        var vp = cm.getViewport(), state = cm.state.foldGutter;
        if (!state)
          return;
        cm.operation(function() {
          updateFoldInfo(cm, vp.from, vp.to);
        });
        state.from = vp.from;
        state.to = vp.to;
      }
      function onGutterClick(cm, line, gutter) {
        var state = cm.state.foldGutter;
        if (!state)
          return;
        var opts = state.options;
        if (gutter != opts.gutter)
          return;
        var folded = isFolded(cm, line);
        if (folded)
          folded.clear();
        else
          cm.foldCode(Pos(line, 0), opts);
      }
      function onChange(cm) {
        var state = cm.state.foldGutter;
        if (!state)
          return;
        var opts = state.options;
        state.from = state.to = 0;
        clearTimeout(state.changeUpdate);
        state.changeUpdate = setTimeout(function() {
          updateInViewport(cm);
        }, opts.foldOnChangeTimeSpan || 600);
      }
      function onViewportChange(cm) {
        var state = cm.state.foldGutter;
        if (!state)
          return;
        var opts = state.options;
        clearTimeout(state.changeUpdate);
        state.changeUpdate = setTimeout(function() {
          var vp = cm.getViewport();
          if (state.from == state.to || vp.from - state.to > 20 || state.from - vp.to > 20) {
            updateInViewport(cm);
          } else {
            cm.operation(function() {
              if (vp.from < state.from) {
                updateFoldInfo(cm, vp.from, state.from);
                state.from = vp.from;
              }
              if (vp.to > state.to) {
                updateFoldInfo(cm, state.to, vp.to);
                state.to = vp.to;
              }
            });
          }
        }, opts.updateViewportTimeSpan || 400);
      }
      function onFold(cm, from) {
        var state = cm.state.foldGutter;
        if (!state)
          return;
        var line = from.line;
        if (line >= state.from && line < state.to)
          updateFoldInfo(cm, line, line + 1);
      }
    });
  }
});

// node_modules/codemirror/addon/fold/brace-fold.js
var require_brace_fold = __commonJS({
  "node_modules/codemirror/addon/fold/brace-fold.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.registerHelper("fold", "brace", function(cm, start) {
        var line = start.line, lineText = cm.getLine(line);
        var tokenType;
        function findOpening(openCh) {
          for (var at = start.ch, pass = 0; ; ) {
            var found = at <= 0 ? -1 : lineText.lastIndexOf(openCh, at - 1);
            if (found == -1) {
              if (pass == 1)
                break;
              pass = 1;
              at = lineText.length;
              continue;
            }
            if (pass == 1 && found < start.ch)
              break;
            tokenType = cm.getTokenTypeAt(CodeMirror2.Pos(line, found + 1));
            if (!/^(comment|string)/.test(tokenType))
              return found + 1;
            at = found - 1;
          }
        }
        var startBrace = findOpening("{"), startBracket = findOpening("[");
        var startToken, endToken, startCh;
        if (startBrace != null && (startBracket == null || startBracket > startBrace)) {
          startCh = startBrace;
          startToken = "{";
          endToken = "}";
        } else if (startBracket != null) {
          startCh = startBracket;
          startToken = "[";
          endToken = "]";
        } else {
          return;
        }
        var count = 1, lastLine = cm.lastLine(), end, endCh;
        outer:
          for (var i = line; i <= lastLine; ++i) {
            var text2 = cm.getLine(i), pos = i == line ? startCh : 0;
            for (; ; ) {
              var nextOpen = text2.indexOf(startToken, pos), nextClose = text2.indexOf(endToken, pos);
              if (nextOpen < 0)
                nextOpen = text2.length;
              if (nextClose < 0)
                nextClose = text2.length;
              pos = Math.min(nextOpen, nextClose);
              if (pos == text2.length)
                break;
              if (cm.getTokenTypeAt(CodeMirror2.Pos(i, pos + 1)) == tokenType) {
                if (pos == nextOpen)
                  ++count;
                else if (!--count) {
                  end = i;
                  endCh = pos;
                  break outer;
                }
              }
              ++pos;
            }
          }
        if (end == null || line == end)
          return;
        return {
          from: CodeMirror2.Pos(line, startCh),
          to: CodeMirror2.Pos(end, endCh)
        };
      });
      CodeMirror2.registerHelper("fold", "import", function(cm, start) {
        function hasImport(line) {
          if (line < cm.firstLine() || line > cm.lastLine())
            return null;
          var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
          if (!/\S/.test(start2.string))
            start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
          if (start2.type != "keyword" || start2.string != "import")
            return null;
          for (var i = line, e = Math.min(cm.lastLine(), line + 10); i <= e; ++i) {
            var text2 = cm.getLine(i), semi = text2.indexOf(";");
            if (semi != -1)
              return { startCh: start2.end, end: CodeMirror2.Pos(i, semi) };
          }
        }
        var startLine = start.line, has = hasImport(startLine), prev;
        if (!has || hasImport(startLine - 1) || (prev = hasImport(startLine - 2)) && prev.end.line == startLine - 1)
          return null;
        for (var end = has.end; ; ) {
          var next = hasImport(end.line + 1);
          if (next == null)
            break;
          end = next.end;
        }
        return { from: cm.clipPos(CodeMirror2.Pos(startLine, has.startCh + 1)), to: end };
      });
      CodeMirror2.registerHelper("fold", "include", function(cm, start) {
        function hasInclude(line) {
          if (line < cm.firstLine() || line > cm.lastLine())
            return null;
          var start2 = cm.getTokenAt(CodeMirror2.Pos(line, 1));
          if (!/\S/.test(start2.string))
            start2 = cm.getTokenAt(CodeMirror2.Pos(line, start2.end + 1));
          if (start2.type == "meta" && start2.string.slice(0, 8) == "#include")
            return start2.start + 8;
        }
        var startLine = start.line, has = hasInclude(startLine);
        if (has == null || hasInclude(startLine - 1) != null)
          return null;
        for (var end = startLine; ; ) {
          var next = hasInclude(end + 1);
          if (next == null)
            break;
          ++end;
        }
        return {
          from: CodeMirror2.Pos(startLine, has + 1),
          to: cm.clipPos(CodeMirror2.Pos(end))
        };
      });
    });
  }
});

// node_modules/codemirror/addon/search/searchcursor.js
var require_searchcursor = __commonJS({
  "node_modules/codemirror/addon/search/searchcursor.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      var Pos = CodeMirror2.Pos;
      function regexpFlags(regexp) {
        var flags = regexp.flags;
        return flags != null ? flags : (regexp.ignoreCase ? "i" : "") + (regexp.global ? "g" : "") + (regexp.multiline ? "m" : "");
      }
      function ensureFlags(regexp, flags) {
        var current = regexpFlags(regexp), target = current;
        for (var i = 0; i < flags.length; i++)
          if (target.indexOf(flags.charAt(i)) == -1)
            target += flags.charAt(i);
        return current == target ? regexp : new RegExp(regexp.source, target);
      }
      function maybeMultiline(regexp) {
        return /\\s|\\n|\n|\\W|\\D|\[\^/.test(regexp.source);
      }
      function searchRegexpForward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {
          regexp.lastIndex = ch;
          var string = doc.getLine(line), match = regexp.exec(string);
          if (match)
            return {
              from: Pos(line, match.index),
              to: Pos(line, match.index + match[0].length),
              match
            };
        }
      }
      function searchRegexpForwardMultiline(doc, regexp, start) {
        if (!maybeMultiline(regexp))
          return searchRegexpForward(doc, regexp, start);
        regexp = ensureFlags(regexp, "gm");
        var string, chunk = 1;
        for (var line = start.line, last = doc.lastLine(); line <= last; ) {
          for (var i = 0; i < chunk; i++) {
            if (line > last)
              break;
            var curLine = doc.getLine(line++);
            string = string == null ? curLine : string + "\n" + curLine;
          }
          chunk = chunk * 2;
          regexp.lastIndex = start.ch;
          var match = regexp.exec(string);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
              match
            };
          }
        }
      }
      function lastMatchIn(string, regexp, endMargin) {
        var match, from = 0;
        while (from <= string.length) {
          regexp.lastIndex = from;
          var newMatch = regexp.exec(string);
          if (!newMatch)
            break;
          var end = newMatch.index + newMatch[0].length;
          if (end > string.length - endMargin)
            break;
          if (!match || end > match.index + match[0].length)
            match = newMatch;
          from = newMatch.index + 1;
        }
        return match;
      }
      function searchRegexpBackward(doc, regexp, start) {
        regexp = ensureFlags(regexp, "g");
        for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {
          var string = doc.getLine(line);
          var match = lastMatchIn(string, regexp, ch < 0 ? 0 : string.length - ch);
          if (match)
            return {
              from: Pos(line, match.index),
              to: Pos(line, match.index + match[0].length),
              match
            };
        }
      }
      function searchRegexpBackwardMultiline(doc, regexp, start) {
        if (!maybeMultiline(regexp))
          return searchRegexpBackward(doc, regexp, start);
        regexp = ensureFlags(regexp, "gm");
        var string, chunkSize = 1, endMargin = doc.getLine(start.line).length - start.ch;
        for (var line = start.line, first = doc.firstLine(); line >= first; ) {
          for (var i = 0; i < chunkSize && line >= first; i++) {
            var curLine = doc.getLine(line--);
            string = string == null ? curLine : curLine + "\n" + string;
          }
          chunkSize *= 2;
          var match = lastMatchIn(string, regexp, endMargin);
          if (match) {
            var before = string.slice(0, match.index).split("\n"), inside = match[0].split("\n");
            var startLine = line + before.length, startCh = before[before.length - 1].length;
            return {
              from: Pos(startLine, startCh),
              to: Pos(startLine + inside.length - 1, inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),
              match
            };
          }
        }
      }
      var doFold, noFold;
      if (String.prototype.normalize) {
        doFold = function(str) {
          return str.normalize("NFD").toLowerCase();
        };
        noFold = function(str) {
          return str.normalize("NFD");
        };
      } else {
        doFold = function(str) {
          return str.toLowerCase();
        };
        noFold = function(str) {
          return str;
        };
      }
      function adjustPos(orig, folded, pos, foldFunc) {
        if (orig.length == folded.length)
          return pos;
        for (var min = 0, max = pos + Math.max(0, orig.length - folded.length); ; ) {
          if (min == max)
            return min;
          var mid = min + max >> 1;
          var len = foldFunc(orig.slice(0, mid)).length;
          if (len == pos)
            return mid;
          else if (len > pos)
            max = mid;
          else
            min = mid + 1;
        }
      }
      function searchStringForward(doc, query, start, caseFold) {
        if (!query.length)
          return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);
        search:
          for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {
            var orig = doc.getLine(line).slice(ch), string = fold(orig);
            if (lines.length == 1) {
              var found = string.indexOf(lines[0]);
              if (found == -1)
                continue search;
              var start = adjustPos(orig, string, found, fold) + ch;
              return {
                from: Pos(line, adjustPos(orig, string, found, fold) + ch),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)
              };
            } else {
              var cutFrom = string.length - lines[0].length;
              if (string.slice(cutFrom) != lines[0])
                continue search;
              for (var i = 1; i < lines.length - 1; i++)
                if (fold(doc.getLine(line + i)) != lines[i])
                  continue search;
              var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1];
              if (endString.slice(0, lastLine.length) != lastLine)
                continue search;
              return {
                from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),
                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))
              };
            }
          }
      }
      function searchStringBackward(doc, query, start, caseFold) {
        if (!query.length)
          return null;
        var fold = caseFold ? doFold : noFold;
        var lines = fold(query).split(/\r|\n\r?/);
        search:
          for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {
            var orig = doc.getLine(line);
            if (ch > -1)
              orig = orig.slice(0, ch);
            var string = fold(orig);
            if (lines.length == 1) {
              var found = string.lastIndexOf(lines[0]);
              if (found == -1)
                continue search;
              return {
                from: Pos(line, adjustPos(orig, string, found, fold)),
                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))
              };
            } else {
              var lastLine = lines[lines.length - 1];
              if (string.slice(0, lastLine.length) != lastLine)
                continue search;
              for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)
                if (fold(doc.getLine(start + i)) != lines[i])
                  continue search;
              var top = doc.getLine(line + 1 - lines.length), topString = fold(top);
              if (topString.slice(topString.length - lines[0].length) != lines[0])
                continue search;
              return {
                from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),
                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))
              };
            }
          }
      }
      function SearchCursor(doc, query, pos, options) {
        this.atOccurrence = false;
        this.afterEmptyMatch = false;
        this.doc = doc;
        pos = pos ? doc.clipPos(pos) : Pos(0, 0);
        this.pos = { from: pos, to: pos };
        var caseFold;
        if (typeof options == "object") {
          caseFold = options.caseFold;
        } else {
          caseFold = options;
          options = null;
        }
        if (typeof query == "string") {
          if (caseFold == null)
            caseFold = false;
          this.matches = function(reverse, pos2) {
            return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos2, caseFold);
          };
        } else {
          query = ensureFlags(query, "gm");
          if (!options || options.multiline !== false)
            this.matches = function(reverse, pos2) {
              return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos2);
            };
          else
            this.matches = function(reverse, pos2) {
              return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos2);
            };
        }
      }
      SearchCursor.prototype = {
        findNext: function() {
          return this.find(false);
        },
        findPrevious: function() {
          return this.find(true);
        },
        find: function(reverse) {
          var head = this.doc.clipPos(reverse ? this.pos.from : this.pos.to);
          if (this.afterEmptyMatch && this.atOccurrence) {
            head = Pos(head.line, head.ch);
            if (reverse) {
              head.ch--;
              if (head.ch < 0) {
                head.line--;
                head.ch = (this.doc.getLine(head.line) || "").length;
              }
            } else {
              head.ch++;
              if (head.ch > (this.doc.getLine(head.line) || "").length) {
                head.ch = 0;
                head.line++;
              }
            }
            if (CodeMirror2.cmpPos(head, this.doc.clipPos(head)) != 0) {
              return this.atOccurrence = false;
            }
          }
          var result = this.matches(reverse, head);
          this.afterEmptyMatch = result && CodeMirror2.cmpPos(result.from, result.to) == 0;
          if (result) {
            this.pos = result;
            this.atOccurrence = true;
            return this.pos.match || true;
          } else {
            var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0);
            this.pos = { from: end, to: end };
            return this.atOccurrence = false;
          }
        },
        from: function() {
          if (this.atOccurrence)
            return this.pos.from;
        },
        to: function() {
          if (this.atOccurrence)
            return this.pos.to;
        },
        replace: function(newText, origin) {
          if (!this.atOccurrence)
            return;
          var lines = CodeMirror2.splitLines(newText);
          this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin);
          this.pos.to = Pos(this.pos.from.line + lines.length - 1, lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0));
        }
      };
      CodeMirror2.defineExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this.doc, query, pos, caseFold);
      });
      CodeMirror2.defineDocExtension("getSearchCursor", function(query, pos, caseFold) {
        return new SearchCursor(this, query, pos, caseFold);
      });
      CodeMirror2.defineExtension("selectMatches", function(query, caseFold) {
        var ranges = [];
        var cur = this.getSearchCursor(query, this.getCursor("from"), caseFold);
        while (cur.findNext()) {
          if (CodeMirror2.cmpPos(cur.to(), this.getCursor("to")) > 0)
            break;
          ranges.push({ anchor: cur.from(), head: cur.to() });
        }
        if (ranges.length)
          this.setSelections(ranges, 0);
      });
    });
  }
});

// node_modules/codemirror/addon/dialog/dialog.js
var require_dialog = __commonJS({
  "node_modules/codemirror/addon/dialog/dialog.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      function dialogDiv(cm, template, bottom) {
        var wrap2 = cm.getWrapperElement();
        var dialog;
        dialog = wrap2.appendChild(document.createElement("div"));
        if (bottom)
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-bottom";
        else
          dialog.className = "CodeMirror-dialog CodeMirror-dialog-top";
        if (typeof template == "string") {
          dialog.innerHTML = template;
        } else {
          dialog.appendChild(template);
        }
        CodeMirror2.addClass(wrap2, "dialog-opened");
        return dialog;
      }
      function closeNotification(cm, newVal) {
        if (cm.state.currentNotificationClose)
          cm.state.currentNotificationClose();
        cm.state.currentNotificationClose = newVal;
      }
      CodeMirror2.defineExtension("openDialog", function(template, callback, options) {
        if (!options)
          options = {};
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options.bottom);
        var closed = false, me = this;
        function close(newVal) {
          if (typeof newVal == "string") {
            inp.value = newVal;
          } else {
            if (closed)
              return;
            closed = true;
            CodeMirror2.rmClass(dialog.parentNode, "dialog-opened");
            dialog.parentNode.removeChild(dialog);
            me.focus();
            if (options.onClose)
              options.onClose(dialog);
          }
        }
        var inp = dialog.getElementsByTagName("input")[0], button;
        if (inp) {
          inp.focus();
          if (options.value) {
            inp.value = options.value;
            if (options.selectValueOnOpen !== false) {
              inp.select();
            }
          }
          if (options.onInput)
            CodeMirror2.on(inp, "input", function(e) {
              options.onInput(e, inp.value, close);
            });
          if (options.onKeyUp)
            CodeMirror2.on(inp, "keyup", function(e) {
              options.onKeyUp(e, inp.value, close);
            });
          CodeMirror2.on(inp, "keydown", function(e) {
            if (options && options.onKeyDown && options.onKeyDown(e, inp.value, close)) {
              return;
            }
            if (e.keyCode == 27 || options.closeOnEnter !== false && e.keyCode == 13) {
              inp.blur();
              CodeMirror2.e_stop(e);
              close();
            }
            if (e.keyCode == 13)
              callback(inp.value, e);
          });
          if (options.closeOnBlur !== false)
            CodeMirror2.on(dialog, "focusout", function(evt) {
              if (evt.relatedTarget !== null)
                close();
            });
        } else if (button = dialog.getElementsByTagName("button")[0]) {
          CodeMirror2.on(button, "click", function() {
            close();
            me.focus();
          });
          if (options.closeOnBlur !== false)
            CodeMirror2.on(button, "blur", close);
          button.focus();
        }
        return close;
      });
      CodeMirror2.defineExtension("openConfirm", function(template, callbacks, options) {
        closeNotification(this, null);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var buttons = dialog.getElementsByTagName("button");
        var closed = false, me = this, blurring = 1;
        function close() {
          if (closed)
            return;
          closed = true;
          CodeMirror2.rmClass(dialog.parentNode, "dialog-opened");
          dialog.parentNode.removeChild(dialog);
          me.focus();
        }
        buttons[0].focus();
        for (var i = 0; i < buttons.length; ++i) {
          var b = buttons[i];
          (function(callback) {
            CodeMirror2.on(b, "click", function(e) {
              CodeMirror2.e_preventDefault(e);
              close();
              if (callback)
                callback(me);
            });
          })(callbacks[i]);
          CodeMirror2.on(b, "blur", function() {
            --blurring;
            setTimeout(function() {
              if (blurring <= 0)
                close();
            }, 200);
          });
          CodeMirror2.on(b, "focus", function() {
            ++blurring;
          });
        }
      });
      CodeMirror2.defineExtension("openNotification", function(template, options) {
        closeNotification(this, close);
        var dialog = dialogDiv(this, template, options && options.bottom);
        var closed = false, doneTimer;
        var duration = options && typeof options.duration !== "undefined" ? options.duration : 5e3;
        function close() {
          if (closed)
            return;
          closed = true;
          clearTimeout(doneTimer);
          CodeMirror2.rmClass(dialog.parentNode, "dialog-opened");
          dialog.parentNode.removeChild(dialog);
        }
        CodeMirror2.on(dialog, "click", function(e) {
          CodeMirror2.e_preventDefault(e);
          close();
        });
        if (duration)
          doneTimer = setTimeout(close, duration);
        return close;
      });
    });
  }
});

// node_modules/codemirror/addon/search/search.js
var require_search = __commonJS({
  "node_modules/codemirror/addon/search/search.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror(), require_searchcursor(), require_dialog());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror", "./searchcursor", "../dialog/dialog"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineOption("search", { bottom: false });
      function searchOverlay(query, caseInsensitive) {
        if (typeof query == "string")
          query = new RegExp(query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), caseInsensitive ? "gi" : "g");
        else if (!query.global)
          query = new RegExp(query.source, query.ignoreCase ? "gi" : "g");
        return { token: function(stream) {
          query.lastIndex = stream.pos;
          var match = query.exec(stream.string);
          if (match && match.index == stream.pos) {
            stream.pos += match[0].length || 1;
            return "searching";
          } else if (match) {
            stream.pos = match.index;
          } else {
            stream.skipToEnd();
          }
        } };
      }
      function SearchState() {
        this.posFrom = this.posTo = this.lastQuery = this.query = null;
        this.overlay = null;
      }
      function getSearchState(cm) {
        return cm.state.search || (cm.state.search = new SearchState());
      }
      function queryCaseInsensitive(query) {
        return typeof query == "string" && query == query.toLowerCase();
      }
      function getSearchCursor(cm, query, pos) {
        return cm.getSearchCursor(query, pos, { caseFold: queryCaseInsensitive(query), multiline: true });
      }
      function persistentDialog(cm, text2, deflt, onEnter, onKeyDown) {
        cm.openDialog(text2, onEnter, {
          value: deflt,
          selectValueOnOpen: true,
          closeOnEnter: false,
          onClose: function() {
            clearSearch(cm);
          },
          onKeyDown,
          bottom: cm.options.search.bottom
        });
      }
      function dialog(cm, text2, shortText, deflt, f) {
        if (cm.openDialog)
          cm.openDialog(text2, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });
        else
          f(prompt(shortText, deflt));
      }
      function confirmDialog(cm, text2, shortText, fs) {
        if (cm.openConfirm)
          cm.openConfirm(text2, fs);
        else if (confirm(shortText))
          fs[0]();
      }
      function parseString(string) {
        return string.replace(/\\([nrt\\])/g, function(match, ch) {
          if (ch == "n")
            return "\n";
          if (ch == "r")
            return "\r";
          if (ch == "t")
            return "	";
          if (ch == "\\")
            return "\\";
          return match;
        });
      }
      function parseQuery(query) {
        var isRE = query.match(/^\/(.*)\/([a-z]*)$/);
        if (isRE) {
          try {
            query = new RegExp(isRE[1], isRE[2].indexOf("i") == -1 ? "" : "i");
          } catch (e) {
          }
        } else {
          query = parseString(query);
        }
        if (typeof query == "string" ? query == "" : query.test(""))
          query = /x^/;
        return query;
      }
      function startSearch(cm, state, query) {
        state.queryText = query;
        state.query = parseQuery(query);
        cm.removeOverlay(state.overlay, queryCaseInsensitive(state.query));
        state.overlay = searchOverlay(state.query, queryCaseInsensitive(state.query));
        cm.addOverlay(state.overlay);
        if (cm.showMatchesOnScrollbar) {
          if (state.annotate) {
            state.annotate.clear();
            state.annotate = null;
          }
          state.annotate = cm.showMatchesOnScrollbar(state.query, queryCaseInsensitive(state.query));
        }
      }
      function doSearch(cm, rev, persistent, immediate) {
        var state = getSearchState(cm);
        if (state.query)
          return findNext(cm, rev);
        var q = cm.getSelection() || state.lastQuery;
        if (q instanceof RegExp && q.source == "x^")
          q = null;
        if (persistent && cm.openDialog) {
          var hiding = null;
          var searchNext = function(query, event) {
            CodeMirror2.e_stop(event);
            if (!query)
              return;
            if (query != state.queryText) {
              startSearch(cm, state, query);
              state.posFrom = state.posTo = cm.getCursor();
            }
            if (hiding)
              hiding.style.opacity = 1;
            findNext(cm, event.shiftKey, function(_, to) {
              var dialog2;
              if (to.line < 3 && document.querySelector && (dialog2 = cm.display.wrapper.querySelector(".CodeMirror-dialog")) && dialog2.getBoundingClientRect().bottom - 4 > cm.cursorCoords(to, "window").top)
                (hiding = dialog2).style.opacity = 0.4;
            });
          };
          persistentDialog(cm, getQueryDialog(cm), q, searchNext, function(event, query) {
            var keyName = CodeMirror2.keyName(event);
            var extra = cm.getOption("extraKeys"), cmd = extra && extra[keyName] || CodeMirror2.keyMap[cm.getOption("keyMap")][keyName];
            if (cmd == "findNext" || cmd == "findPrev" || cmd == "findPersistentNext" || cmd == "findPersistentPrev") {
              CodeMirror2.e_stop(event);
              startSearch(cm, getSearchState(cm), query);
              cm.execCommand(cmd);
            } else if (cmd == "find" || cmd == "findPersistent") {
              CodeMirror2.e_stop(event);
              searchNext(query, event);
            }
          });
          if (immediate && q) {
            startSearch(cm, state, q);
            findNext(cm, rev);
          }
        } else {
          dialog(cm, getQueryDialog(cm), "Search for:", q, function(query) {
            if (query && !state.query)
              cm.operation(function() {
                startSearch(cm, state, query);
                state.posFrom = state.posTo = cm.getCursor();
                findNext(cm, rev);
              });
          });
        }
      }
      function findNext(cm, rev, callback) {
        cm.operation(function() {
          var state = getSearchState(cm);
          var cursor = getSearchCursor(cm, state.query, rev ? state.posFrom : state.posTo);
          if (!cursor.find(rev)) {
            cursor = getSearchCursor(cm, state.query, rev ? CodeMirror2.Pos(cm.lastLine()) : CodeMirror2.Pos(cm.firstLine(), 0));
            if (!cursor.find(rev))
              return;
          }
          cm.setSelection(cursor.from(), cursor.to());
          cm.scrollIntoView({ from: cursor.from(), to: cursor.to() }, 20);
          state.posFrom = cursor.from();
          state.posTo = cursor.to();
          if (callback)
            callback(cursor.from(), cursor.to());
        });
      }
      function clearSearch(cm) {
        cm.operation(function() {
          var state = getSearchState(cm);
          state.lastQuery = state.query;
          if (!state.query)
            return;
          state.query = state.queryText = null;
          cm.removeOverlay(state.overlay);
          if (state.annotate) {
            state.annotate.clear();
            state.annotate = null;
          }
        });
      }
      function el(tag, attrs) {
        var element = tag ? document.createElement(tag) : document.createDocumentFragment();
        for (var key in attrs) {
          element[key] = attrs[key];
        }
        for (var i = 2; i < arguments.length; i++) {
          var child = arguments[i];
          element.appendChild(typeof child == "string" ? document.createTextNode(child) : child);
        }
        return element;
      }
      function getQueryDialog(cm) {
        return el("", null, el("span", { className: "CodeMirror-search-label" }, cm.phrase("Search:")), " ", el("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }), " ", el("span", { style: "color: #888", className: "CodeMirror-search-hint" }, cm.phrase("(Use /re/ syntax for regexp search)")));
      }
      function getReplaceQueryDialog(cm) {
        return el("", null, " ", el("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }), " ", el("span", { style: "color: #888", className: "CodeMirror-search-hint" }, cm.phrase("(Use /re/ syntax for regexp search)")));
      }
      function getReplacementQueryDialog(cm) {
        return el("", null, el("span", { className: "CodeMirror-search-label" }, cm.phrase("With:")), " ", el("input", { type: "text", "style": "width: 10em", className: "CodeMirror-search-field" }));
      }
      function getDoReplaceConfirm(cm) {
        return el("", null, el("span", { className: "CodeMirror-search-label" }, cm.phrase("Replace?")), " ", el("button", {}, cm.phrase("Yes")), " ", el("button", {}, cm.phrase("No")), " ", el("button", {}, cm.phrase("All")), " ", el("button", {}, cm.phrase("Stop")));
      }
      function replaceAll(cm, query, text2) {
        cm.operation(function() {
          for (var cursor = getSearchCursor(cm, query); cursor.findNext(); ) {
            if (typeof query != "string") {
              var match = cm.getRange(cursor.from(), cursor.to()).match(query);
              cursor.replace(text2.replace(/\$(\d)/g, function(_, i) {
                return match[i];
              }));
            } else
              cursor.replace(text2);
          }
        });
      }
      function replace(cm, all) {
        if (cm.getOption("readOnly"))
          return;
        var query = cm.getSelection() || getSearchState(cm).lastQuery;
        var dialogText = all ? cm.phrase("Replace all:") : cm.phrase("Replace:");
        var fragment = el("", null, el("span", { className: "CodeMirror-search-label" }, dialogText), getReplaceQueryDialog(cm));
        dialog(cm, fragment, dialogText, query, function(query2) {
          if (!query2)
            return;
          query2 = parseQuery(query2);
          dialog(cm, getReplacementQueryDialog(cm), cm.phrase("Replace with:"), "", function(text2) {
            text2 = parseString(text2);
            if (all) {
              replaceAll(cm, query2, text2);
            } else {
              clearSearch(cm);
              var cursor = getSearchCursor(cm, query2, cm.getCursor("from"));
              var advance = function() {
                var start = cursor.from(), match;
                if (!(match = cursor.findNext())) {
                  cursor = getSearchCursor(cm, query2);
                  if (!(match = cursor.findNext()) || start && cursor.from().line == start.line && cursor.from().ch == start.ch)
                    return;
                }
                cm.setSelection(cursor.from(), cursor.to());
                cm.scrollIntoView({ from: cursor.from(), to: cursor.to() });
                confirmDialog(cm, getDoReplaceConfirm(cm), cm.phrase("Replace?"), [
                  function() {
                    doReplace(match);
                  },
                  advance,
                  function() {
                    replaceAll(cm, query2, text2);
                  }
                ]);
              };
              var doReplace = function(match) {
                cursor.replace(typeof query2 == "string" ? text2 : text2.replace(/\$(\d)/g, function(_, i) {
                  return match[i];
                }));
                advance();
              };
              advance();
            }
          });
        });
      }
      CodeMirror2.commands.find = function(cm) {
        clearSearch(cm);
        doSearch(cm);
      };
      CodeMirror2.commands.findPersistent = function(cm) {
        clearSearch(cm);
        doSearch(cm, false, true);
      };
      CodeMirror2.commands.findPersistentNext = function(cm) {
        doSearch(cm, false, true, true);
      };
      CodeMirror2.commands.findPersistentPrev = function(cm) {
        doSearch(cm, true, true, true);
      };
      CodeMirror2.commands.findNext = doSearch;
      CodeMirror2.commands.findPrev = function(cm) {
        doSearch(cm, true);
      };
      CodeMirror2.commands.clearSearch = clearSearch;
      CodeMirror2.commands.replace = replace;
      CodeMirror2.commands.replaceAll = function(cm) {
        replace(cm, true);
      };
    });
  }
});

// node_modules/codemirror/addon/search/jump-to-line.js
var require_jump_to_line = __commonJS({
  "node_modules/codemirror/addon/search/jump-to-line.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror(), require_dialog());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror", "../dialog/dialog"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineOption("search", { bottom: false });
      function dialog(cm, text2, shortText, deflt, f) {
        if (cm.openDialog)
          cm.openDialog(text2, f, { value: deflt, selectValueOnOpen: true, bottom: cm.options.search.bottom });
        else
          f(prompt(shortText, deflt));
      }
      function getJumpDialog(cm) {
        return cm.phrase("Jump to line:") + ' <input type="text" style="width: 10em" class="CodeMirror-search-field"/> <span style="color: #888" class="CodeMirror-search-hint">' + cm.phrase("(Use line:column or scroll% syntax)") + "</span>";
      }
      function interpretLine(cm, string) {
        var num = Number(string);
        if (/^[-+]/.test(string))
          return cm.getCursor().line + num;
        else
          return num - 1;
      }
      CodeMirror2.commands.jumpToLine = function(cm) {
        var cur = cm.getCursor();
        dialog(cm, getJumpDialog(cm), cm.phrase("Jump to line:"), cur.line + 1 + ":" + cur.ch, function(posStr) {
          if (!posStr)
            return;
          var match;
          if (match = /^\s*([\+\-]?\d+)\s*\:\s*(\d+)\s*$/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), Number(match[2]));
          } else if (match = /^\s*([\+\-]?\d+(\.\d+)?)\%\s*/.exec(posStr)) {
            var line = Math.round(cm.lineCount() * Number(match[1]) / 100);
            if (/^[-+]/.test(match[1]))
              line = cur.line + line + 1;
            cm.setCursor(line - 1, cur.ch);
          } else if (match = /^\s*\:?\s*([\+\-]?\d+)\s*/.exec(posStr)) {
            cm.setCursor(interpretLine(cm, match[1]), cur.ch);
          }
        });
      };
      CodeMirror2.keyMap["default"]["Alt-G"] = "jumpToLine";
    });
  }
});

// node_modules/codemirror/addon/lint/lint.js
var require_lint = __commonJS({
  "node_modules/codemirror/addon/lint/lint.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      var GUTTER_ID = "CodeMirror-lint-markers";
      var LINT_LINE_ID = "CodeMirror-lint-line-";
      function showTooltip(cm, e, content) {
        var tt = document.createElement("div");
        tt.className = "CodeMirror-lint-tooltip cm-s-" + cm.options.theme;
        tt.appendChild(content.cloneNode(true));
        if (cm.state.lint.options.selfContain)
          cm.getWrapperElement().appendChild(tt);
        else
          document.body.appendChild(tt);
        function position(e2) {
          if (!tt.parentNode)
            return CodeMirror2.off(document, "mousemove", position);
          tt.style.top = Math.max(0, e2.clientY - tt.offsetHeight - 5) + "px";
          tt.style.left = e2.clientX + 5 + "px";
        }
        CodeMirror2.on(document, "mousemove", position);
        position(e);
        if (tt.style.opacity != null)
          tt.style.opacity = 1;
        return tt;
      }
      function rm(elt) {
        if (elt.parentNode)
          elt.parentNode.removeChild(elt);
      }
      function hideTooltip(tt) {
        if (!tt.parentNode)
          return;
        if (tt.style.opacity == null)
          rm(tt);
        tt.style.opacity = 0;
        setTimeout(function() {
          rm(tt);
        }, 600);
      }
      function showTooltipFor(cm, e, content, node) {
        var tooltip = showTooltip(cm, e, content);
        function hide() {
          CodeMirror2.off(node, "mouseout", hide);
          if (tooltip) {
            hideTooltip(tooltip);
            tooltip = null;
          }
        }
        var poll = setInterval(function() {
          if (tooltip)
            for (var n = node; ; n = n.parentNode) {
              if (n && n.nodeType == 11)
                n = n.host;
              if (n == document.body)
                return;
              if (!n) {
                hide();
                break;
              }
            }
          if (!tooltip)
            return clearInterval(poll);
        }, 400);
        CodeMirror2.on(node, "mouseout", hide);
      }
      function LintState(cm, conf, hasGutter) {
        this.marked = [];
        if (conf instanceof Function)
          conf = { getAnnotations: conf };
        if (!conf || conf === true)
          conf = {};
        this.options = {};
        this.linterOptions = conf.options || {};
        for (var prop in defaults)
          this.options[prop] = defaults[prop];
        for (var prop in conf) {
          if (defaults.hasOwnProperty(prop)) {
            if (conf[prop] != null)
              this.options[prop] = conf[prop];
          } else if (!conf.options) {
            this.linterOptions[prop] = conf[prop];
          }
        }
        this.timeout = null;
        this.hasGutter = hasGutter;
        this.onMouseOver = function(e) {
          onMouseOver(cm, e);
        };
        this.waitingFor = 0;
      }
      var defaults = {
        highlightLines: false,
        tooltips: true,
        delay: 500,
        lintOnChange: true,
        getAnnotations: null,
        async: false,
        selfContain: null,
        formatAnnotation: null,
        onUpdateLinting: null
      };
      function clearMarks(cm) {
        var state = cm.state.lint;
        if (state.hasGutter)
          cm.clearGutter(GUTTER_ID);
        if (state.options.highlightLines)
          clearErrorLines(cm);
        for (var i = 0; i < state.marked.length; ++i)
          state.marked[i].clear();
        state.marked.length = 0;
      }
      function clearErrorLines(cm) {
        cm.eachLine(function(line) {
          var has = line.wrapClass && /\bCodeMirror-lint-line-\w+\b/.exec(line.wrapClass);
          if (has)
            cm.removeLineClass(line, "wrap", has[0]);
        });
      }
      function makeMarker(cm, labels, severity, multiple, tooltips) {
        var marker = document.createElement("div"), inner = marker;
        marker.className = "CodeMirror-lint-marker CodeMirror-lint-marker-" + severity;
        if (multiple) {
          inner = marker.appendChild(document.createElement("div"));
          inner.className = "CodeMirror-lint-marker CodeMirror-lint-marker-multiple";
        }
        if (tooltips != false)
          CodeMirror2.on(inner, "mouseover", function(e) {
            showTooltipFor(cm, e, labels, inner);
          });
        return marker;
      }
      function getMaxSeverity(a, b) {
        if (a == "error")
          return a;
        else
          return b;
      }
      function groupByLine(annotations2) {
        var lines = [];
        for (var i = 0; i < annotations2.length; ++i) {
          var ann = annotations2[i], line = ann.from.line;
          (lines[line] || (lines[line] = [])).push(ann);
        }
        return lines;
      }
      function annotationTooltip(ann) {
        var severity = ann.severity;
        if (!severity)
          severity = "error";
        var tip = document.createElement("div");
        tip.className = "CodeMirror-lint-message CodeMirror-lint-message-" + severity;
        if (typeof ann.messageHTML != "undefined") {
          tip.innerHTML = ann.messageHTML;
        } else {
          tip.appendChild(document.createTextNode(ann.message));
        }
        return tip;
      }
      function lintAsync(cm, getAnnotations) {
        var state = cm.state.lint;
        var id = ++state.waitingFor;
        function abort() {
          id = -1;
          cm.off("change", abort);
        }
        cm.on("change", abort);
        getAnnotations(cm.getValue(), function(annotations2, arg2) {
          cm.off("change", abort);
          if (state.waitingFor != id)
            return;
          if (arg2 && annotations2 instanceof CodeMirror2)
            annotations2 = arg2;
          cm.operation(function() {
            updateLinting(cm, annotations2);
          });
        }, state.linterOptions, cm);
      }
      function startLinting(cm) {
        var state = cm.state.lint;
        if (!state)
          return;
        var options = state.options;
        var getAnnotations = options.getAnnotations || cm.getHelper(CodeMirror2.Pos(0, 0), "lint");
        if (!getAnnotations)
          return;
        if (options.async || getAnnotations.async) {
          lintAsync(cm, getAnnotations);
        } else {
          var annotations2 = getAnnotations(cm.getValue(), state.linterOptions, cm);
          if (!annotations2)
            return;
          if (annotations2.then)
            annotations2.then(function(issues) {
              cm.operation(function() {
                updateLinting(cm, issues);
              });
            });
          else
            cm.operation(function() {
              updateLinting(cm, annotations2);
            });
        }
      }
      function updateLinting(cm, annotationsNotSorted) {
        var state = cm.state.lint;
        if (!state)
          return;
        var options = state.options;
        clearMarks(cm);
        var annotations2 = groupByLine(annotationsNotSorted);
        for (var line = 0; line < annotations2.length; ++line) {
          var anns = annotations2[line];
          if (!anns)
            continue;
          var message = [];
          anns = anns.filter(function(item) {
            return message.indexOf(item.message) > -1 ? false : message.push(item.message);
          });
          var maxSeverity = null;
          var tipLabel = state.hasGutter && document.createDocumentFragment();
          for (var i = 0; i < anns.length; ++i) {
            var ann = anns[i];
            var severity = ann.severity;
            if (!severity)
              severity = "error";
            maxSeverity = getMaxSeverity(maxSeverity, severity);
            if (options.formatAnnotation)
              ann = options.formatAnnotation(ann);
            if (state.hasGutter)
              tipLabel.appendChild(annotationTooltip(ann));
            if (ann.to)
              state.marked.push(cm.markText(ann.from, ann.to, {
                className: "CodeMirror-lint-mark CodeMirror-lint-mark-" + severity,
                __annotation: ann
              }));
          }
          if (state.hasGutter)
            cm.setGutterMarker(line, GUTTER_ID, makeMarker(cm, tipLabel, maxSeverity, annotations2[line].length > 1, options.tooltips));
          if (options.highlightLines)
            cm.addLineClass(line, "wrap", LINT_LINE_ID + maxSeverity);
        }
        if (options.onUpdateLinting)
          options.onUpdateLinting(annotationsNotSorted, annotations2, cm);
      }
      function onChange(cm) {
        var state = cm.state.lint;
        if (!state)
          return;
        clearTimeout(state.timeout);
        state.timeout = setTimeout(function() {
          startLinting(cm);
        }, state.options.delay);
      }
      function popupTooltips(cm, annotations2, e) {
        var target = e.target || e.srcElement;
        var tooltip = document.createDocumentFragment();
        for (var i = 0; i < annotations2.length; i++) {
          var ann = annotations2[i];
          tooltip.appendChild(annotationTooltip(ann));
        }
        showTooltipFor(cm, e, tooltip, target);
      }
      function onMouseOver(cm, e) {
        var target = e.target || e.srcElement;
        if (!/\bCodeMirror-lint-mark-/.test(target.className))
          return;
        var box = target.getBoundingClientRect(), x = (box.left + box.right) / 2, y = (box.top + box.bottom) / 2;
        var spans = cm.findMarksAt(cm.coordsChar({ left: x, top: y }, "client"));
        var annotations2 = [];
        for (var i = 0; i < spans.length; ++i) {
          var ann = spans[i].__annotation;
          if (ann)
            annotations2.push(ann);
        }
        if (annotations2.length)
          popupTooltips(cm, annotations2, e);
      }
      CodeMirror2.defineOption("lint", false, function(cm, val, old) {
        if (old && old != CodeMirror2.Init) {
          clearMarks(cm);
          if (cm.state.lint.options.lintOnChange !== false)
            cm.off("change", onChange);
          CodeMirror2.off(cm.getWrapperElement(), "mouseover", cm.state.lint.onMouseOver);
          clearTimeout(cm.state.lint.timeout);
          delete cm.state.lint;
        }
        if (val) {
          var gutters = cm.getOption("gutters"), hasLintGutter = false;
          for (var i = 0; i < gutters.length; ++i)
            if (gutters[i] == GUTTER_ID)
              hasLintGutter = true;
          var state = cm.state.lint = new LintState(cm, val, hasLintGutter);
          if (state.options.lintOnChange)
            cm.on("change", onChange);
          if (state.options.tooltips != false && state.options.tooltips != "gutter")
            CodeMirror2.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
          startLinting(cm);
        }
      });
      CodeMirror2.defineExtension("performLint", function() {
        startLinting(this);
      });
    });
  }
});

// node_modules/codemirror/keymap/sublime.js
var require_sublime = __commonJS({
  "node_modules/codemirror/keymap/sublime.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror(), require_searchcursor(), require_matchbrackets());
      else if (typeof define == "function" && define.amd)
        define(["../lib/codemirror", "../addon/search/searchcursor", "../addon/edit/matchbrackets"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      var cmds = CodeMirror2.commands;
      var Pos = CodeMirror2.Pos;
      function findPosSubword(doc, start, dir) {
        if (dir < 0 && start.ch == 0)
          return doc.clipPos(Pos(start.line - 1));
        var line = doc.getLine(start.line);
        if (dir > 0 && start.ch >= line.length)
          return doc.clipPos(Pos(start.line + 1, 0));
        var state = "start", type2, startPos = start.ch;
        for (var pos = startPos, e = dir < 0 ? 0 : line.length, i = 0; pos != e; pos += dir, i++) {
          var next = line.charAt(dir < 0 ? pos - 1 : pos);
          var cat = next != "_" && CodeMirror2.isWordChar(next) ? "w" : "o";
          if (cat == "w" && next.toUpperCase() == next)
            cat = "W";
          if (state == "start") {
            if (cat != "o") {
              state = "in";
              type2 = cat;
            } else
              startPos = pos + dir;
          } else if (state == "in") {
            if (type2 != cat) {
              if (type2 == "w" && cat == "W" && dir < 0)
                pos--;
              if (type2 == "W" && cat == "w" && dir > 0) {
                if (pos == startPos + 1) {
                  type2 = "w";
                  continue;
                } else
                  pos--;
              }
              break;
            }
          }
        }
        return Pos(start.line, pos);
      }
      function moveSubword(cm, dir) {
        cm.extendSelectionsBy(function(range) {
          if (cm.display.shift || cm.doc.extend || range.empty())
            return findPosSubword(cm.doc, range.head, dir);
          else
            return dir < 0 ? range.from() : range.to();
        });
      }
      cmds.goSubwordLeft = function(cm) {
        moveSubword(cm, -1);
      };
      cmds.goSubwordRight = function(cm) {
        moveSubword(cm, 1);
      };
      cmds.scrollLineUp = function(cm) {
        var info = cm.getScrollInfo();
        if (!cm.somethingSelected()) {
          var visibleBottomLine = cm.lineAtHeight(info.top + info.clientHeight, "local");
          if (cm.getCursor().line >= visibleBottomLine)
            cm.execCommand("goLineUp");
        }
        cm.scrollTo(null, info.top - cm.defaultTextHeight());
      };
      cmds.scrollLineDown = function(cm) {
        var info = cm.getScrollInfo();
        if (!cm.somethingSelected()) {
          var visibleTopLine = cm.lineAtHeight(info.top, "local") + 1;
          if (cm.getCursor().line <= visibleTopLine)
            cm.execCommand("goLineDown");
        }
        cm.scrollTo(null, info.top + cm.defaultTextHeight());
      };
      cmds.splitSelectionByLine = function(cm) {
        var ranges = cm.listSelections(), lineRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(), to = ranges[i].to();
          for (var line = from.line; line <= to.line; ++line)
            if (!(to.line > from.line && line == to.line && to.ch == 0))
              lineRanges.push({
                anchor: line == from.line ? from : Pos(line, 0),
                head: line == to.line ? to : Pos(line)
              });
        }
        cm.setSelections(lineRanges, 0);
      };
      cmds.singleSelectionTop = function(cm) {
        var range = cm.listSelections()[0];
        cm.setSelection(range.anchor, range.head, { scroll: false });
      };
      cmds.selectLine = function(cm) {
        var ranges = cm.listSelections(), extended = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          extended.push({
            anchor: Pos(range.from().line, 0),
            head: Pos(range.to().line + 1, 0)
          });
        }
        cm.setSelections(extended);
      };
      function insertLine(cm, above) {
        if (cm.isReadOnly())
          return CodeMirror2.Pass;
        cm.operation(function() {
          var len = cm.listSelections().length, newSelection = [], last = -1;
          for (var i = 0; i < len; i++) {
            var head = cm.listSelections()[i].head;
            if (head.line <= last)
              continue;
            var at = Pos(head.line + (above ? 0 : 1), 0);
            cm.replaceRange("\n", at, null, "+insertLine");
            cm.indentLine(at.line, null, true);
            newSelection.push({ head: at, anchor: at });
            last = head.line + 1;
          }
          cm.setSelections(newSelection);
        });
        cm.execCommand("indentAuto");
      }
      cmds.insertLineAfter = function(cm) {
        return insertLine(cm, false);
      };
      cmds.insertLineBefore = function(cm) {
        return insertLine(cm, true);
      };
      function wordAt(cm, pos) {
        var start = pos.ch, end = start, line = cm.getLine(pos.line);
        while (start && CodeMirror2.isWordChar(line.charAt(start - 1)))
          --start;
        while (end < line.length && CodeMirror2.isWordChar(line.charAt(end)))
          ++end;
        return { from: Pos(pos.line, start), to: Pos(pos.line, end), word: line.slice(start, end) };
      }
      cmds.selectNextOccurrence = function(cm) {
        var from = cm.getCursor("from"), to = cm.getCursor("to");
        var fullWord = cm.state.sublimeFindFullWord == cm.doc.sel;
        if (CodeMirror2.cmpPos(from, to) == 0) {
          var word2 = wordAt(cm, from);
          if (!word2.word)
            return;
          cm.setSelection(word2.from, word2.to);
          fullWord = true;
        } else {
          var text2 = cm.getRange(from, to);
          var query = fullWord ? new RegExp("\\b" + text2 + "\\b") : text2;
          var cur = cm.getSearchCursor(query, to);
          var found = cur.findNext();
          if (!found) {
            cur = cm.getSearchCursor(query, Pos(cm.firstLine(), 0));
            found = cur.findNext();
          }
          if (!found || isSelectedRange(cm.listSelections(), cur.from(), cur.to()))
            return;
          cm.addSelection(cur.from(), cur.to());
        }
        if (fullWord)
          cm.state.sublimeFindFullWord = cm.doc.sel;
      };
      cmds.skipAndSelectNextOccurrence = function(cm) {
        var prevAnchor = cm.getCursor("anchor"), prevHead = cm.getCursor("head");
        cmds.selectNextOccurrence(cm);
        if (CodeMirror2.cmpPos(prevAnchor, prevHead) != 0) {
          cm.doc.setSelections(cm.doc.listSelections().filter(function(sel) {
            return sel.anchor != prevAnchor || sel.head != prevHead;
          }));
        }
      };
      function addCursorToSelection(cm, dir) {
        var ranges = cm.listSelections(), newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          var newAnchor = cm.findPosV(range.anchor, dir, "line", range.anchor.goalColumn);
          var newHead = cm.findPosV(range.head, dir, "line", range.head.goalColumn);
          newAnchor.goalColumn = range.anchor.goalColumn != null ? range.anchor.goalColumn : cm.cursorCoords(range.anchor, "div").left;
          newHead.goalColumn = range.head.goalColumn != null ? range.head.goalColumn : cm.cursorCoords(range.head, "div").left;
          var newRange = { anchor: newAnchor, head: newHead };
          newRanges.push(range);
          newRanges.push(newRange);
        }
        cm.setSelections(newRanges);
      }
      cmds.addCursorToPrevLine = function(cm) {
        addCursorToSelection(cm, -1);
      };
      cmds.addCursorToNextLine = function(cm) {
        addCursorToSelection(cm, 1);
      };
      function isSelectedRange(ranges, from, to) {
        for (var i = 0; i < ranges.length; i++)
          if (CodeMirror2.cmpPos(ranges[i].from(), from) == 0 && CodeMirror2.cmpPos(ranges[i].to(), to) == 0)
            return true;
        return false;
      }
      var mirror = "(){}[]";
      function selectBetweenBrackets(cm) {
        var ranges = cm.listSelections(), newRanges = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], pos = range.head, opening = cm.scanForBracket(pos, -1);
          if (!opening)
            return false;
          for (; ; ) {
            var closing = cm.scanForBracket(pos, 1);
            if (!closing)
              return false;
            if (closing.ch == mirror.charAt(mirror.indexOf(opening.ch) + 1)) {
              var startPos = Pos(opening.pos.line, opening.pos.ch + 1);
              if (CodeMirror2.cmpPos(startPos, range.from()) == 0 && CodeMirror2.cmpPos(closing.pos, range.to()) == 0) {
                opening = cm.scanForBracket(opening.pos, -1);
                if (!opening)
                  return false;
              } else {
                newRanges.push({ anchor: startPos, head: closing.pos });
                break;
              }
            }
            pos = Pos(closing.pos.line, closing.pos.ch + 1);
          }
        }
        cm.setSelections(newRanges);
        return true;
      }
      cmds.selectScope = function(cm) {
        selectBetweenBrackets(cm) || cm.execCommand("selectAll");
      };
      cmds.selectBetweenBrackets = function(cm) {
        if (!selectBetweenBrackets(cm))
          return CodeMirror2.Pass;
      };
      function puncType(type2) {
        return !type2 ? null : /\bpunctuation\b/.test(type2) ? type2 : void 0;
      }
      cmds.goToBracket = function(cm) {
        cm.extendSelectionsBy(function(range) {
          var next = cm.scanForBracket(range.head, 1, puncType(cm.getTokenTypeAt(range.head)));
          if (next && CodeMirror2.cmpPos(next.pos, range.head) != 0)
            return next.pos;
          var prev = cm.scanForBracket(range.head, -1, puncType(cm.getTokenTypeAt(Pos(range.head.line, range.head.ch + 1))));
          return prev && Pos(prev.pos.line, prev.pos.ch + 1) || range.head;
        });
      };
      cmds.swapLineUp = function(cm) {
        if (cm.isReadOnly())
          return CodeMirror2.Pass;
        var ranges = cm.listSelections(), linesToMove = [], at = cm.firstLine() - 1, newSels = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], from = range.from().line - 1, to = range.to().line;
          newSels.push({
            anchor: Pos(range.anchor.line - 1, range.anchor.ch),
            head: Pos(range.head.line - 1, range.head.ch)
          });
          if (range.to().ch == 0 && !range.empty())
            --to;
          if (from > at)
            linesToMove.push(from, to);
          else if (linesToMove.length)
            linesToMove[linesToMove.length - 1] = to;
          at = to;
        }
        cm.operation(function() {
          for (var i2 = 0; i2 < linesToMove.length; i2 += 2) {
            var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];
            var line = cm.getLine(from2);
            cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");
            if (to2 > cm.lastLine())
              cm.replaceRange("\n" + line, Pos(cm.lastLine()), null, "+swapLine");
            else
              cm.replaceRange(line + "\n", Pos(to2, 0), null, "+swapLine");
          }
          cm.setSelections(newSels);
          cm.scrollIntoView();
        });
      };
      cmds.swapLineDown = function(cm) {
        if (cm.isReadOnly())
          return CodeMirror2.Pass;
        var ranges = cm.listSelections(), linesToMove = [], at = cm.lastLine() + 1;
        for (var i = ranges.length - 1; i >= 0; i--) {
          var range = ranges[i], from = range.to().line + 1, to = range.from().line;
          if (range.to().ch == 0 && !range.empty())
            from--;
          if (from < at)
            linesToMove.push(from, to);
          else if (linesToMove.length)
            linesToMove[linesToMove.length - 1] = to;
          at = to;
        }
        cm.operation(function() {
          for (var i2 = linesToMove.length - 2; i2 >= 0; i2 -= 2) {
            var from2 = linesToMove[i2], to2 = linesToMove[i2 + 1];
            var line = cm.getLine(from2);
            if (from2 == cm.lastLine())
              cm.replaceRange("", Pos(from2 - 1), Pos(from2), "+swapLine");
            else
              cm.replaceRange("", Pos(from2, 0), Pos(from2 + 1, 0), "+swapLine");
            cm.replaceRange(line + "\n", Pos(to2, 0), null, "+swapLine");
          }
          cm.scrollIntoView();
        });
      };
      cmds.toggleCommentIndented = function(cm) {
        cm.toggleComment({ indent: true });
      };
      cmds.joinLines = function(cm) {
        var ranges = cm.listSelections(), joined = [];
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i], from = range.from();
          var start = from.line, end = range.to().line;
          while (i < ranges.length - 1 && ranges[i + 1].from().line == end)
            end = ranges[++i].to().line;
          joined.push({ start, end, anchor: !range.empty() && from });
        }
        cm.operation(function() {
          var offset = 0, ranges2 = [];
          for (var i2 = 0; i2 < joined.length; i2++) {
            var obj = joined[i2];
            var anchor = obj.anchor && Pos(obj.anchor.line - offset, obj.anchor.ch), head;
            for (var line = obj.start; line <= obj.end; line++) {
              var actual = line - offset;
              if (line == obj.end)
                head = Pos(actual, cm.getLine(actual).length + 1);
              if (actual < cm.lastLine()) {
                cm.replaceRange(" ", Pos(actual), Pos(actual + 1, /^\s*/.exec(cm.getLine(actual + 1))[0].length));
                ++offset;
              }
            }
            ranges2.push({ anchor: anchor || head, head });
          }
          cm.setSelections(ranges2, 0);
        });
      };
      cmds.duplicateLine = function(cm) {
        cm.operation(function() {
          var rangeCount = cm.listSelections().length;
          for (var i = 0; i < rangeCount; i++) {
            var range = cm.listSelections()[i];
            if (range.empty())
              cm.replaceRange(cm.getLine(range.head.line) + "\n", Pos(range.head.line, 0));
            else
              cm.replaceRange(cm.getRange(range.from(), range.to()), range.from());
          }
          cm.scrollIntoView();
        });
      };
      function sortLines(cm, caseSensitive, direction) {
        if (cm.isReadOnly())
          return CodeMirror2.Pass;
        var ranges = cm.listSelections(), toSort = [], selected;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (range.empty())
            continue;
          var from = range.from().line, to = range.to().line;
          while (i < ranges.length - 1 && ranges[i + 1].from().line == to)
            to = ranges[++i].to().line;
          if (!ranges[i].to().ch)
            to--;
          toSort.push(from, to);
        }
        if (toSort.length)
          selected = true;
        else
          toSort.push(cm.firstLine(), cm.lastLine());
        cm.operation(function() {
          var ranges2 = [];
          for (var i2 = 0; i2 < toSort.length; i2 += 2) {
            var from2 = toSort[i2], to2 = toSort[i2 + 1];
            var start = Pos(from2, 0), end = Pos(to2);
            var lines = cm.getRange(start, end, false);
            if (caseSensitive)
              lines.sort(function(a, b) {
                return a < b ? -direction : a == b ? 0 : direction;
              });
            else
              lines.sort(function(a, b) {
                var au = a.toUpperCase(), bu = b.toUpperCase();
                if (au != bu) {
                  a = au;
                  b = bu;
                }
                return a < b ? -direction : a == b ? 0 : direction;
              });
            cm.replaceRange(lines, start, end);
            if (selected)
              ranges2.push({ anchor: start, head: Pos(to2 + 1, 0) });
          }
          if (selected)
            cm.setSelections(ranges2, 0);
        });
      }
      cmds.sortLines = function(cm) {
        sortLines(cm, true, 1);
      };
      cmds.reverseSortLines = function(cm) {
        sortLines(cm, true, -1);
      };
      cmds.sortLinesInsensitive = function(cm) {
        sortLines(cm, false, 1);
      };
      cmds.reverseSortLinesInsensitive = function(cm) {
        sortLines(cm, false, -1);
      };
      cmds.nextBookmark = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks)
          while (marks.length) {
            var current = marks.shift();
            var found = current.find();
            if (found) {
              marks.push(current);
              return cm.setSelection(found.from, found.to);
            }
          }
      };
      cmds.prevBookmark = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks)
          while (marks.length) {
            marks.unshift(marks.pop());
            var found = marks[marks.length - 1].find();
            if (!found)
              marks.pop();
            else
              return cm.setSelection(found.from, found.to);
          }
      };
      cmds.toggleBookmark = function(cm) {
        var ranges = cm.listSelections();
        var marks = cm.state.sublimeBookmarks || (cm.state.sublimeBookmarks = []);
        for (var i = 0; i < ranges.length; i++) {
          var from = ranges[i].from(), to = ranges[i].to();
          var found = ranges[i].empty() ? cm.findMarksAt(from) : cm.findMarks(from, to);
          for (var j = 0; j < found.length; j++) {
            if (found[j].sublimeBookmark) {
              found[j].clear();
              for (var k = 0; k < marks.length; k++)
                if (marks[k] == found[j])
                  marks.splice(k--, 1);
              break;
            }
          }
          if (j == found.length)
            marks.push(cm.markText(from, to, { sublimeBookmark: true, clearWhenEmpty: false }));
        }
      };
      cmds.clearBookmarks = function(cm) {
        var marks = cm.state.sublimeBookmarks;
        if (marks)
          for (var i = 0; i < marks.length; i++)
            marks[i].clear();
        marks.length = 0;
      };
      cmds.selectBookmarks = function(cm) {
        var marks = cm.state.sublimeBookmarks, ranges = [];
        if (marks)
          for (var i = 0; i < marks.length; i++) {
            var found = marks[i].find();
            if (!found)
              marks.splice(i--, 0);
            else
              ranges.push({ anchor: found.from, head: found.to });
          }
        if (ranges.length)
          cm.setSelections(ranges, 0);
      };
      function modifyWordOrSelection(cm, mod) {
        cm.operation(function() {
          var ranges = cm.listSelections(), indices = [], replacements = [];
          for (var i = 0; i < ranges.length; i++) {
            var range = ranges[i];
            if (range.empty()) {
              indices.push(i);
              replacements.push("");
            } else
              replacements.push(mod(cm.getRange(range.from(), range.to())));
          }
          cm.replaceSelections(replacements, "around", "case");
          for (var i = indices.length - 1, at; i >= 0; i--) {
            var range = ranges[indices[i]];
            if (at && CodeMirror2.cmpPos(range.head, at) > 0)
              continue;
            var word2 = wordAt(cm, range.head);
            at = word2.from;
            cm.replaceRange(mod(word2.word), word2.from, word2.to);
          }
        });
      }
      cmds.smartBackspace = function(cm) {
        if (cm.somethingSelected())
          return CodeMirror2.Pass;
        cm.operation(function() {
          var cursors = cm.listSelections();
          var indentUnit = cm.getOption("indentUnit");
          for (var i = cursors.length - 1; i >= 0; i--) {
            var cursor = cursors[i].head;
            var toStartOfLine = cm.getRange({ line: cursor.line, ch: 0 }, cursor);
            var column = CodeMirror2.countColumn(toStartOfLine, null, cm.getOption("tabSize"));
            var deletePos = cm.findPosH(cursor, -1, "char", false);
            if (toStartOfLine && !/\S/.test(toStartOfLine) && column % indentUnit == 0) {
              var prevIndent = new Pos(cursor.line, CodeMirror2.findColumn(toStartOfLine, column - indentUnit, indentUnit));
              if (prevIndent.ch != cursor.ch)
                deletePos = prevIndent;
            }
            cm.replaceRange("", deletePos, cursor, "+delete");
          }
        });
      };
      cmds.delLineRight = function(cm) {
        cm.operation(function() {
          var ranges = cm.listSelections();
          for (var i = ranges.length - 1; i >= 0; i--)
            cm.replaceRange("", ranges[i].anchor, Pos(ranges[i].to().line), "+delete");
          cm.scrollIntoView();
        });
      };
      cmds.upcaseAtCursor = function(cm) {
        modifyWordOrSelection(cm, function(str) {
          return str.toUpperCase();
        });
      };
      cmds.downcaseAtCursor = function(cm) {
        modifyWordOrSelection(cm, function(str) {
          return str.toLowerCase();
        });
      };
      cmds.setSublimeMark = function(cm) {
        if (cm.state.sublimeMark)
          cm.state.sublimeMark.clear();
        cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
      };
      cmds.selectToSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found)
          cm.setSelection(cm.getCursor(), found);
      };
      cmds.deleteToSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) {
          var from = cm.getCursor(), to = found;
          if (CodeMirror2.cmpPos(from, to) > 0) {
            var tmp = to;
            to = from;
            from = tmp;
          }
          cm.state.sublimeKilled = cm.getRange(from, to);
          cm.replaceRange("", from, to);
        }
      };
      cmds.swapWithSublimeMark = function(cm) {
        var found = cm.state.sublimeMark && cm.state.sublimeMark.find();
        if (found) {
          cm.state.sublimeMark.clear();
          cm.state.sublimeMark = cm.setBookmark(cm.getCursor());
          cm.setCursor(found);
        }
      };
      cmds.sublimeYank = function(cm) {
        if (cm.state.sublimeKilled != null)
          cm.replaceSelection(cm.state.sublimeKilled, null, "paste");
      };
      cmds.showInCenter = function(cm) {
        var pos = cm.cursorCoords(null, "local");
        cm.scrollTo(null, (pos.top + pos.bottom) / 2 - cm.getScrollInfo().clientHeight / 2);
      };
      function getTarget(cm) {
        var from = cm.getCursor("from"), to = cm.getCursor("to");
        if (CodeMirror2.cmpPos(from, to) == 0) {
          var word2 = wordAt(cm, from);
          if (!word2.word)
            return;
          from = word2.from;
          to = word2.to;
        }
        return { from, to, query: cm.getRange(from, to), word: word2 };
      }
      function findAndGoTo(cm, forward) {
        var target = getTarget(cm);
        if (!target)
          return;
        var query = target.query;
        var cur = cm.getSearchCursor(query, forward ? target.to : target.from);
        if (forward ? cur.findNext() : cur.findPrevious()) {
          cm.setSelection(cur.from(), cur.to());
        } else {
          cur = cm.getSearchCursor(query, forward ? Pos(cm.firstLine(), 0) : cm.clipPos(Pos(cm.lastLine())));
          if (forward ? cur.findNext() : cur.findPrevious())
            cm.setSelection(cur.from(), cur.to());
          else if (target.word)
            cm.setSelection(target.from, target.to);
        }
      }
      ;
      cmds.findUnder = function(cm) {
        findAndGoTo(cm, true);
      };
      cmds.findUnderPrevious = function(cm) {
        findAndGoTo(cm, false);
      };
      cmds.findAllUnder = function(cm) {
        var target = getTarget(cm);
        if (!target)
          return;
        var cur = cm.getSearchCursor(target.query);
        var matches = [];
        var primaryIndex = -1;
        while (cur.findNext()) {
          matches.push({ anchor: cur.from(), head: cur.to() });
          if (cur.from().line <= target.from.line && cur.from().ch <= target.from.ch)
            primaryIndex++;
        }
        cm.setSelections(matches, primaryIndex);
      };
      var keyMap2 = CodeMirror2.keyMap;
      keyMap2.macSublime = {
        "Cmd-Left": "goLineStartSmart",
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-Left": "goSubwordLeft",
        "Ctrl-Right": "goSubwordRight",
        "Ctrl-Alt-Up": "scrollLineUp",
        "Ctrl-Alt-Down": "scrollLineDown",
        "Cmd-L": "selectLine",
        "Shift-Cmd-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Cmd-Enter": "insertLineAfter",
        "Shift-Cmd-Enter": "insertLineBefore",
        "Cmd-D": "selectNextOccurrence",
        "Shift-Cmd-Space": "selectScope",
        "Shift-Cmd-M": "selectBetweenBrackets",
        "Cmd-M": "goToBracket",
        "Cmd-Ctrl-Up": "swapLineUp",
        "Cmd-Ctrl-Down": "swapLineDown",
        "Cmd-/": "toggleCommentIndented",
        "Cmd-J": "joinLines",
        "Shift-Cmd-D": "duplicateLine",
        "F5": "sortLines",
        "Shift-F5": "reverseSortLines",
        "Cmd-F5": "sortLinesInsensitive",
        "Shift-Cmd-F5": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Cmd-F2": "toggleBookmark",
        "Shift-Cmd-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Cmd-K Cmd-D": "skipAndSelectNextOccurrence",
        "Cmd-K Cmd-K": "delLineRight",
        "Cmd-K Cmd-U": "upcaseAtCursor",
        "Cmd-K Cmd-L": "downcaseAtCursor",
        "Cmd-K Cmd-Space": "setSublimeMark",
        "Cmd-K Cmd-A": "selectToSublimeMark",
        "Cmd-K Cmd-W": "deleteToSublimeMark",
        "Cmd-K Cmd-X": "swapWithSublimeMark",
        "Cmd-K Cmd-Y": "sublimeYank",
        "Cmd-K Cmd-C": "showInCenter",
        "Cmd-K Cmd-G": "clearBookmarks",
        "Cmd-K Cmd-Backspace": "delLineLeft",
        "Cmd-K Cmd-1": "foldAll",
        "Cmd-K Cmd-0": "unfoldAll",
        "Cmd-K Cmd-J": "unfoldAll",
        "Ctrl-Shift-Up": "addCursorToPrevLine",
        "Ctrl-Shift-Down": "addCursorToNextLine",
        "Cmd-F3": "findUnder",
        "Shift-Cmd-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Cmd-[": "fold",
        "Shift-Cmd-]": "unfold",
        "Cmd-I": "findIncremental",
        "Shift-Cmd-I": "findIncrementalReverse",
        "Cmd-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "macDefault"
      };
      CodeMirror2.normalizeKeyMap(keyMap2.macSublime);
      keyMap2.pcSublime = {
        "Shift-Tab": "indentLess",
        "Shift-Ctrl-K": "deleteLine",
        "Alt-Q": "wrapLines",
        "Ctrl-T": "transposeChars",
        "Alt-Left": "goSubwordLeft",
        "Alt-Right": "goSubwordRight",
        "Ctrl-Up": "scrollLineUp",
        "Ctrl-Down": "scrollLineDown",
        "Ctrl-L": "selectLine",
        "Shift-Ctrl-L": "splitSelectionByLine",
        "Esc": "singleSelectionTop",
        "Ctrl-Enter": "insertLineAfter",
        "Shift-Ctrl-Enter": "insertLineBefore",
        "Ctrl-D": "selectNextOccurrence",
        "Shift-Ctrl-Space": "selectScope",
        "Shift-Ctrl-M": "selectBetweenBrackets",
        "Ctrl-M": "goToBracket",
        "Shift-Ctrl-Up": "swapLineUp",
        "Shift-Ctrl-Down": "swapLineDown",
        "Ctrl-/": "toggleCommentIndented",
        "Ctrl-J": "joinLines",
        "Shift-Ctrl-D": "duplicateLine",
        "F9": "sortLines",
        "Shift-F9": "reverseSortLines",
        "Ctrl-F9": "sortLinesInsensitive",
        "Shift-Ctrl-F9": "reverseSortLinesInsensitive",
        "F2": "nextBookmark",
        "Shift-F2": "prevBookmark",
        "Ctrl-F2": "toggleBookmark",
        "Shift-Ctrl-F2": "clearBookmarks",
        "Alt-F2": "selectBookmarks",
        "Backspace": "smartBackspace",
        "Ctrl-K Ctrl-D": "skipAndSelectNextOccurrence",
        "Ctrl-K Ctrl-K": "delLineRight",
        "Ctrl-K Ctrl-U": "upcaseAtCursor",
        "Ctrl-K Ctrl-L": "downcaseAtCursor",
        "Ctrl-K Ctrl-Space": "setSublimeMark",
        "Ctrl-K Ctrl-A": "selectToSublimeMark",
        "Ctrl-K Ctrl-W": "deleteToSublimeMark",
        "Ctrl-K Ctrl-X": "swapWithSublimeMark",
        "Ctrl-K Ctrl-Y": "sublimeYank",
        "Ctrl-K Ctrl-C": "showInCenter",
        "Ctrl-K Ctrl-G": "clearBookmarks",
        "Ctrl-K Ctrl-Backspace": "delLineLeft",
        "Ctrl-K Ctrl-1": "foldAll",
        "Ctrl-K Ctrl-0": "unfoldAll",
        "Ctrl-K Ctrl-J": "unfoldAll",
        "Ctrl-Alt-Up": "addCursorToPrevLine",
        "Ctrl-Alt-Down": "addCursorToNextLine",
        "Ctrl-F3": "findUnder",
        "Shift-Ctrl-F3": "findUnderPrevious",
        "Alt-F3": "findAllUnder",
        "Shift-Ctrl-[": "fold",
        "Shift-Ctrl-]": "unfold",
        "Ctrl-I": "findIncremental",
        "Shift-Ctrl-I": "findIncrementalReverse",
        "Ctrl-H": "replace",
        "F3": "findNext",
        "Shift-F3": "findPrev",
        "fallthrough": "pcDefault"
      };
      CodeMirror2.normalizeKeyMap(keyMap2.pcSublime);
      var mac = keyMap2.default == keyMap2.macDefault;
      keyMap2.sublime = mac ? keyMap2.macSublime : keyMap2.pcSublime;
    });
  }
});

// node_modules/graphql-language-service-interface/esm/autocompleteUtils.js
function getDefinitionState(tokenState) {
  let definitionState;
  forEachState(tokenState, (state) => {
    switch (state.kind) {
      case "Query":
      case "ShortQuery":
      case "Mutation":
      case "Subscription":
      case "FragmentDefinition":
        definitionState = state;
        break;
    }
  });
  return definitionState;
}
function getFieldDef3(schema, type2, fieldName) {
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
    return SchemaMetaFieldDef;
  }
  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type2) {
    return TypeMetaFieldDef;
  }
  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type2)) {
    return TypeNameMetaFieldDef;
  }
  if ("getFields" in type2) {
    return type2.getFields()[fieldName];
  }
  return null;
}
function forEachState(stack, fn) {
  const reverseStateStack = [];
  let state = stack;
  while (state && state.kind) {
    reverseStateStack.push(state);
    state = state.prevState;
  }
  for (let i = reverseStateStack.length - 1; i >= 0; i--) {
    fn(reverseStateStack[i]);
  }
}
function objectValues2(object) {
  const keys = Object.keys(object);
  const len = keys.length;
  const values = new Array(len);
  for (let i = 0; i < len; ++i) {
    values[i] = object[keys[i]];
  }
  return values;
}
function hintList(token, list2) {
  return filterAndSortList(list2, normalizeText(token.string));
}
function filterAndSortList(list2, text2) {
  if (!text2) {
    return filterNonEmpty(list2, (entry) => !entry.isDeprecated);
  }
  const byProximity = list2.map((entry) => ({
    proximity: getProximity(normalizeText(entry.label), text2),
    entry
  }));
  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a, b) => (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.label.length - b.entry.label.length).map((pair) => pair.entry);
}
function filterNonEmpty(array, predicate) {
  const filtered = array.filter(predicate);
  return filtered.length === 0 ? array : filtered;
}
function normalizeText(text2) {
  return text2.toLowerCase().replace(/\W/g, "");
}
function getProximity(suggestion, text2) {
  let proximity = lexicalDistance(text2, suggestion);
  if (suggestion.length > text2.length) {
    proximity -= suggestion.length - text2.length - 1;
    proximity += suggestion.indexOf(text2) === 0 ? 0 : 0.5;
  }
  return proximity;
}
function lexicalDistance(a, b) {
  let i;
  let j;
  const d = [];
  const aLength = a.length;
  const bLength = b.length;
  for (i = 0; i <= aLength; i++) {
    d[i] = [i];
  }
  for (j = 1; j <= bLength; j++) {
    d[0][j] = j;
  }
  for (i = 1; i <= aLength; i++) {
    for (j = 1; j <= bLength; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
      if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
        d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
      }
    }
  }
  return d[aLength][bLength];
}
var init_autocompleteUtils = __esm({
  "node_modules/graphql-language-service-interface/esm/autocompleteUtils.js"() {
    init_define_process_env();
    init_graphql2();
    init_introspection();
  }
});

// node_modules/vscode-languageserver-types/lib/esm/main.js
var integer, uinteger, Position2, Range2, Location2, LocationLink, Color, ColorInformation, ColorPresentation, FoldingRangeKind, FoldingRange, DiagnosticRelatedInformation, DiagnosticSeverity, DiagnosticTag, CodeDescription, Diagnostic, Command, TextEdit, ChangeAnnotation, ChangeAnnotationIdentifier, AnnotatedTextEdit, TextDocumentEdit, CreateFile, RenameFile, DeleteFile, WorkspaceEdit, TextEditChangeImpl, ChangeAnnotations, WorkspaceChange, TextDocumentIdentifier, VersionedTextDocumentIdentifier, OptionalVersionedTextDocumentIdentifier, TextDocumentItem, MarkupKind, MarkupContent, CompletionItemKind, InsertTextFormat, CompletionItemTag, InsertReplaceEdit, InsertTextMode, CompletionItem, CompletionList, MarkedString, Hover, ParameterInformation, SignatureInformation, DocumentHighlightKind, DocumentHighlight, SymbolKind, SymbolTag, SymbolInformation, DocumentSymbol, CodeActionKind, CodeActionContext, CodeAction, CodeLens, FormattingOptions, DocumentLink, SelectionRange, TextDocument, FullTextDocument, Is;
var init_main = __esm({
  "node_modules/vscode-languageserver-types/lib/esm/main.js"() {
    init_define_process_env();
    "use strict";
    (function(integer2) {
      integer2.MIN_VALUE = -2147483648;
      integer2.MAX_VALUE = 2147483647;
    })(integer || (integer = {}));
    (function(uinteger2) {
      uinteger2.MIN_VALUE = 0;
      uinteger2.MAX_VALUE = 2147483647;
    })(uinteger || (uinteger = {}));
    (function(Position3) {
      function create(line, character) {
        if (line === Number.MAX_VALUE) {
          line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
          character = uinteger.MAX_VALUE;
        }
        return { line, character };
      }
      Position3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
      }
      Position3.is = is;
    })(Position2 || (Position2 = {}));
    (function(Range3) {
      function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
          return { start: Position2.create(one, two), end: Position2.create(three, four) };
        } else if (Position2.is(one) && Position2.is(two)) {
          return { start: one, end: two };
        } else {
          throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
      }
      Range3.create = create;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Position2.is(candidate.start) && Position2.is(candidate.end);
      }
      Range3.is = is;
    })(Range2 || (Range2 = {}));
    (function(Location3) {
      function create(uri, range) {
        return { uri, range };
      }
      Location3.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range2.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
      }
      Location3.is = is;
    })(Location2 || (Location2 = {}));
    (function(LocationLink2) {
      function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
      }
      LocationLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range2.is(candidate.targetRange) && Is.string(candidate.targetUri) && (Range2.is(candidate.targetSelectionRange) || Is.undefined(candidate.targetSelectionRange)) && (Range2.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
      }
      LocationLink2.is = is;
    })(LocationLink || (LocationLink = {}));
    (function(Color2) {
      function create(red, green, blue, alpha) {
        return {
          red,
          green,
          blue,
          alpha
        };
      }
      Color2.create = create;
      function is(value) {
        var candidate = value;
        return Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
      }
      Color2.is = is;
    })(Color || (Color = {}));
    (function(ColorInformation2) {
      function create(range, color) {
        return {
          range,
          color
        };
      }
      ColorInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Range2.is(candidate.range) && Color.is(candidate.color);
      }
      ColorInformation2.is = is;
    })(ColorInformation || (ColorInformation = {}));
    (function(ColorPresentation2) {
      function create(label, textEdit, additionalTextEdits) {
        return {
          label,
          textEdit,
          additionalTextEdits
        };
      }
      ColorPresentation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
      }
      ColorPresentation2.is = is;
    })(ColorPresentation || (ColorPresentation = {}));
    (function(FoldingRangeKind2) {
      FoldingRangeKind2["Comment"] = "comment";
      FoldingRangeKind2["Imports"] = "imports";
      FoldingRangeKind2["Region"] = "region";
    })(FoldingRangeKind || (FoldingRangeKind = {}));
    (function(FoldingRange2) {
      function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
          startLine,
          endLine
        };
        if (Is.defined(startCharacter)) {
          result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
          result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
          result.kind = kind;
        }
        return result;
      }
      FoldingRange2.create = create;
      function is(value) {
        var candidate = value;
        return Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
      }
      FoldingRange2.is = is;
    })(FoldingRange || (FoldingRange = {}));
    (function(DiagnosticRelatedInformation2) {
      function create(location, message) {
        return {
          location,
          message
        };
      }
      DiagnosticRelatedInformation2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location2.is(candidate.location) && Is.string(candidate.message);
      }
      DiagnosticRelatedInformation2.is = is;
    })(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
    (function(DiagnosticSeverity2) {
      DiagnosticSeverity2.Error = 1;
      DiagnosticSeverity2.Warning = 2;
      DiagnosticSeverity2.Information = 3;
      DiagnosticSeverity2.Hint = 4;
    })(DiagnosticSeverity || (DiagnosticSeverity = {}));
    (function(DiagnosticTag2) {
      DiagnosticTag2.Unnecessary = 1;
      DiagnosticTag2.Deprecated = 2;
    })(DiagnosticTag || (DiagnosticTag = {}));
    (function(CodeDescription2) {
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && candidate !== null && Is.string(candidate.href);
      }
      CodeDescription2.is = is;
    })(CodeDescription || (CodeDescription = {}));
    (function(Diagnostic2) {
      function create(range, message, severity, code, source, relatedInformation) {
        var result = { range, message };
        if (Is.defined(severity)) {
          result.severity = severity;
        }
        if (Is.defined(code)) {
          result.code = code;
        }
        if (Is.defined(source)) {
          result.source = source;
        }
        if (Is.defined(relatedInformation)) {
          result.relatedInformation = relatedInformation;
        }
        return result;
      }
      Diagnostic2.create = create;
      function is(value) {
        var _a2;
        var candidate = value;
        return Is.defined(candidate) && Range2.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a2 = candidate.codeDescription) === null || _a2 === void 0 ? void 0 : _a2.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
      }
      Diagnostic2.is = is;
    })(Diagnostic || (Diagnostic = {}));
    (function(Command2) {
      function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          args[_i - 2] = arguments[_i];
        }
        var result = { title, command };
        if (Is.defined(args) && args.length > 0) {
          result.arguments = args;
        }
        return result;
      }
      Command2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
      }
      Command2.is = is;
    })(Command || (Command = {}));
    (function(TextEdit2) {
      function replace(range, newText) {
        return { range, newText };
      }
      TextEdit2.replace = replace;
      function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
      }
      TextEdit2.insert = insert;
      function del(range) {
        return { range, newText: "" };
      }
      TextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range2.is(candidate.range);
      }
      TextEdit2.is = is;
    })(TextEdit || (TextEdit = {}));
    (function(ChangeAnnotation2) {
      function create(label, needsConfirmation, description) {
        var result = { label };
        if (needsConfirmation !== void 0) {
          result.needsConfirmation = needsConfirmation;
        }
        if (description !== void 0) {
          result.description = description;
        }
        return result;
      }
      ChangeAnnotation2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
      }
      ChangeAnnotation2.is = is;
    })(ChangeAnnotation || (ChangeAnnotation = {}));
    (function(ChangeAnnotationIdentifier2) {
      function is(value) {
        var candidate = value;
        return typeof candidate === "string";
      }
      ChangeAnnotationIdentifier2.is = is;
    })(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
    (function(AnnotatedTextEdit2) {
      function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.replace = replace;
      function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
      }
      AnnotatedTextEdit2.insert = insert;
      function del(range, annotation) {
        return { range, newText: "", annotationId: annotation };
      }
      AnnotatedTextEdit2.del = del;
      function is(value) {
        var candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      AnnotatedTextEdit2.is = is;
    })(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
    (function(TextDocumentEdit2) {
      function create(textDocument, edits) {
        return { textDocument, edits };
      }
      TextDocumentEdit2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
      }
      TextDocumentEdit2.is = is;
    })(TextDocumentEdit || (TextDocumentEdit = {}));
    (function(CreateFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "create",
          uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      CreateFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      CreateFile2.is = is;
    })(CreateFile || (CreateFile = {}));
    (function(RenameFile2) {
      function create(oldUri, newUri, options, annotation) {
        var result = {
          kind: "rename",
          oldUri,
          newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      RenameFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      RenameFile2.is = is;
    })(RenameFile || (RenameFile = {}));
    (function(DeleteFile2) {
      function create(uri, options, annotation) {
        var result = {
          kind: "delete",
          uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
          result.options = options;
        }
        if (annotation !== void 0) {
          result.annotationId = annotation;
        }
        return result;
      }
      DeleteFile2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
      }
      DeleteFile2.is = is;
    })(DeleteFile || (DeleteFile = {}));
    (function(WorkspaceEdit2) {
      function is(value) {
        var candidate = value;
        return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
          if (Is.string(change.kind)) {
            return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
          } else {
            return TextDocumentEdit.is(change);
          }
        }));
      }
      WorkspaceEdit2.is = is;
    })(WorkspaceEdit || (WorkspaceEdit = {}));
    TextEditChangeImpl = function() {
      function TextEditChangeImpl2(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
      }
      TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.delete = function(range, annotation) {
        var edit;
        var id;
        if (annotation === void 0) {
          edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
          id = annotation;
          edit = AnnotatedTextEdit.del(range, annotation);
        } else {
          this.assertChangeAnnotations(this.changeAnnotations);
          id = this.changeAnnotations.manage(annotation);
          edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== void 0) {
          return id;
        }
      };
      TextEditChangeImpl2.prototype.add = function(edit) {
        this.edits.push(edit);
      };
      TextEditChangeImpl2.prototype.all = function() {
        return this.edits;
      };
      TextEditChangeImpl2.prototype.clear = function() {
        this.edits.splice(0, this.edits.length);
      };
      TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
        if (value === void 0) {
          throw new Error("Text edit change is not configured to manage change annotations.");
        }
      };
      return TextEditChangeImpl2;
    }();
    ChangeAnnotations = function() {
      function ChangeAnnotations2(annotations2) {
        this._annotations = annotations2 === void 0 ? Object.create(null) : annotations2;
        this._counter = 0;
        this._size = 0;
      }
      ChangeAnnotations2.prototype.all = function() {
        return this._annotations;
      };
      Object.defineProperty(ChangeAnnotations2.prototype, "size", {
        get: function() {
          return this._size;
        },
        enumerable: false,
        configurable: true
      });
      ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
        var id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
          id = idOrAnnotation;
        } else {
          id = this.nextId();
          annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== void 0) {
          throw new Error("Id " + id + " is already in use.");
        }
        if (annotation === void 0) {
          throw new Error("No annotation provided for id " + id);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
      };
      ChangeAnnotations2.prototype.nextId = function() {
        this._counter++;
        return this._counter.toString();
      };
      return ChangeAnnotations2;
    }();
    WorkspaceChange = function() {
      function WorkspaceChange2(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== void 0) {
          this._workspaceEdit = workspaceEdit;
          if (workspaceEdit.documentChanges) {
            this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
            workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            workspaceEdit.documentChanges.forEach(function(change) {
              if (TextDocumentEdit.is(change)) {
                var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                _this._textEditChanges[change.textDocument.uri] = textEditChange;
              }
            });
          } else if (workspaceEdit.changes) {
            Object.keys(workspaceEdit.changes).forEach(function(key) {
              var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
              _this._textEditChanges[key] = textEditChange;
            });
          }
        } else {
          this._workspaceEdit = {};
        }
      }
      Object.defineProperty(WorkspaceChange2.prototype, "edit", {
        get: function() {
          this.initDocumentChanges();
          if (this._changeAnnotations !== void 0) {
            if (this._changeAnnotations.size === 0) {
              this._workspaceEdit.changeAnnotations = void 0;
            } else {
              this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
          }
          return this._workspaceEdit;
        },
        enumerable: false,
        configurable: true
      });
      WorkspaceChange2.prototype.getTextEditChange = function(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var textDocument = { uri: key.uri, version: key.version };
          var result = this._textEditChanges[textDocument.uri];
          if (!result) {
            var edits = [];
            var textDocumentEdit = {
              textDocument,
              edits
            };
            this._workspaceEdit.documentChanges.push(textDocumentEdit);
            result = new TextEditChangeImpl(edits, this._changeAnnotations);
            this._textEditChanges[textDocument.uri] = result;
          }
          return result;
        } else {
          this.initChanges();
          if (this._workspaceEdit.changes === void 0) {
            throw new Error("Workspace edit is not configured for normal text edit changes.");
          }
          var result = this._textEditChanges[key];
          if (!result) {
            var edits = [];
            this._workspaceEdit.changes[key] = edits;
            result = new TextEditChangeImpl(edits);
            this._textEditChanges[key] = result;
          }
          return result;
        }
      };
      WorkspaceChange2.prototype.initDocumentChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._changeAnnotations = new ChangeAnnotations();
          this._workspaceEdit.documentChanges = [];
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      };
      WorkspaceChange2.prototype.initChanges = function() {
        if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
          this._workspaceEdit.changes = Object.create(null);
        }
      };
      WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = CreateFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = RenameFile.create(oldUri, newUri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === void 0) {
          throw new Error("Workspace edit is not configured for document changes.");
        }
        var annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
          annotation = optionsOrAnnotation;
        } else {
          options = optionsOrAnnotation;
        }
        var operation;
        var id;
        if (annotation === void 0) {
          operation = DeleteFile.create(uri, options);
        } else {
          id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
          operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== void 0) {
          return id;
        }
      };
      return WorkspaceChange2;
    }();
    (function(TextDocumentIdentifier2) {
      function create(uri) {
        return { uri };
      }
      TextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
      }
      TextDocumentIdentifier2.is = is;
    })(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
    (function(VersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      VersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
      }
      VersionedTextDocumentIdentifier2.is = is;
    })(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
    (function(OptionalVersionedTextDocumentIdentifier2) {
      function create(uri, version2) {
        return { uri, version: version2 };
      }
      OptionalVersionedTextDocumentIdentifier2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
      }
      OptionalVersionedTextDocumentIdentifier2.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
    (function(TextDocumentItem2) {
      function create(uri, languageId, version2, text2) {
        return { uri, languageId, version: version2, text: text2 };
      }
      TextDocumentItem2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
      }
      TextDocumentItem2.is = is;
    })(TextDocumentItem || (TextDocumentItem = {}));
    (function(MarkupKind2) {
      MarkupKind2.PlainText = "plaintext";
      MarkupKind2.Markdown = "markdown";
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupKind2) {
      function is(value) {
        var candidate = value;
        return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
      }
      MarkupKind2.is = is;
    })(MarkupKind || (MarkupKind = {}));
    (function(MarkupContent2) {
      function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
      }
      MarkupContent2.is = is;
    })(MarkupContent || (MarkupContent = {}));
    (function(CompletionItemKind2) {
      CompletionItemKind2.Text = 1;
      CompletionItemKind2.Method = 2;
      CompletionItemKind2.Function = 3;
      CompletionItemKind2.Constructor = 4;
      CompletionItemKind2.Field = 5;
      CompletionItemKind2.Variable = 6;
      CompletionItemKind2.Class = 7;
      CompletionItemKind2.Interface = 8;
      CompletionItemKind2.Module = 9;
      CompletionItemKind2.Property = 10;
      CompletionItemKind2.Unit = 11;
      CompletionItemKind2.Value = 12;
      CompletionItemKind2.Enum = 13;
      CompletionItemKind2.Keyword = 14;
      CompletionItemKind2.Snippet = 15;
      CompletionItemKind2.Color = 16;
      CompletionItemKind2.File = 17;
      CompletionItemKind2.Reference = 18;
      CompletionItemKind2.Folder = 19;
      CompletionItemKind2.EnumMember = 20;
      CompletionItemKind2.Constant = 21;
      CompletionItemKind2.Struct = 22;
      CompletionItemKind2.Event = 23;
      CompletionItemKind2.Operator = 24;
      CompletionItemKind2.TypeParameter = 25;
    })(CompletionItemKind || (CompletionItemKind = {}));
    (function(InsertTextFormat2) {
      InsertTextFormat2.PlainText = 1;
      InsertTextFormat2.Snippet = 2;
    })(InsertTextFormat || (InsertTextFormat = {}));
    (function(CompletionItemTag2) {
      CompletionItemTag2.Deprecated = 1;
    })(CompletionItemTag || (CompletionItemTag = {}));
    (function(InsertReplaceEdit2) {
      function create(newText, insert, replace) {
        return { newText, insert, replace };
      }
      InsertReplaceEdit2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.newText) && Range2.is(candidate.insert) && Range2.is(candidate.replace);
      }
      InsertReplaceEdit2.is = is;
    })(InsertReplaceEdit || (InsertReplaceEdit = {}));
    (function(InsertTextMode2) {
      InsertTextMode2.asIs = 1;
      InsertTextMode2.adjustIndentation = 2;
    })(InsertTextMode || (InsertTextMode = {}));
    (function(CompletionItem2) {
      function create(label) {
        return { label };
      }
      CompletionItem2.create = create;
    })(CompletionItem || (CompletionItem = {}));
    (function(CompletionList2) {
      function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
      }
      CompletionList2.create = create;
    })(CompletionList || (CompletionList = {}));
    (function(MarkedString2) {
      function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
      }
      MarkedString2.fromPlainText = fromPlainText;
      function is(value) {
        var candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
      }
      MarkedString2.is = is;
    })(MarkedString || (MarkedString = {}));
    (function(Hover2) {
      function is(value) {
        var candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range2.is(value.range));
      }
      Hover2.is = is;
    })(Hover || (Hover = {}));
    (function(ParameterInformation2) {
      function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
      }
      ParameterInformation2.create = create;
    })(ParameterInformation || (ParameterInformation = {}));
    (function(SignatureInformation2) {
      function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
          parameters[_i - 2] = arguments[_i];
        }
        var result = { label };
        if (Is.defined(documentation)) {
          result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
          result.parameters = parameters;
        } else {
          result.parameters = [];
        }
        return result;
      }
      SignatureInformation2.create = create;
    })(SignatureInformation || (SignatureInformation = {}));
    (function(DocumentHighlightKind2) {
      DocumentHighlightKind2.Text = 1;
      DocumentHighlightKind2.Read = 2;
      DocumentHighlightKind2.Write = 3;
    })(DocumentHighlightKind || (DocumentHighlightKind = {}));
    (function(DocumentHighlight2) {
      function create(range, kind) {
        var result = { range };
        if (Is.number(kind)) {
          result.kind = kind;
        }
        return result;
      }
      DocumentHighlight2.create = create;
    })(DocumentHighlight || (DocumentHighlight = {}));
    (function(SymbolKind2) {
      SymbolKind2.File = 1;
      SymbolKind2.Module = 2;
      SymbolKind2.Namespace = 3;
      SymbolKind2.Package = 4;
      SymbolKind2.Class = 5;
      SymbolKind2.Method = 6;
      SymbolKind2.Property = 7;
      SymbolKind2.Field = 8;
      SymbolKind2.Constructor = 9;
      SymbolKind2.Enum = 10;
      SymbolKind2.Interface = 11;
      SymbolKind2.Function = 12;
      SymbolKind2.Variable = 13;
      SymbolKind2.Constant = 14;
      SymbolKind2.String = 15;
      SymbolKind2.Number = 16;
      SymbolKind2.Boolean = 17;
      SymbolKind2.Array = 18;
      SymbolKind2.Object = 19;
      SymbolKind2.Key = 20;
      SymbolKind2.Null = 21;
      SymbolKind2.EnumMember = 22;
      SymbolKind2.Struct = 23;
      SymbolKind2.Event = 24;
      SymbolKind2.Operator = 25;
      SymbolKind2.TypeParameter = 26;
    })(SymbolKind || (SymbolKind = {}));
    (function(SymbolTag2) {
      SymbolTag2.Deprecated = 1;
    })(SymbolTag || (SymbolTag = {}));
    (function(SymbolInformation2) {
      function create(name2, kind, range, uri, containerName) {
        var result = {
          name: name2,
          kind,
          location: { uri, range }
        };
        if (containerName) {
          result.containerName = containerName;
        }
        return result;
      }
      SymbolInformation2.create = create;
    })(SymbolInformation || (SymbolInformation = {}));
    (function(DocumentSymbol2) {
      function create(name2, detail, kind, range, selectionRange, children) {
        var result = {
          name: name2,
          detail,
          kind,
          range,
          selectionRange
        };
        if (children !== void 0) {
          result.children = children;
        }
        return result;
      }
      DocumentSymbol2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range2.is(candidate.range) && Range2.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
      }
      DocumentSymbol2.is = is;
    })(DocumentSymbol || (DocumentSymbol = {}));
    (function(CodeActionKind2) {
      CodeActionKind2.Empty = "";
      CodeActionKind2.QuickFix = "quickfix";
      CodeActionKind2.Refactor = "refactor";
      CodeActionKind2.RefactorExtract = "refactor.extract";
      CodeActionKind2.RefactorInline = "refactor.inline";
      CodeActionKind2.RefactorRewrite = "refactor.rewrite";
      CodeActionKind2.Source = "source";
      CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
      CodeActionKind2.SourceFixAll = "source.fixAll";
    })(CodeActionKind || (CodeActionKind = {}));
    (function(CodeActionContext2) {
      function create(diagnostics, only) {
        var result = { diagnostics };
        if (only !== void 0 && only !== null) {
          result.only = only;
        }
        return result;
      }
      CodeActionContext2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
      }
      CodeActionContext2.is = is;
    })(CodeActionContext || (CodeActionContext = {}));
    (function(CodeAction2) {
      function create(title, kindOrCommandOrEdit, kind) {
        var result = { title };
        var checkKind = true;
        if (typeof kindOrCommandOrEdit === "string") {
          checkKind = false;
          result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
          result.command = kindOrCommandOrEdit;
        } else {
          result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== void 0) {
          result.kind = kind;
        }
        return result;
      }
      CodeAction2.create = create;
      function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
      }
      CodeAction2.is = is;
    })(CodeAction || (CodeAction = {}));
    (function(CodeLens2) {
      function create(range, data) {
        var result = { range };
        if (Is.defined(data)) {
          result.data = data;
        }
        return result;
      }
      CodeLens2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
      }
      CodeLens2.is = is;
    })(CodeLens || (CodeLens = {}));
    (function(FormattingOptions2) {
      function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
      }
      FormattingOptions2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
      }
      FormattingOptions2.is = is;
    })(FormattingOptions || (FormattingOptions = {}));
    (function(DocumentLink2) {
      function create(range, target, data) {
        return { range, target, data };
      }
      DocumentLink2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Range2.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
      }
      DocumentLink2.is = is;
    })(DocumentLink || (DocumentLink = {}));
    (function(SelectionRange2) {
      function create(range, parent) {
        return { range, parent };
      }
      SelectionRange2.create = create;
      function is(value) {
        var candidate = value;
        return candidate !== void 0 && Range2.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
      }
      SelectionRange2.is = is;
    })(SelectionRange || (SelectionRange = {}));
    (function(TextDocument2) {
      function create(uri, languageId, version2, content) {
        return new FullTextDocument(uri, languageId, version2, content);
      }
      TextDocument2.create = create;
      function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
      }
      TextDocument2.is = is;
      function applyEdits(document2, edits) {
        var text2 = document2.getText();
        var sortedEdits = mergeSort(edits, function(a, b) {
          var diff2 = a.range.start.line - b.range.start.line;
          if (diff2 === 0) {
            return a.range.start.character - b.range.start.character;
          }
          return diff2;
        });
        var lastModifiedOffset = text2.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
          var e = sortedEdits[i];
          var startOffset = document2.offsetAt(e.range.start);
          var endOffset = document2.offsetAt(e.range.end);
          if (endOffset <= lastModifiedOffset) {
            text2 = text2.substring(0, startOffset) + e.newText + text2.substring(endOffset, text2.length);
          } else {
            throw new Error("Overlapping edit");
          }
          lastModifiedOffset = startOffset;
        }
        return text2;
      }
      TextDocument2.applyEdits = applyEdits;
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        var p2 = data.length / 2 | 0;
        var left = data.slice(0, p2);
        var right = data.slice(p2);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          var ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
    })(TextDocument || (TextDocument = {}));
    FullTextDocument = function() {
      function FullTextDocument2(uri, languageId, version2, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version2;
        this._content = content;
        this._lineOffsets = void 0;
      }
      Object.defineProperty(FullTextDocument2.prototype, "uri", {
        get: function() {
          return this._uri;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "languageId", {
        get: function() {
          return this._languageId;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(FullTextDocument2.prototype, "version", {
        get: function() {
          return this._version;
        },
        enumerable: false,
        configurable: true
      });
      FullTextDocument2.prototype.getText = function(range) {
        if (range) {
          var start = this.offsetAt(range.start);
          var end = this.offsetAt(range.end);
          return this._content.substring(start, end);
        }
        return this._content;
      };
      FullTextDocument2.prototype.update = function(event, version2) {
        this._content = event.text;
        this._version = version2;
        this._lineOffsets = void 0;
      };
      FullTextDocument2.prototype.getLineOffsets = function() {
        if (this._lineOffsets === void 0) {
          var lineOffsets = [];
          var text2 = this._content;
          var isLineStart = true;
          for (var i = 0; i < text2.length; i++) {
            if (isLineStart) {
              lineOffsets.push(i);
              isLineStart = false;
            }
            var ch = text2.charAt(i);
            isLineStart = ch === "\r" || ch === "\n";
            if (ch === "\r" && i + 1 < text2.length && text2.charAt(i + 1) === "\n") {
              i++;
            }
          }
          if (isLineStart && text2.length > 0) {
            lineOffsets.push(text2.length);
          }
          this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
      };
      FullTextDocument2.prototype.positionAt = function(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
          return Position2.create(0, offset);
        }
        while (low < high) {
          var mid = Math.floor((low + high) / 2);
          if (lineOffsets[mid] > offset) {
            high = mid;
          } else {
            low = mid + 1;
          }
        }
        var line = low - 1;
        return Position2.create(line, offset - lineOffsets[line]);
      };
      FullTextDocument2.prototype.offsetAt = function(position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
          return this._content.length;
        } else if (position.line < 0) {
          return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
      };
      Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
        get: function() {
          return this.getLineOffsets().length;
        },
        enumerable: false,
        configurable: true
      });
      return FullTextDocument2;
    }();
    (function(Is2) {
      var toString3 = Object.prototype.toString;
      function defined(value) {
        return typeof value !== "undefined";
      }
      Is2.defined = defined;
      function undefined2(value) {
        return typeof value === "undefined";
      }
      Is2.undefined = undefined2;
      function boolean(value) {
        return value === true || value === false;
      }
      Is2.boolean = boolean;
      function string(value) {
        return toString3.call(value) === "[object String]";
      }
      Is2.string = string;
      function number(value) {
        return toString3.call(value) === "[object Number]";
      }
      Is2.number = number;
      function numberRange(value, min, max) {
        return toString3.call(value) === "[object Number]" && min <= value && value <= max;
      }
      Is2.numberRange = numberRange;
      function integer2(value) {
        return toString3.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
      }
      Is2.integer = integer2;
      function uinteger2(value) {
        return toString3.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
      }
      Is2.uinteger = uinteger2;
      function func(value) {
        return toString3.call(value) === "[object Function]";
      }
      Is2.func = func;
      function objectLiteral(value) {
        return value !== null && typeof value === "object";
      }
      Is2.objectLiteral = objectLiteral;
      function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
      }
      Is2.typedArray = typedArray;
    })(Is || (Is = {}));
  }
});

// node_modules/graphql-language-service-parser/esm/CharacterStream.js
var CharacterStream;
var init_CharacterStream = __esm({
  "node_modules/graphql-language-service-parser/esm/CharacterStream.js"() {
    init_define_process_env();
    CharacterStream = class {
      constructor(sourceText) {
        this.getStartOfToken = () => this._start;
        this.getCurrentPosition = () => this._pos;
        this.eol = () => this._sourceText.length === this._pos;
        this.sol = () => this._pos === 0;
        this.peek = () => {
          return this._sourceText.charAt(this._pos) ? this._sourceText.charAt(this._pos) : null;
        };
        this.next = () => {
          const char = this._sourceText.charAt(this._pos);
          this._pos++;
          return char;
        };
        this.eat = (pattern) => {
          const isMatched = this._testNextCharacter(pattern);
          if (isMatched) {
            this._start = this._pos;
            this._pos++;
            return this._sourceText.charAt(this._pos - 1);
          }
          return void 0;
        };
        this.eatWhile = (match) => {
          let isMatched = this._testNextCharacter(match);
          let didEat = false;
          if (isMatched) {
            didEat = isMatched;
            this._start = this._pos;
          }
          while (isMatched) {
            this._pos++;
            isMatched = this._testNextCharacter(match);
            didEat = true;
          }
          return didEat;
        };
        this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
        this.skipToEnd = () => {
          this._pos = this._sourceText.length;
        };
        this.skipTo = (position) => {
          this._pos = position;
        };
        this.match = (pattern, consume = true, caseFold = false) => {
          let token = null;
          let match = null;
          if (typeof pattern === "string") {
            const regex = new RegExp(pattern, caseFold ? "i" : "g");
            match = regex.test(this._sourceText.substr(this._pos, pattern.length));
            token = pattern;
          } else if (pattern instanceof RegExp) {
            match = this._sourceText.slice(this._pos).match(pattern);
            token = match && match[0];
          }
          if (match != null) {
            if (typeof pattern === "string" || match instanceof Array && this._sourceText.startsWith(match[0], this._pos)) {
              if (consume) {
                this._start = this._pos;
                if (token && token.length) {
                  this._pos += token.length;
                }
              }
              return match;
            }
          }
          return false;
        };
        this.backUp = (num) => {
          this._pos -= num;
        };
        this.column = () => this._pos;
        this.indentation = () => {
          const match = this._sourceText.match(/\s*/);
          let indent2 = 0;
          if (match && match.length !== 0) {
            const whitespaces = match[0];
            let pos = 0;
            while (whitespaces.length > pos) {
              if (whitespaces.charCodeAt(pos) === 9) {
                indent2 += 2;
              } else {
                indent2++;
              }
              pos++;
            }
          }
          return indent2;
        };
        this.current = () => this._sourceText.slice(this._start, this._pos);
        this._start = 0;
        this._pos = 0;
        this._sourceText = sourceText;
      }
      _testNextCharacter(pattern) {
        const character = this._sourceText.charAt(this._pos);
        let isMatched = false;
        if (typeof pattern === "string") {
          isMatched = character === pattern;
        } else {
          isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
        }
        return isMatched;
      }
    };
  }
});

// node_modules/graphql-language-service-parser/esm/RuleHelpers.js
function opt(ofRule) {
  return { ofRule };
}
function list(ofRule, separator) {
  return { ofRule, isList: true, separator };
}
function butNot(rule, exclusions) {
  const ruleMatch = rule.match;
  rule.match = (token) => {
    let check = false;
    if (ruleMatch) {
      check = ruleMatch(token);
    }
    return check && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token));
  };
  return rule;
}
function t(kind, style) {
  return { style, match: (token) => token.kind === kind };
}
function p(value, style) {
  return {
    style: style || "punctuation",
    match: (token) => token.kind === "Punctuation" && token.value === value
  };
}
var init_RuleHelpers = __esm({
  "node_modules/graphql-language-service-parser/esm/RuleHelpers.js"() {
    init_define_process_env();
  }
});

// node_modules/graphql-language-service-parser/esm/Rules.js
function word(value) {
  return {
    style: "keyword",
    match: (token) => token.kind === "Name" && token.value === value
  };
}
function name(style) {
  return {
    style,
    match: (token) => token.kind === "Name",
    update(state, token) {
      state.name = token.value;
    }
  };
}
function type(style) {
  return {
    style,
    match: (token) => token.kind === "Name",
    update(state, token) {
      if (state.prevState && state.prevState.prevState) {
        state.name = token.value;
        state.prevState.prevState.type = token.value;
      }
    }
  };
}
var isIgnored, LexRules, ParseRules;
var init_Rules = __esm({
  "node_modules/graphql-language-service-parser/esm/Rules.js"() {
    init_define_process_env();
    init_RuleHelpers();
    isIgnored = (ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0";
    LexRules = {
      Name: /^[_A-Za-z][_0-9A-Za-z]*/,
      Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
      Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
      String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
      Comment: /^#.*/
    };
    ParseRules = {
      Document: [list("Definition")],
      Definition(token) {
        switch (token.value) {
          case "{":
            return "ShortQuery";
          case "query":
            return "Query";
          case "mutation":
            return "Mutation";
          case "subscription":
            return "Subscription";
          case "fragment":
            return "FragmentDefinition";
          case "schema":
            return "SchemaDef";
          case "scalar":
            return "ScalarDef";
          case "type":
            return "ObjectTypeDef";
          case "interface":
            return "InterfaceDef";
          case "union":
            return "UnionDef";
          case "enum":
            return "EnumDef";
          case "input":
            return "InputDef";
          case "extend":
            return "ExtendDef";
          case "directive":
            return "DirectiveDef";
        }
      },
      ShortQuery: ["SelectionSet"],
      Query: [
        word("query"),
        opt(name("def")),
        opt("VariableDefinitions"),
        list("Directive"),
        "SelectionSet"
      ],
      Mutation: [
        word("mutation"),
        opt(name("def")),
        opt("VariableDefinitions"),
        list("Directive"),
        "SelectionSet"
      ],
      Subscription: [
        word("subscription"),
        opt(name("def")),
        opt("VariableDefinitions"),
        list("Directive"),
        "SelectionSet"
      ],
      VariableDefinitions: [p("("), list("VariableDefinition"), p(")")],
      VariableDefinition: ["Variable", p(":"), "Type", opt("DefaultValue")],
      Variable: [p("$", "variable"), name("variable")],
      DefaultValue: [p("="), "Value"],
      SelectionSet: [p("{"), list("Selection"), p("}")],
      Selection(token, stream) {
        return token.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
      },
      AliasedField: [
        name("property"),
        p(":"),
        name("qualifier"),
        opt("Arguments"),
        list("Directive"),
        opt("SelectionSet")
      ],
      Field: [
        name("property"),
        opt("Arguments"),
        list("Directive"),
        opt("SelectionSet")
      ],
      Arguments: [p("("), list("Argument"), p(")")],
      Argument: [name("attribute"), p(":"), "Value"],
      FragmentSpread: [p("..."), name("def"), list("Directive")],
      InlineFragment: [
        p("..."),
        opt("TypeCondition"),
        list("Directive"),
        "SelectionSet"
      ],
      FragmentDefinition: [
        word("fragment"),
        opt(butNot(name("def"), [word("on")])),
        "TypeCondition",
        list("Directive"),
        "SelectionSet"
      ],
      TypeCondition: [word("on"), "NamedType"],
      Value(token) {
        switch (token.kind) {
          case "Number":
            return "NumberValue";
          case "String":
            return "StringValue";
          case "Punctuation":
            switch (token.value) {
              case "[":
                return "ListValue";
              case "{":
                return "ObjectValue";
              case "$":
                return "Variable";
              case "&":
                return "NamedType";
            }
            return null;
          case "Name":
            switch (token.value) {
              case "true":
              case "false":
                return "BooleanValue";
            }
            if (token.value === "null") {
              return "NullValue";
            }
            return "EnumValue";
        }
      },
      NumberValue: [t("Number", "number")],
      StringValue: [t("String", "string")],
      BooleanValue: [t("Name", "builtin")],
      NullValue: [t("Name", "keyword")],
      EnumValue: [name("string-2")],
      ListValue: [p("["), list("Value"), p("]")],
      ObjectValue: [p("{"), list("ObjectField"), p("}")],
      ObjectField: [name("attribute"), p(":"), "Value"],
      Type(token) {
        return token.value === "[" ? "ListType" : "NonNullType";
      },
      ListType: [p("["), "Type", p("]"), opt(p("!"))],
      NonNullType: ["NamedType", opt(p("!"))],
      NamedType: [type("atom")],
      Directive: [p("@", "meta"), name("meta"), opt("Arguments")],
      DirectiveDef: [
        word("directive"),
        p("@", "meta"),
        name("meta"),
        opt("ArgumentsDef"),
        word("on"),
        list("DirectiveLocation", p("|"))
      ],
      InterfaceDef: [
        word("interface"),
        name("atom"),
        opt("Implements"),
        list("Directive"),
        p("{"),
        list("FieldDef"),
        p("}")
      ],
      Implements: [word("implements"), list("NamedType", p("&"))],
      DirectiveLocation: [name("string-2")],
      SchemaDef: [
        word("schema"),
        list("Directive"),
        p("{"),
        list("OperationTypeDef"),
        p("}")
      ],
      OperationTypeDef: [name("keyword"), p(":"), name("atom")],
      ScalarDef: [word("scalar"), name("atom"), list("Directive")],
      ObjectTypeDef: [
        word("type"),
        name("atom"),
        opt("Implements"),
        list("Directive"),
        p("{"),
        list("FieldDef"),
        p("}")
      ],
      FieldDef: [
        name("property"),
        opt("ArgumentsDef"),
        p(":"),
        "Type",
        list("Directive")
      ],
      ArgumentsDef: [p("("), list("InputValueDef"), p(")")],
      InputValueDef: [
        name("attribute"),
        p(":"),
        "Type",
        opt("DefaultValue"),
        list("Directive")
      ],
      UnionDef: [
        word("union"),
        name("atom"),
        list("Directive"),
        p("="),
        list("UnionMember", p("|"))
      ],
      UnionMember: ["NamedType"],
      EnumDef: [
        word("enum"),
        name("atom"),
        list("Directive"),
        p("{"),
        list("EnumValueDef"),
        p("}")
      ],
      EnumValueDef: [name("string-2"), list("Directive")],
      InputDef: [
        word("input"),
        name("atom"),
        list("Directive"),
        p("{"),
        list("InputValueDef"),
        p("}")
      ],
      ExtendDef: [word("extend"), "ObjectTypeDef"]
    };
  }
});

// node_modules/graphql-language-service-parser/esm/onlineParser.js
function onlineParser(options = {
  eatWhitespace: (stream) => stream.eatWhile(isIgnored),
  lexRules: LexRules,
  parseRules: ParseRules,
  editorConfig: {}
}) {
  return {
    startState() {
      const initialState = {
        level: 0,
        step: 0,
        name: null,
        kind: null,
        type: null,
        rule: null,
        needsSeperator: false,
        prevState: null
      };
      pushRule(options.parseRules, initialState, "Document");
      return initialState;
    },
    token(stream, state) {
      return getToken(stream, state, options);
    }
  };
}
function getToken(stream, state, options) {
  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
  if (state.rule && state.rule.length === 0) {
    popRule(state);
  } else if (state.needsAdvance) {
    state.needsAdvance = false;
    advanceRule(state, true);
  }
  if (stream.sol()) {
    const tabSize = editorConfig && editorConfig.tabSize || 2;
    state.indentLevel = Math.floor(stream.indentation() / tabSize);
  }
  if (eatWhitespace(stream)) {
    return "ws";
  }
  const token = lex(lexRules, stream);
  if (!token) {
    const matchedSomething = stream.match(/\S+/);
    if (!matchedSomething) {
      stream.match(/\s/);
    }
    pushRule(SpecialParseRules, state, "Invalid");
    return "invalidchar";
  }
  if (token.kind === "Comment") {
    pushRule(SpecialParseRules, state, "Comment");
    return "comment";
  }
  const backupState = assign({}, state);
  if (token.kind === "Punctuation") {
    if (/^[{([]/.test(token.value)) {
      if (state.indentLevel !== void 0) {
        state.levels = (state.levels || []).concat(state.indentLevel + 1);
      }
    } else if (/^[})\]]/.test(token.value)) {
      const levels = state.levels = (state.levels || []).slice(0, -1);
      if (state.indentLevel) {
        if (levels.length > 0 && levels[levels.length - 1] < state.indentLevel) {
          state.indentLevel = levels[levels.length - 1];
        }
      }
    }
  }
  while (state.rule) {
    let expected = typeof state.rule === "function" ? state.step === 0 ? state.rule(token, stream) : null : state.rule[state.step];
    if (state.needsSeperator) {
      expected = expected && (expected === null || expected === void 0 ? void 0 : expected.separator);
    }
    if (expected) {
      if (expected.ofRule) {
        expected = expected.ofRule;
      }
      if (typeof expected === "string") {
        pushRule(parseRules, state, expected);
        continue;
      }
      if (expected.match && expected.match(token)) {
        if (expected.update) {
          expected.update(state, token);
        }
        if (token.kind === "Punctuation") {
          advanceRule(state, true);
        } else {
          state.needsAdvance = true;
        }
        return expected.style;
      }
    }
    unsuccessful(state);
  }
  assign(state, backupState);
  pushRule(SpecialParseRules, state, "Invalid");
  return "invalidchar";
}
function assign(to, from) {
  const keys = Object.keys(from);
  for (let i = 0; i < keys.length; i++) {
    to[keys[i]] = from[keys[i]];
  }
  return to;
}
function pushRule(rules, state, ruleKind) {
  if (!rules[ruleKind]) {
    throw new TypeError("Unknown rule: " + ruleKind);
  }
  state.prevState = Object.assign({}, state);
  state.kind = ruleKind;
  state.name = null;
  state.type = null;
  state.rule = rules[ruleKind];
  state.step = 0;
  state.needsSeperator = false;
}
function popRule(state) {
  if (!state.prevState) {
    return;
  }
  state.kind = state.prevState.kind;
  state.name = state.prevState.name;
  state.type = state.prevState.type;
  state.rule = state.prevState.rule;
  state.step = state.prevState.step;
  state.needsSeperator = state.prevState.needsSeperator;
  state.prevState = state.prevState.prevState;
}
function advanceRule(state, successful) {
  if (isList(state) && state.rule) {
    const step = state.rule[state.step];
    if (step.separator) {
      const separator = step.separator;
      state.needsSeperator = !state.needsSeperator;
      if (!state.needsSeperator && separator.ofRule) {
        return;
      }
    }
    if (successful) {
      return;
    }
  }
  state.needsSeperator = false;
  state.step++;
  while (state.rule && !(Array.isArray(state.rule) && state.step < state.rule.length)) {
    popRule(state);
    if (state.rule) {
      if (isList(state)) {
        if (state.rule && state.rule[state.step].separator) {
          state.needsSeperator = !state.needsSeperator;
        }
      } else {
        state.needsSeperator = false;
        state.step++;
      }
    }
  }
}
function isList(state) {
  const step = Array.isArray(state.rule) && typeof state.rule[state.step] !== "string" && state.rule[state.step];
  return step && step.isList;
}
function unsuccessful(state) {
  while (state.rule && !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {
    popRule(state);
  }
  if (state.rule) {
    advanceRule(state, false);
  }
}
function lex(lexRules, stream) {
  const kinds = Object.keys(lexRules);
  for (let i = 0; i < kinds.length; i++) {
    const match = stream.match(lexRules[kinds[i]]);
    if (match && match instanceof Array) {
      return { kind: kinds[i], value: match[0] };
    }
  }
}
var SpecialParseRules;
var init_onlineParser = __esm({
  "node_modules/graphql-language-service-parser/esm/onlineParser.js"() {
    init_define_process_env();
    init_Rules();
    SpecialParseRules = {
      Invalid: [],
      Comment: []
    };
  }
});

// node_modules/graphql-language-service-parser/esm/types.js
var AdditionalRuleKinds, RuleKinds;
var init_types = __esm({
  "node_modules/graphql-language-service-parser/esm/types.js"() {
    init_define_process_env();
    init_graphql2();
    AdditionalRuleKinds = {
      ALIASED_FIELD: "AliasedField",
      ARGUMENTS: "Arguments",
      SHORT_QUERY: "ShortQuery",
      QUERY: "Query",
      MUTATION: "Mutation",
      SUBSCRIPTION: "Subscription",
      TYPE_CONDITION: "TypeCondition",
      INVALID: "Invalid",
      COMMENT: "Comment",
      SCHEMA_DEF: "SchemaDef",
      SCALAR_DEF: "ScalarDef",
      OBJECT_TYPE_DEF: "ObjectTypeDef",
      OBJECT_VALUE: "ObjectValue",
      LIST_VALUE: "ListValue",
      INTERFACE_DEF: "InterfaceDef",
      UNION_DEF: "UnionDef",
      ENUM_DEF: "EnumDef",
      ENUM_VALUE: "EnumValue",
      FIELD_DEF: "FieldDef",
      INPUT_DEF: "InputDef",
      INPUT_VALUE_DEF: "InputValueDef",
      ARGUMENTS_DEF: "ArgumentsDef",
      EXTEND_DEF: "ExtendDef",
      DIRECTIVE_DEF: "DirectiveDef",
      IMPLEMENTS: "Implements",
      VARIABLE_DEFINITIONS: "VariableDefinitions",
      TYPE: "Type"
    };
    RuleKinds = Object.assign(Object.assign({}, Kind), AdditionalRuleKinds);
  }
});

// node_modules/graphql-language-service-parser/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  AdditionalRuleKinds: () => AdditionalRuleKinds,
  CharacterStream: () => CharacterStream,
  LexRules: () => LexRules,
  ParseRules: () => ParseRules,
  RuleKinds: () => RuleKinds,
  butNot: () => butNot,
  isIgnored: () => isIgnored,
  list: () => list,
  onlineParser: () => onlineParser,
  opt: () => opt,
  p: () => p,
  t: () => t
});
var init_esm2 = __esm({
  "node_modules/graphql-language-service-parser/esm/index.js"() {
    init_define_process_env();
    init_CharacterStream();
    init_Rules();
    init_RuleHelpers();
    init_onlineParser();
    init_types();
  }
});

// node_modules/graphql-language-service-interface/esm/getAutocompleteSuggestions.js
function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs) {
  var _a2;
  const token = contextToken || getTokenAtPosition(queryText, cursor);
  const state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
  if (!state) {
    return [];
  }
  const kind = state.kind;
  const step = state.step;
  const typeInfo = getTypeInfo(schema, token.state);
  if (kind === RuleKinds.DOCUMENT) {
    return hintList(token, [
      { label: "query", kind: CompletionItemKind.Function },
      { label: "mutation", kind: CompletionItemKind.Function },
      { label: "subscription", kind: CompletionItemKind.Function },
      { label: "fragment", kind: CompletionItemKind.Function },
      { label: "{", kind: CompletionItemKind.Constructor }
    ]);
  }
  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {
    return getSuggestionsForImplements(token, state, schema, queryText, typeInfo);
  }
  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {
    return getSuggestionsForFieldNames(token, typeInfo, schema);
  }
  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {
    const argDefs = typeInfo.argDefs;
    if (argDefs) {
      return hintList(token, argDefs.map((argDef) => {
        var _a3;
        return {
          label: argDef.name,
          detail: String(argDef.type),
          documentation: (_a3 = argDef.description) !== null && _a3 !== void 0 ? _a3 : void 0,
          kind: CompletionItemKind.Variable,
          type: argDef.type
        };
      }));
    }
  }
  if (kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) {
    if (typeInfo.objectFieldDefs) {
      const objectFields = objectValues2(typeInfo.objectFieldDefs);
      const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;
      return hintList(token, objectFields.map((field) => {
        var _a3;
        return {
          label: field.name,
          detail: String(field.type),
          documentation: (_a3 = field.description) !== null && _a3 !== void 0 ? _a3 : void 0,
          kind: completionKind,
          type: field.type
        };
      }));
    }
  }
  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {
    return getSuggestionsForInputValues(token, typeInfo, queryText, schema);
  }
  if (kind === RuleKinds.VARIABLE && step === 1) {
    const namedInputType = getNamedType(typeInfo.inputType);
    const variableDefinitions = getVariableCompletions(queryText, schema);
    return hintList(token, variableDefinitions.filter((v) => v.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
  }
  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState != null && state.prevState.kind === RuleKinds.TYPE_CONDITION) {
    return getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, kind);
  }
  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {
    return getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
  }
  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && state.prevState && (state.prevState.kind === RuleKinds.VARIABLE_DEFINITION || state.prevState.kind === RuleKinds.LIST_TYPE || state.prevState.kind === RuleKinds.NON_NULL_TYPE)) {
    return getSuggestionsForVariableDefinition(token, schema, kind);
  }
  if (kind === RuleKinds.DIRECTIVE) {
    return getSuggestionsForDirective(token, state, schema, kind);
  }
  return [];
}
function getSuggestionsForFieldNames(token, typeInfo, schema) {
  if (typeInfo.parentType) {
    const parentType = typeInfo.parentType;
    let fields7 = [];
    if ("getFields" in parentType) {
      fields7 = objectValues2(parentType.getFields());
    }
    if (isCompositeType(parentType)) {
      fields7.push(TypeNameMetaFieldDef);
    }
    if (parentType === schema.getQueryType()) {
      fields7.push(SchemaMetaFieldDef, TypeMetaFieldDef);
    }
    return hintList(token, fields7.map((field, index) => {
      var _a2;
      return {
        sortText: String(index) + field.name,
        label: field.name,
        detail: String(field.type),
        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,
        deprecated: field.isDeprecated,
        isDeprecated: field.isDeprecated,
        deprecationReason: field.deprecationReason,
        kind: CompletionItemKind.Field,
        type: field.type
      };
    }));
  }
  return [];
}
function getSuggestionsForInputValues(token, typeInfo, queryText, schema) {
  const namedInputType = getNamedType(typeInfo.inputType);
  const queryVariables = getVariableCompletions(queryText, schema, true).filter((v) => v.detail === namedInputType.name);
  if (namedInputType instanceof GraphQLEnumType) {
    const values = namedInputType.getValues();
    return hintList(token, values.map((value) => {
      var _a2;
      return {
        label: value.name,
        detail: String(namedInputType),
        documentation: (_a2 = value.description) !== null && _a2 !== void 0 ? _a2 : void 0,
        deprecated: value.isDeprecated,
        isDeprecated: value.isDeprecated,
        deprecationReason: value.deprecationReason,
        kind: CompletionItemKind.EnumMember,
        type: namedInputType
      };
    }).concat(queryVariables));
  } else if (namedInputType === GraphQLBoolean) {
    return hintList(token, queryVariables.concat([
      {
        label: "true",
        detail: String(GraphQLBoolean),
        documentation: "Not false.",
        kind: CompletionItemKind.Variable,
        type: GraphQLBoolean
      },
      {
        label: "false",
        detail: String(GraphQLBoolean),
        documentation: "Not true.",
        kind: CompletionItemKind.Variable,
        type: GraphQLBoolean
      }
    ]));
  }
  return queryVariables;
}
function getSuggestionsForImplements(token, tokenState, schema, documentText, typeInfo) {
  if (tokenState.needsSeperator) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const schemaInterfaces = objectValues2(typeMap).filter(isInterfaceType);
  const schemaInterfaceNames = schemaInterfaces.map(({ name: name2 }) => name2);
  const inlineInterfaces = new Set();
  runOnlineParser(documentText, (_, state) => {
    var _a2, _b, _c, _d, _e;
    if (state.name) {
      if (state.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state.name)) {
        inlineInterfaces.add(state.name);
      }
      if (state.kind === RuleKinds.NAMED_TYPE && ((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === RuleKinds.IMPLEMENTS) {
        if (typeInfo.interfaceDef) {
          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name: name2 }) => name2 === state.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state.name);
          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
          typeInfo.interfaceDef = new GraphQLInterfaceType(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
            ...interfaceConfig.interfaces,
            type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
          ] }));
        } else if (typeInfo.objectTypeDef) {
          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name: name2 }) => name2 === state.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state.name);
          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
          typeInfo.objectTypeDef = new GraphQLObjectType(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
            ...objectTypeConfig.interfaces,
            type2 || new GraphQLInterfaceType({ name: state.name, fields: {} })
          ] }));
        }
      }
    }
  });
  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
  const siblingInterfaceNames = siblingInterfaces.map(({ name: name2 }) => name2);
  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name2) => ({ name: name2 }))).filter(({ name: name2 }) => name2 !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name2));
  return hintList(token, possibleInterfaces.map((type2) => {
    const result = {
      label: type2.name,
      kind: CompletionItemKind.Interface,
      type: type2
    };
    if (type2 === null || type2 === void 0 ? void 0 : type2.description) {
      result.documentation = type2.description;
    }
    return result;
  }));
}
function getSuggestionsForFragmentTypeConditions(token, typeInfo, schema, _kind) {
  let possibleTypes;
  if (typeInfo.parentType) {
    if (isAbstractType(typeInfo.parentType)) {
      const abstractType = assertAbstractType(typeInfo.parentType);
      const possibleObjTypes = schema.getPossibleTypes(abstractType);
      const possibleIfaceMap = Object.create(null);
      possibleObjTypes.forEach((type2) => {
        type2.getInterfaces().forEach((iface) => {
          possibleIfaceMap[iface.name] = iface;
        });
      });
      possibleTypes = possibleObjTypes.concat(objectValues2(possibleIfaceMap));
    } else {
      possibleTypes = [typeInfo.parentType];
    }
  } else {
    const typeMap = schema.getTypeMap();
    possibleTypes = objectValues2(typeMap).filter(isCompositeType);
  }
  return hintList(token, possibleTypes.map((type2) => {
    const namedType = getNamedType(type2);
    return {
      label: String(type2),
      documentation: namedType && namedType.description || "",
      kind: CompletionItemKind.Field
    };
  }));
}
function getSuggestionsForFragmentSpread(token, typeInfo, schema, queryText, fragmentDefs) {
  if (!queryText) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const defState = getDefinitionState(token.state);
  const fragments = getFragmentDefinitions(queryText);
  if (fragmentDefs && fragmentDefs.length > 0) {
    fragments.push(...fragmentDefs);
  }
  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
  return hintList(token, relevantFrags.map((frag) => ({
    label: frag.name.value,
    detail: String(typeMap[frag.typeCondition.name.value]),
    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
    kind: CompletionItemKind.Field,
    type: typeMap[frag.typeCondition.name.value]
  })));
}
function getVariableCompletions(queryText, schema, forcePrefix = false) {
  let variableName;
  let variableType;
  const definitions = Object.create({});
  runOnlineParser(queryText, (_, state) => {
    if (state.kind === RuleKinds.VARIABLE && state.name) {
      variableName = state.name;
    }
    if (state.kind === RuleKinds.NAMED_TYPE && variableName) {
      const parentDefinition = getParentDefinition(state, RuleKinds.TYPE);
      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
      }
    }
    if (variableName && variableType) {
      if (!definitions[variableName]) {
        definitions[variableName] = {
          detail: variableType.toString(),
          label: `$${variableName}`,
          type: variableType,
          kind: CompletionItemKind.Variable
        };
        if (forcePrefix) {
          definitions[variableName].insertText = `$${variableName}`;
        }
        variableName = null;
        variableType = null;
      }
    }
  });
  return objectValues2(definitions);
}
function getFragmentDefinitions(queryText) {
  const fragmentDefs = [];
  runOnlineParser(queryText, (_, state) => {
    if (state.kind === RuleKinds.FRAGMENT_DEFINITION && state.name && state.type) {
      fragmentDefs.push({
        kind: RuleKinds.FRAGMENT_DEFINITION,
        name: {
          kind: "Name",
          value: state.name
        },
        selectionSet: {
          kind: RuleKinds.SELECTION_SET,
          selections: []
        },
        typeCondition: {
          kind: RuleKinds.NAMED_TYPE,
          name: {
            kind: "Name",
            value: state.type
          }
        }
      });
    }
  });
  return fragmentDefs;
}
function getSuggestionsForVariableDefinition(token, schema, _kind) {
  const inputTypeMap = schema.getTypeMap();
  const inputTypes = objectValues2(inputTypeMap).filter(isInputType);
  return hintList(token, inputTypes.map((type2) => ({
    label: type2.name,
    documentation: type2.description,
    kind: CompletionItemKind.Variable
  })));
}
function getSuggestionsForDirective(token, state, schema, _kind) {
  if (state.prevState && state.prevState.kind) {
    const directives = schema.getDirectives().filter((directive) => canUseDirective(state.prevState, directive));
    return hintList(token, directives.map((directive) => ({
      label: directive.name,
      documentation: directive.description || "",
      kind: CompletionItemKind.Function
    })));
  }
  return [];
}
function getTokenAtPosition(queryText, cursor) {
  let styleAtCursor = null;
  let stateAtCursor = null;
  let stringAtCursor = null;
  const token = runOnlineParser(queryText, (stream, state, style, index) => {
    if (index === cursor.line) {
      if (stream.getCurrentPosition() >= cursor.character) {
        styleAtCursor = style;
        stateAtCursor = Object.assign({}, state);
        stringAtCursor = stream.current();
        return "BREAK";
      }
    }
  });
  return {
    start: token.start,
    end: token.end,
    string: stringAtCursor || token.string,
    state: stateAtCursor || token.state,
    style: styleAtCursor || token.style
  };
}
function runOnlineParser(queryText, callback) {
  const lines = queryText.split("\n");
  const parser = onlineParser();
  let state = parser.startState();
  let style = "";
  let stream = new CharacterStream("");
  for (let i = 0; i < lines.length; i++) {
    stream = new CharacterStream(lines[i]);
    while (!stream.eol()) {
      style = parser.token(stream, state);
      const code = callback(stream, state, style, i);
      if (code === "BREAK") {
        break;
      }
    }
    callback(stream, state, style, i);
    if (!state.kind) {
      state = parser.startState();
    }
  }
  return {
    start: stream.getStartOfToken(),
    end: stream.getCurrentPosition(),
    string: stream.current(),
    state,
    style
  };
}
function canUseDirective(state, directive) {
  if (!state || !state.kind) {
    return false;
  }
  const kind = state.kind;
  const locations = directive.locations;
  switch (kind) {
    case RuleKinds.QUERY:
      return locations.indexOf("QUERY") !== -1;
    case RuleKinds.MUTATION:
      return locations.indexOf("MUTATION") !== -1;
    case RuleKinds.SUBSCRIPTION:
      return locations.indexOf("SUBSCRIPTION") !== -1;
    case RuleKinds.FIELD:
    case RuleKinds.ALIASED_FIELD:
      return locations.indexOf("FIELD") !== -1;
    case RuleKinds.FRAGMENT_DEFINITION:
      return locations.indexOf("FRAGMENT_DEFINITION") !== -1;
    case RuleKinds.FRAGMENT_SPREAD:
      return locations.indexOf("FRAGMENT_SPREAD") !== -1;
    case RuleKinds.INLINE_FRAGMENT:
      return locations.indexOf("INLINE_FRAGMENT") !== -1;
    case RuleKinds.SCHEMA_DEF:
      return locations.indexOf("SCHEMA") !== -1;
    case RuleKinds.SCALAR_DEF:
      return locations.indexOf("SCALAR") !== -1;
    case RuleKinds.OBJECT_TYPE_DEF:
      return locations.indexOf("OBJECT") !== -1;
    case RuleKinds.FIELD_DEF:
      return locations.indexOf("FIELD_DEFINITION") !== -1;
    case RuleKinds.INTERFACE_DEF:
      return locations.indexOf("INTERFACE") !== -1;
    case RuleKinds.UNION_DEF:
      return locations.indexOf("UNION") !== -1;
    case RuleKinds.ENUM_DEF:
      return locations.indexOf("ENUM") !== -1;
    case RuleKinds.ENUM_VALUE:
      return locations.indexOf("ENUM_VALUE") !== -1;
    case RuleKinds.INPUT_DEF:
      return locations.indexOf("INPUT_OBJECT") !== -1;
    case RuleKinds.INPUT_VALUE_DEF:
      const prevStateKind = state.prevState && state.prevState.kind;
      switch (prevStateKind) {
        case RuleKinds.ARGUMENTS_DEF:
          return locations.indexOf("ARGUMENT_DEFINITION") !== -1;
        case RuleKinds.INPUT_DEF:
          return locations.indexOf("INPUT_FIELD_DEFINITION") !== -1;
      }
  }
  return false;
}
function getTypeInfo(schema, tokenState) {
  let argDef;
  let argDefs;
  let directiveDef;
  let enumValue;
  let fieldDef;
  let inputType;
  let objectTypeDef;
  let objectFieldDefs;
  let parentType;
  let type2;
  let interfaceDef;
  forEachState(tokenState, (state) => {
    switch (state.kind) {
      case RuleKinds.QUERY:
      case "ShortQuery":
        type2 = schema.getQueryType();
        break;
      case RuleKinds.MUTATION:
        type2 = schema.getMutationType();
        break;
      case RuleKinds.SUBSCRIPTION:
        type2 = schema.getSubscriptionType();
        break;
      case RuleKinds.INLINE_FRAGMENT:
      case RuleKinds.FRAGMENT_DEFINITION:
        if (state.type) {
          type2 = schema.getType(state.type);
        }
        break;
      case RuleKinds.FIELD:
      case RuleKinds.ALIASED_FIELD: {
        if (!type2 || !state.name) {
          fieldDef = null;
        } else {
          fieldDef = parentType ? getFieldDef3(schema, parentType, state.name) : null;
          type2 = fieldDef ? fieldDef.type : null;
        }
        break;
      }
      case RuleKinds.SELECTION_SET:
        parentType = getNamedType(type2);
        break;
      case RuleKinds.DIRECTIVE:
        directiveDef = state.name ? schema.getDirective(state.name) : null;
        break;
      case RuleKinds.INTERFACE_DEF:
        if (state.name) {
          objectTypeDef = null;
          interfaceDef = new GraphQLInterfaceType({
            name: state.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.OBJECT_TYPE_DEF:
        if (state.name) {
          interfaceDef = null;
          objectTypeDef = new GraphQLObjectType({
            name: state.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.ARGUMENTS: {
        if (!state.prevState) {
          argDefs = null;
        } else {
          switch (state.prevState.kind) {
            case RuleKinds.FIELD:
              argDefs = fieldDef && fieldDef.args;
              break;
            case RuleKinds.DIRECTIVE:
              argDefs = directiveDef && directiveDef.args;
              break;
            case RuleKinds.ALIASED_FIELD: {
              const name2 = state.prevState && state.prevState.name;
              if (!name2) {
                argDefs = null;
                break;
              }
              const field = parentType ? getFieldDef3(schema, parentType, name2) : null;
              if (!field) {
                argDefs = null;
                break;
              }
              argDefs = field.args;
              break;
            }
            default:
              argDefs = null;
              break;
          }
        }
        break;
      }
      case RuleKinds.ARGUMENT:
        if (argDefs) {
          for (let i = 0; i < argDefs.length; i++) {
            if (argDefs[i].name === state.name) {
              argDef = argDefs[i];
              break;
            }
          }
        }
        inputType = argDef && argDef.type;
        break;
      case RuleKinds.ENUM_VALUE:
        const enumType = getNamedType(inputType);
        enumValue = enumType instanceof GraphQLEnumType ? find2(enumType.getValues(), (val) => val.value === state.name) : null;
        break;
      case RuleKinds.LIST_VALUE:
        const nullableType = getNullableType(inputType);
        inputType = nullableType instanceof GraphQLList ? nullableType.ofType : null;
        break;
      case RuleKinds.OBJECT_VALUE:
        const objectType = getNamedType(inputType);
        objectFieldDefs = objectType instanceof GraphQLInputObjectType ? objectType.getFields() : null;
        break;
      case RuleKinds.OBJECT_FIELD:
        const objectField = state.name && objectFieldDefs ? objectFieldDefs[state.name] : null;
        inputType = objectField && objectField.type;
        break;
      case RuleKinds.NAMED_TYPE:
        if (state.name) {
          type2 = schema.getType(state.name);
        }
        break;
    }
  });
  return {
    argDef,
    argDefs,
    directiveDef,
    enumValue,
    fieldDef,
    inputType,
    objectFieldDefs,
    parentType,
    type: type2,
    interfaceDef,
    objectTypeDef
  };
}
function find2(array, predicate) {
  for (let i = 0; i < array.length; i++) {
    if (predicate(array[i])) {
      return array[i];
    }
  }
  return null;
}
var collectFragmentDefs, getParentDefinition;
var init_getAutocompleteSuggestions = __esm({
  "node_modules/graphql-language-service-interface/esm/getAutocompleteSuggestions.js"() {
    init_define_process_env();
    init_main();
    init_graphql2();
    init_graphql2();
    init_esm2();
    init_autocompleteUtils();
    collectFragmentDefs = (op) => {
      const externalFragments = [];
      if (op) {
        visit(parse(op, {
          experimentalFragmentVariables: true
        }), {
          FragmentDefinition(def) {
            externalFragments.push(def);
          }
        });
      }
      return externalFragments;
    };
    getParentDefinition = (state, kind) => {
      var _a2, _b, _c, _d, _e, _f, _g, _h, _j, _k;
      if (((_a2 = state.prevState) === null || _a2 === void 0 ? void 0 : _a2.kind) === kind) {
        return state.prevState;
      }
      if (((_c = (_b = state.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
        return state.prevState.prevState;
      }
      if (((_f = (_e = (_d = state.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
        return state.prevState.prevState.prevState;
      }
      if (((_k = (_j = (_h = (_g = state.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
        return state.prevState.prevState.prevState.prevState;
      }
    };
  }
});

// node_modules/graphql-language-service-interface/esm/getDefinition.js
function assert(value, message) {
  if (!value) {
    throw new Error(message);
  }
}
function getRange(text2, node) {
  const location = node.loc;
  assert(location, "Expected ASTNode to have a location.");
  return locToRange(text2, location);
}
function getPosition(text2, node) {
  const location = node.loc;
  assert(location, "Expected ASTNode to have a location.");
  return offsetToPosition(text2, location.start);
}
function getDefinitionQueryResultForNamedType(text2, node, dependencies) {
  return __awaiter(this, void 0, void 0, function* () {
    const name2 = node.name.value;
    const defNodes = dependencies.filter(({ definition }) => definition.name && definition.name.value === name2);
    if (defNodes.length === 0) {
      throw Error(`Definition not found for GraphQL type ${name2}`);
    }
    const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForNodeDefinition(filePath || "", content, definition));
    return {
      definitions,
      queryRange: definitions.map((_) => getRange(text2, node))
    };
  });
}
function getDefinitionQueryResultForFragmentSpread(text2, fragment, dependencies) {
  return __awaiter(this, void 0, void 0, function* () {
    const name2 = fragment.name.value;
    const defNodes = dependencies.filter(({ definition }) => definition.name.value === name2);
    if (defNodes.length === 0) {
      throw Error(`Definition not found for GraphQL fragment ${name2}`);
    }
    const definitions = defNodes.map(({ filePath, content, definition }) => getDefinitionForFragmentDefinition(filePath || "", content, definition));
    return {
      definitions,
      queryRange: definitions.map((_) => getRange(text2, fragment))
    };
  });
}
function getDefinitionQueryResultForDefinitionNode(path, text2, definition) {
  return {
    definitions: [getDefinitionForFragmentDefinition(path, text2, definition)],
    queryRange: definition.name ? [getRange(text2, definition.name)] : []
  };
}
function getDefinitionForFragmentDefinition(path, text2, definition) {
  const name2 = definition.name;
  if (!name2) {
    throw Error("Expected ASTNode to have a Name.");
  }
  return {
    path,
    position: getPosition(text2, definition),
    range: getRange(text2, definition),
    name: name2.value || "",
    language: LANGUAGE,
    projectRoot: path
  };
}
function getDefinitionForNodeDefinition(path, text2, definition) {
  const name2 = definition.name;
  assert(name2, "Expected ASTNode to have a Name.");
  return {
    path,
    position: getPosition(text2, definition),
    range: getRange(text2, definition),
    name: name2.value || "",
    language: LANGUAGE,
    projectRoot: path
  };
}
var __awaiter, LANGUAGE;
var init_getDefinition = __esm({
  "node_modules/graphql-language-service-interface/esm/getDefinition.js"() {
    init_define_process_env();
    init_esm();
    __awaiter = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve4) {
          resolve4(value);
        });
      }
      return new (P || (P = Promise))(function(resolve4, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    LANGUAGE = "GraphQL";
  }
});

// node_modules/graphql-language-service-interface/esm/getDiagnostics.js
function getDiagnostics(query, schema = null, customRules, isRelayCompatMode, externalFragments) {
  let ast = null;
  if (externalFragments) {
    if (typeof externalFragments === "string") {
      query += "\n\n" + externalFragments;
    } else {
      query += "\n\n" + externalFragments.reduce((agg, node) => {
        agg += print(node) + "\n\n";
        return agg;
      }, "");
    }
  }
  try {
    ast = parse(query);
  } catch (error2) {
    const range = getRange2(error2.locations[0], query);
    return [
      {
        severity: DIAGNOSTIC_SEVERITY.Error,
        message: error2.message,
        source: "GraphQL: Syntax",
        range
      }
    ];
  }
  return validateQuery(ast, schema, customRules, isRelayCompatMode);
}
function validateQuery(ast, schema = null, customRules, isRelayCompatMode) {
  if (!schema) {
    return [];
  }
  const validationErrorAnnotations = mapCat(validateWithCustomRules(schema, ast, customRules, isRelayCompatMode), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Error, "Validation"));
  const deprecationWarningAnnotations = mapCat(findDeprecatedUsages(schema, ast), (error2) => annotations(error2, DIAGNOSTIC_SEVERITY.Warning, "Deprecation"));
  return validationErrorAnnotations.concat(deprecationWarningAnnotations);
}
function mapCat(array, mapper) {
  return Array.prototype.concat.apply([], array.map(mapper));
}
function annotations(error2, severity, type2) {
  if (!error2.nodes) {
    return [];
  }
  const highlightedNodes = [];
  error2.nodes.forEach((node) => {
    const highlightNode = node.kind !== "Variable" && "name" in node && node.name !== void 0 ? node.name : "variable" in node && node.variable !== void 0 ? node.variable : node;
    if (highlightNode) {
      invariant2(error2.locations, "GraphQL validation error requires locations.");
      const loc = error2.locations[0];
      const highlightLoc = getLocation2(highlightNode);
      const end = loc.column + (highlightLoc.end - highlightLoc.start);
      highlightedNodes.push({
        source: `GraphQL: ${type2}`,
        message: error2.message,
        severity,
        range: new Range(new Position(loc.line - 1, loc.column - 1), new Position(loc.line - 1, end))
      });
    }
  });
  return highlightedNodes;
}
function getRange2(location, queryText) {
  const parser = onlineParser();
  const state = parser.startState();
  const lines = queryText.split("\n");
  invariant2(lines.length >= location.line, "Query text must have more lines than where the error happened");
  let stream = null;
  for (let i = 0; i < location.line; i++) {
    stream = new CharacterStream(lines[i]);
    while (!stream.eol()) {
      const style = parser.token(stream, state);
      if (style === "invalidchar") {
        break;
      }
    }
  }
  invariant2(stream, "Expected Parser stream to be available.");
  const line = location.line - 1;
  const start = stream.getStartOfToken();
  const end = stream.getCurrentPosition();
  return new Range(new Position(line, start), new Position(line, end));
}
function getLocation2(node) {
  const typeCastedNode = node;
  const location = typeCastedNode.loc;
  invariant2(location, "Expected ASTNode to have a location.");
  return location;
}
var SEVERITY, DIAGNOSTIC_SEVERITY, invariant2;
var init_getDiagnostics = __esm({
  "node_modules/graphql-language-service-interface/esm/getDiagnostics.js"() {
    init_define_process_env();
    init_graphql2();
    init_graphql2();
    init_esm2();
    init_esm();
    SEVERITY = {
      Error: "Error",
      Warning: "Warning",
      Information: "Information",
      Hint: "Hint"
    };
    DIAGNOSTIC_SEVERITY = {
      [SEVERITY.Error]: 1,
      [SEVERITY.Warning]: 2,
      [SEVERITY.Information]: 3,
      [SEVERITY.Hint]: 4
    };
    invariant2 = (condition, message) => {
      if (!condition) {
        throw new Error(message);
      }
    };
  }
});

// node_modules/graphql-language-service-interface/esm/getOutline.js
function getOutline(documentText) {
  let ast;
  try {
    ast = parse(documentText);
  } catch (error2) {
    return null;
  }
  const visitorFns = outlineTreeConverter(documentText);
  const outlineTrees = visit(ast, {
    leave(node) {
      if (visitorFns !== void 0 && node.kind in visitorFns) {
        return visitorFns[node.kind](node);
      }
      return null;
    }
  });
  return { outlineTrees };
}
function outlineTreeConverter(docText) {
  const meta = (node) => {
    return {
      representativeName: node.name,
      startPosition: offsetToPosition(docText, node.loc.start),
      endPosition: offsetToPosition(docText, node.loc.end),
      kind: node.kind,
      children: node.selectionSet || node.fields || node.values || node.arguments || []
    };
  };
  return {
    Field: (node) => {
      const tokenizedText = node.alias ? [buildToken("plain", node.alias), buildToken("plain", ": ")] : [];
      tokenizedText.push(buildToken("plain", node.name));
      return Object.assign({ tokenizedText }, meta(node));
    },
    OperationDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", node.operation),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    Document: (node) => node.definitions,
    SelectionSet: (node) => concatMap(node.selections, (child) => {
      return child.kind === INLINE_FRAGMENT ? child.selectionSet : child;
    }),
    Name: (node) => node.value,
    FragmentDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "fragment"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InterfaceTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "interface"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    EnumTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "enum"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    EnumValueDefinition: (node) => Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node)),
    ObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "type"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InputObjectTypeDefinition: (node) => Object.assign({ tokenizedText: [
      buildToken("keyword", "input"),
      buildToken("whitespace", " "),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    FragmentSpread: (node) => Object.assign({ tokenizedText: [
      buildToken("plain", "..."),
      buildToken("class-name", node.name)
    ] }, meta(node)),
    InputValueDefinition: (node) => {
      return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
    },
    FieldDefinition: (node) => {
      return Object.assign({ tokenizedText: [buildToken("plain", node.name)] }, meta(node));
    },
    InlineFragment: (node) => node.selectionSet
  };
}
function buildToken(kind, value) {
  return { kind, value };
}
function concatMap(arr, fn) {
  const res = [];
  for (let i = 0; i < arr.length; i++) {
    const x = fn(arr[i], i);
    if (Array.isArray(x)) {
      res.push(...x);
    } else {
      res.push(x);
    }
  }
  return res;
}
var INLINE_FRAGMENT;
var init_getOutline = __esm({
  "node_modules/graphql-language-service-interface/esm/getOutline.js"() {
    init_define_process_env();
    init_graphql2();
    init_esm();
    ({ INLINE_FRAGMENT } = Kind);
  }
});

// node_modules/graphql-language-service-interface/esm/getHoverInformation.js
function getHoverInformation(schema, queryText, cursor, contextToken) {
  const token = contextToken || getTokenAtPosition(queryText, cursor);
  if (!schema || !token || !token.state) {
    return "";
  }
  const state = token.state;
  const kind = state.kind;
  const step = state.step;
  const typeInfo = getTypeInfo(schema, token.state);
  const options = { schema };
  if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
    const into = [];
    renderField(into, typeInfo, options);
    renderDescription(into, options, typeInfo.fieldDef);
    return into.join("").trim();
  } else if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
    const into = [];
    renderDirective(into, typeInfo, options);
    renderDescription(into, options, typeInfo.directiveDef);
    return into.join("").trim();
  } else if (kind === "Argument" && step === 0 && typeInfo.argDef) {
    const into = [];
    renderArg(into, typeInfo, options);
    renderDescription(into, options, typeInfo.argDef);
    return into.join("").trim();
  } else if (kind === "EnumValue" && typeInfo.enumValue && "description" in typeInfo.enumValue) {
    const into = [];
    renderEnumValue(into, typeInfo, options);
    renderDescription(into, options, typeInfo.enumValue);
    return into.join("").trim();
  } else if (kind === "NamedType" && typeInfo.type && "description" in typeInfo.type) {
    const into = [];
    renderType2(into, typeInfo, options, typeInfo.type);
    renderDescription(into, options, typeInfo.type);
    return into.join("").trim();
  }
  return "";
}
function renderField(into, typeInfo, options) {
  renderQualifiedField(into, typeInfo, options);
  renderTypeAnnotation(into, typeInfo, options, typeInfo.type);
}
function renderQualifiedField(into, typeInfo, options) {
  if (!typeInfo.fieldDef) {
    return;
  }
  const fieldName = typeInfo.fieldDef.name;
  if (fieldName.slice(0, 2) !== "__") {
    renderType2(into, typeInfo, options, typeInfo.parentType);
    text(into, ".");
  }
  text(into, fieldName);
}
function renderDirective(into, typeInfo, _options) {
  if (!typeInfo.directiveDef) {
    return;
  }
  const name2 = "@" + typeInfo.directiveDef.name;
  text(into, name2);
}
function renderArg(into, typeInfo, options) {
  if (typeInfo.directiveDef) {
    renderDirective(into, typeInfo, options);
  } else if (typeInfo.fieldDef) {
    renderQualifiedField(into, typeInfo, options);
  }
  if (!typeInfo.argDef) {
    return;
  }
  const name2 = typeInfo.argDef.name;
  text(into, "(");
  text(into, name2);
  renderTypeAnnotation(into, typeInfo, options, typeInfo.inputType);
  text(into, ")");
}
function renderTypeAnnotation(into, typeInfo, options, t2) {
  text(into, ": ");
  renderType2(into, typeInfo, options, t2);
}
function renderEnumValue(into, typeInfo, options) {
  if (!typeInfo.enumValue) {
    return;
  }
  const name2 = typeInfo.enumValue.name;
  renderType2(into, typeInfo, options, typeInfo.inputType);
  text(into, ".");
  text(into, name2);
}
function renderType2(into, typeInfo, options, t2) {
  if (!t2) {
    return;
  }
  if (t2 instanceof GraphQLNonNull) {
    renderType2(into, typeInfo, options, t2.ofType);
    text(into, "!");
  } else if (t2 instanceof GraphQLList) {
    text(into, "[");
    renderType2(into, typeInfo, options, t2.ofType);
    text(into, "]");
  } else {
    text(into, t2.name);
  }
}
function renderDescription(into, options, def) {
  if (!def) {
    return;
  }
  const description = typeof def.description === "string" ? def.description : null;
  if (description) {
    text(into, "\n\n");
    text(into, description);
  }
  renderDeprecation(into, options, def);
}
function renderDeprecation(into, _options, def) {
  if (!def) {
    return;
  }
  const reason = def.deprecationReason ? def.deprecationReason : null;
  if (!reason) {
    return;
  }
  text(into, "\n\n");
  text(into, "Deprecated: ");
  text(into, reason);
}
function text(into, content) {
  into.push(content);
}
var init_getHoverInformation = __esm({
  "node_modules/graphql-language-service-interface/esm/getHoverInformation.js"() {
    init_define_process_env();
    init_graphql2();
    init_getAutocompleteSuggestions();
  }
});

// node_modules/graphql-language-service-interface/esm/GraphQLLanguageService.js
function getKind(tree) {
  if (tree.kind === "FieldDefinition" && tree.children && tree.children.length > 0) {
    return KIND_TO_SYMBOL_KIND.FieldWithArguments;
  }
  return KIND_TO_SYMBOL_KIND[tree.kind];
}
var __awaiter2, FRAGMENT_DEFINITION, OBJECT_TYPE_DEFINITION, INTERFACE_TYPE_DEFINITION, ENUM_TYPE_DEFINITION, UNION_TYPE_DEFINITION, SCALAR_TYPE_DEFINITION, INPUT_OBJECT_TYPE_DEFINITION, SCALAR_TYPE_EXTENSION, OBJECT_TYPE_EXTENSION, INTERFACE_TYPE_EXTENSION, UNION_TYPE_EXTENSION, ENUM_TYPE_EXTENSION, INPUT_OBJECT_TYPE_EXTENSION, DIRECTIVE_DEFINITION, FRAGMENT_SPREAD, OPERATION_DEFINITION, NAMED_TYPE, KIND_TO_SYMBOL_KIND, GraphQLLanguageService;
var init_GraphQLLanguageService = __esm({
  "node_modules/graphql-language-service-interface/esm/GraphQLLanguageService.js"() {
    init_define_process_env();
    init_main();
    init_graphql2();
    init_getAutocompleteSuggestions();
    init_getHoverInformation();
    init_getDiagnostics();
    init_getDefinition();
    init_getOutline();
    init_esm();
    __awaiter2 = function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve4) {
          resolve4(value);
        });
      }
      return new (P || (P = Promise))(function(resolve4, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    ({ FRAGMENT_DEFINITION, OBJECT_TYPE_DEFINITION, INTERFACE_TYPE_DEFINITION, ENUM_TYPE_DEFINITION, UNION_TYPE_DEFINITION, SCALAR_TYPE_DEFINITION, INPUT_OBJECT_TYPE_DEFINITION, SCALAR_TYPE_EXTENSION, OBJECT_TYPE_EXTENSION, INTERFACE_TYPE_EXTENSION, UNION_TYPE_EXTENSION, ENUM_TYPE_EXTENSION, INPUT_OBJECT_TYPE_EXTENSION, DIRECTIVE_DEFINITION, FRAGMENT_SPREAD, OPERATION_DEFINITION, NAMED_TYPE } = Kind);
    KIND_TO_SYMBOL_KIND = {
      [Kind.FIELD]: SymbolKind.Field,
      [Kind.OPERATION_DEFINITION]: SymbolKind.Class,
      [Kind.FRAGMENT_DEFINITION]: SymbolKind.Class,
      [Kind.FRAGMENT_SPREAD]: SymbolKind.Struct,
      [Kind.OBJECT_TYPE_DEFINITION]: SymbolKind.Class,
      [Kind.ENUM_TYPE_DEFINITION]: SymbolKind.Enum,
      [Kind.ENUM_VALUE_DEFINITION]: SymbolKind.EnumMember,
      [Kind.INPUT_OBJECT_TYPE_DEFINITION]: SymbolKind.Class,
      [Kind.INPUT_VALUE_DEFINITION]: SymbolKind.Field,
      [Kind.FIELD_DEFINITION]: SymbolKind.Field,
      [Kind.INTERFACE_TYPE_DEFINITION]: SymbolKind.Interface,
      [Kind.DOCUMENT]: SymbolKind.File,
      FieldWithArguments: SymbolKind.Method
    };
    GraphQLLanguageService = class {
      constructor(cache) {
        this._graphQLCache = cache;
        this._graphQLConfig = cache.getGraphQLConfig();
      }
      getConfigForURI(uri) {
        const config = this._graphQLCache.getProjectForFile(uri);
        if (config) {
          return config;
        }
        throw Error(`No config found for uri: ${uri}`);
      }
      getDiagnostics(query, uri, isRelayCompatMode) {
        return __awaiter2(this, void 0, void 0, function* () {
          let queryHasExtensions = false;
          const projectConfig = this.getConfigForURI(uri);
          if (!projectConfig) {
            return [];
          }
          const { schema: schemaPath, name: projectName, extensions } = projectConfig;
          try {
            const queryAST = parse(query);
            if (!schemaPath || uri !== schemaPath) {
              queryHasExtensions = queryAST.definitions.some((definition) => {
                switch (definition.kind) {
                  case OBJECT_TYPE_DEFINITION:
                  case INTERFACE_TYPE_DEFINITION:
                  case ENUM_TYPE_DEFINITION:
                  case UNION_TYPE_DEFINITION:
                  case SCALAR_TYPE_DEFINITION:
                  case INPUT_OBJECT_TYPE_DEFINITION:
                  case SCALAR_TYPE_EXTENSION:
                  case OBJECT_TYPE_EXTENSION:
                  case INTERFACE_TYPE_EXTENSION:
                  case UNION_TYPE_EXTENSION:
                  case ENUM_TYPE_EXTENSION:
                  case INPUT_OBJECT_TYPE_EXTENSION:
                  case DIRECTIVE_DEFINITION:
                    return true;
                }
                return false;
              });
            }
          } catch (error2) {
            const range = getRange2(error2.locations[0], query);
            return [
              {
                severity: DIAGNOSTIC_SEVERITY.Error,
                message: error2.message,
                source: "GraphQL: Syntax",
                range
              }
            ];
          }
          let source = query;
          const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
          const fragmentDependencies = yield this._graphQLCache.getFragmentDependencies(query, fragmentDefinitions);
          const dependenciesSource = fragmentDependencies.reduce((prev, cur) => `${prev} ${print(cur.definition)}`, "");
          source = `${source} ${dependenciesSource}`;
          let validationAst = null;
          try {
            validationAst = parse(source);
          } catch (error2) {
            return [];
          }
          let customRules = null;
          if ((extensions === null || extensions === void 0 ? void 0 : extensions.customValidationRules) && typeof extensions.customValidationRules === "function") {
            customRules = extensions.customValidationRules(this._graphQLConfig);
          }
          const schema = yield this._graphQLCache.getSchema(projectName, queryHasExtensions);
          if (!schema) {
            return [];
          }
          return validateQuery(validationAst, schema, customRules, isRelayCompatMode);
        });
      }
      getAutocompleteSuggestions(query, position, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          const projectConfig = this.getConfigForURI(filePath);
          const schema = yield this._graphQLCache.getSchema(projectConfig.name);
          const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
          const fragmentInfo = Array.from(fragmentDefinitions).map(([, info]) => info.definition);
          if (schema) {
            return getAutocompleteSuggestions(schema, query, position, void 0, fragmentInfo);
          }
          return [];
        });
      }
      getHoverInformation(query, position, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          const projectConfig = this.getConfigForURI(filePath);
          const schema = yield this._graphQLCache.getSchema(projectConfig.name);
          if (schema) {
            return getHoverInformation(schema, query, position);
          }
          return "";
        });
      }
      getDefinition(query, position, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          const projectConfig = this.getConfigForURI(filePath);
          let ast;
          try {
            ast = parse(query);
          } catch (error2) {
            return null;
          }
          const node = getASTNodeAtPosition(query, ast, position);
          if (node) {
            switch (node.kind) {
              case FRAGMENT_SPREAD:
                return this._getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig);
              case FRAGMENT_DEFINITION:
              case OPERATION_DEFINITION:
                return getDefinitionQueryResultForDefinitionNode(filePath, query, node);
              case NAMED_TYPE:
                return this._getDefinitionForNamedType(query, ast, node, filePath, projectConfig);
            }
          }
          return null;
        });
      }
      getDocumentSymbols(document2, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          const outline = yield this.getOutline(document2);
          if (!outline) {
            return [];
          }
          const output = [];
          const input = outline.outlineTrees.map((tree) => [null, tree]);
          while (input.length > 0) {
            const res = input.pop();
            if (!res) {
              return [];
            }
            const [parent, tree] = res;
            if (!tree) {
              return [];
            }
            output.push({
              name: tree.representativeName,
              kind: getKind(tree),
              location: {
                uri: filePath,
                range: {
                  start: tree.startPosition,
                  end: tree.endPosition
                }
              },
              containerName: parent ? parent.representativeName : void 0
            });
            input.push(...tree.children.map((child) => [tree, child]));
          }
          return output;
        });
      }
      _getDefinitionForNamedType(query, ast, node, filePath, projectConfig) {
        return __awaiter2(this, void 0, void 0, function* () {
          const objectTypeDefinitions = yield this._graphQLCache.getObjectTypeDefinitions(projectConfig);
          const dependencies = yield this._graphQLCache.getObjectTypeDependenciesForAST(ast, objectTypeDefinitions);
          const localObjectTypeDefinitions = ast.definitions.filter((definition) => definition.kind === OBJECT_TYPE_DEFINITION || definition.kind === INPUT_OBJECT_TYPE_DEFINITION || definition.kind === ENUM_TYPE_DEFINITION || definition.kind === SCALAR_TYPE_DEFINITION || definition.kind === INTERFACE_TYPE_DEFINITION);
          const typeCastedDefs = localObjectTypeDefinitions;
          const localOperationDefinationInfos = typeCastedDefs.map((definition) => ({
            filePath,
            content: query,
            definition
          }));
          const result = yield getDefinitionQueryResultForNamedType(query, node, dependencies.concat(localOperationDefinationInfos));
          return result;
        });
      }
      _getDefinitionForFragmentSpread(query, ast, node, filePath, projectConfig) {
        return __awaiter2(this, void 0, void 0, function* () {
          const fragmentDefinitions = yield this._graphQLCache.getFragmentDefinitions(projectConfig);
          const dependencies = yield this._graphQLCache.getFragmentDependenciesForAST(ast, fragmentDefinitions);
          const localFragDefinitions = ast.definitions.filter((definition) => definition.kind === FRAGMENT_DEFINITION);
          const typeCastedDefs = localFragDefinitions;
          const localFragInfos = typeCastedDefs.map((definition) => ({
            filePath,
            content: query,
            definition
          }));
          const result = yield getDefinitionQueryResultForFragmentSpread(query, node, dependencies.concat(localFragInfos));
          return result;
        });
      }
      getOutline(documentText) {
        return __awaiter2(this, void 0, void 0, function* () {
          return getOutline(documentText);
        });
      }
    };
  }
});

// node_modules/graphql-language-service-interface/esm/index.js
var esm_exports3 = {};
__export(esm_exports3, {
  DIAGNOSTIC_SEVERITY: () => DIAGNOSTIC_SEVERITY,
  GraphQLLanguageService: () => GraphQLLanguageService,
  LANGUAGE: () => LANGUAGE,
  SEVERITY: () => SEVERITY,
  canUseDirective: () => canUseDirective,
  forEachState: () => forEachState,
  getAutocompleteSuggestions: () => getAutocompleteSuggestions,
  getDefinitionQueryResultForDefinitionNode: () => getDefinitionQueryResultForDefinitionNode,
  getDefinitionQueryResultForFragmentSpread: () => getDefinitionQueryResultForFragmentSpread,
  getDefinitionQueryResultForNamedType: () => getDefinitionQueryResultForNamedType,
  getDefinitionState: () => getDefinitionState,
  getDiagnostics: () => getDiagnostics,
  getFieldDef: () => getFieldDef3,
  getFragmentDefinitions: () => getFragmentDefinitions,
  getHoverInformation: () => getHoverInformation,
  getOutline: () => getOutline,
  getRange: () => getRange2,
  getTokenAtPosition: () => getTokenAtPosition,
  getTypeInfo: () => getTypeInfo,
  getVariableCompletions: () => getVariableCompletions,
  hintList: () => hintList,
  objectValues: () => objectValues2,
  runOnlineParser: () => runOnlineParser,
  validateQuery: () => validateQuery
});
var init_esm3 = __esm({
  "node_modules/graphql-language-service-interface/esm/index.js"() {
    init_define_process_env();
    init_autocompleteUtils();
    init_getAutocompleteSuggestions();
    init_getDefinition();
    init_getDiagnostics();
    init_getOutline();
    init_getHoverInformation();
    init_GraphQLLanguageService();
  }
});

// node_modules/codemirror-graphql/hint.js
var require_hint = __commonJS({
  "node_modules/codemirror-graphql/hint.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    require_show_hint();
    var graphql_language_service_interface_1 = (init_esm3(), esm_exports3);
    var graphql_language_service_utils_1 = (init_esm(), esm_exports);
    codemirror_1.default.registerHelper("hint", "graphql", function(editor, options) {
      var schema = options.schema;
      if (!schema) {
        return;
      }
      var cur = editor.getCursor();
      var token = editor.getTokenAt(cur);
      var tokenStart = token.type !== null && /"|\w/.test(token.string[0]) ? token.start : token.end;
      var position = new graphql_language_service_utils_1.Position(cur.line, tokenStart);
      var rawResults = graphql_language_service_interface_1.getAutocompleteSuggestions(schema, editor.getValue(), position, token, options.externalFragments);
      var results = {
        list: rawResults.map(function(item) {
          return {
            text: item.label,
            type: item.type,
            description: item.documentation,
            isDeprecated: item.isDeprecated,
            deprecationReason: item.deprecationReason
          };
        }),
        from: { line: cur.line, ch: tokenStart },
        to: { line: cur.line, ch: token.end }
      };
      if (results && results.list && results.list.length > 0) {
        results.from = codemirror_1.default.Pos(results.from.line, results.from.ch);
        results.to = codemirror_1.default.Pos(results.to.line, results.to.ch);
        codemirror_1.default.signal(editor, "hasCompletion", editor, results, token);
      }
      return results;
    });
  }
});

// node_modules/codemirror-graphql/lint.js
var require_lint2 = __commonJS({
  "node_modules/codemirror-graphql/lint.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_language_service_interface_1 = (init_esm3(), esm_exports3);
    var SEVERITY2 = ["error", "warning", "information", "hint"];
    var TYPE = {
      "GraphQL: Validation": "validation",
      "GraphQL: Deprecation": "deprecation",
      "GraphQL: Syntax": "syntax"
    };
    codemirror_1.default.registerHelper("lint", "graphql", function(text2, options) {
      var schema = options.schema;
      var rawResults = graphql_language_service_interface_1.getDiagnostics(text2, schema, options.validationRules, void 0, options.externalFragments);
      var results = rawResults.map(function(error2) {
        return {
          message: error2.message,
          severity: error2.severity ? SEVERITY2[error2.severity - 1] : SEVERITY2[0],
          type: error2.source ? TYPE[error2.source] : void 0,
          from: codemirror_1.default.Pos(error2.range.start.line, error2.range.start.character),
          to: codemirror_1.default.Pos(error2.range.end.line, error2.range.end.character)
        };
      });
      return results;
    });
  }
});

// node_modules/codemirror-graphql/utils/forEachState.js
var require_forEachState = __commonJS({
  "node_modules/codemirror-graphql/utils/forEachState.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function forEachState2(stack, fn) {
      var reverseStateStack = [];
      var state = stack;
      while (state && state.kind) {
        reverseStateStack.push(state);
        state = state.prevState;
      }
      for (var i = reverseStateStack.length - 1; i >= 0; i--) {
        fn(reverseStateStack[i]);
      }
    }
    exports.default = forEachState2;
  }
});

// node_modules/codemirror-graphql/utils/getTypeInfo.js
var require_getTypeInfo = __commonJS({
  "node_modules/codemirror-graphql/utils/getTypeInfo.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var graphql_1 = (init_graphql2(), graphql_exports);
    var introspection_1 = (init_introspection(), introspection_exports);
    var forEachState_1 = __importDefault(require_forEachState());
    function getTypeInfo2(schema, tokenState) {
      var info = {
        schema,
        type: null,
        parentType: null,
        inputType: null,
        directiveDef: null,
        fieldDef: null,
        argDef: null,
        argDefs: null,
        objectFieldDefs: null
      };
      forEachState_1.default(tokenState, function(state) {
        switch (state.kind) {
          case "Query":
          case "ShortQuery":
            info.type = schema.getQueryType();
            break;
          case "Mutation":
            info.type = schema.getMutationType();
            break;
          case "Subscription":
            info.type = schema.getSubscriptionType();
            break;
          case "InlineFragment":
          case "FragmentDefinition":
            if (state.type) {
              info.type = schema.getType(state.type);
            }
            break;
          case "Field":
          case "AliasedField":
            info.fieldDef = info.type && state.name ? getFieldDef4(schema, info.parentType, state.name) : null;
            info.type = info.fieldDef && info.fieldDef.type;
            break;
          case "SelectionSet":
            info.parentType = info.type ? graphql_1.getNamedType(info.type) : null;
            break;
          case "Directive":
            info.directiveDef = state.name ? schema.getDirective(state.name) : null;
            break;
          case "Arguments":
            var parentDef = state.prevState ? state.prevState.kind === "Field" ? info.fieldDef : state.prevState.kind === "Directive" ? info.directiveDef : state.prevState.kind === "AliasedField" ? state.prevState.name && getFieldDef4(schema, info.parentType, state.prevState.name) : null : null;
            info.argDefs = parentDef ? parentDef.args : null;
            break;
          case "Argument":
            info.argDef = null;
            if (info.argDefs) {
              for (var i = 0; i < info.argDefs.length; i++) {
                if (info.argDefs[i].name === state.name) {
                  info.argDef = info.argDefs[i];
                  break;
                }
              }
            }
            info.inputType = info.argDef && info.argDef.type;
            break;
          case "EnumValue":
            var enumType = info.inputType ? graphql_1.getNamedType(info.inputType) : null;
            info.enumValue = enumType instanceof graphql_1.GraphQLEnumType ? find4(enumType.getValues(), function(val) {
              return val.value === state.name;
            }) : null;
            break;
          case "ListValue":
            var nullableType = info.inputType ? graphql_1.getNullableType(info.inputType) : null;
            info.inputType = nullableType instanceof graphql_1.GraphQLList ? nullableType.ofType : null;
            break;
          case "ObjectValue":
            var objectType = info.inputType ? graphql_1.getNamedType(info.inputType) : null;
            info.objectFieldDefs = objectType instanceof graphql_1.GraphQLInputObjectType ? objectType.getFields() : null;
            break;
          case "ObjectField":
            var objectField = state.name && info.objectFieldDefs ? info.objectFieldDefs[state.name] : null;
            info.inputType = objectField && objectField.type;
            break;
          case "NamedType":
            info.type = state.name ? schema.getType(state.name) : null;
            break;
        }
      });
      return info;
    }
    exports.default = getTypeInfo2;
    function getFieldDef4(schema, type2, fieldName) {
      if (fieldName === introspection_1.SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
        return introspection_1.SchemaMetaFieldDef;
      }
      if (fieldName === introspection_1.TypeMetaFieldDef.name && schema.getQueryType() === type2) {
        return introspection_1.TypeMetaFieldDef;
      }
      if (fieldName === introspection_1.TypeNameMetaFieldDef.name && graphql_1.isCompositeType(type2)) {
        return introspection_1.TypeNameMetaFieldDef;
      }
      if (type2 && type2.getFields) {
        return type2.getFields()[fieldName];
      }
    }
    function find4(array, predicate) {
      for (var i = 0; i < array.length; i++) {
        if (predicate(array[i])) {
          return array[i];
        }
      }
    }
  }
});

// node_modules/codemirror-graphql/utils/SchemaReference.js
var require_SchemaReference = __commonJS({
  "node_modules/codemirror-graphql/utils/SchemaReference.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getTypeReference = exports.getEnumValueReference = exports.getArgumentReference = exports.getDirectiveReference = exports.getFieldReference = void 0;
    var graphql_1 = (init_graphql2(), graphql_exports);
    function getFieldReference(typeInfo) {
      return {
        kind: "Field",
        schema: typeInfo.schema,
        field: typeInfo.fieldDef,
        type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType
      };
    }
    exports.getFieldReference = getFieldReference;
    function getDirectiveReference(typeInfo) {
      return {
        kind: "Directive",
        schema: typeInfo.schema,
        directive: typeInfo.directiveDef
      };
    }
    exports.getDirectiveReference = getDirectiveReference;
    function getArgumentReference(typeInfo) {
      return typeInfo.directiveDef ? {
        kind: "Argument",
        schema: typeInfo.schema,
        argument: typeInfo.argDef,
        directive: typeInfo.directiveDef
      } : {
        kind: "Argument",
        schema: typeInfo.schema,
        argument: typeInfo.argDef,
        field: typeInfo.fieldDef,
        type: isMetaField(typeInfo.fieldDef) ? null : typeInfo.parentType
      };
    }
    exports.getArgumentReference = getArgumentReference;
    function getEnumValueReference(typeInfo) {
      return {
        kind: "EnumValue",
        value: typeInfo.enumValue || void 0,
        type: typeInfo.inputType ? graphql_1.getNamedType(typeInfo.inputType) : void 0
      };
    }
    exports.getEnumValueReference = getEnumValueReference;
    function getTypeReference(typeInfo, type2) {
      return {
        kind: "Type",
        schema: typeInfo.schema,
        type: type2 || typeInfo.type
      };
    }
    exports.getTypeReference = getTypeReference;
    function isMetaField(fieldDef) {
      return fieldDef.name.slice(0, 2) === "__";
    }
  }
});

// node_modules/codemirror-graphql/utils/info-addon.js
var require_info_addon = __commonJS({
  "node_modules/codemirror-graphql/utils/info-addon.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    codemirror_1.default.defineOption("info", false, function(cm, options, old) {
      if (old && old !== codemirror_1.default.Init) {
        var oldOnMouseOver = cm.state.info.onMouseOver;
        codemirror_1.default.off(cm.getWrapperElement(), "mouseover", oldOnMouseOver);
        clearTimeout(cm.state.info.hoverTimeout);
        delete cm.state.info;
      }
      if (options) {
        var state = cm.state.info = createState(options);
        state.onMouseOver = onMouseOver.bind(null, cm);
        codemirror_1.default.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
      }
    });
    function createState(options) {
      return {
        options: options instanceof Function ? { render: options } : options === true ? {} : options
      };
    }
    function getHoverTime(cm) {
      var options = cm.state.info.options;
      return options && options.hoverTime || 500;
    }
    function onMouseOver(cm, e) {
      var state = cm.state.info;
      var target = e.target || e.srcElement;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if (target.nodeName !== "SPAN" || state.hoverTimeout !== void 0) {
        return;
      }
      var box = target.getBoundingClientRect();
      var onMouseMove = function() {
        clearTimeout(state.hoverTimeout);
        state.hoverTimeout = setTimeout(onHover, hoverTime);
      };
      var onMouseOut = function() {
        codemirror_1.default.off(document, "mousemove", onMouseMove);
        codemirror_1.default.off(cm.getWrapperElement(), "mouseout", onMouseOut);
        clearTimeout(state.hoverTimeout);
        state.hoverTimeout = void 0;
      };
      var onHover = function() {
        codemirror_1.default.off(document, "mousemove", onMouseMove);
        codemirror_1.default.off(cm.getWrapperElement(), "mouseout", onMouseOut);
        state.hoverTimeout = void 0;
        onMouseHover(cm, box);
      };
      var hoverTime = getHoverTime(cm);
      state.hoverTimeout = setTimeout(onHover, hoverTime);
      codemirror_1.default.on(document, "mousemove", onMouseMove);
      codemirror_1.default.on(cm.getWrapperElement(), "mouseout", onMouseOut);
    }
    function onMouseHover(cm, box) {
      var pos = cm.coordsChar({
        left: (box.left + box.right) / 2,
        top: (box.top + box.bottom) / 2
      });
      var state = cm.state.info;
      var options = state.options;
      var render = options.render || cm.getHelper(pos, "info");
      if (render) {
        var token = cm.getTokenAt(pos, true);
        if (token) {
          var info = render(token, options, cm, pos);
          if (info) {
            showPopup(cm, box, info);
          }
        }
      }
    }
    function showPopup(cm, box, info) {
      var popup = document.createElement("div");
      popup.className = "CodeMirror-info";
      popup.appendChild(info);
      document.body.appendChild(popup);
      var popupBox = popup.getBoundingClientRect();
      var popupStyle = window.getComputedStyle(popup);
      var popupWidth = popupBox.right - popupBox.left + parseFloat(popupStyle.marginLeft) + parseFloat(popupStyle.marginRight);
      var popupHeight = popupBox.bottom - popupBox.top + parseFloat(popupStyle.marginTop) + parseFloat(popupStyle.marginBottom);
      var topPos = box.bottom;
      if (popupHeight > window.innerHeight - box.bottom - 15 && box.top > window.innerHeight - box.bottom) {
        topPos = box.top - popupHeight;
      }
      if (topPos < 0) {
        topPos = box.bottom;
      }
      var leftPos = Math.max(0, window.innerWidth - popupWidth - 15);
      if (leftPos > box.left) {
        leftPos = box.left;
      }
      popup.style.opacity = "1";
      popup.style.top = topPos + "px";
      popup.style.left = leftPos + "px";
      var popupTimeout;
      var onMouseOverPopup = function() {
        clearTimeout(popupTimeout);
      };
      var onMouseOut = function() {
        clearTimeout(popupTimeout);
        popupTimeout = setTimeout(hidePopup, 200);
      };
      var hidePopup = function() {
        codemirror_1.default.off(popup, "mouseover", onMouseOverPopup);
        codemirror_1.default.off(popup, "mouseout", onMouseOut);
        codemirror_1.default.off(cm.getWrapperElement(), "mouseout", onMouseOut);
        if (popup.style.opacity) {
          popup.style.opacity = "0";
          setTimeout(function() {
            if (popup.parentNode) {
              popup.parentNode.removeChild(popup);
            }
          }, 600);
        } else if (popup.parentNode) {
          popup.parentNode.removeChild(popup);
        }
      };
      codemirror_1.default.on(popup, "mouseover", onMouseOverPopup);
      codemirror_1.default.on(popup, "mouseout", onMouseOut);
      codemirror_1.default.on(cm.getWrapperElement(), "mouseout", onMouseOut);
    }
  }
});

// node_modules/codemirror-graphql/info.js
var require_info = __commonJS({
  "node_modules/codemirror-graphql/info.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var graphql_1 = (init_graphql2(), graphql_exports);
    var codemirror_1 = __importDefault(require_codemirror());
    var getTypeInfo_1 = __importDefault(require_getTypeInfo());
    var SchemaReference_1 = require_SchemaReference();
    require_info_addon();
    codemirror_1.default.registerHelper("info", "graphql", function(token, options) {
      if (!options.schema || !token.state) {
        return;
      }
      var state = token.state;
      var kind = state.kind;
      var step = state.step;
      var typeInfo = getTypeInfo_1.default(options.schema, token.state);
      if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
        var into = document.createElement("div");
        renderField2(into, typeInfo, options);
        renderDescription2(into, options, typeInfo.fieldDef);
        return into;
      } else if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
        var into = document.createElement("div");
        renderDirective2(into, typeInfo, options);
        renderDescription2(into, options, typeInfo.directiveDef);
        return into;
      } else if (kind === "Argument" && step === 0 && typeInfo.argDef) {
        var into = document.createElement("div");
        renderArg2(into, typeInfo, options);
        renderDescription2(into, options, typeInfo.argDef);
        return into;
      } else if (kind === "EnumValue" && typeInfo.enumValue && typeInfo.enumValue.description) {
        var into = document.createElement("div");
        renderEnumValue2(into, typeInfo, options);
        renderDescription2(into, options, typeInfo.enumValue);
        return into;
      } else if (kind === "NamedType" && typeInfo.type && typeInfo.type.description) {
        var into = document.createElement("div");
        renderType4(into, typeInfo, options, typeInfo.type);
        renderDescription2(into, options, typeInfo.type);
        return into;
      }
    });
    function renderField2(into, typeInfo, options) {
      renderQualifiedField2(into, typeInfo, options);
      renderTypeAnnotation2(into, typeInfo, options, typeInfo.type);
    }
    function renderQualifiedField2(into, typeInfo, options) {
      var _a2;
      var fieldName = ((_a2 = typeInfo.fieldDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
      if (fieldName.slice(0, 2) !== "__") {
        renderType4(into, typeInfo, options, typeInfo.parentType);
        text2(into, ".");
      }
      text2(into, fieldName, "field-name", options, SchemaReference_1.getFieldReference(typeInfo));
    }
    function renderDirective2(into, typeInfo, options) {
      var _a2;
      var name2 = "@" + (((_a2 = typeInfo.directiveDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "");
      text2(into, name2, "directive-name", options, SchemaReference_1.getDirectiveReference(typeInfo));
    }
    function renderArg2(into, typeInfo, options) {
      var _a2;
      if (typeInfo.directiveDef) {
        renderDirective2(into, typeInfo, options);
      } else if (typeInfo.fieldDef) {
        renderQualifiedField2(into, typeInfo, options);
      }
      var name2 = ((_a2 = typeInfo.argDef) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
      text2(into, "(");
      text2(into, name2, "arg-name", options, SchemaReference_1.getArgumentReference(typeInfo));
      renderTypeAnnotation2(into, typeInfo, options, typeInfo.inputType);
      text2(into, ")");
    }
    function renderTypeAnnotation2(into, typeInfo, options, t2) {
      text2(into, ": ");
      renderType4(into, typeInfo, options, t2);
    }
    function renderEnumValue2(into, typeInfo, options) {
      var _a2;
      var name2 = ((_a2 = typeInfo.enumValue) === null || _a2 === void 0 ? void 0 : _a2.name) || "";
      renderType4(into, typeInfo, options, typeInfo.inputType);
      text2(into, ".");
      text2(into, name2, "enum-value", options, SchemaReference_1.getEnumValueReference(typeInfo));
    }
    function renderType4(into, typeInfo, options, t2) {
      if (t2 instanceof graphql_1.GraphQLNonNull) {
        renderType4(into, typeInfo, options, t2.ofType);
        text2(into, "!");
      } else if (t2 instanceof graphql_1.GraphQLList) {
        text2(into, "[");
        renderType4(into, typeInfo, options, t2.ofType);
        text2(into, "]");
      } else {
        text2(into, (t2 === null || t2 === void 0 ? void 0 : t2.name) || "", "type-name", options, SchemaReference_1.getTypeReference(typeInfo, t2));
      }
    }
    function renderDescription2(into, options, def) {
      var description = def.description;
      if (description) {
        var descriptionDiv = document.createElement("div");
        descriptionDiv.className = "info-description";
        if (options.renderDescription) {
          descriptionDiv.innerHTML = options.renderDescription(description);
        } else {
          descriptionDiv.appendChild(document.createTextNode(description));
        }
        into.appendChild(descriptionDiv);
      }
      renderDeprecation2(into, options, def);
    }
    function renderDeprecation2(into, options, def) {
      var reason = def.deprecationReason;
      if (reason) {
        var deprecationDiv = document.createElement("div");
        deprecationDiv.className = "info-deprecation";
        if (options.renderDescription) {
          deprecationDiv.innerHTML = options.renderDescription(reason);
        } else {
          deprecationDiv.appendChild(document.createTextNode(reason));
        }
        var label = document.createElement("span");
        label.className = "info-deprecation-label";
        label.appendChild(document.createTextNode("Deprecated: "));
        deprecationDiv.insertBefore(label, deprecationDiv.firstChild);
        into.appendChild(deprecationDiv);
      }
    }
    function text2(into, content, className, options, ref) {
      if (className === void 0) {
        className = "";
      }
      if (options === void 0) {
        options = { onClick: null };
      }
      if (ref === void 0) {
        ref = null;
      }
      if (className) {
        var onClick_1 = options.onClick;
        var node = void 0;
        if (onClick_1) {
          node = document.createElement("a");
          node.href = "javascript:void 0";
          node.addEventListener("click", function(e) {
            onClick_1(ref, e);
          });
        } else {
          node = document.createElement("span");
        }
        node.className = className;
        node.appendChild(document.createTextNode(content));
        into.appendChild(node);
      } else {
        into.appendChild(document.createTextNode(content));
      }
    }
  }
});

// node_modules/codemirror-graphql/utils/jump-addon.js
var require_jump_addon = __commonJS({
  "node_modules/codemirror-graphql/utils/jump-addon.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    codemirror_1.default.defineOption("jump", false, function(cm, options, old) {
      if (old && old !== codemirror_1.default.Init) {
        var oldOnMouseOver = cm.state.jump.onMouseOver;
        codemirror_1.default.off(cm.getWrapperElement(), "mouseover", oldOnMouseOver);
        var oldOnMouseOut = cm.state.jump.onMouseOut;
        codemirror_1.default.off(cm.getWrapperElement(), "mouseout", oldOnMouseOut);
        codemirror_1.default.off(document, "keydown", cm.state.jump.onKeyDown);
        delete cm.state.jump;
      }
      if (options) {
        var state = cm.state.jump = {
          options,
          onMouseOver: onMouseOver.bind(null, cm),
          onMouseOut: onMouseOut.bind(null, cm),
          onKeyDown: onKeyDown.bind(null, cm)
        };
        codemirror_1.default.on(cm.getWrapperElement(), "mouseover", state.onMouseOver);
        codemirror_1.default.on(cm.getWrapperElement(), "mouseout", state.onMouseOut);
        codemirror_1.default.on(document, "keydown", state.onKeyDown);
      }
    });
    function onMouseOver(cm, event) {
      var target = event.target || event.srcElement;
      if (!(target instanceof HTMLElement)) {
        return;
      }
      if ((target === null || target === void 0 ? void 0 : target.nodeName) !== "SPAN") {
        return;
      }
      var box = target.getBoundingClientRect();
      var cursor = {
        left: (box.left + box.right) / 2,
        top: (box.top + box.bottom) / 2
      };
      cm.state.jump.cursor = cursor;
      if (cm.state.jump.isHoldingModifier) {
        enableJumpMode(cm);
      }
    }
    function onMouseOut(cm) {
      if (!cm.state.jump.isHoldingModifier && cm.state.jump.cursor) {
        cm.state.jump.cursor = null;
        return;
      }
      if (cm.state.jump.isHoldingModifier && cm.state.jump.marker) {
        disableJumpMode(cm);
      }
    }
    function onKeyDown(cm, event) {
      if (cm.state.jump.isHoldingModifier || !isJumpModifier(event.key)) {
        return;
      }
      cm.state.jump.isHoldingModifier = true;
      if (cm.state.jump.cursor) {
        enableJumpMode(cm);
      }
      var onKeyUp = function(upEvent) {
        if (upEvent.code !== event.code) {
          return;
        }
        cm.state.jump.isHoldingModifier = false;
        if (cm.state.jump.marker) {
          disableJumpMode(cm);
        }
        codemirror_1.default.off(document, "keyup", onKeyUp);
        codemirror_1.default.off(document, "click", onClick);
        cm.off("mousedown", onMouseDown);
      };
      var onClick = function(clickEvent) {
        var destination = cm.state.jump.destination;
        if (destination) {
          cm.state.jump.options.onClick(destination, clickEvent);
        }
      };
      var onMouseDown = function(_, downEvent) {
        if (cm.state.jump.destination) {
          downEvent.codemirrorIgnore = true;
        }
      };
      codemirror_1.default.on(document, "keyup", onKeyUp);
      codemirror_1.default.on(document, "click", onClick);
      cm.on("mousedown", onMouseDown);
    }
    var isMac = typeof navigator !== "undefined" && navigator && navigator.appVersion.indexOf("Mac") !== -1;
    function isJumpModifier(key) {
      return key === (isMac ? "Meta" : "Control");
    }
    function enableJumpMode(cm) {
      if (cm.state.jump.marker) {
        return;
      }
      var cursor = cm.state.jump.cursor;
      var pos = cm.coordsChar(cursor);
      var token = cm.getTokenAt(pos, true);
      var options = cm.state.jump.options;
      var getDestination = options.getDestination || cm.getHelper(pos, "jump");
      if (getDestination) {
        var destination = getDestination(token, options, cm);
        if (destination) {
          var marker = cm.markText({ line: pos.line, ch: token.start }, { line: pos.line, ch: token.end }, { className: "CodeMirror-jump-token" });
          cm.state.jump.marker = marker;
          cm.state.jump.destination = destination;
        }
      }
    }
    function disableJumpMode(cm) {
      var marker = cm.state.jump.marker;
      cm.state.jump.marker = null;
      cm.state.jump.destination = null;
      marker.clear();
    }
  }
});

// node_modules/codemirror-graphql/jump.js
var require_jump = __commonJS({
  "node_modules/codemirror-graphql/jump.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var getTypeInfo_1 = __importDefault(require_getTypeInfo());
    var SchemaReference_1 = require_SchemaReference();
    require_jump_addon();
    codemirror_1.default.registerHelper("jump", "graphql", function(token, options) {
      if (!options.schema || !options.onClick || !token.state) {
        return;
      }
      var state = token.state;
      var kind = state.kind;
      var step = state.step;
      var typeInfo = getTypeInfo_1.default(options.schema, state);
      if (kind === "Field" && step === 0 && typeInfo.fieldDef || kind === "AliasedField" && step === 2 && typeInfo.fieldDef) {
        return SchemaReference_1.getFieldReference(typeInfo);
      } else if (kind === "Directive" && step === 1 && typeInfo.directiveDef) {
        return SchemaReference_1.getDirectiveReference(typeInfo);
      } else if (kind === "Argument" && step === 0 && typeInfo.argDef) {
        return SchemaReference_1.getArgumentReference(typeInfo);
      } else if (kind === "EnumValue" && typeInfo.enumValue) {
        return SchemaReference_1.getEnumValueReference(typeInfo);
      } else if (kind === "NamedType" && typeInfo.type) {
        return SchemaReference_1.getTypeReference(typeInfo);
      }
    });
  }
});

// node_modules/codemirror-graphql/mode.js
var require_mode = __commonJS({
  "node_modules/codemirror-graphql/mode.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_language_service_parser_1 = (init_esm2(), esm_exports2);
    codemirror_1.default.defineMode("graphql", function(config) {
      var parser = graphql_language_service_parser_1.onlineParser({
        eatWhitespace: function(stream) {
          return stream.eatWhile(graphql_language_service_parser_1.isIgnored);
        },
        lexRules: graphql_language_service_parser_1.LexRules,
        parseRules: graphql_language_service_parser_1.ParseRules,
        editorConfig: { tabSize: config.tabSize }
      });
      return {
        config,
        startState: parser.startState,
        token: parser.token,
        indent: indent2,
        electricInput: /^\s*[})\]]/,
        fold: "brace",
        lineComment: "#",
        closeBrackets: {
          pairs: '()[]{}""',
          explode: "()[]{}"
        }
      };
    });
    function indent2(state, textAfter) {
      var _a2, _b;
      var levels = state.levels;
      var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
      return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
    }
  }
});

// node_modules/codemirror-graphql/utils/hintList.js
var require_hintList = __commonJS({
  "node_modules/codemirror-graphql/utils/hintList.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function hintList2(cursor, token, list2) {
      var hints = filterAndSortList2(list2, normalizeText2(token.string));
      if (!hints) {
        return;
      }
      var tokenStart = token.type !== null && /"|\w/.test(token.string[0]) ? token.start : token.end;
      return {
        list: hints,
        from: { line: cursor.line, ch: tokenStart },
        to: { line: cursor.line, ch: token.end }
      };
    }
    exports.default = hintList2;
    function filterAndSortList2(list2, text2) {
      if (!text2) {
        return filterNonEmpty2(list2, function(entry) {
          return !entry.isDeprecated;
        });
      }
      var byProximity = list2.map(function(entry) {
        return {
          proximity: getProximity2(normalizeText2(entry.text), text2),
          entry
        };
      });
      var conciseMatches = filterNonEmpty2(filterNonEmpty2(byProximity, function(pair) {
        return pair.proximity <= 2;
      }), function(pair) {
        return !pair.entry.isDeprecated;
      });
      var sortedMatches = conciseMatches.sort(function(a, b) {
        return (a.entry.isDeprecated ? 1 : 0) - (b.entry.isDeprecated ? 1 : 0) || a.proximity - b.proximity || a.entry.text.length - b.entry.text.length;
      });
      return sortedMatches.map(function(pair) {
        return pair.entry;
      });
    }
    function filterNonEmpty2(array, predicate) {
      var filtered = array.filter(predicate);
      return filtered.length === 0 ? array : filtered;
    }
    function normalizeText2(text2) {
      return text2.toLowerCase().replace(/\W/g, "");
    }
    function getProximity2(suggestion, text2) {
      var proximity = lexicalDistance2(text2, suggestion);
      if (suggestion.length > text2.length) {
        proximity -= suggestion.length - text2.length - 1;
        proximity += suggestion.indexOf(text2) === 0 ? 0 : 0.5;
      }
      return proximity;
    }
    function lexicalDistance2(a, b) {
      var i;
      var j;
      var d = [];
      var aLength = a.length;
      var bLength = b.length;
      for (i = 0; i <= aLength; i++) {
        d[i] = [i];
      }
      for (j = 1; j <= bLength; j++) {
        d[0][j] = j;
      }
      for (i = 1; i <= aLength; i++) {
        for (j = 1; j <= bLength; j++) {
          var cost = a[i - 1] === b[j - 1] ? 0 : 1;
          d[i][j] = Math.min(d[i - 1][j] + 1, d[i][j - 1] + 1, d[i - 1][j - 1] + cost);
          if (i > 1 && j > 1 && a[i - 1] === b[j - 2] && a[i - 2] === b[j - 1]) {
            d[i][j] = Math.min(d[i][j], d[i - 2][j - 2] + cost);
          }
        }
      }
      return d[aLength][bLength];
    }
  }
});

// node_modules/codemirror-graphql/variables/hint.js
var require_hint2 = __commonJS({
  "node_modules/codemirror-graphql/variables/hint.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_1 = (init_graphql2(), graphql_exports);
    var forEachState_1 = __importDefault(require_forEachState());
    var hintList_1 = __importDefault(require_hintList());
    codemirror_1.default.registerHelper("hint", "graphql-variables", function(editor, options) {
      var cur = editor.getCursor();
      var token = editor.getTokenAt(cur);
      var results = getVariablesHint(cur, token, options);
      if (results && results.list && results.list.length > 0) {
        results.from = codemirror_1.default.Pos(results.from.line, results.from.ch);
        results.to = codemirror_1.default.Pos(results.to.line, results.to.ch);
        codemirror_1.default.signal(editor, "hasCompletion", editor, results, token);
      }
      return results;
    });
    function getVariablesHint(cur, token, options) {
      var state = token.state.kind === "Invalid" ? token.state.prevState : token.state;
      var kind = state.kind;
      var step = state.step;
      if (kind === "Document" && step === 0) {
        return hintList_1.default(cur, token, [{ text: "{" }]);
      }
      var variableToType = options.variableToType;
      if (!variableToType) {
        return;
      }
      var typeInfo = getTypeInfo2(variableToType, token.state);
      if (kind === "Document" || kind === "Variable" && step === 0) {
        var variableNames = Object.keys(variableToType);
        return hintList_1.default(cur, token, variableNames.map(function(name2) {
          return {
            text: '"' + name2 + '": ',
            type: variableToType[name2]
          };
        }));
      }
      if (kind === "ObjectValue" || kind === "ObjectField" && step === 0) {
        if (typeInfo.fields) {
          var inputFields = Object.keys(typeInfo.fields).map(function(fieldName) {
            return typeInfo.fields[fieldName];
          });
          return hintList_1.default(cur, token, inputFields.map(function(field) {
            return {
              text: '"' + field.name + '": ',
              type: field.type,
              description: field.description
            };
          }));
        }
      }
      if (kind === "StringValue" || kind === "NumberValue" || kind === "BooleanValue" || kind === "NullValue" || kind === "ListValue" && step === 1 || kind === "ObjectField" && step === 2 || kind === "Variable" && step === 2) {
        var namedInputType_1 = typeInfo.type ? graphql_1.getNamedType(typeInfo.type) : void 0;
        if (namedInputType_1 instanceof graphql_1.GraphQLInputObjectType) {
          return hintList_1.default(cur, token, [{ text: "{" }]);
        } else if (namedInputType_1 instanceof graphql_1.GraphQLEnumType) {
          var values = namedInputType_1.getValues();
          return hintList_1.default(cur, token, values.map(function(value) {
            return {
              text: '"' + value.name + '"',
              type: namedInputType_1,
              description: value.description
            };
          }));
        } else if (namedInputType_1 === graphql_1.GraphQLBoolean) {
          return hintList_1.default(cur, token, [
            { text: "true", type: graphql_1.GraphQLBoolean, description: "Not false." },
            { text: "false", type: graphql_1.GraphQLBoolean, description: "Not true." }
          ]);
        }
      }
    }
    function getTypeInfo2(variableToType, tokenState) {
      var info = {
        type: null,
        fields: null
      };
      forEachState_1.default(tokenState, function(state) {
        if (state.kind === "Variable") {
          info.type = variableToType[state.name];
        } else if (state.kind === "ListValue") {
          var nullableType = info.type ? graphql_1.getNullableType(info.type) : void 0;
          info.type = nullableType instanceof graphql_1.GraphQLList ? nullableType.ofType : null;
        } else if (state.kind === "ObjectValue") {
          var objectType = info.type ? graphql_1.getNamedType(info.type) : void 0;
          info.fields = objectType instanceof graphql_1.GraphQLInputObjectType ? objectType.getFields() : null;
        } else if (state.kind === "ObjectField") {
          var objectField = state.name && info.fields ? info.fields[state.name] : null;
          info.type = objectField && objectField.type;
        }
      });
      return info;
    }
  }
});

// node_modules/codemirror-graphql/utils/jsonParse.js
var require_jsonParse = __commonJS({
  "node_modules/codemirror-graphql/utils/jsonParse.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function jsonParse(str) {
      string = str;
      strLen = str.length;
      start = end = lastEnd = -1;
      ch();
      lex2();
      var ast = parseObj();
      expect("EOF");
      return ast;
    }
    exports.default = jsonParse;
    var string;
    var strLen;
    var start;
    var end;
    var lastEnd;
    var code;
    var kind;
    function parseObj() {
      var nodeStart = start;
      var members = [];
      expect("{");
      if (!skip("}")) {
        do {
          members.push(parseMember());
        } while (skip(","));
        expect("}");
      }
      return {
        kind: "Object",
        start: nodeStart,
        end: lastEnd,
        members
      };
    }
    function parseMember() {
      var nodeStart = start;
      var key = kind === "String" ? curToken() : null;
      expect("String");
      expect(":");
      var value = parseVal();
      return {
        kind: "Member",
        start: nodeStart,
        end: lastEnd,
        key,
        value
      };
    }
    function parseArr() {
      var nodeStart = start;
      var values = [];
      expect("[");
      if (!skip("]")) {
        do {
          values.push(parseVal());
        } while (skip(","));
        expect("]");
      }
      return {
        kind: "Array",
        start: nodeStart,
        end: lastEnd,
        values
      };
    }
    function parseVal() {
      switch (kind) {
        case "[":
          return parseArr();
        case "{":
          return parseObj();
        case "String":
        case "Number":
        case "Boolean":
        case "Null":
          var token = curToken();
          lex2();
          return token;
      }
      expect("Value");
    }
    function curToken() {
      return { kind, start, end, value: JSON.parse(string.slice(start, end)) };
    }
    function expect(str) {
      if (kind === str) {
        lex2();
        return;
      }
      var found;
      if (kind === "EOF") {
        found = "[end of file]";
      } else if (end - start > 1) {
        found = "`" + string.slice(start, end) + "`";
      } else {
        var match = string.slice(start).match(/^.+?\b/);
        found = "`" + (match ? match[0] : string[start]) + "`";
      }
      throw syntaxError2("Expected " + str + " but found " + found + ".");
    }
    function syntaxError2(message) {
      return { message, start, end };
    }
    function skip(k) {
      if (kind === k) {
        lex2();
        return true;
      }
    }
    function ch() {
      if (end < strLen) {
        end++;
        code = end === strLen ? 0 : string.charCodeAt(end);
      }
      return code;
    }
    function lex2() {
      lastEnd = end;
      while (code === 9 || code === 10 || code === 13 || code === 32) {
        ch();
      }
      if (code === 0) {
        kind = "EOF";
        return;
      }
      start = end;
      switch (code) {
        case 34:
          kind = "String";
          return readString2();
        case 45:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 56:
        case 57:
          kind = "Number";
          return readNumber2();
        case 102:
          if (string.slice(start, start + 5) !== "false") {
            break;
          }
          end += 4;
          ch();
          kind = "Boolean";
          return;
        case 110:
          if (string.slice(start, start + 4) !== "null") {
            break;
          }
          end += 3;
          ch();
          kind = "Null";
          return;
        case 116:
          if (string.slice(start, start + 4) !== "true") {
            break;
          }
          end += 3;
          ch();
          kind = "Boolean";
          return;
      }
      kind = string[start];
      ch();
    }
    function readString2() {
      ch();
      while (code !== 34 && code > 31) {
        if (code === 92) {
          code = ch();
          switch (code) {
            case 34:
            case 47:
            case 92:
            case 98:
            case 102:
            case 110:
            case 114:
            case 116:
              ch();
              break;
            case 117:
              ch();
              readHex();
              readHex();
              readHex();
              readHex();
              break;
            default:
              throw syntaxError2("Bad character escape sequence.");
          }
        } else if (end === strLen) {
          throw syntaxError2("Unterminated string.");
        } else {
          ch();
        }
      }
      if (code === 34) {
        ch();
        return;
      }
      throw syntaxError2("Unterminated string.");
    }
    function readHex() {
      if (code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102) {
        return ch();
      }
      throw syntaxError2("Expected hexadecimal digit.");
    }
    function readNumber2() {
      if (code === 45) {
        ch();
      }
      if (code === 48) {
        ch();
      } else {
        readDigits2();
      }
      if (code === 46) {
        ch();
        readDigits2();
      }
      if (code === 69 || code === 101) {
        code = ch();
        if (code === 43 || code === 45) {
          ch();
        }
        readDigits2();
      }
    }
    function readDigits2() {
      if (code < 48 || code > 57) {
        throw syntaxError2("Expected decimal digit.");
      }
      do {
        ch();
      } while (code >= 48 && code <= 57);
    }
  }
});

// node_modules/codemirror-graphql/variables/lint.js
var require_lint3 = __commonJS({
  "node_modules/codemirror-graphql/variables/lint.js"(exports) {
    init_define_process_env();
    "use strict";
    var __read5 = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error2) {
        e = { error: error2 };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_1 = (init_graphql2(), graphql_exports);
    var jsonParse_1 = __importDefault(require_jsonParse());
    codemirror_1.default.registerHelper("lint", "graphql-variables", function(text2, options, editor) {
      if (!text2) {
        return [];
      }
      var ast;
      try {
        ast = jsonParse_1.default(text2);
      } catch (syntaxError2) {
        if (syntaxError2.stack) {
          throw syntaxError2;
        }
        return [lintError(editor, syntaxError2, syntaxError2.message)];
      }
      var variableToType = options.variableToType;
      if (!variableToType) {
        return [];
      }
      return validateVariables(editor, variableToType, ast);
    });
    function validateVariables(editor, variableToType, variablesAST) {
      var errors2 = [];
      variablesAST.members.forEach(function(member) {
        var _a2;
        if (member) {
          var variableName = (_a2 = member.key) === null || _a2 === void 0 ? void 0 : _a2.value;
          var type2 = variableToType[variableName];
          if (!type2) {
            errors2.push(lintError(editor, member.key, 'Variable "$' + variableName + '" does not appear in any GraphQL query.'));
          } else {
            validateValue(type2, member.value).forEach(function(_a3) {
              var _b = __read5(_a3, 2), node = _b[0], message = _b[1];
              errors2.push(lintError(editor, node, message));
            });
          }
        }
      });
      return errors2;
    }
    function validateValue(type2, valueAST) {
      if (!type2 || !valueAST) {
        return [];
      }
      if (type2 instanceof graphql_1.GraphQLNonNull) {
        if (valueAST.kind === "Null") {
          return [[valueAST, 'Type "' + type2 + '" is non-nullable and cannot be null.']];
        }
        return validateValue(type2.ofType, valueAST);
      }
      if (valueAST.kind === "Null") {
        return [];
      }
      if (type2 instanceof graphql_1.GraphQLList) {
        var itemType_1 = type2.ofType;
        if (valueAST.kind === "Array") {
          var values = valueAST.values || [];
          return mapCat2(values, function(item) {
            return validateValue(itemType_1, item);
          });
        }
        return validateValue(itemType_1, valueAST);
      }
      if (type2 instanceof graphql_1.GraphQLInputObjectType) {
        if (valueAST.kind !== "Object") {
          return [[valueAST, 'Type "' + type2 + '" must be an Object.']];
        }
        var providedFields_1 = Object.create(null);
        var fieldErrors_1 = mapCat2(valueAST.members, function(member) {
          var _a2;
          var fieldName = (_a2 = member === null || member === void 0 ? void 0 : member.key) === null || _a2 === void 0 ? void 0 : _a2.value;
          providedFields_1[fieldName] = true;
          var inputField = type2.getFields()[fieldName];
          if (!inputField) {
            return [
              [
                member.key,
                'Type "' + type2 + '" does not have a field "' + fieldName + '".'
              ]
            ];
          }
          var fieldType = inputField ? inputField.type : void 0;
          return validateValue(fieldType, member.value);
        });
        Object.keys(type2.getFields()).forEach(function(fieldName) {
          if (!providedFields_1[fieldName]) {
            var fieldType = type2.getFields()[fieldName].type;
            if (fieldType instanceof graphql_1.GraphQLNonNull) {
              fieldErrors_1.push([
                valueAST,
                'Object of type "' + type2 + '" is missing required field "' + fieldName + '".'
              ]);
            }
          }
        });
        return fieldErrors_1;
      }
      if (type2.name === "Boolean" && valueAST.kind !== "Boolean" || type2.name === "String" && valueAST.kind !== "String" || type2.name === "ID" && valueAST.kind !== "Number" && valueAST.kind !== "String" || type2.name === "Float" && valueAST.kind !== "Number" || type2.name === "Int" && (valueAST.kind !== "Number" || (valueAST.value | 0) !== valueAST.value)) {
        return [[valueAST, 'Expected value of type "' + type2 + '".']];
      }
      if (type2 instanceof graphql_1.GraphQLEnumType || type2 instanceof graphql_1.GraphQLScalarType) {
        if (valueAST.kind !== "String" && valueAST.kind !== "Number" && valueAST.kind !== "Boolean" && valueAST.kind !== "Null" || isNullish(type2.parseValue(valueAST.value))) {
          return [[valueAST, 'Expected value of type "' + type2 + '".']];
        }
      }
      return [];
    }
    function lintError(editor, node, message) {
      return {
        message,
        severity: "error",
        type: "validation",
        from: editor.posFromIndex(node.start),
        to: editor.posFromIndex(node.end)
      };
    }
    function isNullish(value) {
      return value === null || value === void 0 || value !== value;
    }
    function mapCat2(array, mapper) {
      return Array.prototype.concat.apply([], array.map(mapper));
    }
  }
});

// node_modules/codemirror-graphql/variables/mode.js
var require_mode2 = __commonJS({
  "node_modules/codemirror-graphql/variables/mode.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_language_service_parser_1 = (init_esm2(), esm_exports2);
    codemirror_1.default.defineMode("graphql-variables", function(config) {
      var parser = graphql_language_service_parser_1.onlineParser({
        eatWhitespace: function(stream) {
          return stream.eatSpace();
        },
        lexRules: LexRules2,
        parseRules: ParseRules2,
        editorConfig: { tabSize: config.tabSize }
      });
      return {
        config,
        startState: parser.startState,
        token: parser.token,
        indent: indent2,
        electricInput: /^\s*[}\]]/,
        fold: "brace",
        closeBrackets: {
          pairs: '[]{}""',
          explode: "[]{}"
        }
      };
    });
    function indent2(state, textAfter) {
      var _a2, _b;
      var levels = state.levels;
      var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
      return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
    }
    var LexRules2 = {
      Punctuation: /^\[|]|\{|\}|:|,/,
      Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
      String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
      Keyword: /^true|false|null/
    };
    var ParseRules2 = {
      Document: [graphql_language_service_parser_1.p("{"), graphql_language_service_parser_1.list("Variable", graphql_language_service_parser_1.opt(graphql_language_service_parser_1.p(","))), graphql_language_service_parser_1.p("}")],
      Variable: [namedKey("variable"), graphql_language_service_parser_1.p(":"), "Value"],
      Value: function(token) {
        switch (token.kind) {
          case "Number":
            return "NumberValue";
          case "String":
            return "StringValue";
          case "Punctuation":
            switch (token.value) {
              case "[":
                return "ListValue";
              case "{":
                return "ObjectValue";
            }
            return null;
          case "Keyword":
            switch (token.value) {
              case "true":
              case "false":
                return "BooleanValue";
              case "null":
                return "NullValue";
            }
            return null;
        }
      },
      NumberValue: [graphql_language_service_parser_1.t("Number", "number")],
      StringValue: [graphql_language_service_parser_1.t("String", "string")],
      BooleanValue: [graphql_language_service_parser_1.t("Keyword", "builtin")],
      NullValue: [graphql_language_service_parser_1.t("Keyword", "keyword")],
      ListValue: [graphql_language_service_parser_1.p("["), graphql_language_service_parser_1.list("Value", graphql_language_service_parser_1.opt(graphql_language_service_parser_1.p(","))), graphql_language_service_parser_1.p("]")],
      ObjectValue: [graphql_language_service_parser_1.p("{"), graphql_language_service_parser_1.list("ObjectField", graphql_language_service_parser_1.opt(graphql_language_service_parser_1.p(","))), graphql_language_service_parser_1.p("}")],
      ObjectField: [namedKey("attribute"), graphql_language_service_parser_1.p(":"), "Value"]
    };
    function namedKey(style) {
      return {
        style,
        match: function(token) {
          return token.kind === "String";
        },
        update: function(state, token) {
          state.name = token.value.slice(1, -1);
        }
      };
    }
  }
});

// node_modules/codemirror/mode/javascript/javascript.js
var require_javascript = __commonJS({
  "node_modules/codemirror/mode/javascript/javascript.js"(exports, module) {
    init_define_process_env();
    (function(mod) {
      if (typeof exports == "object" && typeof module == "object")
        mod(require_codemirror());
      else if (typeof define == "function" && define.amd)
        define(["../../lib/codemirror"], mod);
      else
        mod(CodeMirror);
    })(function(CodeMirror2) {
      "use strict";
      CodeMirror2.defineMode("javascript", function(config, parserConfig) {
        var indentUnit = config.indentUnit;
        var statementIndent = parserConfig.statementIndent;
        var jsonldMode = parserConfig.jsonld;
        var jsonMode = parserConfig.json || jsonldMode;
        var trackScope = parserConfig.trackScope !== false;
        var isTS = parserConfig.typescript;
        var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;
        var keywords = function() {
          function kw(type3) {
            return { type: type3, style: "keyword" };
          }
          var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
          var operator = kw("operator"), atom = { type: "atom", style: "atom" };
          return {
            "if": kw("if"),
            "while": A,
            "with": A,
            "else": B,
            "do": B,
            "try": B,
            "finally": B,
            "return": D,
            "break": D,
            "continue": D,
            "new": kw("new"),
            "delete": C,
            "void": C,
            "throw": C,
            "debugger": kw("debugger"),
            "var": kw("var"),
            "const": kw("var"),
            "let": kw("var"),
            "function": kw("function"),
            "catch": kw("catch"),
            "for": kw("for"),
            "switch": kw("switch"),
            "case": kw("case"),
            "default": kw("default"),
            "in": operator,
            "typeof": operator,
            "instanceof": operator,
            "true": atom,
            "false": atom,
            "null": atom,
            "undefined": atom,
            "NaN": atom,
            "Infinity": atom,
            "this": kw("this"),
            "class": kw("class"),
            "super": kw("atom"),
            "yield": C,
            "export": kw("export"),
            "import": kw("import"),
            "extends": C,
            "await": C
          };
        }();
        var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
        var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;
        function readRegexp(stream) {
          var escaped = false, next, inSet = false;
          while ((next = stream.next()) != null) {
            if (!escaped) {
              if (next == "/" && !inSet)
                return;
              if (next == "[")
                inSet = true;
              else if (inSet && next == "]")
                inSet = false;
            }
            escaped = !escaped && next == "\\";
          }
        }
        var type2, content;
        function ret(tp, style, cont2) {
          type2 = tp;
          content = cont2;
          return style;
        }
        function tokenBase(stream, state) {
          var ch = stream.next();
          if (ch == '"' || ch == "'") {
            state.tokenize = tokenString(ch);
            return state.tokenize(stream, state);
          } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
            return ret("number", "number");
          } else if (ch == "." && stream.match("..")) {
            return ret("spread", "meta");
          } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
            return ret(ch);
          } else if (ch == "=" && stream.eat(">")) {
            return ret("=>", "operator");
          } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
            return ret("number", "number");
          } else if (/\d/.test(ch)) {
            stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
            return ret("number", "number");
          } else if (ch == "/") {
            if (stream.eat("*")) {
              state.tokenize = tokenComment;
              return tokenComment(stream, state);
            } else if (stream.eat("/")) {
              stream.skipToEnd();
              return ret("comment", "comment");
            } else if (expressionAllowed(stream, state, 1)) {
              readRegexp(stream);
              stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
              return ret("regexp", "string-2");
            } else {
              stream.eat("=");
              return ret("operator", "operator", stream.current());
            }
          } else if (ch == "`") {
            state.tokenize = tokenQuasi;
            return tokenQuasi(stream, state);
          } else if (ch == "#" && stream.peek() == "!") {
            stream.skipToEnd();
            return ret("meta", "meta");
          } else if (ch == "#" && stream.eatWhile(wordRE)) {
            return ret("variable", "property");
          } else if (ch == "<" && stream.match("!--") || ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start))) {
            stream.skipToEnd();
            return ret("comment", "comment");
          } else if (isOperatorChar.test(ch)) {
            if (ch != ">" || !state.lexical || state.lexical.type != ">") {
              if (stream.eat("=")) {
                if (ch == "!" || ch == "=")
                  stream.eat("=");
              } else if (/[<>*+\-|&?]/.test(ch)) {
                stream.eat(ch);
                if (ch == ">")
                  stream.eat(ch);
              }
            }
            if (ch == "?" && stream.eat("."))
              return ret(".");
            return ret("operator", "operator", stream.current());
          } else if (wordRE.test(ch)) {
            stream.eatWhile(wordRE);
            var word2 = stream.current();
            if (state.lastType != ".") {
              if (keywords.propertyIsEnumerable(word2)) {
                var kw = keywords[word2];
                return ret(kw.type, kw.style, word2);
              }
              if (word2 == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
                return ret("async", "keyword", word2);
            }
            return ret("variable", "variable", word2);
          }
        }
        function tokenString(quote) {
          return function(stream, state) {
            var escaped = false, next;
            if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)) {
              state.tokenize = tokenBase;
              return ret("jsonld-keyword", "meta");
            }
            while ((next = stream.next()) != null) {
              if (next == quote && !escaped)
                break;
              escaped = !escaped && next == "\\";
            }
            if (!escaped)
              state.tokenize = tokenBase;
            return ret("string", "string");
          };
        }
        function tokenComment(stream, state) {
          var maybeEnd = false, ch;
          while (ch = stream.next()) {
            if (ch == "/" && maybeEnd) {
              state.tokenize = tokenBase;
              break;
            }
            maybeEnd = ch == "*";
          }
          return ret("comment", "comment");
        }
        function tokenQuasi(stream, state) {
          var escaped = false, next;
          while ((next = stream.next()) != null) {
            if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
              state.tokenize = tokenBase;
              break;
            }
            escaped = !escaped && next == "\\";
          }
          return ret("quasi", "string-2", stream.current());
        }
        var brackets = "([{}])";
        function findFatArrow(stream, state) {
          if (state.fatArrowAt)
            state.fatArrowAt = null;
          var arrow = stream.string.indexOf("=>", stream.start);
          if (arrow < 0)
            return;
          if (isTS) {
            var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
            if (m)
              arrow = m.index;
          }
          var depth = 0, sawSomething = false;
          for (var pos = arrow - 1; pos >= 0; --pos) {
            var ch = stream.string.charAt(pos);
            var bracket = brackets.indexOf(ch);
            if (bracket >= 0 && bracket < 3) {
              if (!depth) {
                ++pos;
                break;
              }
              if (--depth == 0) {
                if (ch == "(")
                  sawSomething = true;
                break;
              }
            } else if (bracket >= 3 && bracket < 6) {
              ++depth;
            } else if (wordRE.test(ch)) {
              sawSomething = true;
            } else if (/["'\/`]/.test(ch)) {
              for (; ; --pos) {
                if (pos == 0)
                  return;
                var next = stream.string.charAt(pos - 1);
                if (next == ch && stream.string.charAt(pos - 2) != "\\") {
                  pos--;
                  break;
                }
              }
            } else if (sawSomething && !depth) {
              ++pos;
              break;
            }
          }
          if (sawSomething && !depth)
            state.fatArrowAt = pos;
        }
        var atomicTypes = {
          "atom": true,
          "number": true,
          "variable": true,
          "string": true,
          "regexp": true,
          "this": true,
          "import": true,
          "jsonld-keyword": true
        };
        function JSLexical(indented, column, type3, align, prev, info) {
          this.indented = indented;
          this.column = column;
          this.type = type3;
          this.prev = prev;
          this.info = info;
          if (align != null)
            this.align = align;
        }
        function inScope(state, varname) {
          if (!trackScope)
            return false;
          for (var v = state.localVars; v; v = v.next)
            if (v.name == varname)
              return true;
          for (var cx2 = state.context; cx2; cx2 = cx2.prev) {
            for (var v = cx2.vars; v; v = v.next)
              if (v.name == varname)
                return true;
          }
        }
        function parseJS(state, style, type3, content2, stream) {
          var cc = state.cc;
          cx.state = state;
          cx.stream = stream;
          cx.marked = null, cx.cc = cc;
          cx.style = style;
          if (!state.lexical.hasOwnProperty("align"))
            state.lexical.align = true;
          while (true) {
            var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
            if (combinator(type3, content2)) {
              while (cc.length && cc[cc.length - 1].lex)
                cc.pop()();
              if (cx.marked)
                return cx.marked;
              if (type3 == "variable" && inScope(state, content2))
                return "variable-2";
              return style;
            }
          }
        }
        var cx = { state: null, column: null, marked: null, cc: null };
        function pass() {
          for (var i = arguments.length - 1; i >= 0; i--)
            cx.cc.push(arguments[i]);
        }
        function cont() {
          pass.apply(null, arguments);
          return true;
        }
        function inList(name2, list2) {
          for (var v = list2; v; v = v.next)
            if (v.name == name2)
              return true;
          return false;
        }
        function register(varname) {
          var state = cx.state;
          cx.marked = "def";
          if (!trackScope)
            return;
          if (state.context) {
            if (state.lexical.info == "var" && state.context && state.context.block) {
              var newContext = registerVarScoped(varname, state.context);
              if (newContext != null) {
                state.context = newContext;
                return;
              }
            } else if (!inList(varname, state.localVars)) {
              state.localVars = new Var(varname, state.localVars);
              return;
            }
          }
          if (parserConfig.globalVars && !inList(varname, state.globalVars))
            state.globalVars = new Var(varname, state.globalVars);
        }
        function registerVarScoped(varname, context) {
          if (!context) {
            return null;
          } else if (context.block) {
            var inner = registerVarScoped(varname, context.prev);
            if (!inner)
              return null;
            if (inner == context.prev)
              return context;
            return new Context(inner, context.vars, true);
          } else if (inList(varname, context.vars)) {
            return context;
          } else {
            return new Context(context.prev, new Var(varname, context.vars), false);
          }
        }
        function isModifier(name2) {
          return name2 == "public" || name2 == "private" || name2 == "protected" || name2 == "abstract" || name2 == "readonly";
        }
        function Context(prev, vars, block3) {
          this.prev = prev;
          this.vars = vars;
          this.block = block3;
        }
        function Var(name2, next) {
          this.name = name2;
          this.next = next;
        }
        var defaultVars = new Var("this", new Var("arguments", null));
        function pushcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
          cx.state.localVars = defaultVars;
        }
        function pushblockcontext() {
          cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
          cx.state.localVars = null;
        }
        function popcontext() {
          cx.state.localVars = cx.state.context.vars;
          cx.state.context = cx.state.context.prev;
        }
        popcontext.lex = true;
        function pushlex(type3, info) {
          var result = function() {
            var state = cx.state, indent2 = state.indented;
            if (state.lexical.type == "stat")
              indent2 = state.lexical.indented;
            else
              for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
                indent2 = outer.indented;
            state.lexical = new JSLexical(indent2, cx.stream.column(), type3, null, state.lexical, info);
          };
          result.lex = true;
          return result;
        }
        function poplex() {
          var state = cx.state;
          if (state.lexical.prev) {
            if (state.lexical.type == ")")
              state.indented = state.lexical.indented;
            state.lexical = state.lexical.prev;
          }
        }
        poplex.lex = true;
        function expect(wanted) {
          function exp(type3) {
            if (type3 == wanted)
              return cont();
            else if (wanted == ";" || type3 == "}" || type3 == ")" || type3 == "]")
              return pass();
            else
              return cont(exp);
          }
          ;
          return exp;
        }
        function statement(type3, value) {
          if (type3 == "var")
            return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
          if (type3 == "keyword a")
            return cont(pushlex("form"), parenExpr, statement, poplex);
          if (type3 == "keyword b")
            return cont(pushlex("form"), statement, poplex);
          if (type3 == "keyword d")
            return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
          if (type3 == "debugger")
            return cont(expect(";"));
          if (type3 == "{")
            return cont(pushlex("}"), pushblockcontext, block2, poplex, popcontext);
          if (type3 == ";")
            return cont();
          if (type3 == "if") {
            if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
              cx.state.cc.pop()();
            return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
          }
          if (type3 == "function")
            return cont(functiondef);
          if (type3 == "for")
            return cont(pushlex("form"), pushblockcontext, forspec, statement, popcontext, poplex);
          if (type3 == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form", type3 == "class" ? type3 : value), className, poplex);
          }
          if (type3 == "variable") {
            if (isTS && value == "declare") {
              cx.marked = "keyword";
              return cont(statement);
            } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
              cx.marked = "keyword";
              if (value == "enum")
                return cont(enumdef);
              else if (value == "type")
                return cont(typename, expect("operator"), typeexpr, expect(";"));
              else
                return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block2, poplex, poplex);
            } else if (isTS && value == "namespace") {
              cx.marked = "keyword";
              return cont(pushlex("form"), expression, statement, poplex);
            } else if (isTS && value == "abstract") {
              cx.marked = "keyword";
              return cont(statement);
            } else {
              return cont(pushlex("stat"), maybelabel);
            }
          }
          if (type3 == "switch")
            return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext, block2, poplex, poplex, popcontext);
          if (type3 == "case")
            return cont(expression, expect(":"));
          if (type3 == "default")
            return cont(expect(":"));
          if (type3 == "catch")
            return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
          if (type3 == "export")
            return cont(pushlex("stat"), afterExport, poplex);
          if (type3 == "import")
            return cont(pushlex("stat"), afterImport, poplex);
          if (type3 == "async")
            return cont(statement);
          if (value == "@")
            return cont(expression, statement);
          return pass(pushlex("stat"), expression, expect(";"), poplex);
        }
        function maybeCatchBinding(type3) {
          if (type3 == "(")
            return cont(funarg, expect(")"));
        }
        function expression(type3, value) {
          return expressionInner(type3, value, false);
        }
        function expressionNoComma(type3, value) {
          return expressionInner(type3, value, true);
        }
        function parenExpr(type3) {
          if (type3 != "(")
            return pass();
          return cont(pushlex(")"), maybeexpression, expect(")"), poplex);
        }
        function expressionInner(type3, value, noComma) {
          if (cx.state.fatArrowAt == cx.stream.start) {
            var body = noComma ? arrowBodyNoComma : arrowBody;
            if (type3 == "(")
              return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
            else if (type3 == "variable")
              return pass(pushcontext, pattern, expect("=>"), body, popcontext);
          }
          var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
          if (atomicTypes.hasOwnProperty(type3))
            return cont(maybeop);
          if (type3 == "function")
            return cont(functiondef, maybeop);
          if (type3 == "class" || isTS && value == "interface") {
            cx.marked = "keyword";
            return cont(pushlex("form"), classExpression, poplex);
          }
          if (type3 == "keyword c" || type3 == "async")
            return cont(noComma ? expressionNoComma : expression);
          if (type3 == "(")
            return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
          if (type3 == "operator" || type3 == "spread")
            return cont(noComma ? expressionNoComma : expression);
          if (type3 == "[")
            return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
          if (type3 == "{")
            return contCommasep(objprop, "}", null, maybeop);
          if (type3 == "quasi")
            return pass(quasi, maybeop);
          if (type3 == "new")
            return cont(maybeTarget(noComma));
          return cont();
        }
        function maybeexpression(type3) {
          if (type3.match(/[;\}\)\],]/))
            return pass();
          return pass(expression);
        }
        function maybeoperatorComma(type3, value) {
          if (type3 == ",")
            return cont(maybeexpression);
          return maybeoperatorNoComma(type3, value, false);
        }
        function maybeoperatorNoComma(type3, value, noComma) {
          var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
          var expr = noComma == false ? expression : expressionNoComma;
          if (type3 == "=>")
            return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
          if (type3 == "operator") {
            if (/\+\+|--/.test(value) || isTS && value == "!")
              return cont(me);
            if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
              return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
            if (value == "?")
              return cont(expression, expect(":"), expr);
            return cont(expr);
          }
          if (type3 == "quasi") {
            return pass(quasi, me);
          }
          if (type3 == ";")
            return;
          if (type3 == "(")
            return contCommasep(expressionNoComma, ")", "call", me);
          if (type3 == ".")
            return cont(property, me);
          if (type3 == "[")
            return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
          if (isTS && value == "as") {
            cx.marked = "keyword";
            return cont(typeexpr, me);
          }
          if (type3 == "regexp") {
            cx.state.lastType = cx.marked = "operator";
            cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
            return cont(expr);
          }
        }
        function quasi(type3, value) {
          if (type3 != "quasi")
            return pass();
          if (value.slice(value.length - 2) != "${")
            return cont(quasi);
          return cont(maybeexpression, continueQuasi);
        }
        function continueQuasi(type3) {
          if (type3 == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasi);
          }
        }
        function arrowBody(type3) {
          findFatArrow(cx.stream, cx.state);
          return pass(type3 == "{" ? statement : expression);
        }
        function arrowBodyNoComma(type3) {
          findFatArrow(cx.stream, cx.state);
          return pass(type3 == "{" ? statement : expressionNoComma);
        }
        function maybeTarget(noComma) {
          return function(type3) {
            if (type3 == ".")
              return cont(noComma ? targetNoComma : target);
            else if (type3 == "variable" && isTS)
              return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma);
            else
              return pass(noComma ? expressionNoComma : expression);
          };
        }
        function target(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorComma);
          }
        }
        function targetNoComma(_, value) {
          if (value == "target") {
            cx.marked = "keyword";
            return cont(maybeoperatorNoComma);
          }
        }
        function maybelabel(type3) {
          if (type3 == ":")
            return cont(poplex, statement);
          return pass(maybeoperatorComma, expect(";"), poplex);
        }
        function property(type3) {
          if (type3 == "variable") {
            cx.marked = "property";
            return cont();
          }
        }
        function objprop(type3, value) {
          if (type3 == "async") {
            cx.marked = "property";
            return cont(objprop);
          } else if (type3 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            if (value == "get" || value == "set")
              return cont(getterSetter);
            var m;
            if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
              cx.state.fatArrowAt = cx.stream.pos + m[0].length;
            return cont(afterprop);
          } else if (type3 == "number" || type3 == "string") {
            cx.marked = jsonldMode ? "property" : cx.style + " property";
            return cont(afterprop);
          } else if (type3 == "jsonld-keyword") {
            return cont(afterprop);
          } else if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type3 == "[") {
            return cont(expression, maybetype, expect("]"), afterprop);
          } else if (type3 == "spread") {
            return cont(expressionNoComma, afterprop);
          } else if (value == "*") {
            cx.marked = "keyword";
            return cont(objprop);
          } else if (type3 == ":") {
            return pass(afterprop);
          }
        }
        function getterSetter(type3) {
          if (type3 != "variable")
            return pass(afterprop);
          cx.marked = "property";
          return cont(functiondef);
        }
        function afterprop(type3) {
          if (type3 == ":")
            return cont(expressionNoComma);
          if (type3 == "(")
            return pass(functiondef);
        }
        function commasep(what, end, sep) {
          function proceed(type3, value) {
            if (sep ? sep.indexOf(type3) > -1 : type3 == ",") {
              var lex2 = cx.state.lexical;
              if (lex2.info == "call")
                lex2.pos = (lex2.pos || 0) + 1;
              return cont(function(type4, value2) {
                if (type4 == end || value2 == end)
                  return pass();
                return pass(what);
              }, proceed);
            }
            if (type3 == end || value == end)
              return cont();
            if (sep && sep.indexOf(";") > -1)
              return pass(what);
            return cont(expect(end));
          }
          return function(type3, value) {
            if (type3 == end || value == end)
              return cont();
            return pass(what, proceed);
          };
        }
        function contCommasep(what, end, info) {
          for (var i = 3; i < arguments.length; i++)
            cx.cc.push(arguments[i]);
          return cont(pushlex(end, info), commasep(what, end), poplex);
        }
        function block2(type3) {
          if (type3 == "}")
            return cont();
          return pass(statement, block2);
        }
        function maybetype(type3, value) {
          if (isTS) {
            if (type3 == ":")
              return cont(typeexpr);
            if (value == "?")
              return cont(maybetype);
          }
        }
        function maybetypeOrIn(type3, value) {
          if (isTS && (type3 == ":" || value == "in"))
            return cont(typeexpr);
        }
        function mayberettype(type3) {
          if (isTS && type3 == ":") {
            if (cx.stream.match(/^\s*\w+\s+is\b/, false))
              return cont(expression, isKW, typeexpr);
            else
              return cont(typeexpr);
          }
        }
        function isKW(_, value) {
          if (value == "is") {
            cx.marked = "keyword";
            return cont();
          }
        }
        function typeexpr(type3, value) {
          if (value == "keyof" || value == "typeof" || value == "infer" || value == "readonly") {
            cx.marked = "keyword";
            return cont(value == "typeof" ? expressionNoComma : typeexpr);
          }
          if (type3 == "variable" || value == "void") {
            cx.marked = "type";
            return cont(afterType);
          }
          if (value == "|" || value == "&")
            return cont(typeexpr);
          if (type3 == "string" || type3 == "number" || type3 == "atom")
            return cont(afterType);
          if (type3 == "[")
            return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType);
          if (type3 == "{")
            return cont(pushlex("}"), typeprops, poplex, afterType);
          if (type3 == "(")
            return cont(commasep(typearg, ")"), maybeReturnType, afterType);
          if (type3 == "<")
            return cont(commasep(typeexpr, ">"), typeexpr);
          if (type3 == "quasi") {
            return pass(quasiType, afterType);
          }
        }
        function maybeReturnType(type3) {
          if (type3 == "=>")
            return cont(typeexpr);
        }
        function typeprops(type3) {
          if (type3.match(/[\}\)\]]/))
            return cont();
          if (type3 == "," || type3 == ";")
            return cont(typeprops);
          return pass(typeprop, typeprops);
        }
        function typeprop(type3, value) {
          if (type3 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(typeprop);
          } else if (value == "?" || type3 == "number" || type3 == "string") {
            return cont(typeprop);
          } else if (type3 == ":") {
            return cont(typeexpr);
          } else if (type3 == "[") {
            return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop);
          } else if (type3 == "(") {
            return pass(functiondecl, typeprop);
          } else if (!type3.match(/[;\}\)\],]/)) {
            return cont();
          }
        }
        function quasiType(type3, value) {
          if (type3 != "quasi")
            return pass();
          if (value.slice(value.length - 2) != "${")
            return cont(quasiType);
          return cont(typeexpr, continueQuasiType);
        }
        function continueQuasiType(type3) {
          if (type3 == "}") {
            cx.marked = "string-2";
            cx.state.tokenize = tokenQuasi;
            return cont(quasiType);
          }
        }
        function typearg(type3, value) {
          if (type3 == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?")
            return cont(typearg);
          if (type3 == ":")
            return cont(typeexpr);
          if (type3 == "spread")
            return cont(typearg);
          return pass(typeexpr);
        }
        function afterType(type3, value) {
          if (value == "<")
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
          if (value == "|" || type3 == "." || value == "&")
            return cont(typeexpr);
          if (type3 == "[")
            return cont(typeexpr, expect("]"), afterType);
          if (value == "extends" || value == "implements") {
            cx.marked = "keyword";
            return cont(typeexpr);
          }
          if (value == "?")
            return cont(typeexpr, expect(":"), typeexpr);
        }
        function maybeTypeArgs(_, value) {
          if (value == "<")
            return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType);
        }
        function typeparam() {
          return pass(typeexpr, maybeTypeDefault);
        }
        function maybeTypeDefault(_, value) {
          if (value == "=")
            return cont(typeexpr);
        }
        function vardef(_, value) {
          if (value == "enum") {
            cx.marked = "keyword";
            return cont(enumdef);
          }
          return pass(pattern, maybetype, maybeAssign, vardefCont);
        }
        function pattern(type3, value) {
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(pattern);
          }
          if (type3 == "variable") {
            register(value);
            return cont();
          }
          if (type3 == "spread")
            return cont(pattern);
          if (type3 == "[")
            return contCommasep(eltpattern, "]");
          if (type3 == "{")
            return contCommasep(proppattern, "}");
        }
        function proppattern(type3, value) {
          if (type3 == "variable" && !cx.stream.match(/^\s*:/, false)) {
            register(value);
            return cont(maybeAssign);
          }
          if (type3 == "variable")
            cx.marked = "property";
          if (type3 == "spread")
            return cont(pattern);
          if (type3 == "}")
            return pass();
          if (type3 == "[")
            return cont(expression, expect("]"), expect(":"), proppattern);
          return cont(expect(":"), pattern, maybeAssign);
        }
        function eltpattern() {
          return pass(pattern, maybeAssign);
        }
        function maybeAssign(_type, value) {
          if (value == "=")
            return cont(expressionNoComma);
        }
        function vardefCont(type3) {
          if (type3 == ",")
            return cont(vardef);
        }
        function maybeelse(type3, value) {
          if (type3 == "keyword b" && value == "else")
            return cont(pushlex("form", "else"), statement, poplex);
        }
        function forspec(type3, value) {
          if (value == "await")
            return cont(forspec);
          if (type3 == "(")
            return cont(pushlex(")"), forspec1, poplex);
        }
        function forspec1(type3) {
          if (type3 == "var")
            return cont(vardef, forspec2);
          if (type3 == "variable")
            return cont(forspec2);
          return pass(forspec2);
        }
        function forspec2(type3, value) {
          if (type3 == ")")
            return cont();
          if (type3 == ";")
            return cont(forspec2);
          if (value == "in" || value == "of") {
            cx.marked = "keyword";
            return cont(expression, forspec2);
          }
          return pass(expression, forspec2);
        }
        function functiondef(type3, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondef);
          }
          if (type3 == "variable") {
            register(value);
            return cont(functiondef);
          }
          if (type3 == "(")
            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
          if (isTS && value == "<")
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef);
        }
        function functiondecl(type3, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(functiondecl);
          }
          if (type3 == "variable") {
            register(value);
            return cont(functiondecl);
          }
          if (type3 == "(")
            return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
          if (isTS && value == "<")
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl);
        }
        function typename(type3, value) {
          if (type3 == "keyword" || type3 == "variable") {
            cx.marked = "type";
            return cont(typename);
          } else if (value == "<") {
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex);
          }
        }
        function funarg(type3, value) {
          if (value == "@")
            cont(expression, funarg);
          if (type3 == "spread")
            return cont(funarg);
          if (isTS && isModifier(value)) {
            cx.marked = "keyword";
            return cont(funarg);
          }
          if (isTS && type3 == "this")
            return cont(maybetype, maybeAssign);
          return pass(pattern, maybetype, maybeAssign);
        }
        function classExpression(type3, value) {
          if (type3 == "variable")
            return className(type3, value);
          return classNameAfter(type3, value);
        }
        function className(type3, value) {
          if (type3 == "variable") {
            register(value);
            return cont(classNameAfter);
          }
        }
        function classNameAfter(type3, value) {
          if (value == "<")
            return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter);
          if (value == "extends" || value == "implements" || isTS && type3 == ",") {
            if (value == "implements")
              cx.marked = "keyword";
            return cont(isTS ? typeexpr : expression, classNameAfter);
          }
          if (type3 == "{")
            return cont(pushlex("}"), classBody, poplex);
        }
        function classBody(type3, value) {
          if (type3 == "async" || type3 == "variable" && (value == "static" || value == "get" || value == "set" || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false)) {
            cx.marked = "keyword";
            return cont(classBody);
          }
          if (type3 == "variable" || cx.style == "keyword") {
            cx.marked = "property";
            return cont(classfield, classBody);
          }
          if (type3 == "number" || type3 == "string")
            return cont(classfield, classBody);
          if (type3 == "[")
            return cont(expression, maybetype, expect("]"), classfield, classBody);
          if (value == "*") {
            cx.marked = "keyword";
            return cont(classBody);
          }
          if (isTS && type3 == "(")
            return pass(functiondecl, classBody);
          if (type3 == ";" || type3 == ",")
            return cont(classBody);
          if (type3 == "}")
            return cont();
          if (value == "@")
            return cont(expression, classBody);
        }
        function classfield(type3, value) {
          if (value == "!")
            return cont(classfield);
          if (value == "?")
            return cont(classfield);
          if (type3 == ":")
            return cont(typeexpr, maybeAssign);
          if (value == "=")
            return cont(expressionNoComma);
          var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
          return pass(isInterface ? functiondecl : functiondef);
        }
        function afterExport(type3, value) {
          if (value == "*") {
            cx.marked = "keyword";
            return cont(maybeFrom, expect(";"));
          }
          if (value == "default") {
            cx.marked = "keyword";
            return cont(expression, expect(";"));
          }
          if (type3 == "{")
            return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
          return pass(statement);
        }
        function exportField(type3, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(expect("variable"));
          }
          if (type3 == "variable")
            return pass(expressionNoComma, exportField);
        }
        function afterImport(type3) {
          if (type3 == "string")
            return cont();
          if (type3 == "(")
            return pass(expression);
          if (type3 == ".")
            return pass(maybeoperatorComma);
          return pass(importSpec, maybeMoreImports, maybeFrom);
        }
        function importSpec(type3, value) {
          if (type3 == "{")
            return contCommasep(importSpec, "}");
          if (type3 == "variable")
            register(value);
          if (value == "*")
            cx.marked = "keyword";
          return cont(maybeAs);
        }
        function maybeMoreImports(type3) {
          if (type3 == ",")
            return cont(importSpec, maybeMoreImports);
        }
        function maybeAs(_type, value) {
          if (value == "as") {
            cx.marked = "keyword";
            return cont(importSpec);
          }
        }
        function maybeFrom(_type, value) {
          if (value == "from") {
            cx.marked = "keyword";
            return cont(expression);
          }
        }
        function arrayLiteral(type3) {
          if (type3 == "]")
            return cont();
          return pass(commasep(expressionNoComma, "]"));
        }
        function enumdef() {
          return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex);
        }
        function enummember() {
          return pass(pattern, maybeAssign);
        }
        function isContinuedStatement(state, textAfter) {
          return state.lastType == "operator" || state.lastType == "," || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0));
        }
        function expressionAllowed(stream, state, backUp) {
          return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)));
        }
        return {
          startState: function(basecolumn) {
            var state = {
              tokenize: tokenBase,
              lastType: "sof",
              cc: [],
              lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
              localVars: parserConfig.localVars,
              context: parserConfig.localVars && new Context(null, null, false),
              indented: basecolumn || 0
            };
            if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
              state.globalVars = parserConfig.globalVars;
            return state;
          },
          token: function(stream, state) {
            if (stream.sol()) {
              if (!state.lexical.hasOwnProperty("align"))
                state.lexical.align = false;
              state.indented = stream.indentation();
              findFatArrow(stream, state);
            }
            if (state.tokenize != tokenComment && stream.eatSpace())
              return null;
            var style = state.tokenize(stream, state);
            if (type2 == "comment")
              return style;
            state.lastType = type2 == "operator" && (content == "++" || content == "--") ? "incdec" : type2;
            return parseJS(state, style, type2, content, stream);
          },
          indent: function(state, textAfter) {
            if (state.tokenize == tokenComment || state.tokenize == tokenQuasi)
              return CodeMirror2.Pass;
            if (state.tokenize != tokenBase)
              return 0;
            var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
            if (!/^\s*else\b/.test(textAfter))
              for (var i = state.cc.length - 1; i >= 0; --i) {
                var c = state.cc[i];
                if (c == poplex)
                  lexical = lexical.prev;
                else if (c != maybeelse && c != popcontext)
                  break;
              }
            while ((lexical.type == "stat" || lexical.type == "form") && (firstChar == "}" || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter)))
              lexical = lexical.prev;
            if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
              lexical = lexical.prev;
            var type3 = lexical.type, closing = firstChar == type3;
            if (type3 == "vardef")
              return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
            else if (type3 == "form" && firstChar == "{")
              return lexical.indented;
            else if (type3 == "form")
              return lexical.indented + indentUnit;
            else if (type3 == "stat")
              return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
            else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
              return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
            else if (lexical.align)
              return lexical.column + (closing ? 0 : 1);
            else
              return lexical.indented + (closing ? 0 : indentUnit);
          },
          electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
          blockCommentStart: jsonMode ? null : "/*",
          blockCommentEnd: jsonMode ? null : "*/",
          blockCommentContinue: jsonMode ? null : " * ",
          lineComment: jsonMode ? null : "//",
          fold: "brace",
          closeBrackets: "()[]{}''\"\"``",
          helperType: jsonMode ? "json" : "javascript",
          jsonldMode,
          jsonMode,
          expressionAllowed,
          skipExpression: function(state) {
            parseJS(state, "atom", "atom", "true", new CodeMirror2.StringStream("", 2, null));
          }
        };
      });
      CodeMirror2.registerHelper("wordChars", "javascript", /[\w$]/);
      CodeMirror2.defineMIME("text/javascript", "javascript");
      CodeMirror2.defineMIME("text/ecmascript", "javascript");
      CodeMirror2.defineMIME("application/javascript", "javascript");
      CodeMirror2.defineMIME("application/x-javascript", "javascript");
      CodeMirror2.defineMIME("application/ecmascript", "javascript");
      CodeMirror2.defineMIME("application/json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/x-json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/manifest+json", { name: "javascript", json: true });
      CodeMirror2.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
      CodeMirror2.defineMIME("text/typescript", { name: "javascript", typescript: true });
      CodeMirror2.defineMIME("application/typescript", { name: "javascript", typescript: true });
    });
  }
});

// node_modules/codemirror-graphql/results/mode.js
var require_mode3 = __commonJS({
  "node_modules/codemirror-graphql/results/mode.js"(exports) {
    init_define_process_env();
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var codemirror_1 = __importDefault(require_codemirror());
    var graphql_language_service_parser_1 = (init_esm2(), esm_exports2);
    codemirror_1.default.defineMode("graphql-results", function(config) {
      var parser = graphql_language_service_parser_1.onlineParser({
        eatWhitespace: function(stream) {
          return stream.eatSpace();
        },
        lexRules: LexRules2,
        parseRules: ParseRules2,
        editorConfig: { tabSize: config.tabSize }
      });
      return {
        config,
        startState: parser.startState,
        token: parser.token,
        indent: indent2,
        electricInput: /^\s*[}\]]/,
        fold: "brace",
        closeBrackets: {
          pairs: '[]{}""',
          explode: "[]{}"
        }
      };
    });
    function indent2(state, textAfter) {
      var _a2, _b;
      var levels = state.levels;
      var level = !levels || levels.length === 0 ? state.indentLevel : levels[levels.length - 1] - (((_a2 = this.electricInput) === null || _a2 === void 0 ? void 0 : _a2.test(textAfter)) ? 1 : 0);
      return (level || 0) * (((_b = this.config) === null || _b === void 0 ? void 0 : _b.indentUnit) || 0);
    }
    var LexRules2 = {
      Punctuation: /^\[|]|\{|\}|:|,/,
      Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
      String: /^"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?/,
      Keyword: /^true|false|null/
    };
    var ParseRules2 = {
      Document: [graphql_language_service_parser_1.p("{"), graphql_language_service_parser_1.list("Entry", graphql_language_service_parser_1.p(",")), graphql_language_service_parser_1.p("}")],
      Entry: [graphql_language_service_parser_1.t("String", "def"), graphql_language_service_parser_1.p(":"), "Value"],
      Value: function(token) {
        switch (token.kind) {
          case "Number":
            return "NumberValue";
          case "String":
            return "StringValue";
          case "Punctuation":
            switch (token.value) {
              case "[":
                return "ListValue";
              case "{":
                return "ObjectValue";
            }
            return null;
          case "Keyword":
            switch (token.value) {
              case "true":
              case "false":
                return "BooleanValue";
              case "null":
                return "NullValue";
            }
            return null;
        }
      },
      NumberValue: [graphql_language_service_parser_1.t("Number", "number")],
      StringValue: [graphql_language_service_parser_1.t("String", "string")],
      BooleanValue: [graphql_language_service_parser_1.t("Keyword", "builtin")],
      NullValue: [graphql_language_service_parser_1.t("Keyword", "keyword")],
      ListValue: [graphql_language_service_parser_1.p("["), graphql_language_service_parser_1.list("Value", graphql_language_service_parser_1.p(",")), graphql_language_service_parser_1.p("]")],
      ObjectValue: [graphql_language_service_parser_1.p("{"), graphql_language_service_parser_1.list("ObjectField", graphql_language_service_parser_1.p(",")), graphql_language_service_parser_1.p("}")],
      ObjectField: [graphql_language_service_parser_1.t("String", "property"), graphql_language_service_parser_1.p(":"), "Value"]
    };
  }
});

// dep:graphiql
init_define_process_env();

// node_modules/graphiql/esm/index.js
init_define_process_env();

// node_modules/graphiql/esm/components/GraphiQL.js
init_define_process_env();
var import_react23 = __toModule(require_react());
init_graphql2();
var import_copy_to_clipboard = __toModule(require_copy_to_clipboard());
init_esm();

// node_modules/graphiql/esm/components/ExecuteButton.js
init_define_process_env();
var import_react = __toModule(require_react());
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ExecuteButton = function(_super) {
  __extends(ExecuteButton2, _super);
  function ExecuteButton2(props) {
    var _this = _super.call(this, props) || this;
    _this._onClick = function() {
      if (_this.props.isRunning) {
        _this.props.onStop();
      } else {
        _this.props.onRun();
      }
    };
    _this._onOptionSelected = function(operation) {
      _this.setState({ optionsOpen: false });
      _this.props.onRun(operation.name && operation.name.value);
    };
    _this._onOptionsOpen = function(downEvent) {
      var initialPress = true;
      var downTarget = downEvent.currentTarget;
      _this.setState({ highlight: null, optionsOpen: true });
      var onMouseUp = function(upEvent) {
        var _a2;
        if (initialPress && upEvent.target === downTarget) {
          initialPress = false;
        } else {
          document.removeEventListener("mouseup", onMouseUp);
          onMouseUp = null;
          var isOptionsMenuClicked = upEvent.currentTarget && ((_a2 = downTarget.parentNode) === null || _a2 === void 0 ? void 0 : _a2.compareDocumentPosition(upEvent.currentTarget)) && Node.DOCUMENT_POSITION_CONTAINED_BY;
          if (!isOptionsMenuClicked) {
            _this.setState({ optionsOpen: false });
          }
        }
      };
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.state = {
      optionsOpen: false,
      highlight: null
    };
    return _this;
  }
  ExecuteButton2.prototype.render = function() {
    var _this = this;
    var operations = this.props.operations || [];
    var optionsOpen = this.state.optionsOpen;
    var hasOptions = operations && operations.length > 1;
    var options = null;
    if (hasOptions && optionsOpen) {
      var highlight_1 = this.state.highlight;
      options = import_react.default.createElement("ul", { className: "execute-options" }, operations.map(function(operation, i) {
        var opName = operation.name ? operation.name.value : "<Unnamed " + operation.operation + ">";
        return import_react.default.createElement("li", { key: opName + "-" + i, className: operation === highlight_1 ? "selected" : void 0, onMouseOver: function() {
          return _this.setState({ highlight: operation });
        }, onMouseOut: function() {
          return _this.setState({ highlight: null });
        }, onMouseUp: function() {
          return _this._onOptionSelected(operation);
        } }, opName);
      }));
    }
    var onClick;
    if (this.props.isRunning || !hasOptions) {
      onClick = this._onClick;
    }
    var onMouseDown = function() {
    };
    if (!this.props.isRunning && hasOptions && !optionsOpen) {
      onMouseDown = this._onOptionsOpen;
    }
    var pathJSX = this.props.isRunning ? import_react.default.createElement("path", { d: "M 10 10 L 23 10 L 23 23 L 10 23 z" }) : import_react.default.createElement("path", { d: "M 11 9 L 24 16 L 11 23 z" });
    return import_react.default.createElement("div", { className: "execute-button-wrap" }, import_react.default.createElement("button", { type: "button", className: "execute-button", onMouseDown, onClick, title: "Execute Query (Ctrl-Enter)" }, import_react.default.createElement("svg", { width: "34", height: "34" }, pathJSX)), options);
  };
  return ExecuteButton2;
}(import_react.default.Component);

// node_modules/graphiql/esm/components/ImagePreview.js
init_define_process_env();
var import_react2 = __toModule(require_react());
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
function tokenToURL(token) {
  if (token.type !== "string") {
    return;
  }
  var value = token.string.slice(1).slice(0, -1).trim();
  try {
    var location_1 = window.location;
    return new URL(value, location_1.protocol + "//" + location_1.host);
  } catch (err) {
    return;
  }
}
function isImageURL(url) {
  return /(bmp|gif|jpeg|jpg|png|svg)$/.test(url.pathname);
}
var ImagePreview = function(_super) {
  __extends2(ImagePreview2, _super);
  function ImagePreview2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._node = null;
    _this.state = {
      width: null,
      height: null,
      src: null,
      mime: null
    };
    return _this;
  }
  ImagePreview2.shouldRender = function(token) {
    var url = tokenToURL(token);
    return url ? isImageURL(url) : false;
  };
  ImagePreview2.prototype.componentDidMount = function() {
    this._updateMetadata();
  };
  ImagePreview2.prototype.componentDidUpdate = function() {
    this._updateMetadata();
  };
  ImagePreview2.prototype.render = function() {
    var _this = this;
    var _a2;
    var dims = null;
    if (this.state.width !== null && this.state.height !== null) {
      var dimensions = this.state.width + "x" + this.state.height;
      if (this.state.mime !== null) {
        dimensions += " " + this.state.mime;
      }
      dims = import_react2.default.createElement("div", null, dimensions);
    }
    return import_react2.default.createElement("div", null, import_react2.default.createElement("img", { onLoad: function() {
      return _this._updateMetadata();
    }, ref: function(node) {
      _this._node = node;
    }, src: (_a2 = tokenToURL(this.props.token)) === null || _a2 === void 0 ? void 0 : _a2.href }), dims);
  };
  ImagePreview2.prototype._updateMetadata = function() {
    var _this = this;
    if (!this._node) {
      return;
    }
    var width = this._node.naturalWidth;
    var height = this._node.naturalHeight;
    var src = this._node.src;
    if (src !== this.state.src) {
      this.setState({ src });
      fetch(src, { method: "HEAD" }).then(function(response) {
        _this.setState({
          mime: response.headers.get("Content-Type")
        });
      });
    }
    if (width !== this.state.width || height !== this.state.height) {
      this.setState({ height, width });
    }
  };
  return ImagePreview2;
}(import_react2.default.Component);

// node_modules/graphiql/esm/components/ToolbarButton.js
init_define_process_env();
var import_react3 = __toModule(require_react());
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ToolbarButton = function(_super) {
  __extends3(ToolbarButton2, _super);
  function ToolbarButton2(props) {
    var _this = _super.call(this, props) || this;
    _this.handleClick = function() {
      try {
        _this.props.onClick();
        _this.setState({ error: null });
      } catch (error2) {
        _this.setState({ error: error2 });
      }
    };
    _this.state = { error: null };
    return _this;
  }
  ToolbarButton2.prototype.render = function() {
    var error2 = this.state.error;
    return import_react3.default.createElement("button", { className: "toolbar-button" + (error2 ? " error" : ""), onClick: this.handleClick, title: error2 ? error2.message : this.props.title, "aria-invalid": error2 ? "true" : "false" }, this.props.label);
  };
  return ToolbarButton2;
}(import_react3.default.Component);

// node_modules/graphiql/esm/components/ToolbarGroup.js
init_define_process_env();
var import_react4 = __toModule(require_react());
function ToolbarGroup(_a2) {
  var children = _a2.children;
  return import_react4.default.createElement("div", { className: "toolbar-button-group" }, children);
}

// node_modules/graphiql/esm/components/ToolbarMenu.js
init_define_process_env();
var import_react5 = __toModule(require_react());
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ToolbarMenu = function(_super) {
  __extends4(ToolbarMenu2, _super);
  function ToolbarMenu2(props) {
    var _this = _super.call(this, props) || this;
    _this._node = null;
    _this._listener = null;
    _this.handleOpen = function(e) {
      preventDefault(e);
      _this.setState({ visible: true });
      _this._subscribe();
    };
    _this.state = { visible: false };
    return _this;
  }
  ToolbarMenu2.prototype.componentWillUnmount = function() {
    this._release();
  };
  ToolbarMenu2.prototype.render = function() {
    var _this = this;
    var visible = this.state.visible;
    return import_react5.default.createElement("a", { className: "toolbar-menu toolbar-button", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault, ref: function(node) {
      if (node) {
        _this._node = node;
      }
    }, title: this.props.title }, this.props.label, import_react5.default.createElement("svg", { width: "14", height: "8" }, import_react5.default.createElement("path", { fill: "#666", d: "M 5 1.5 L 14 1.5 L 9.5 7 z" })), import_react5.default.createElement("ul", { className: "toolbar-menu-items" + (visible ? " open" : "") }, this.props.children));
  };
  ToolbarMenu2.prototype._subscribe = function() {
    if (!this._listener) {
      this._listener = this.handleClick.bind(this);
      document.addEventListener("click", this._listener);
    }
  };
  ToolbarMenu2.prototype._release = function() {
    if (this._listener) {
      document.removeEventListener("click", this._listener);
      this._listener = null;
    }
  };
  ToolbarMenu2.prototype.handleClick = function(e) {
    if (this._node !== e.target) {
      e.preventDefault();
      this.setState({ visible: false });
      this._release();
    }
  };
  return ToolbarMenu2;
}(import_react5.default.Component);
var ToolbarMenuItem = function(_a2) {
  var onSelect = _a2.onSelect, title = _a2.title, label = _a2.label;
  return import_react5.default.createElement("li", { onMouseOver: function(e) {
    e.currentTarget.className = "hover";
  }, onMouseOut: function(e) {
    e.currentTarget.className = "";
  }, onMouseDown: preventDefault, onMouseUp: onSelect, title }, label);
};
function preventDefault(e) {
  e.preventDefault();
}

// node_modules/graphiql/esm/components/QueryEditor.js
init_define_process_env();
var import_react6 = __toModule(require_react());
var import_markdown_it2 = __toModule(require_markdown_it());

// node_modules/graphiql/esm/utility/normalizeWhitespace.js
init_define_process_env();
var invalidCharacters = Array.from({ length: 11 }, function(_, i) {
  return String.fromCharCode(8192 + i);
}).concat(["\u2028", "\u2029", "\u202F", "\xA0"]);
var sanitizeRegex = new RegExp("[" + invalidCharacters.join("") + "]", "g");
function normalizeWhitespace(line) {
  return line.replace(sanitizeRegex, " ");
}

// node_modules/graphiql/esm/utility/onHasCompletion.js
init_define_process_env();
init_graphql2();
var import_markdown_it = __toModule(require_markdown_it());
var md = new import_markdown_it.default();
function onHasCompletion(_cm, data, onHintInformationRender) {
  var CodeMirror2 = require_codemirror();
  var information;
  var deprecation;
  CodeMirror2.on(data, "select", function(ctx, el) {
    if (!information) {
      var hintsUl_1 = el.parentNode;
      information = document.createElement("div");
      information.className = "CodeMirror-hint-information";
      hintsUl_1.appendChild(information);
      deprecation = document.createElement("div");
      deprecation.className = "CodeMirror-hint-deprecation";
      hintsUl_1.appendChild(deprecation);
      var onRemoveFn_1;
      hintsUl_1.addEventListener("DOMNodeRemoved", onRemoveFn_1 = function(event) {
        if (event.target === hintsUl_1) {
          hintsUl_1.removeEventListener("DOMNodeRemoved", onRemoveFn_1);
          information = null;
          deprecation = null;
          onRemoveFn_1 = null;
        }
      });
    }
    var description = ctx.description ? md.render(ctx.description) : "Self descriptive.";
    var type2 = ctx.type ? '<span class="infoType">' + renderType(ctx.type) + "</span>" : "";
    information.innerHTML = '<div class="content">' + (description.slice(0, 3) === "<p>" ? "<p>" + type2 + description.slice(3) : type2 + description) + "</div>";
    if (ctx && deprecation && ctx.isDeprecated) {
      var reason = ctx.deprecationReason ? md.render(ctx.deprecationReason) : "";
      deprecation.innerHTML = '<span class="deprecation-label">Deprecated</span>' + reason;
      deprecation.style.display = "block";
    } else if (deprecation) {
      deprecation.style.display = "none";
    }
    if (onHintInformationRender) {
      onHintInformationRender(information);
    }
  });
}
function renderType(type2) {
  if (type2 instanceof GraphQLNonNull) {
    return renderType(type2.ofType) + "!";
  }
  if (type2 instanceof GraphQLList) {
    return "[" + renderType(type2.ofType) + "]";
  }
  return '<a class="typeName">' + type2.name + "</a>";
}

// node_modules/graphiql/esm/utility/commonKeys.js
init_define_process_env();
var _a;
var isMacOs = false;
if (typeof window === "object") {
  isMacOs = window.navigator.platform === "MacIntel";
}
var commonKeys = (_a = {}, _a[isMacOs ? "Cmd-F" : "Ctrl-F"] = "findPersistent", _a["Cmd-G"] = "findPersistent", _a["Ctrl-G"] = "findPersistent", _a["Ctrl-Left"] = "goSubwordLeft", _a["Ctrl-Right"] = "goSubwordRight", _a["Alt-Left"] = "goGroupLeft", _a["Alt-Right"] = "goGroupRight", _a);
var commonKeys_default = commonKeys;

// node_modules/graphiql/esm/components/QueryEditor.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
var md2 = new import_markdown_it2.default();
var AUTO_COMPLETE_AFTER_KEY = /^[a-zA-Z0-9_@(]$/;
var QueryEditor = function(_super) {
  __extends5(QueryEditor2, _super);
  function QueryEditor2(props) {
    var _this = _super.call(this, props) || this;
    _this.editor = null;
    _this.ignoreChangeEvent = false;
    _this._node = null;
    _this._onKeyUp = function(_cm, event) {
      if (AUTO_COMPLETE_AFTER_KEY.test(event.key) && _this.editor) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.ignoreChangeEvent && _this.editor) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(cm, data) {
      onHasCompletion(cm, data, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  QueryEditor2.prototype.componentDidMount = function() {
    var _this = this;
    var _a2, _b, _c;
    var CodeMirror2 = require_codemirror();
    require_show_hint();
    require_comment();
    require_matchbrackets();
    require_closebrackets();
    require_foldgutter();
    require_brace_fold();
    require_search();
    require_searchcursor();
    require_jump_to_line();
    require_dialog();
    require_lint();
    require_sublime();
    require_hint();
    require_lint2();
    require_info();
    require_jump();
    require_mode();
    var editor = this.editor = CodeMirror2(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: "graphql",
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      lint: {
        schema: this.props.schema,
        validationRules: (_a2 = this.props.validationRules) !== null && _a2 !== void 0 ? _a2 : null,
        externalFragments: (_b = this.props) === null || _b === void 0 ? void 0 : _b.externalFragments
      },
      hintOptions: {
        schema: this.props.schema,
        closeOnUnfocus: false,
        completeSingle: false,
        container: this._node,
        externalFragments: (_c = this.props) === null || _c === void 0 ? void 0 : _c.externalFragments
      },
      info: {
        schema: this.props.schema,
        renderDescription: function(text2) {
          return md2.render(text2);
        },
        onClick: function(reference) {
          return _this.props.onClickReference && _this.props.onClickReference(reference);
        }
      },
      jump: {
        schema: this.props.schema,
        onClick: function(reference) {
          return _this.props.onClickReference && _this.props.onClickReference(reference);
        }
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign(__assign({ "Cmd-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Ctrl-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Alt-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Shift-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Shift-Alt-Space": function() {
        return editor.showHint({ completeSingle: true, container: _this._node });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-C": function() {
        if (_this.props.onCopyQuery) {
          _this.props.onCopyQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-F": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys_default), { "Cmd-S": function() {
        if (_this.props.onRunQuery) {
        }
      }, "Ctrl-S": function() {
        if (_this.props.onRunQuery) {
        }
      } })
    });
    if (editor) {
      editor.on("change", this._onEdit);
      editor.on("keyup", this._onKeyUp);
      editor.on("hasCompletion", this._onHasCompletion);
      editor.on("beforeChange", this._onBeforeChange);
    }
  };
  QueryEditor2.prototype.componentDidUpdate = function(prevProps) {
    var CodeMirror2 = require_codemirror();
    this.ignoreChangeEvent = true;
    if (this.props.schema !== prevProps.schema && this.editor) {
      this.editor.options.lint.schema = this.props.schema;
      this.editor.options.hintOptions.schema = this.props.schema;
      this.editor.options.info.schema = this.props.schema;
      this.editor.options.jump.schema = this.props.schema;
      CodeMirror2.signal(this.editor, "change", this.editor);
    }
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue && this.editor) {
      this.cachedValue = this.props.value;
      this.editor.setValue(this.props.value);
    }
    this.ignoreChangeEvent = false;
  };
  QueryEditor2.prototype.componentWillUnmount = function() {
    if (this.editor) {
      this.editor.off("change", this._onEdit);
      this.editor.off("keyup", this._onKeyUp);
      this.editor.off("hasCompletion", this._onHasCompletion);
      this.editor = null;
    }
  };
  QueryEditor2.prototype.render = function() {
    var _this = this;
    return import_react6.default.createElement("section", { className: "query-editor", "aria-label": "Query Editor", ref: function(node) {
      _this._node = node;
    } });
  };
  QueryEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  QueryEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  QueryEditor2.prototype._onBeforeChange = function(_instance, change) {
    if (change.origin === "paste") {
      var text2 = change.text.map(normalizeWhitespace);
      change.update(change.from, change.to, text2);
    }
  };
  return QueryEditor2;
}(import_react6.default.Component);

// node_modules/graphiql/esm/components/VariableEditor.js
init_define_process_env();
var import_react7 = __toModule(require_react());
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign2.apply(this, arguments);
};
var VariableEditor = function(_super) {
  __extends6(VariableEditor2, _super);
  function VariableEditor2(props) {
    var _this = _super.call(this, props) || this;
    _this.editor = null;
    _this._node = null;
    _this.ignoreChangeEvent = false;
    _this._onKeyUp = function(_cm, event) {
      var code = event.keyCode;
      if (!_this.editor) {
        return;
      }
      if (code >= 65 && code <= 90 || !event.shiftKey && code >= 48 && code <= 57 || event.shiftKey && code === 189 || event.shiftKey && code === 222) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.editor) {
        return;
      }
      if (!_this.ignoreChangeEvent) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(instance, changeObj) {
      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  VariableEditor2.prototype.componentDidMount = function() {
    var _this = this;
    this.CodeMirror = require_codemirror();
    require_show_hint();
    require_matchbrackets();
    require_closebrackets();
    require_brace_fold();
    require_foldgutter();
    require_lint();
    require_searchcursor();
    require_jump_to_line();
    require_dialog();
    require_sublime();
    require_hint2();
    require_lint3();
    require_mode2();
    var editor = this.editor = this.CodeMirror(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: "graphql-variables",
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      lint: {
        variableToType: this.props.variableToType
      },
      hintOptions: {
        variableToType: this.props.variableToType,
        closeOnUnfocus: false,
        completeSingle: false,
        container: this._node
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign2({ "Cmd-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Ctrl-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Alt-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Shift-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys_default)
    });
    editor.on("change", this._onEdit);
    editor.on("keyup", this._onKeyUp);
    editor.on("hasCompletion", this._onHasCompletion);
  };
  VariableEditor2.prototype.componentDidUpdate = function(prevProps) {
    this.CodeMirror = require_codemirror();
    if (!this.editor) {
      return;
    }
    this.ignoreChangeEvent = true;
    if (this.props.variableToType !== prevProps.variableToType) {
      this.editor.options.lint.variableToType = this.props.variableToType;
      this.editor.options.hintOptions.variableToType = this.props.variableToType;
      this.CodeMirror.signal(this.editor, "change", this.editor);
    }
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
      var thisValue = this.props.value || "";
      this.cachedValue = thisValue;
      this.editor.setValue(thisValue);
    }
    this.ignoreChangeEvent = false;
  };
  VariableEditor2.prototype.componentWillUnmount = function() {
    if (!this.editor) {
      return;
    }
    this.editor.off("change", this._onEdit);
    this.editor.off("keyup", this._onKeyUp);
    this.editor.off("hasCompletion", this._onHasCompletion);
    this.editor = null;
  };
  VariableEditor2.prototype.render = function() {
    var _this = this;
    return import_react7.default.createElement("div", { className: "codemirrorWrap", style: {
      position: this.props.active ? "relative" : "absolute",
      visibility: this.props.active ? "visible" : "hidden"
    }, ref: function(node) {
      _this._node = node;
    } });
  };
  VariableEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  VariableEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return VariableEditor2;
}(import_react7.default.Component);

// node_modules/graphiql/esm/components/HeaderEditor.js
init_define_process_env();
var import_react8 = __toModule(require_react());
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign3.apply(this, arguments);
};
var HeaderEditor = function(_super) {
  __extends7(HeaderEditor2, _super);
  function HeaderEditor2(props) {
    var _this = _super.call(this, props) || this;
    _this.editor = null;
    _this._node = null;
    _this.ignoreChangeEvent = false;
    _this._onKeyUp = function(_cm, event) {
      var code = event.keyCode;
      if (!_this.editor) {
        return;
      }
      if (code >= 65 && code <= 90 || !event.shiftKey && code >= 48 && code <= 57 || event.shiftKey && code === 189 || event.shiftKey && code === 222) {
        _this.editor.execCommand("autocomplete");
      }
    };
    _this._onEdit = function() {
      if (!_this.editor) {
        return;
      }
      if (!_this.ignoreChangeEvent) {
        _this.cachedValue = _this.editor.getValue();
        if (_this.props.onEdit) {
          _this.props.onEdit(_this.cachedValue);
        }
      }
    };
    _this._onHasCompletion = function(instance, changeObj) {
      onHasCompletion(instance, changeObj, _this.props.onHintInformationRender);
    };
    _this.cachedValue = props.value || "";
    return _this;
  }
  HeaderEditor2.prototype.componentDidMount = function() {
    var _this = this;
    this.CodeMirror = require_codemirror();
    require_show_hint();
    require_matchbrackets();
    require_closebrackets();
    require_brace_fold();
    require_foldgutter();
    require_lint();
    require_searchcursor();
    require_jump_to_line();
    require_dialog();
    require_javascript();
    require_sublime();
    var editor = this.editor = this.CodeMirror(this._node, {
      value: this.props.value || "",
      lineNumbers: true,
      tabSize: 2,
      mode: { name: "javascript", json: true },
      theme: this.props.editorTheme || "graphiql",
      keyMap: "sublime",
      autoCloseBrackets: true,
      matchBrackets: true,
      showCursorWhenSelecting: true,
      readOnly: this.props.readOnly ? "nocursor" : false,
      foldGutter: {
        minFoldSize: 4
      },
      gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
      extraKeys: __assign3({ "Cmd-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Ctrl-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Alt-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Shift-Space": function() {
        return _this.editor.showHint({
          completeSingle: false,
          container: _this._node
        });
      }, "Cmd-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Ctrl-Enter": function() {
        if (_this.props.onRunQuery) {
          _this.props.onRunQuery();
        }
      }, "Shift-Ctrl-P": function() {
        if (_this.props.onPrettifyQuery) {
          _this.props.onPrettifyQuery();
        }
      }, "Shift-Ctrl-M": function() {
        if (_this.props.onMergeQuery) {
          _this.props.onMergeQuery();
        }
      } }, commonKeys_default)
    });
    editor.on("change", this._onEdit);
    editor.on("keyup", this._onKeyUp);
    editor.on("hasCompletion", this._onHasCompletion);
  };
  HeaderEditor2.prototype.componentDidUpdate = function(prevProps) {
    this.CodeMirror = require_codemirror();
    if (!this.editor) {
      return;
    }
    this.ignoreChangeEvent = true;
    if (this.props.value !== prevProps.value && this.props.value !== this.cachedValue) {
      var thisValue = this.props.value || "";
      this.cachedValue = thisValue;
      this.editor.setValue(thisValue);
    }
    this.ignoreChangeEvent = false;
  };
  HeaderEditor2.prototype.componentWillUnmount = function() {
    if (!this.editor) {
      return;
    }
    this.editor.off("change", this._onEdit);
    this.editor.off("keyup", this._onKeyUp);
    this.editor.off("hasCompletion", this._onHasCompletion);
    this.editor = null;
  };
  HeaderEditor2.prototype.render = function() {
    var _this = this;
    return import_react8.default.createElement("div", { className: "codemirrorWrap", style: {
      position: this.props.active ? "relative" : "absolute",
      visibility: this.props.active ? "visible" : "hidden"
    }, ref: function(node) {
      _this._node = node;
    } });
  };
  HeaderEditor2.prototype.getCodeMirror = function() {
    return this.editor;
  };
  HeaderEditor2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return HeaderEditor2;
}(import_react8.default.Component);

// node_modules/graphiql/esm/components/ResultViewer.js
init_define_process_env();
var import_react9 = __toModule(require_react());
var import_react_dom = __toModule(require_react_dom());
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ResultViewer = function(_super) {
  __extends8(ResultViewer2, _super);
  function ResultViewer2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.viewer = null;
    _this._node = null;
    return _this;
  }
  ResultViewer2.prototype.componentDidMount = function() {
    var CodeMirror2 = require_codemirror();
    require_foldgutter();
    require_brace_fold();
    require_dialog();
    require_search();
    require_searchcursor();
    require_jump_to_line();
    require_sublime();
    require_mode3();
    var Tooltip = this.props.ResultsTooltip;
    var ImagePreview2 = this.props.ImagePreview;
    if (Tooltip || ImagePreview2) {
      require_info_addon();
      var tooltipDiv_1 = document.createElement("div");
      CodeMirror2.registerHelper("info", "graphql-results", function(token, _options, _cm, pos) {
        var infoElements = [];
        if (Tooltip) {
          infoElements.push(import_react9.default.createElement(Tooltip, { pos }));
        }
        if (ImagePreview2 && typeof ImagePreview2.shouldRender === "function" && ImagePreview2.shouldRender(token)) {
          infoElements.push(import_react9.default.createElement(ImagePreview2, { token }));
        }
        if (!infoElements.length) {
          import_react_dom.default.unmountComponentAtNode(tooltipDiv_1);
          return null;
        }
        import_react_dom.default.render(import_react9.default.createElement("div", null, infoElements), tooltipDiv_1);
        return tooltipDiv_1;
      });
    }
    this.viewer = CodeMirror2(this._node, {
      lineWrapping: true,
      value: this.props.value || "",
      readOnly: true,
      theme: this.props.editorTheme || "graphiql",
      mode: "graphql-results",
      keyMap: "sublime",
      foldGutter: {
        minFoldSize: 4
      },
      gutters: ["CodeMirror-foldgutter"],
      info: Boolean(this.props.ResultsTooltip || this.props.ImagePreview),
      extraKeys: commonKeys_default
    });
  };
  ResultViewer2.prototype.shouldComponentUpdate = function(nextProps) {
    return this.props.value !== nextProps.value;
  };
  ResultViewer2.prototype.componentDidUpdate = function() {
    if (this.viewer) {
      this.viewer.setValue(this.props.value || "");
    }
  };
  ResultViewer2.prototype.componentWillUnmount = function() {
    this.viewer = null;
  };
  ResultViewer2.prototype.render = function() {
    var _this = this;
    return import_react9.default.createElement("section", { className: "result-window", "aria-label": "Result Window", "aria-live": "polite", "aria-atomic": "true", ref: function(node) {
      if (node) {
        _this.props.registerRef(node);
        _this._node = node;
      }
    } });
  };
  ResultViewer2.prototype.getCodeMirror = function() {
    return this.viewer;
  };
  ResultViewer2.prototype.getClientHeight = function() {
    return this._node && this._node.clientHeight;
  };
  return ResultViewer2;
}(import_react9.default.Component);

// node_modules/graphiql/esm/components/DocExplorer.js
init_define_process_env();
var import_react20 = __toModule(require_react());
init_graphql2();

// node_modules/graphiql/esm/components/DocExplorer/FieldDoc.js
init_define_process_env();
var import_react15 = __toModule(require_react());

// node_modules/graphiql/esm/components/DocExplorer/Argument.js
init_define_process_env();
var import_react12 = __toModule(require_react());

// node_modules/graphiql/esm/components/DocExplorer/TypeLink.js
init_define_process_env();
var import_react10 = __toModule(require_react());
init_graphql2();
function TypeLink(props) {
  var onClick = props.onClick ? props.onClick : function() {
    return null;
  };
  return renderType3(props.type, onClick);
}
function renderType3(type2, onClick) {
  if (type2 instanceof GraphQLNonNull) {
    return import_react10.default.createElement("span", null, renderType3(type2.ofType, onClick), "!");
  }
  if (type2 instanceof GraphQLList) {
    return import_react10.default.createElement("span", null, "[", renderType3(type2.ofType, onClick), "]");
  }
  return import_react10.default.createElement("a", { className: "type-name", onClick: function(event) {
    event.preventDefault();
    onClick(type2, event);
  }, href: "#" }, type2 === null || type2 === void 0 ? void 0 : type2.name);
}

// node_modules/graphiql/esm/components/DocExplorer/DefaultValue.js
init_define_process_env();
var import_react11 = __toModule(require_react());
init_graphql2();
var printDefault = function(ast) {
  if (!ast) {
    return "";
  }
  return print(ast);
};
function DefaultValue(_a2) {
  var field = _a2.field;
  if ("defaultValue" in field && field.defaultValue !== void 0) {
    return import_react11.default.createElement("span", null, " = ", import_react11.default.createElement("span", { className: "arg-default-value" }, printDefault(astFromValue(field.defaultValue, field.type))));
  }
  return null;
}

// node_modules/graphiql/esm/components/DocExplorer/Argument.js
function Argument2(_a2) {
  var arg = _a2.arg, onClickType = _a2.onClickType, showDefaultValue = _a2.showDefaultValue;
  return import_react12.default.createElement("span", { className: "arg" }, import_react12.default.createElement("span", { className: "arg-name" }, arg.name), ": ", import_react12.default.createElement(TypeLink, { type: arg.type, onClick: onClickType }), showDefaultValue !== false && import_react12.default.createElement(DefaultValue, { field: arg }));
}

// node_modules/graphiql/esm/components/DocExplorer/Directive.js
init_define_process_env();
var import_react13 = __toModule(require_react());
function Directive2(_a2) {
  var directive = _a2.directive;
  return import_react13.default.createElement("span", { className: "doc-category-item", id: directive.name.value }, "@", directive.name.value);
}

// node_modules/graphiql/esm/components/DocExplorer/MarkdownContent.js
init_define_process_env();
var import_react14 = __toModule(require_react());
var import_markdown_it3 = __toModule(require_markdown_it());
var md3 = new import_markdown_it3.default();
function MarkdownContent(_a2) {
  var markdown = _a2.markdown, className = _a2.className;
  if (!markdown) {
    return import_react14.default.createElement("div", null);
  }
  return import_react14.default.createElement("div", { className, dangerouslySetInnerHTML: { __html: md3.render(markdown) } });
}

// node_modules/graphiql/esm/components/DocExplorer/FieldDoc.js
function FieldDoc(_a2) {
  var field = _a2.field, onClickType = _a2.onClickType;
  var argsDef;
  if (field && "args" in field && field.args.length > 0) {
    argsDef = import_react15.default.createElement("div", { className: "doc-category" }, import_react15.default.createElement("div", { className: "doc-category-title" }, "arguments"), field.args.map(function(arg) {
      return import_react15.default.createElement("div", { key: arg.name, className: "doc-category-item" }, import_react15.default.createElement("div", null, import_react15.default.createElement(Argument2, { arg, onClickType })), import_react15.default.createElement(MarkdownContent, { className: "doc-value-description", markdown: arg.description }));
    }));
  }
  var directivesDef;
  if (field && field.astNode && field.astNode.directives && field.astNode.directives.length > 0) {
    directivesDef = import_react15.default.createElement("div", { className: "doc-category" }, import_react15.default.createElement("div", { className: "doc-category-title" }, "directives"), field.astNode.directives.map(function(directive) {
      return import_react15.default.createElement("div", { key: directive.name.value, className: "doc-category-item" }, import_react15.default.createElement("div", null, import_react15.default.createElement(Directive2, { directive })));
    }));
  }
  return import_react15.default.createElement("div", null, import_react15.default.createElement(MarkdownContent, { className: "doc-type-description", markdown: (field === null || field === void 0 ? void 0 : field.description) || "No Description" }), field && "deprecationReason" in field && import_react15.default.createElement(MarkdownContent, { className: "doc-deprecation", markdown: field === null || field === void 0 ? void 0 : field.deprecationReason }), import_react15.default.createElement("div", { className: "doc-category" }, import_react15.default.createElement("div", { className: "doc-category-title" }, "type"), import_react15.default.createElement(TypeLink, { type: field === null || field === void 0 ? void 0 : field.type, onClick: onClickType })), argsDef, directivesDef);
}

// node_modules/graphiql/esm/components/DocExplorer/SchemaDoc.js
init_define_process_env();
var import_react16 = __toModule(require_react());
function SchemaDoc(_a2) {
  var schema = _a2.schema, onClickType = _a2.onClickType;
  var queryType = schema.getQueryType();
  var mutationType = schema.getMutationType && schema.getMutationType();
  var subscriptionType = schema.getSubscriptionType && schema.getSubscriptionType();
  return import_react16.default.createElement("div", null, import_react16.default.createElement(MarkdownContent, { className: "doc-type-description", markdown: schema.description || "A GraphQL schema provides a root type for each kind of operation." }), import_react16.default.createElement("div", { className: "doc-category" }, import_react16.default.createElement("div", { className: "doc-category-title" }, "root types"), import_react16.default.createElement("div", { className: "doc-category-item" }, import_react16.default.createElement("span", { className: "keyword" }, "query"), ": ", import_react16.default.createElement(TypeLink, { type: queryType, onClick: onClickType })), mutationType && import_react16.default.createElement("div", { className: "doc-category-item" }, import_react16.default.createElement("span", { className: "keyword" }, "mutation"), ": ", import_react16.default.createElement(TypeLink, { type: mutationType, onClick: onClickType })), subscriptionType && import_react16.default.createElement("div", { className: "doc-category-item" }, import_react16.default.createElement("span", { className: "keyword" }, "subscription"), ": ", import_react16.default.createElement(TypeLink, { type: subscriptionType, onClick: onClickType }))));
}

// node_modules/graphiql/esm/components/DocExplorer/SearchBox.js
init_define_process_env();
var import_react17 = __toModule(require_react());

// node_modules/graphiql/esm/utility/debounce.js
init_define_process_env();
function debounce(duration, fn) {
  var timeout;
  return function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (timeout) {
      window.clearTimeout(timeout);
    }
    timeout = window.setTimeout(function() {
      timeout = null;
      fn.apply(_this, args);
    }, duration);
  };
}

// node_modules/graphiql/esm/components/DocExplorer/SearchBox.js
var __extends9 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var SearchBox = function(_super) {
  __extends9(SearchBox2, _super);
  function SearchBox2(props) {
    var _this = _super.call(this, props) || this;
    _this.handleChange = function(event) {
      var value = event.currentTarget.value;
      _this.setState({ value });
      _this.debouncedOnSearch(value);
    };
    _this.handleClear = function() {
      _this.setState({ value: "" });
      _this.props.onSearch("");
    };
    _this.state = { value: props.value || "" };
    _this.debouncedOnSearch = debounce(200, _this.props.onSearch);
    return _this;
  }
  SearchBox2.prototype.render = function() {
    return import_react17.default.createElement("label", { className: "search-box" }, import_react17.default.createElement("div", { className: "search-box-icon", "aria-hidden": "true" }, "\u26B2"), import_react17.default.createElement("input", { value: this.state.value, onChange: this.handleChange, type: "text", placeholder: this.props.placeholder, "aria-label": this.props.placeholder }), this.state.value && import_react17.default.createElement("button", { className: "search-box-clear", onClick: this.handleClear, "aria-label": "Clear search input" }, "\u2715"));
  };
  return SearchBox2;
}(import_react17.default.Component);
var SearchBox_default = SearchBox;

// node_modules/graphiql/esm/components/DocExplorer/SearchResults.js
init_define_process_env();
var import_react18 = __toModule(require_react());
var __extends10 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var SearchResults = function(_super) {
  __extends10(SearchResults2, _super);
  function SearchResults2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SearchResults2.prototype.shouldComponentUpdate = function(nextProps) {
    return this.props.schema !== nextProps.schema || this.props.searchValue !== nextProps.searchValue;
  };
  SearchResults2.prototype.render = function() {
    var e_1, _a2;
    var searchValue = this.props.searchValue;
    var withinType = this.props.withinType;
    var schema = this.props.schema;
    var onClickType = this.props.onClickType;
    var onClickField = this.props.onClickField;
    var matchedWithin = [];
    var matchedTypes = [];
    var matchedFields = [];
    var typeMap = schema.getTypeMap();
    var typeNames = Object.keys(typeMap);
    if (withinType) {
      typeNames = typeNames.filter(function(n) {
        return n !== withinType.name;
      });
      typeNames.unshift(withinType.name);
    }
    var _loop_1 = function(typeName2) {
      if (matchedWithin.length + matchedTypes.length + matchedFields.length >= 100) {
        return "break";
      }
      var type2 = typeMap[typeName2];
      if (withinType !== type2 && isMatch(typeName2, searchValue)) {
        matchedTypes.push(import_react18.default.createElement("div", { className: "doc-category-item", key: typeName2 }, import_react18.default.createElement(TypeLink, { type: type2, onClick: onClickType })));
      }
      if (type2 && "getFields" in type2) {
        var fields_1 = type2.getFields();
        Object.keys(fields_1).forEach(function(fieldName) {
          var field = fields_1[fieldName];
          var matchingArgs;
          if (!isMatch(fieldName, searchValue)) {
            if ("args" in field && field.args.length) {
              matchingArgs = field.args.filter(function(arg) {
                return isMatch(arg.name, searchValue);
              });
              if (matchingArgs.length === 0) {
                return;
              }
            } else {
              return;
            }
          }
          var match = import_react18.default.createElement("div", { className: "doc-category-item", key: typeName2 + "." + fieldName }, withinType !== type2 && [
            import_react18.default.createElement(TypeLink, { key: "type", type: type2, onClick: onClickType }),
            "."
          ], import_react18.default.createElement("a", { className: "field-name", onClick: function(event) {
            return onClickField(field, type2, event);
          } }, field.name), matchingArgs && [
            "(",
            import_react18.default.createElement("span", { key: "args" }, matchingArgs.map(function(arg) {
              return import_react18.default.createElement(Argument2, { key: arg.name, arg, onClickType, showDefaultValue: false });
            })),
            ")"
          ]);
          if (withinType === type2) {
            matchedWithin.push(match);
          } else {
            matchedFields.push(match);
          }
        });
      }
    };
    try {
      for (var typeNames_1 = __values(typeNames), typeNames_1_1 = typeNames_1.next(); !typeNames_1_1.done; typeNames_1_1 = typeNames_1.next()) {
        var typeName = typeNames_1_1.value;
        var state_1 = _loop_1(typeName);
        if (state_1 === "break")
          break;
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (typeNames_1_1 && !typeNames_1_1.done && (_a2 = typeNames_1.return))
          _a2.call(typeNames_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    if (matchedWithin.length + matchedTypes.length + matchedFields.length === 0) {
      return import_react18.default.createElement("span", { className: "doc-alert-text" }, "No results found.");
    }
    if (withinType && matchedTypes.length + matchedFields.length > 0) {
      return import_react18.default.createElement("div", null, matchedWithin, import_react18.default.createElement("div", { className: "doc-category" }, import_react18.default.createElement("div", { className: "doc-category-title" }, "other results"), matchedTypes, matchedFields));
    }
    return import_react18.default.createElement("div", { className: "doc-search-items" }, matchedWithin, matchedTypes, matchedFields);
  };
  return SearchResults2;
}(import_react18.default.Component);
var SearchResults_default = SearchResults;
function isMatch(sourceText, searchValue) {
  try {
    var escaped = searchValue.replace(/[^_0-9A-Za-z]/g, function(ch) {
      return "\\" + ch;
    });
    return sourceText.search(new RegExp(escaped, "i")) !== -1;
  } catch (e) {
    return sourceText.toLowerCase().indexOf(searchValue.toLowerCase()) !== -1;
  }
}

// node_modules/graphiql/esm/components/DocExplorer/TypeDoc.js
init_define_process_env();
var import_react19 = __toModule(require_react());
init_graphql2();
var __extends11 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var TypeDoc = function(_super) {
  __extends11(TypeDoc2, _super);
  function TypeDoc2(props) {
    var _this = _super.call(this, props) || this;
    _this.handleShowDeprecated = function() {
      return _this.setState({ showDeprecated: true });
    };
    _this.state = { showDeprecated: false };
    return _this;
  }
  TypeDoc2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
    return this.props.type !== nextProps.type || this.props.schema !== nextProps.schema || this.state.showDeprecated !== nextState.showDeprecated;
  };
  TypeDoc2.prototype.render = function() {
    var schema = this.props.schema;
    var type2 = this.props.type;
    var onClickType = this.props.onClickType;
    var onClickField = this.props.onClickField;
    var typesTitle = null;
    var types = [];
    if (type2 instanceof GraphQLUnionType) {
      typesTitle = "possible types";
      types = schema.getPossibleTypes(type2);
    } else if (type2 instanceof GraphQLInterfaceType) {
      typesTitle = "implementations";
      types = schema.getPossibleTypes(type2);
    } else if (type2 instanceof GraphQLObjectType) {
      typesTitle = "implements";
      types = type2.getInterfaces();
    }
    var typesDef;
    if (types && types.length > 0) {
      typesDef = import_react19.default.createElement("div", { className: "doc-category" }, import_react19.default.createElement("div", { className: "doc-category-title" }, typesTitle), types.map(function(subtype) {
        return import_react19.default.createElement("div", { key: subtype.name, className: "doc-category-item" }, import_react19.default.createElement(TypeLink, { type: subtype, onClick: onClickType }));
      }));
    }
    var fieldsDef;
    var deprecatedFieldsDef;
    if (type2 && "getFields" in type2) {
      var fieldMap_1 = type2.getFields();
      var fields7 = Object.keys(fieldMap_1).map(function(name2) {
        return fieldMap_1[name2];
      });
      fieldsDef = import_react19.default.createElement("div", { className: "doc-category" }, import_react19.default.createElement("div", { className: "doc-category-title" }, "fields"), fields7.filter(function(field) {
        return "isDeprecated" in field ? !field.isDeprecated : true;
      }).map(function(field) {
        return import_react19.default.createElement(Field2, { key: field.name, type: type2, field, onClickType, onClickField });
      }));
      var deprecatedFields = fields7.filter(function(field) {
        return "isDeprecated" in field && field.isDeprecated;
      });
      if (deprecatedFields.length > 0) {
        deprecatedFieldsDef = import_react19.default.createElement("div", { className: "doc-category" }, import_react19.default.createElement("div", { className: "doc-category-title" }, "deprecated fields"), !this.state.showDeprecated ? import_react19.default.createElement("button", { className: "show-btn", onClick: this.handleShowDeprecated }, "Show deprecated fields...") : deprecatedFields.map(function(field) {
          return import_react19.default.createElement(Field2, { key: field.name, type: type2, field, onClickType, onClickField });
        }));
      }
    }
    var valuesDef;
    var deprecatedValuesDef;
    if (type2 instanceof GraphQLEnumType) {
      var values = type2.getValues();
      valuesDef = import_react19.default.createElement("div", { className: "doc-category" }, import_react19.default.createElement("div", { className: "doc-category-title" }, "values"), values.filter(function(value) {
        return !value.isDeprecated;
      }).map(function(value) {
        return import_react19.default.createElement(EnumValue2, { key: value.name, value });
      }));
      var deprecatedValues = values.filter(function(value) {
        return value.isDeprecated;
      });
      if (deprecatedValues.length > 0) {
        deprecatedValuesDef = import_react19.default.createElement("div", { className: "doc-category" }, import_react19.default.createElement("div", { className: "doc-category-title" }, "deprecated values"), !this.state.showDeprecated ? import_react19.default.createElement("button", { className: "show-btn", onClick: this.handleShowDeprecated }, "Show deprecated values...") : deprecatedValues.map(function(value) {
          return import_react19.default.createElement(EnumValue2, { key: value.name, value });
        }));
      }
    }
    return import_react19.default.createElement("div", null, import_react19.default.createElement(MarkdownContent, { className: "doc-type-description", markdown: "description" in type2 && type2.description || "No Description" }), type2 instanceof GraphQLObjectType && typesDef, fieldsDef, deprecatedFieldsDef, valuesDef, deprecatedValuesDef, !(type2 instanceof GraphQLObjectType) && typesDef);
  };
  return TypeDoc2;
}(import_react19.default.Component);
var TypeDoc_default = TypeDoc;
function Field2(_a2) {
  var type2 = _a2.type, field = _a2.field, onClickType = _a2.onClickType, onClickField = _a2.onClickField;
  return import_react19.default.createElement("div", { className: "doc-category-item" }, import_react19.default.createElement("a", { className: "field-name", onClick: function(event) {
    return onClickField(field, type2, event);
  } }, field.name), "args" in field && field.args && field.args.length > 0 && [
    "(",
    import_react19.default.createElement("span", { key: "args" }, field.args.map(function(arg) {
      return import_react19.default.createElement(Argument2, { key: arg.name, arg, onClickType });
    })),
    ")"
  ], ": ", import_react19.default.createElement(TypeLink, { type: field.type, onClick: onClickType }), import_react19.default.createElement(DefaultValue, { field }), field.description && import_react19.default.createElement(MarkdownContent, { className: "field-short-description", markdown: field.description }), "deprecationReason" in field && field.deprecationReason && import_react19.default.createElement(MarkdownContent, { className: "doc-deprecation", markdown: field.deprecationReason }));
}
function EnumValue2(_a2) {
  var value = _a2.value;
  return import_react19.default.createElement("div", { className: "doc-category-item" }, import_react19.default.createElement("div", { className: "enum-value" }, value.name), import_react19.default.createElement(MarkdownContent, { className: "doc-value-description", markdown: value.description }), value.deprecationReason && import_react19.default.createElement(MarkdownContent, { className: "doc-deprecation", markdown: value.deprecationReason }));
}

// node_modules/graphiql/esm/components/DocExplorer.js
var __extends12 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign4 = function() {
  __assign4 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign4.apply(this, arguments);
};
var initialNav = {
  name: "Schema",
  title: "Documentation Explorer"
};
var DocExplorer = function(_super) {
  __extends12(DocExplorer2, _super);
  function DocExplorer2(props) {
    var _this = _super.call(this, props) || this;
    _this.handleNavBackClick = function() {
      if (_this.state.navStack.length > 1) {
        _this.setState({ navStack: _this.state.navStack.slice(0, -1) });
      }
    };
    _this.handleClickType = function(type2) {
      _this.showDoc(type2);
    };
    _this.handleClickField = function(field) {
      _this.showDoc(field);
    };
    _this.handleSearch = function(value) {
      _this.showSearch(value);
    };
    _this.state = { navStack: [initialNav] };
    return _this;
  }
  DocExplorer2.prototype.shouldComponentUpdate = function(nextProps, nextState) {
    return this.props.schema !== nextProps.schema || this.state.navStack !== nextState.navStack;
  };
  DocExplorer2.prototype.render = function() {
    var schema = this.props.schema;
    var navStack = this.state.navStack;
    var navItem = navStack[navStack.length - 1];
    var content;
    if (schema === void 0) {
      content = import_react20.default.createElement("div", { className: "spinner-container" }, import_react20.default.createElement("div", { className: "spinner" }));
    } else if (!schema) {
      content = import_react20.default.createElement("div", { className: "error-container" }, "No Schema Available");
    } else if (navItem.search) {
      content = import_react20.default.createElement(SearchResults_default, { searchValue: navItem.search, withinType: navItem.def, schema, onClickType: this.handleClickType, onClickField: this.handleClickField });
    } else if (navStack.length === 1) {
      content = import_react20.default.createElement(SchemaDoc, { schema, onClickType: this.handleClickType });
    } else if (isType(navItem.def)) {
      content = import_react20.default.createElement(TypeDoc_default, { schema, type: navItem.def, onClickType: this.handleClickType, onClickField: this.handleClickField });
    } else {
      content = import_react20.default.createElement(FieldDoc, { field: navItem.def, onClickType: this.handleClickType });
    }
    var shouldSearchBoxAppear = navStack.length === 1 || isType(navItem.def) && "getFields" in navItem.def;
    var prevName;
    if (navStack.length > 1) {
      prevName = navStack[navStack.length - 2].name;
    }
    return import_react20.default.createElement("section", { className: "doc-explorer", key: navItem.name, "aria-label": "Documentation Explorer" }, import_react20.default.createElement("div", { className: "doc-explorer-title-bar" }, prevName && import_react20.default.createElement("button", { className: "doc-explorer-back", onClick: this.handleNavBackClick, "aria-label": "Go back to " + prevName }, prevName), import_react20.default.createElement("div", { className: "doc-explorer-title" }, navItem.title || navItem.name), import_react20.default.createElement("div", { className: "doc-explorer-rhs" }, this.props.children)), import_react20.default.createElement("div", { className: "doc-explorer-contents" }, shouldSearchBoxAppear && import_react20.default.createElement(SearchBox_default, { value: navItem.search, placeholder: "Search " + navItem.name + "...", onSearch: this.handleSearch }), content));
  };
  DocExplorer2.prototype.showDoc = function(typeOrField) {
    var navStack = this.state.navStack;
    var topNav = navStack[navStack.length - 1];
    if (topNav.def !== typeOrField) {
      this.setState({
        navStack: navStack.concat([
          {
            name: typeOrField.name,
            def: typeOrField
          }
        ])
      });
    }
  };
  DocExplorer2.prototype.showDocForReference = function(reference) {
    if (reference && reference.kind === "Type") {
      this.showDoc(reference.type);
    } else if (reference.kind === "Field") {
      this.showDoc(reference.field);
    } else if (reference.kind === "Argument" && reference.field) {
      this.showDoc(reference.field);
    } else if (reference.kind === "EnumValue" && reference.type) {
      this.showDoc(reference.type);
    }
  };
  DocExplorer2.prototype.showSearch = function(search) {
    var navStack = this.state.navStack.slice();
    var topNav = navStack[navStack.length - 1];
    navStack[navStack.length - 1] = __assign4(__assign4({}, topNav), { search });
    this.setState({ navStack });
  };
  DocExplorer2.prototype.reset = function() {
    this.setState({ navStack: [initialNav] });
  };
  return DocExplorer2;
}(import_react20.default.Component);

// node_modules/graphiql/esm/components/QueryHistory.js
init_define_process_env();
init_graphql2();
var import_react22 = __toModule(require_react());

// node_modules/graphiql/esm/utility/QueryStore.js
init_define_process_env();
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
};
var QueryStore = function() {
  function QueryStore2(key, storage, maxSize) {
    if (maxSize === void 0) {
      maxSize = null;
    }
    this.key = key;
    this.storage = storage;
    this.maxSize = maxSize;
    this.items = this.fetchAll();
  }
  Object.defineProperty(QueryStore2.prototype, "length", {
    get: function() {
      return this.items.length;
    },
    enumerable: false,
    configurable: true
  });
  QueryStore2.prototype.contains = function(item) {
    return this.items.some(function(x) {
      return x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName;
    });
  };
  QueryStore2.prototype.edit = function(item) {
    var itemIndex = this.items.findIndex(function(x) {
      return x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName;
    });
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1, item);
      this.save();
    }
  };
  QueryStore2.prototype.delete = function(item) {
    var itemIndex = this.items.findIndex(function(x) {
      return x.query === item.query && x.variables === item.variables && x.headers === item.headers && x.operationName === item.operationName;
    });
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1);
      this.save();
    }
  };
  QueryStore2.prototype.fetchRecent = function() {
    return this.items[this.items.length - 1];
  };
  QueryStore2.prototype.fetchAll = function() {
    var raw = this.storage.get(this.key);
    if (raw) {
      return JSON.parse(raw)[this.key];
    }
    return [];
  };
  QueryStore2.prototype.push = function(item) {
    var _a2;
    var items = __spread(this.items, [item]);
    if (this.maxSize && items.length > this.maxSize) {
      items.shift();
    }
    for (var attempts = 0; attempts < 5; attempts++) {
      var response = this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = items, _a2)));
      if (!response || !response.error) {
        this.items = items;
      } else if (response.isQuotaError && this.maxSize) {
        items.shift();
      } else {
        return;
      }
    }
  };
  QueryStore2.prototype.save = function() {
    var _a2;
    this.storage.set(this.key, JSON.stringify((_a2 = {}, _a2[this.key] = this.items, _a2)));
  };
  return QueryStore2;
}();
var QueryStore_default = QueryStore;

// node_modules/graphiql/esm/components/HistoryQuery.js
init_define_process_env();
var import_react21 = __toModule(require_react());
var __extends13 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var HistoryQuery = function(_super) {
  __extends13(HistoryQuery2, _super);
  function HistoryQuery2(props) {
    var _this = _super.call(this, props) || this;
    _this.state = {
      editable: false
    };
    _this.editField = null;
    return _this;
  }
  HistoryQuery2.prototype.render = function() {
    var _this = this;
    var _a2;
    var displayName = this.props.label || this.props.operationName || ((_a2 = this.props.query) === null || _a2 === void 0 ? void 0 : _a2.split("\n").filter(function(line) {
      return line.indexOf("#") !== 0;
    }).join(""));
    var starIcon = this.props.favorite ? "\u2605" : "\u2606";
    return import_react21.default.createElement("li", { className: this.state.editable ? "editable" : void 0 }, this.state.editable ? import_react21.default.createElement("input", { type: "text", defaultValue: this.props.label, ref: function(c) {
      _this.editField = c;
    }, onBlur: this.handleFieldBlur.bind(this), onKeyDown: this.handleFieldKeyDown.bind(this), placeholder: "Type a label" }) : import_react21.default.createElement("button", { className: "history-label", onClick: this.handleClick.bind(this) }, displayName), import_react21.default.createElement("button", { onClick: this.handleEditClick.bind(this), "aria-label": "Edit label" }, "\u270E"), import_react21.default.createElement("button", { className: this.props.favorite ? "favorited" : void 0, onClick: this.handleStarClick.bind(this), "aria-label": this.props.favorite ? "Remove favorite" : "Add favorite" }, starIcon));
  };
  HistoryQuery2.prototype.handleClick = function() {
    this.props.onSelect(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label);
  };
  HistoryQuery2.prototype.handleStarClick = function(e) {
    e.stopPropagation();
    this.props.handleToggleFavorite(this.props.query, this.props.variables, this.props.headers, this.props.operationName, this.props.label, this.props.favorite);
  };
  HistoryQuery2.prototype.handleFieldBlur = function(e) {
    e.stopPropagation();
    this.setState({ editable: false });
    this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.target.value, this.props.favorite);
  };
  HistoryQuery2.prototype.handleFieldKeyDown = function(e) {
    if (e.keyCode === 13) {
      e.stopPropagation();
      this.setState({ editable: false });
      this.props.handleEditLabel(this.props.query, this.props.variables, this.props.headers, this.props.operationName, e.currentTarget.value, this.props.favorite);
    }
  };
  HistoryQuery2.prototype.handleEditClick = function(e) {
    var _this = this;
    e.stopPropagation();
    this.setState({ editable: true }, function() {
      if (_this.editField) {
        _this.editField.focus();
      }
    });
  };
  return HistoryQuery2;
}(import_react21.default.Component);
var HistoryQuery_default = HistoryQuery;

// node_modules/graphiql/esm/components/QueryHistory.js
var __extends14 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign5 = function() {
  __assign5 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign5.apply(this, arguments);
};
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread2 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read2(arguments[i]));
  return ar;
};
var MAX_QUERY_SIZE = 1e5;
var MAX_HISTORY_LENGTH = 20;
var shouldSaveQuery = function(query, variables, headers, lastQuerySaved) {
  if (!query) {
    return false;
  }
  try {
    parse(query);
  } catch (e) {
    return false;
  }
  if (query.length > MAX_QUERY_SIZE) {
    return false;
  }
  if (!lastQuerySaved) {
    return true;
  }
  if (JSON.stringify(query) === JSON.stringify(lastQuerySaved.query)) {
    if (JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables)) {
      if (JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers)) {
        return false;
      }
      if (headers && !lastQuerySaved.headers) {
        return false;
      }
    }
    if (variables && !lastQuerySaved.variables) {
      return false;
    }
  }
  return true;
};
var QueryHistory = function(_super) {
  __extends14(QueryHistory2, _super);
  function QueryHistory2(props) {
    var _this = _super.call(this, props) || this;
    _this.updateHistory = function(query, variables, headers, operationName) {
      if (shouldSaveQuery(query, variables, headers, _this.historyStore.fetchRecent())) {
        _this.historyStore.push({
          query,
          variables,
          headers,
          operationName
        });
        var historyQueries2 = _this.historyStore.items;
        var favoriteQueries2 = _this.favoriteStore.items;
        var queries2 = historyQueries2.concat(favoriteQueries2);
        _this.setState({
          queries: queries2
        });
      }
    };
    _this.toggleFavorite = function(query, variables, headers, operationName, label, favorite) {
      var item = {
        query,
        variables,
        headers,
        operationName,
        label
      };
      if (!_this.favoriteStore.contains(item)) {
        item.favorite = true;
        _this.favoriteStore.push(item);
      } else if (favorite) {
        item.favorite = false;
        _this.favoriteStore.delete(item);
      }
      _this.setState({
        queries: __spread2(_this.historyStore.items, _this.favoriteStore.items)
      });
    };
    _this.editLabel = function(query, variables, headers, operationName, label, favorite) {
      var item = {
        query,
        variables,
        headers,
        operationName,
        label
      };
      if (favorite) {
        _this.favoriteStore.edit(__assign5(__assign5({}, item), { favorite }));
      } else {
        _this.historyStore.edit(item);
      }
      _this.setState({
        queries: __spread2(_this.historyStore.items, _this.favoriteStore.items)
      });
    };
    _this.historyStore = new QueryStore_default("queries", props.storage, MAX_HISTORY_LENGTH);
    _this.favoriteStore = new QueryStore_default("favorites", props.storage, null);
    var historyQueries = _this.historyStore.fetchAll();
    var favoriteQueries = _this.favoriteStore.fetchAll();
    var queries = historyQueries.concat(favoriteQueries);
    _this.state = { queries };
    return _this;
  }
  QueryHistory2.prototype.render = function() {
    var _this = this;
    var queries = this.state.queries.slice().reverse();
    var queryNodes = queries.map(function(query, i) {
      return import_react22.default.createElement(HistoryQuery_default, __assign5({ handleEditLabel: _this.editLabel, handleToggleFavorite: _this.toggleFavorite, key: i + ":" + (query.label || query.query), onSelect: _this.props.onSelectQuery }, query));
    });
    return import_react22.default.createElement("section", { "aria-label": "History" }, import_react22.default.createElement("div", { className: "history-title-bar" }, import_react22.default.createElement("div", { className: "history-title" }, "History"), import_react22.default.createElement("div", { className: "doc-explorer-rhs" }, this.props.children)), import_react22.default.createElement("ul", { className: "history-contents" }, queryNodes));
  };
  return QueryHistory2;
}(import_react22.default.Component);

// node_modules/graphiql/esm/utility/CodeMirrorSizer.js
init_define_process_env();
var CodeMirrorSizer = function() {
  function CodeMirrorSizer2() {
    this.sizes = [];
  }
  CodeMirrorSizer2.prototype.updateSizes = function(components) {
    var _this = this;
    components.forEach(function(component, i) {
      if (component) {
        var size = component.getClientHeight();
        if (i <= _this.sizes.length && size !== _this.sizes[i]) {
          var editor = component.getCodeMirror();
          if (editor) {
            editor.setSize(null, null);
          }
        }
        _this.sizes[i] = size;
      }
    });
  };
  return CodeMirrorSizer2;
}();
var CodeMirrorSizer_default = CodeMirrorSizer;

// node_modules/graphiql/esm/utility/StorageAPI.js
init_define_process_env();
function isQuotaError(storage, e) {
  return e instanceof DOMException && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage.length !== 0;
}
var StorageAPI = function() {
  function StorageAPI2(storage) {
    this.storage = storage || (typeof window !== "undefined" ? window.localStorage : null);
  }
  StorageAPI2.prototype.get = function(name2) {
    if (this.storage) {
      var value = this.storage.getItem("graphiql:" + name2);
      if (value === "null" || value === "undefined") {
        this.storage.removeItem("graphiql:" + name2);
        return null;
      }
      if (value) {
        return value;
      }
    }
    return null;
  };
  StorageAPI2.prototype.set = function(name2, value) {
    var quotaError = false;
    var error2 = null;
    if (this.storage) {
      var key = "graphiql:" + name2;
      if (value) {
        try {
          this.storage.setItem(key, value);
        } catch (e) {
          error2 = e;
          quotaError = isQuotaError(this.storage, e);
        }
      } else {
        this.storage.removeItem(key);
      }
    }
    return {
      isQuotaError: quotaError,
      error: error2
    };
  };
  return StorageAPI2;
}();
var StorageAPI_default = StorageAPI;

// node_modules/graphiql/esm/utility/getQueryFacts.js
init_define_process_env();
init_graphql2();
function getOperationFacts(schema, documentStr) {
  if (!documentStr) {
    return;
  }
  var documentAST;
  try {
    documentAST = parse(documentStr, {
      experimentalFragmentVariables: true
    });
  } catch (_a2) {
    return;
  }
  var variableToType = schema ? collectVariables(schema, documentAST) : void 0;
  var operations = [];
  visit(documentAST, {
    OperationDefinition: function(node) {
      operations.push(node);
    }
  });
  return { variableToType, operations, documentAST };
}
var getQueryFacts = getOperationFacts;
function collectVariables(schema, documentAST) {
  var variableToType = Object.create(null);
  documentAST.definitions.forEach(function(definition) {
    if (definition.kind === "OperationDefinition") {
      var variableDefinitions = definition.variableDefinitions;
      if (variableDefinitions) {
        variableDefinitions.forEach(function(_a2) {
          var variable = _a2.variable, type2 = _a2.type;
          var inputType = typeFromAST(schema, type2);
          if (inputType) {
            variableToType[variable.name.value] = inputType;
          }
        });
      }
    }
  });
  return variableToType;
}

// node_modules/graphiql/esm/utility/getSelectedOperationName.js
init_define_process_env();
function getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {
  if (!operations || operations.length < 1) {
    return;
  }
  var names = operations.map(function(op) {
    return op.name && op.name.value;
  });
  if (prevSelectedOperationName && names.indexOf(prevSelectedOperationName) !== -1) {
    return prevSelectedOperationName;
  }
  if (prevSelectedOperationName && prevOperations) {
    var prevNames = prevOperations.map(function(op) {
      return op.name && op.name.value;
    });
    var prevIndex = prevNames.indexOf(prevSelectedOperationName);
    if (prevIndex !== -1 && prevIndex < names.length) {
      return names[prevIndex];
    }
  }
  return names[0];
}

// node_modules/graphiql/esm/utility/find.js
init_define_process_env();
function find3(list2, predicate) {
  for (var i = 0; i < list2.length; i++) {
    if (predicate(list2[i])) {
      return list2[i];
    }
  }
}

// node_modules/graphiql/esm/utility/fillLeafs.js
init_define_process_env();
init_graphql2();
function fillLeafs(schema, docString, getDefaultFieldNames) {
  var insertions = [];
  if (!schema || !docString) {
    return { insertions, result: docString };
  }
  var ast;
  try {
    ast = parse(docString);
  } catch (error2) {
    return { insertions, result: docString };
  }
  var fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;
  var typeInfo = new TypeInfo(schema);
  visit(ast, {
    leave: function(node) {
      typeInfo.leave(node);
    },
    enter: function(node) {
      typeInfo.enter(node);
      if (node.kind === "Field" && !node.selectionSet) {
        var fieldType = typeInfo.getType();
        var selectionSet = buildSelectionSet(isFieldType(fieldType), fieldNameFn);
        if (selectionSet && node.loc) {
          var indent2 = getIndentation(docString, node.loc.start);
          insertions.push({
            index: node.loc.end,
            string: " " + print(selectionSet).replace(/\n/g, "\n" + indent2)
          });
        }
      }
    }
  });
  return {
    insertions,
    result: withInsertions(docString, insertions)
  };
}
function defaultGetDefaultFieldNames(type2) {
  if (!("getFields" in type2)) {
    return [];
  }
  var fields7 = type2.getFields();
  if (fields7.id) {
    return ["id"];
  }
  if (fields7.edges) {
    return ["edges"];
  }
  if (fields7.node) {
    return ["node"];
  }
  var leafFieldNames = [];
  Object.keys(fields7).forEach(function(fieldName) {
    if (isLeafType(fields7[fieldName].type)) {
      leafFieldNames.push(fieldName);
    }
  });
  return leafFieldNames;
}
function buildSelectionSet(type2, getDefaultFieldNames) {
  var namedType = getNamedType(type2);
  if (!type2 || isLeafType(type2)) {
    return;
  }
  var fieldNames = getDefaultFieldNames(namedType);
  if (!Array.isArray(fieldNames) || fieldNames.length === 0 || !("getFields" in namedType)) {
    return;
  }
  return {
    kind: "SelectionSet",
    selections: fieldNames.map(function(fieldName) {
      var fieldDef = namedType.getFields()[fieldName];
      var fieldType = fieldDef ? fieldDef.type : null;
      return {
        kind: "Field",
        name: {
          kind: "Name",
          value: fieldName
        },
        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)
      };
    })
  };
}
function withInsertions(initial, insertions) {
  if (insertions.length === 0) {
    return initial;
  }
  var edited = "";
  var prevIndex = 0;
  insertions.forEach(function(_a2) {
    var index = _a2.index, string = _a2.string;
    edited += initial.slice(prevIndex, index) + string;
    prevIndex = index;
  });
  edited += initial.slice(prevIndex);
  return edited;
}
function getIndentation(str, index) {
  var indentStart = index;
  var indentEnd = index;
  while (indentStart) {
    var c = str.charCodeAt(indentStart - 1);
    if (c === 10 || c === 13 || c === 8232 || c === 8233) {
      break;
    }
    indentStart--;
    if (c !== 9 && c !== 11 && c !== 12 && c !== 32 && c !== 160) {
      indentEnd = indentStart;
    }
  }
  return str.substring(indentStart, indentEnd);
}
function isFieldType(fieldType) {
  if (fieldType) {
    return fieldType;
  }
}

// node_modules/graphiql/esm/utility/elementPosition.js
init_define_process_env();
function getLeft(initialElem) {
  var pt = 0;
  var elem = initialElem;
  while (elem.offsetParent) {
    pt += elem.offsetLeft;
    elem = elem.offsetParent;
  }
  return pt;
}
function getTop(initialElem) {
  var pt = 0;
  var elem = initialElem;
  while (elem.offsetParent) {
    pt += elem.offsetTop;
    elem = elem.offsetParent;
  }
  return pt;
}

// node_modules/graphiql/esm/utility/mergeAst.js
init_define_process_env();
init_graphql2();
var __assign6 = function() {
  __assign6 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign6.apply(this, arguments);
};
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread3 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read3(arguments[i]));
  return ar;
};
function uniqueBy(array, iteratee) {
  var e_1, _a2;
  var FilteredMap = new Map();
  var result = [];
  try {
    for (var array_1 = __values2(array), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
      var item = array_1_1.value;
      if (item.kind === "Field") {
        var uniqueValue = iteratee(item);
        var existing = FilteredMap.get(uniqueValue);
        if (item.directives && item.directives.length) {
          var itemClone = __assign6({}, item);
          result.push(itemClone);
        } else if (existing && existing.selectionSet && item.selectionSet) {
          existing.selectionSet.selections = __spread3(existing.selectionSet.selections, item.selectionSet.selections);
        } else if (!existing) {
          var itemClone = __assign6({}, item);
          FilteredMap.set(uniqueValue, itemClone);
          result.push(itemClone);
        }
      } else {
        result.push(item);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (array_1_1 && !array_1_1.done && (_a2 = array_1.return))
        _a2.call(array_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return result;
}
function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {
  var e_2, _a2;
  var _b;
  var selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;
  var outputSelections = [];
  var seenSpreads = [];
  try {
    for (var selections_1 = __values2(selections), selections_1_1 = selections_1.next(); !selections_1_1.done; selections_1_1 = selections_1.next()) {
      var selection = selections_1_1.value;
      if (selection.kind === "FragmentSpread") {
        var fragmentName = selection.name.value;
        if (!selection.directives || selection.directives.length === 0) {
          if (seenSpreads.indexOf(fragmentName) >= 0) {
            continue;
          } else {
            seenSpreads.push(fragmentName);
          }
        }
        var fragmentDefinition = fragmentDefinitions[selection.name.value];
        if (fragmentDefinition) {
          var typeCondition = fragmentDefinition.typeCondition, directives = fragmentDefinition.directives, selectionSet = fragmentDefinition.selectionSet;
          selection = {
            kind: "InlineFragment",
            typeCondition,
            directives,
            selectionSet
          };
        }
      }
      if (selection.kind === "InlineFragment" && (!selection.directives || ((_b = selection.directives) === null || _b === void 0 ? void 0 : _b.length) === 0)) {
        var fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;
        if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {
          outputSelections.push.apply(outputSelections, __spread3(inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType)));
          continue;
        }
      }
      outputSelections.push(selection);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (selections_1_1 && !selections_1_1.done && (_a2 = selections_1.return))
        _a2.call(selections_1);
    } finally {
      if (e_2)
        throw e_2.error;
    }
  }
  return outputSelections;
}
function mergeAST(documentAST, schema) {
  var e_3, _a2;
  var typeInfo = schema ? new TypeInfo(schema) : null;
  var fragmentDefinitions = Object.create(null);
  try {
    for (var _b = __values2(documentAST.definitions), _c = _b.next(); !_c.done; _c = _b.next()) {
      var definition = _c.value;
      if (definition.kind === "FragmentDefinition") {
        fragmentDefinitions[definition.name.value] = definition;
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_3)
        throw e_3.error;
    }
  }
  var visitors = {
    SelectionSet: function(node) {
      var selectionSetType = typeInfo ? typeInfo.getParentType() : null;
      var selections = node.selections;
      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);
      selections = uniqueBy(selections, function(selection) {
        return selection.alias ? selection.alias.value : selection.name.value;
      });
      return __assign6(__assign6({}, node), { selections });
    },
    FragmentDefinition: function() {
      return null;
    }
  };
  return visit(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);
}

// node_modules/graphiql/esm/utility/introspectionQueries.js
init_define_process_env();
init_graphql2();
var introspectionQuery = getIntrospectionQuery();
var staticName = "IntrospectionQuery";
var introspectionQueryName = staticName;
var introspectionQuerySansSubscriptions = introspectionQuery.replace("subscriptionType { name }", "");

// node_modules/graphiql/node_modules/dset/merge/index.mjs
init_define_process_env();
function merge(a, b, k) {
  if (typeof a === "object" && typeof b === "object") {
    if (Array.isArray(a) && Array.isArray(b)) {
      for (k = 0; k < b.length; k++) {
        a[k] = merge(a[k], b[k]);
      }
    } else {
      for (k in b) {
        a[k] = merge(a[k], b[k]);
      }
    }
    return a;
  }
  return b;
}
function dset(obj, keys, val) {
  keys.split && (keys = keys.split("."));
  var i = 0, l = keys.length, t2 = obj, x, k;
  for (; i < l; ) {
    k = keys[i++];
    if (k === "__proto__" || k === "constructor" || k === "prototype")
      break;
    t2 = t2[k] = i === l ? merge(t2[k], val) : typeof (x = t2[k]) === typeof keys ? x : keys[i] * 0 !== 0 || !!~("" + keys[i]).indexOf(".") ? {} : [];
  }
}

// node_modules/graphiql/esm/components/GraphiQL.js
var __extends15 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign7 = function() {
  __assign7 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign7.apply(this, arguments);
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve4) {
      resolve4(value);
    });
  }
  return new (P || (P = Promise))(function(resolve4, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve4(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var __rest = function(s, e) {
  var t2 = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t2[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t2[p2[i]] = s[p2[i]];
    }
  return t2;
};
var __asyncValues = function(o) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values3 === "function" ? __values3(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve4, reject) {
        v = o[n](v), settle(resolve4, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve4, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve4({ value: v2, done: d });
    }, reject);
  }
};
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
};
var __spread4 = function() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read4(arguments[i]));
  return ar;
};
var __values3 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var DEFAULT_DOC_EXPLORER_WIDTH = 350;
var majorVersion = parseInt(import_react23.default.version.slice(0, 2), 10);
if (majorVersion < 16) {
  throw Error([
    "GraphiQL 0.18.0 and after is not compatible with React 15 or below.",
    "If you are using a CDN source (jsdelivr, unpkg, etc), follow this example:",
    "https://github.com/graphql/graphiql/blob/master/examples/graphiql-cdn/index.html#L49"
  ].join("\n"));
}
var GraphiQL = function(_super) {
  __extends15(GraphiQL2, _super);
  function GraphiQL2(props) {
    var _a2, _b;
    var _this = _super.call(this, props) || this;
    _this._editorQueryID = 0;
    _this.safeSetState = function(nextState, callback) {
      _this.componentIsMounted && _this.setState(nextState, callback);
    };
    _this.handleClickReference = function(reference) {
      _this.setState({ docExplorerOpen: true }, function() {
        if (_this.docExplorerComponent) {
          _this.docExplorerComponent.showDocForReference(reference);
        }
      });
      _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
    };
    _this.handleRunQuery = function(selectedOperationName) {
      return __awaiter3(_this, void 0, void 0, function() {
        var queryID, editedQuery, variables2, headers2, shouldPersistHeaders2, operationName2, fullResponse_1, subscription, error_1;
        var _this2 = this;
        return __generator(this, function(_a3) {
          switch (_a3.label) {
            case 0:
              this._editorQueryID++;
              queryID = this._editorQueryID;
              editedQuery = this.autoCompleteLeafs() || this.state.query;
              variables2 = this.state.variables;
              headers2 = this.state.headers;
              shouldPersistHeaders2 = this.state.shouldPersistHeaders;
              operationName2 = this.state.operationName;
              if (selectedOperationName && selectedOperationName !== operationName2) {
                operationName2 = selectedOperationName;
                this.handleEditOperationName(operationName2);
              }
              _a3.label = 1;
            case 1:
              _a3.trys.push([1, 3, , 4]);
              this.setState({
                isWaitingForResponse: true,
                response: void 0,
                operationName: operationName2
              });
              this._storage.set("operationName", operationName2);
              if (this._queryHistory) {
                this._queryHistory.updateHistory(editedQuery, variables2, headers2, operationName2);
              }
              fullResponse_1 = { data: {} };
              return [4, this._fetchQuery(editedQuery, variables2, headers2, operationName2, shouldPersistHeaders2, function(result) {
                var e_1, _a4;
                if (queryID === _this2._editorQueryID) {
                  var maybeMultipart = Array.isArray(result) ? result : false;
                  if (!maybeMultipart && typeof result !== "string" && result !== null && "hasNext" in result) {
                    maybeMultipart = [result];
                  }
                  if (maybeMultipart) {
                    var payload = { data: fullResponse_1.data };
                    var maybeErrors = __spread4((fullResponse_1 === null || fullResponse_1 === void 0 ? void 0 : fullResponse_1.errors) || [], maybeMultipart.map(function(i) {
                      return i.errors;
                    }).flat().filter(Boolean));
                    if (maybeErrors.length) {
                      payload.errors = maybeErrors;
                    }
                    try {
                      for (var maybeMultipart_1 = __values3(maybeMultipart), maybeMultipart_1_1 = maybeMultipart_1.next(); !maybeMultipart_1_1.done; maybeMultipart_1_1 = maybeMultipart_1.next()) {
                        var part = maybeMultipart_1_1.value;
                        var path = part.path, data = part.data, _errors = part.errors, rest = __rest(part, ["path", "data", "errors"]);
                        if (path) {
                          if (!data) {
                            throw new Error("Expected part to contain a data property, but got " + part);
                          }
                          dset(payload.data, path, data);
                        } else if (data) {
                          payload.data = part.data;
                        }
                        fullResponse_1 = __assign7(__assign7({}, payload), rest);
                      }
                    } catch (e_1_1) {
                      e_1 = { error: e_1_1 };
                    } finally {
                      try {
                        if (maybeMultipart_1_1 && !maybeMultipart_1_1.done && (_a4 = maybeMultipart_1.return))
                          _a4.call(maybeMultipart_1);
                      } finally {
                        if (e_1)
                          throw e_1.error;
                      }
                    }
                    _this2.setState({
                      isWaitingForResponse: false,
                      response: GraphiQL2.formatResult(fullResponse_1)
                    });
                  } else {
                    _this2.setState({
                      isWaitingForResponse: false,
                      response: GraphiQL2.formatResult(result)
                    });
                  }
                }
              })];
            case 2:
              subscription = _a3.sent();
              this.setState({ subscription });
              return [3, 4];
            case 3:
              error_1 = _a3.sent();
              this.setState({
                isWaitingForResponse: false,
                response: error_1.message
              });
              return [3, 4];
            case 4:
              return [2];
          }
        });
      });
    };
    _this.handleStopQuery = function() {
      var subscription = _this.state.subscription;
      _this.setState({
        isWaitingForResponse: false,
        subscription: null
      });
      if (subscription) {
        subscription.unsubscribe();
      }
    };
    _this.handlePrettifyQuery = function() {
      var _a3, _b2, _c;
      var editor = _this.getQueryEditor();
      var editorContent = (_a3 = editor === null || editor === void 0 ? void 0 : editor.getValue()) !== null && _a3 !== void 0 ? _a3 : "";
      var prettifiedEditorContent = print(parse(editorContent, { experimentalFragmentVariables: true }));
      if (prettifiedEditorContent !== editorContent) {
        editor === null || editor === void 0 ? void 0 : editor.setValue(prettifiedEditorContent);
      }
      var variableEditor = _this.getVariableEditor();
      var variableEditorContent = (_b2 = variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.getValue()) !== null && _b2 !== void 0 ? _b2 : "";
      try {
        var prettifiedVariableEditorContent = JSON.stringify(JSON.parse(variableEditorContent), null, 2);
        if (prettifiedVariableEditorContent !== variableEditorContent) {
          variableEditor === null || variableEditor === void 0 ? void 0 : variableEditor.setValue(prettifiedVariableEditorContent);
        }
      } catch (_d) {
      }
      var headerEditor = _this.getHeaderEditor();
      var headerEditorContent = (_c = headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.getValue()) !== null && _c !== void 0 ? _c : "";
      try {
        var prettifiedHeaderEditorContent = JSON.stringify(JSON.parse(headerEditorContent), null, 2);
        if (prettifiedHeaderEditorContent !== headerEditorContent) {
          headerEditor === null || headerEditor === void 0 ? void 0 : headerEditor.setValue(prettifiedHeaderEditorContent);
        }
      } catch (_e) {
      }
    };
    _this.handleMergeQuery = function() {
      var editor = _this.getQueryEditor();
      var query2 = editor.getValue();
      if (!query2) {
        return;
      }
      var ast = _this.state.documentAST;
      editor.setValue(print(mergeAST(ast, _this.state.schema)));
    };
    _this.handleEditQuery = debounce(100, function(value) {
      var queryFacts2 = _this._updateQueryFacts(value, _this.state.operationName, _this.state.operations, _this.state.schema);
      _this.setState(__assign7({ query: value }, queryFacts2));
      _this._storage.set("query", value);
      if (_this.props.onEditQuery) {
        return _this.props.onEditQuery(value, queryFacts2 === null || queryFacts2 === void 0 ? void 0 : queryFacts2.documentAST);
      }
    });
    _this.handleCopyQuery = function() {
      var editor = _this.getQueryEditor();
      var query2 = editor && editor.getValue();
      if (!query2) {
        return;
      }
      (0, import_copy_to_clipboard.default)(query2);
      if (_this.props.onCopyQuery) {
        return _this.props.onCopyQuery(query2);
      }
    };
    _this._updateQueryFacts = function(query2, operationName2, prevOperations, schema) {
      var queryFacts2 = getOperationFacts(schema, query2);
      if (queryFacts2) {
        var updatedOperationName = getSelectedOperationName(prevOperations, operationName2, queryFacts2.operations);
        var onEditOperationName = _this.props.onEditOperationName;
        if (onEditOperationName && updatedOperationName && operationName2 !== updatedOperationName) {
          onEditOperationName(updatedOperationName);
        }
        return __assign7({ operationName: updatedOperationName }, queryFacts2);
      }
    };
    _this.handleEditVariables = function(value) {
      _this.setState({ variables: value });
      debounce(500, function() {
        return _this._storage.set("variables", value);
      })();
      if (_this.props.onEditVariables) {
        _this.props.onEditVariables(value);
      }
    };
    _this.handleEditHeaders = function(value) {
      _this.setState({ headers: value });
      _this.props.shouldPersistHeaders && debounce(500, function() {
        return _this._storage.set("headers", value);
      })();
      if (_this.props.onEditHeaders) {
        _this.props.onEditHeaders(value);
      }
    };
    _this.handleEditOperationName = function(operationName2) {
      var onEditOperationName = _this.props.onEditOperationName;
      if (onEditOperationName) {
        onEditOperationName(operationName2);
      }
    };
    _this.handleHintInformationRender = function(elem) {
      elem.addEventListener("click", _this._onClickHintInformation);
      var onRemoveFn;
      elem.addEventListener("DOMNodeRemoved", onRemoveFn = function() {
        elem.removeEventListener("DOMNodeRemoved", onRemoveFn);
        elem.removeEventListener("click", _this._onClickHintInformation);
      });
    };
    _this.handleEditorRunQuery = function() {
      _this._runQueryAtCursor();
    };
    _this._onClickHintInformation = function(event) {
      if ((event === null || event === void 0 ? void 0 : event.currentTarget) && "className" in event.currentTarget && event.currentTarget.className === "typeName") {
        var typeName = event.currentTarget.innerHTML;
        var schema = _this.state.schema;
        if (schema) {
          var type_1 = schema.getType(typeName);
          if (type_1) {
            _this.setState({ docExplorerOpen: true }, function() {
              if (_this.docExplorerComponent) {
                _this.docExplorerComponent.showDoc(type_1);
              }
            });
            debounce(500, function() {
              return _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
            })();
          }
        }
      }
    };
    _this.handleToggleDocs = function() {
      if (typeof _this.props.onToggleDocs === "function") {
        _this.props.onToggleDocs(!_this.state.docExplorerOpen);
      }
      _this._storage.set("docExplorerOpen", JSON.stringify(!_this.state.docExplorerOpen));
      _this.setState({ docExplorerOpen: !_this.state.docExplorerOpen });
    };
    _this.handleToggleHistory = function() {
      if (typeof _this.props.onToggleHistory === "function") {
        _this.props.onToggleHistory(!_this.state.historyPaneOpen);
      }
      _this._storage.set("historyPaneOpen", JSON.stringify(!_this.state.historyPaneOpen));
      _this.setState({ historyPaneOpen: !_this.state.historyPaneOpen });
    };
    _this.handleSelectHistoryQuery = function(query2, variables2, headers2, operationName2) {
      if (query2) {
        _this.handleEditQuery(query2);
      }
      if (variables2) {
        _this.handleEditVariables(variables2);
      }
      if (headers2) {
        _this.handleEditHeaders(headers2);
      }
      if (operationName2) {
        _this.handleEditOperationName(operationName2);
      }
    };
    _this.handleResizeStart = function(downEvent) {
      if (!_this._didClickDragBar(downEvent)) {
        return;
      }
      downEvent.preventDefault();
      var offset = downEvent.clientX - getLeft(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        var editorBar = _this.editorBarComponent;
        var leftSize = moveEvent.clientX - getLeft(editorBar) - offset;
        var rightSize = editorBar.clientWidth - leftSize;
        _this.setState({ editorFlex: leftSize / rightSize });
        debounce(500, function() {
          return _this._storage.set("editorFlex", JSON.stringify(_this.state.editorFlex));
        })();
      };
      var onMouseUp = function() {
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.handleResetResize = function() {
      _this.setState({ editorFlex: 1 });
      _this._storage.set("editorFlex", JSON.stringify(_this.state.editorFlex));
    };
    _this.handleDocsResizeStart = function(downEvent) {
      downEvent.preventDefault();
      var hadWidth = _this.state.docExplorerWidth;
      var offset = downEvent.clientX - getLeft(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        var app = _this.graphiqlContainer;
        var cursorPos = moveEvent.clientX - getLeft(app) - offset;
        var docsSize = app.clientWidth - cursorPos;
        if (docsSize < 100) {
          if (typeof _this.props.onToggleDocs === "function") {
            _this.props.onToggleDocs(!_this.state.docExplorerOpen);
          }
          _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
          _this.setState({ docExplorerOpen: false });
        } else {
          _this.setState({
            docExplorerOpen: true,
            docExplorerWidth: Math.min(docsSize, 650)
          });
          debounce(500, function() {
            return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
          })();
        }
        _this._storage.set("docExplorerOpen", JSON.stringify(_this.state.docExplorerOpen));
      };
      var onMouseUp = function() {
        if (!_this.state.docExplorerOpen) {
          _this.setState({ docExplorerWidth: hadWidth });
          debounce(500, function() {
            return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
          })();
        }
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    _this.handleDocsResetResize = function() {
      _this.setState({
        docExplorerWidth: DEFAULT_DOC_EXPLORER_WIDTH
      });
      debounce(500, function() {
        return _this._storage.set("docExplorerWidth", JSON.stringify(_this.state.docExplorerWidth));
      })();
    };
    _this.handleTabClickPropogation = function(downEvent) {
      downEvent.preventDefault();
      downEvent.stopPropagation();
    };
    _this.handleOpenHeaderEditorTab = function(_clickEvent) {
      _this.setState({
        headerEditorActive: true,
        variableEditorActive: false,
        secondaryEditorOpen: true
      });
    };
    _this.handleOpenVariableEditorTab = function(_clickEvent) {
      _this.setState({
        headerEditorActive: false,
        variableEditorActive: true,
        secondaryEditorOpen: true
      });
    };
    _this.handleSecondaryEditorResizeStart = function(downEvent) {
      downEvent.preventDefault();
      var didMove = false;
      var wasOpen = _this.state.secondaryEditorOpen;
      var hadHeight = _this.state.secondaryEditorHeight;
      var offset = downEvent.clientY - getTop(downEvent.target);
      var onMouseMove = function(moveEvent) {
        if (moveEvent.buttons === 0) {
          return onMouseUp();
        }
        didMove = true;
        var editorBar = _this.editorBarComponent;
        var topSize = moveEvent.clientY - getTop(editorBar) - offset;
        var bottomSize = editorBar.clientHeight - topSize;
        if (bottomSize < 60) {
          _this.setState({
            secondaryEditorOpen: false,
            secondaryEditorHeight: hadHeight
          });
        } else {
          _this.setState({
            secondaryEditorOpen: true,
            secondaryEditorHeight: bottomSize
          });
        }
        debounce(500, function() {
          return _this._storage.set("secondaryEditorHeight", JSON.stringify(_this.state.secondaryEditorHeight));
        })();
      };
      var onMouseUp = function() {
        if (!didMove) {
          _this.setState({ secondaryEditorOpen: !wasOpen });
        }
        document.removeEventListener("mousemove", onMouseMove);
        document.removeEventListener("mouseup", onMouseUp);
        onMouseMove = null;
        onMouseUp = null;
      };
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    if (typeof props.fetcher !== "function") {
      throw new TypeError("GraphiQL requires a fetcher function.");
    }
    _this._storage = new StorageAPI_default(props.storage);
    _this.componentIsMounted = false;
    var query = props.query !== void 0 ? props.query : _this._storage.get("query") ? _this._storage.get("query") : props.defaultQuery !== void 0 ? props.defaultQuery : defaultQuery;
    var queryFacts = getOperationFacts(props.schema, query);
    var variables = props.variables !== void 0 ? props.variables : _this._storage.get("variables");
    var headers = props.headers !== void 0 ? props.headers : _this._storage.get("headers");
    var operationName = props.operationName !== void 0 ? props.operationName : getSelectedOperationName(void 0, _this._storage.get("operationName"), queryFacts && queryFacts.operations);
    var docExplorerOpen = props.docExplorerOpen || false;
    if (_this._storage.get("docExplorerOpen")) {
      docExplorerOpen = _this._storage.get("docExplorerOpen") === "true";
    }
    var secondaryEditorOpen;
    if (props.defaultVariableEditorOpen !== void 0) {
      secondaryEditorOpen = props.defaultVariableEditorOpen;
    } else if (props.defaultSecondaryEditorOpen !== void 0) {
      secondaryEditorOpen = props.defaultSecondaryEditorOpen;
    } else {
      secondaryEditorOpen = Boolean(variables || headers);
    }
    var headerEditorEnabled = (_a2 = props.headerEditorEnabled) !== null && _a2 !== void 0 ? _a2 : false;
    var shouldPersistHeaders = (_b = props.shouldPersistHeaders) !== null && _b !== void 0 ? _b : false;
    _this.state = __assign7({
      schema: props.schema,
      query,
      variables,
      headers,
      operationName,
      docExplorerOpen,
      response: props.response,
      editorFlex: Number(_this._storage.get("editorFlex")) || 1,
      secondaryEditorOpen,
      secondaryEditorHeight: Number(_this._storage.get("secondaryEditorHeight")) || 200,
      variableEditorActive: _this._storage.get("variableEditorActive") === "true" || props.headerEditorEnabled ? _this._storage.get("headerEditorActive") !== "true" : true,
      headerEditorActive: _this._storage.get("headerEditorActive") === "true",
      headerEditorEnabled,
      shouldPersistHeaders,
      historyPaneOpen: _this._storage.get("historyPaneOpen") === "true" || false,
      docExplorerWidth: Number(_this._storage.get("docExplorerWidth")) || DEFAULT_DOC_EXPLORER_WIDTH,
      isWaitingForResponse: false,
      subscription: null
    }, queryFacts);
    return _this;
  }
  GraphiQL2.formatResult = function(result) {
    return JSON.stringify(result, null, 2);
  };
  GraphiQL2.formatError = function(rawError) {
    var result = Array.isArray(rawError) ? rawError.map(formatSingleError) : formatSingleError(rawError);
    return JSON.stringify(result, null, 2);
  };
  GraphiQL2.prototype.componentDidMount = function() {
    this.componentIsMounted = true;
    if (this.state.schema === void 0) {
      this.fetchSchema();
    }
    this.codeMirrorSizer = new CodeMirrorSizer_default();
    global.g = this;
  };
  GraphiQL2.prototype.UNSAFE_componentWillMount = function() {
    this.componentIsMounted = false;
  };
  GraphiQL2.prototype.UNSAFE_componentWillReceiveProps = function(nextProps) {
    var _this = this;
    var nextSchema = this.state.schema;
    var nextQuery = this.state.query;
    var nextVariables = this.state.variables;
    var nextHeaders = this.state.headers;
    var nextOperationName = this.state.operationName;
    var nextResponse = this.state.response;
    if (nextProps.schema !== void 0) {
      nextSchema = nextProps.schema;
    }
    if (nextProps.query !== void 0 && this.props.query !== nextProps.query) {
      nextQuery = nextProps.query;
    }
    if (nextProps.variables !== void 0 && this.props.variables !== nextProps.variables) {
      nextVariables = nextProps.variables;
    }
    if (nextProps.headers !== void 0 && this.props.headers !== nextProps.headers) {
      nextHeaders = nextProps.headers;
    }
    if (nextProps.operationName !== void 0) {
      nextOperationName = nextProps.operationName;
    }
    if (nextProps.response !== void 0) {
      nextResponse = nextProps.response;
    }
    if (nextQuery && nextSchema && (nextSchema !== this.state.schema || nextQuery !== this.state.query || nextOperationName !== this.state.operationName)) {
      var updatedQueryAttributes = this._updateQueryFacts(nextQuery, nextOperationName, this.state.operations, nextSchema);
      if (updatedQueryAttributes !== void 0) {
        nextOperationName = updatedQueryAttributes.operationName;
        this.setState(updatedQueryAttributes);
      }
    }
    if (nextProps.schema === void 0 && nextProps.fetcher !== this.props.fetcher) {
      nextSchema = void 0;
    }
    this._storage.set("operationName", nextOperationName);
    this.setState({
      schema: nextSchema,
      query: nextQuery,
      variables: nextVariables,
      headers: nextHeaders,
      operationName: nextOperationName,
      response: nextResponse
    }, function() {
      if (_this.state.schema === void 0) {
        if (_this.docExplorerComponent) {
          _this.docExplorerComponent.reset();
        }
        _this.fetchSchema();
      }
    });
  };
  GraphiQL2.prototype.componentDidUpdate = function() {
    this.codeMirrorSizer.updateSizes([
      this.queryEditorComponent,
      this.variableEditorComponent,
      this.headerEditorComponent,
      this.resultComponent
    ]);
  };
  GraphiQL2.prototype.render = function() {
    var _this = this;
    var _a2;
    var children = import_react23.default.Children.toArray(this.props.children);
    var logo = find3(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Logo);
    }) || import_react23.default.createElement(GraphiQL2.Logo, null);
    var toolbar = find3(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Toolbar);
    }) || import_react23.default.createElement(GraphiQL2.Toolbar, null, import_react23.default.createElement(ToolbarButton, { onClick: this.handlePrettifyQuery, title: "Prettify Query (Shift-Ctrl-P)", label: "Prettify" }), import_react23.default.createElement(ToolbarButton, { onClick: this.handleMergeQuery, title: "Merge Query (Shift-Ctrl-M)", label: "Merge" }), import_react23.default.createElement(ToolbarButton, { onClick: this.handleCopyQuery, title: "Copy Query (Shift-Ctrl-C)", label: "Copy" }), import_react23.default.createElement(ToolbarButton, { onClick: this.handleToggleHistory, title: "Show History", label: "History" }), ((_a2 = this.props.toolbar) === null || _a2 === void 0 ? void 0 : _a2.additionalContent) ? this.props.toolbar.additionalContent : null);
    var footer = find3(children, function(child) {
      return isChildComponentType(child, GraphiQL2.Footer);
    });
    var queryWrapStyle = {
      WebkitFlex: this.state.editorFlex,
      flex: this.state.editorFlex
    };
    var docWrapStyle = {
      display: "block",
      width: this.state.docExplorerWidth
    };
    var docExplorerWrapClasses = "docExplorerWrap" + (this.state.docExplorerWidth < 200 ? " doc-explorer-narrow" : "");
    var historyPaneStyle = {
      display: this.state.historyPaneOpen ? "block" : "none",
      width: "230px",
      zIndex: 7
    };
    var secondaryEditorOpen = this.state.secondaryEditorOpen;
    var secondaryEditorStyle = {
      height: secondaryEditorOpen ? this.state.secondaryEditorHeight : void 0
    };
    return import_react23.default.createElement("div", { ref: function(n) {
      _this.graphiqlContainer = n;
    }, className: "graphiql-container" }, this.state.historyPaneOpen && import_react23.default.createElement("div", { className: "historyPaneWrap", style: historyPaneStyle }, import_react23.default.createElement(QueryHistory, { ref: function(node) {
      _this._queryHistory = node;
    }, operationName: this.state.operationName, query: this.state.query, variables: this.state.variables, onSelectQuery: this.handleSelectHistoryQuery, storage: this._storage, queryID: this._editorQueryID }, import_react23.default.createElement("button", { className: "docExplorerHide", onClick: this.handleToggleHistory, "aria-label": "Close History" }, "\u2715"))), import_react23.default.createElement("div", { className: "editorWrap" }, import_react23.default.createElement("div", { className: "topBarWrap" }, import_react23.default.createElement("div", { className: "topBar" }, logo, import_react23.default.createElement(ExecuteButton, { isRunning: Boolean(this.state.subscription), onRun: this.handleRunQuery, onStop: this.handleStopQuery, operations: this.state.operations }), toolbar), !this.state.docExplorerOpen && import_react23.default.createElement("button", { className: "docExplorerShow", onClick: this.handleToggleDocs, "aria-label": "Open Documentation Explorer" }, "Docs")), import_react23.default.createElement("div", { ref: function(n) {
      _this.editorBarComponent = n;
    }, className: "editorBar", onDoubleClick: this.handleResetResize, onMouseDown: this.handleResizeStart }, import_react23.default.createElement("div", { className: "queryWrap", style: queryWrapStyle }, import_react23.default.createElement(QueryEditor, { ref: function(n) {
      _this.queryEditorComponent = n;
    }, schema: this.state.schema, validationRules: this.props.validationRules, value: this.state.query, onEdit: this.handleEditQuery, onHintInformationRender: this.handleHintInformationRender, onClickReference: this.handleClickReference, onCopyQuery: this.handleCopyQuery, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, externalFragments: this.props.externalFragments }), import_react23.default.createElement("section", { className: "variable-editor secondary-editor", style: secondaryEditorStyle, "aria-label": this.state.variableEditorActive ? "Query Variables" : "Request Headers" }, import_react23.default.createElement("div", { className: "secondary-editor-title variable-editor-title", id: "secondary-editor-title", style: {
      cursor: secondaryEditorOpen ? "row-resize" : "n-resize"
    }, onMouseDown: this.handleSecondaryEditorResizeStart }, import_react23.default.createElement("div", { style: {
      cursor: "pointer",
      color: this.state.variableEditorActive ? "#000" : "gray",
      display: "inline-block"
    }, onClick: this.handleOpenVariableEditorTab, onMouseDown: this.handleTabClickPropogation }, "Query Variables"), this.state.headerEditorEnabled && import_react23.default.createElement("div", { style: {
      cursor: "pointer",
      color: this.state.headerEditorActive ? "#000" : "gray",
      display: "inline-block",
      marginLeft: "20px"
    }, onClick: this.handleOpenHeaderEditorTab, onMouseDown: this.handleTabClickPropogation }, "Request Headers")), import_react23.default.createElement(VariableEditor, { ref: function(n) {
      _this.variableEditorComponent = n;
    }, value: this.state.variables, variableToType: this.state.variableToType, onEdit: this.handleEditVariables, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.variableEditorActive }), this.state.headerEditorEnabled && import_react23.default.createElement(HeaderEditor, { ref: function(n) {
      _this.headerEditorComponent = n;
    }, value: this.state.headers, onEdit: this.handleEditHeaders, onHintInformationRender: this.handleHintInformationRender, onPrettifyQuery: this.handlePrettifyQuery, onMergeQuery: this.handleMergeQuery, onRunQuery: this.handleEditorRunQuery, editorTheme: this.props.editorTheme, readOnly: this.props.readOnly, active: this.state.headerEditorActive }))), import_react23.default.createElement("div", { className: "resultWrap" }, this.state.isWaitingForResponse && import_react23.default.createElement("div", { className: "spinner-container" }, import_react23.default.createElement("div", { className: "spinner" })), import_react23.default.createElement(ResultViewer, { registerRef: function(n) {
      _this.resultViewerElement = n;
    }, ref: function(c) {
      _this.resultComponent = c;
    }, value: this.state.response, editorTheme: this.props.editorTheme, ResultsTooltip: this.props.ResultsTooltip, ImagePreview }), footer))), this.state.docExplorerOpen && import_react23.default.createElement("div", { className: docExplorerWrapClasses, style: docWrapStyle }, import_react23.default.createElement("div", { className: "docExplorerResizer", onDoubleClick: this.handleDocsResetResize, onMouseDown: this.handleDocsResizeStart }), import_react23.default.createElement(DocExplorer, { ref: function(c) {
      _this.docExplorerComponent = c;
    }, schema: this.state.schema }, import_react23.default.createElement("button", { className: "docExplorerHide", onClick: this.handleToggleDocs, "aria-label": "Close Documentation Explorer" }, "\u2715"))));
  };
  GraphiQL2.prototype.getQueryEditor = function() {
    if (this.queryEditorComponent) {
      return this.queryEditorComponent.getCodeMirror();
    }
  };
  GraphiQL2.prototype.getVariableEditor = function() {
    if (this.variableEditorComponent) {
      return this.variableEditorComponent.getCodeMirror();
    }
    return null;
  };
  GraphiQL2.prototype.getHeaderEditor = function() {
    if (this.headerEditorComponent) {
      return this.headerEditorComponent.getCodeMirror();
    }
    return null;
  };
  GraphiQL2.prototype.refresh = function() {
    if (this.queryEditorComponent) {
      this.queryEditorComponent.getCodeMirror().refresh();
    }
    if (this.variableEditorComponent) {
      this.variableEditorComponent.getCodeMirror().refresh();
    }
    if (this.headerEditorComponent) {
      this.headerEditorComponent.getCodeMirror().refresh();
    }
    if (this.resultComponent) {
      this.resultComponent.getCodeMirror().refresh();
    }
  };
  GraphiQL2.prototype.autoCompleteLeafs = function() {
    var _a2 = fillLeafs(this.state.schema, this.state.query, this.props.getDefaultFieldNames), insertions = _a2.insertions, result = _a2.result;
    if (insertions && insertions.length > 0) {
      var editor_1 = this.getQueryEditor();
      if (editor_1) {
        editor_1.operation(function() {
          var cursor = editor_1.getCursor();
          var cursorIndex = editor_1.indexFromPos(cursor);
          editor_1.setValue(result || "");
          var added = 0;
          var markers = insertions.map(function(_a3) {
            var index = _a3.index, string = _a3.string;
            return editor_1.markText(editor_1.posFromIndex(index + added), editor_1.posFromIndex(index + (added += string.length)), {
              className: "autoInsertedLeaf",
              clearOnEnter: true,
              title: "Automatically added leaf fields"
            });
          });
          setTimeout(function() {
            return markers.forEach(function(marker) {
              return marker.clear();
            });
          }, 7e3);
          var newCursorIndex = cursorIndex;
          insertions.forEach(function(_a3) {
            var index = _a3.index, string = _a3.string;
            if (index < cursorIndex) {
              newCursorIndex += string.length;
            }
          });
          editor_1.setCursor(editor_1.posFromIndex(newCursorIndex));
        });
      }
    }
    return result;
  };
  GraphiQL2.prototype.fetchSchema = function() {
    var _this = this;
    var fetcher = this.props.fetcher;
    var fetcherOpts = {
      shouldPersistHeaders: Boolean(this.props.shouldPersistHeaders),
      documentAST: this.state.documentAST
    };
    if (this.state.headers && this.state.headers.trim().length > 2) {
      fetcherOpts.headers = JSON.parse(this.state.headers);
    } else if (this.props.headers) {
      fetcherOpts.headers = JSON.parse(this.props.headers);
    }
    var fetch2 = fetcherReturnToPromise(fetcher({
      query: introspectionQuery,
      operationName: introspectionQueryName
    }, fetcherOpts));
    if (!isPromise2(fetch2)) {
      this.setState({
        response: "Fetcher did not return a Promise for introspection."
      });
      return;
    }
    fetch2.then(function(result) {
      if (typeof result !== "string" && "data" in result) {
        return result;
      }
      var fetch22 = fetcherReturnToPromise(fetcher({
        query: introspectionQuerySansSubscriptions,
        operationName: introspectionQueryName
      }, fetcherOpts));
      if (!isPromise2(fetch2)) {
        throw new Error("Fetcher did not return a Promise for introspection.");
      }
      return fetch22;
    }).then(function(result) {
      if (_this.state.schema !== void 0) {
        return;
      }
      if (typeof result !== "string" && "data" in result) {
        var schema = buildClientSchema(result.data);
        var queryFacts = getOperationFacts(schema, _this.state.query);
        _this.safeSetState(__assign7({ schema }, queryFacts));
      } else {
        var responseString = typeof result === "string" ? result : GraphiQL2.formatResult(result);
        _this.safeSetState({
          schema: void 0,
          response: responseString
        });
      }
    }).catch(function(error2) {
      _this.safeSetState({
        schema: void 0,
        response: error2 ? GraphiQL2.formatError(error2) : void 0
      });
    });
  };
  GraphiQL2.prototype._fetchQuery = function(query, variables, headers, operationName, shouldPersistHeaders, cb) {
    return __awaiter3(this, void 0, void 0, function() {
      var fetcher, jsonVariables, jsonHeaders, externalFragments_1, fragmentDependencies, fetch2;
      var _this = this;
      return __generator(this, function(_a2) {
        fetcher = this.props.fetcher;
        jsonVariables = null;
        jsonHeaders = null;
        try {
          jsonVariables = variables && variables.trim() !== "" ? JSON.parse(variables) : null;
        } catch (error2) {
          throw new Error("Variables are invalid JSON: " + error2.message + ".");
        }
        if (typeof jsonVariables !== "object") {
          throw new Error("Variables are not a JSON object.");
        }
        try {
          jsonHeaders = headers && headers.trim() !== "" ? JSON.parse(headers) : null;
        } catch (error2) {
          throw new Error("Headers are invalid JSON: " + error2.message + ".");
        }
        if (typeof jsonHeaders !== "object") {
          throw new Error("Headers are not a JSON object.");
        }
        if (this.props.externalFragments) {
          externalFragments_1 = new Map();
          if (Array.isArray(this.props.externalFragments)) {
            this.props.externalFragments.forEach(function(def) {
              externalFragments_1.set(def.name.value, def);
            });
          } else {
            visit(parse(this.props.externalFragments, {
              experimentalFragmentVariables: true
            }), {
              FragmentDefinition: function(def) {
                externalFragments_1.set(def.name.value, def);
              }
            });
          }
          fragmentDependencies = getFragmentDependenciesForAST(this.state.documentAST, externalFragments_1);
          if (fragmentDependencies.length > 0) {
            query += "\n" + fragmentDependencies.map(function(node) {
              return print(node);
            }).join("\n");
          }
        }
        fetch2 = fetcher({
          query,
          variables: jsonVariables,
          operationName
        }, {
          headers: jsonHeaders,
          shouldPersistHeaders,
          documentAST: this.state.documentAST
        });
        return [2, Promise.resolve(fetch2).then(function(value) {
          if (isObservable(value)) {
            var subscription = value.subscribe({
              next: cb,
              error: function(error2) {
                _this.safeSetState({
                  isWaitingForResponse: false,
                  response: error2 ? GraphiQL2.formatError(error2) : void 0,
                  subscription: null
                });
              },
              complete: function() {
                _this.safeSetState({
                  isWaitingForResponse: false,
                  subscription: null
                });
              }
            });
            return subscription;
          } else if (isAsyncIterable2(value)) {
            (function() {
              return __awaiter3(_this, void 0, void 0, function() {
                var value_1, value_1_1, result, e_2_1, error_2;
                var e_2, _a3;
                return __generator(this, function(_b) {
                  switch (_b.label) {
                    case 0:
                      _b.trys.push([0, 13, , 14]);
                      _b.label = 1;
                    case 1:
                      _b.trys.push([1, 6, 7, 12]);
                      value_1 = __asyncValues(value);
                      _b.label = 2;
                    case 2:
                      return [4, value_1.next()];
                    case 3:
                      if (!(value_1_1 = _b.sent(), !value_1_1.done))
                        return [3, 5];
                      result = value_1_1.value;
                      cb(result);
                      _b.label = 4;
                    case 4:
                      return [3, 2];
                    case 5:
                      return [3, 12];
                    case 6:
                      e_2_1 = _b.sent();
                      e_2 = { error: e_2_1 };
                      return [3, 12];
                    case 7:
                      _b.trys.push([7, , 10, 11]);
                      if (!(value_1_1 && !value_1_1.done && (_a3 = value_1.return)))
                        return [3, 9];
                      return [4, _a3.call(value_1)];
                    case 8:
                      _b.sent();
                      _b.label = 9;
                    case 9:
                      return [3, 11];
                    case 10:
                      if (e_2)
                        throw e_2.error;
                      return [7];
                    case 11:
                      return [7];
                    case 12:
                      this.safeSetState({
                        isWaitingForResponse: false,
                        subscription: null
                      });
                      return [3, 14];
                    case 13:
                      error_2 = _b.sent();
                      this.safeSetState({
                        isWaitingForResponse: false,
                        response: error_2 ? GraphiQL2.formatError(error_2) : void 0,
                        subscription: null
                      });
                      return [3, 14];
                    case 14:
                      return [2];
                  }
                });
              });
            })();
            return {
              unsubscribe: function() {
                var _a3, _b;
                return (_b = (_a3 = value[Symbol.asyncIterator]()).return) === null || _b === void 0 ? void 0 : _b.call(_a3);
              }
            };
          } else {
            cb(value);
            return null;
          }
        }).catch(function(error2) {
          _this.safeSetState({
            isWaitingForResponse: false,
            response: error2 ? GraphiQL2.formatError(error2) : void 0
          });
          return null;
        })];
      });
    });
  };
  GraphiQL2.prototype._runQueryAtCursor = function() {
    if (this.state.subscription) {
      this.handleStopQuery();
      return;
    }
    var operationName;
    var operations = this.state.operations;
    if (operations) {
      var editor = this.getQueryEditor();
      if (editor && editor.hasFocus()) {
        var cursor = editor.getCursor();
        var cursorIndex = editor.indexFromPos(cursor);
        for (var i = 0; i < operations.length; i++) {
          var operation = operations[i];
          if (operation.loc && operation.loc.start <= cursorIndex && operation.loc.end >= cursorIndex) {
            operationName = operation.name && operation.name.value;
            break;
          }
        }
      }
    }
    this.handleRunQuery(operationName);
  };
  GraphiQL2.prototype._didClickDragBar = function(event) {
    if (event.button !== 0 || event.ctrlKey) {
      return false;
    }
    var target = event.target;
    if (target.className.indexOf("CodeMirror-gutter") !== 0) {
      return false;
    }
    var resultWindow = this.resultViewerElement;
    while (target) {
      if (target === resultWindow) {
        return true;
      }
      target = target.parentNode;
    }
    return false;
  };
  GraphiQL2.Logo = GraphiQLLogo;
  GraphiQL2.Toolbar = GraphiQLToolbar;
  GraphiQL2.Footer = GraphiQLFooter;
  GraphiQL2.QueryEditor = QueryEditor;
  GraphiQL2.VariableEditor = VariableEditor;
  GraphiQL2.HeaderEditor = HeaderEditor;
  GraphiQL2.ResultViewer = ResultViewer;
  GraphiQL2.Button = ToolbarButton;
  GraphiQL2.ToolbarButton = ToolbarButton;
  GraphiQL2.Group = ToolbarGroup;
  GraphiQL2.Menu = ToolbarMenu;
  GraphiQL2.MenuItem = ToolbarMenuItem;
  return GraphiQL2;
}(import_react23.default.Component);
function GraphiQLLogo(props) {
  return import_react23.default.createElement("div", { className: "title" }, props.children || import_react23.default.createElement("span", null, "Graph", import_react23.default.createElement("em", null, "i"), "QL"));
}
GraphiQLLogo.displayName = "GraphiQLLogo";
function GraphiQLToolbar(props) {
  return import_react23.default.createElement("div", { className: "toolbar", role: "toolbar", "aria-label": "Editor Commands" }, props.children);
}
GraphiQLToolbar.displayName = "GraphiQLToolbar";
function GraphiQLFooter(props) {
  return import_react23.default.createElement("div", { className: "footer" }, props.children);
}
GraphiQLFooter.displayName = "GraphiQLFooter";
var formatSingleError = function(error2) {
  return __assign7(__assign7({}, error2), { message: error2.message, stack: error2.stack });
};
var defaultQuery = '# Welcome to GraphiQL\n#\n# GraphiQL is an in-browser tool for writing, validating, and\n# testing GraphQL queries.\n#\n# Type queries into this side of the screen, and you will see intelligent\n# typeaheads aware of the current GraphQL type schema and live syntax and\n# validation errors highlighted within the text.\n#\n# GraphQL queries typically start with a "{" character. Lines that start\n# with a # are ignored.\n#\n# An example GraphQL query might look like:\n#\n#     {\n#       field(arg: "value") {\n#         subField\n#       }\n#     }\n#\n# Keyboard shortcuts:\n#\n#  Prettify Query:  Shift-Ctrl-P (or press the prettify button above)\n#\n#     Merge Query:  Shift-Ctrl-M (or press the merge button above)\n#\n#       Run Query:  Ctrl-Enter (or press the play button above)\n#\n#   Auto Complete:  Ctrl-Space (or just start typing)\n#\n\n';
function isPromise2(value) {
  return typeof value === "object" && typeof value.then === "function";
}
function observableToPromise(observable) {
  return new Promise(function(resolve4, reject) {
    var subscription = observable.subscribe({
      next: function(v) {
        resolve4(v);
        subscription.unsubscribe();
      },
      error: reject,
      complete: function() {
        reject(new Error("no value resolved"));
      }
    });
  });
}
function isObservable(value) {
  return typeof value === "object" && "subscribe" in value && typeof value.subscribe === "function";
}
function isAsyncIterable2(input) {
  return typeof input === "object" && input !== null && (input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator in input);
}
function asyncIterableToPromise(input) {
  return new Promise(function(resolve4, reject) {
    var _a2;
    var iteratorReturn = (_a2 = ("return" in input ? input : input[Symbol.asyncIterator]()).return) === null || _a2 === void 0 ? void 0 : _a2.bind(input);
    var iteratorNext = ("next" in input ? input : input[Symbol.asyncIterator]()).next.bind(input);
    iteratorNext().then(function(result) {
      resolve4(result.value);
      iteratorReturn === null || iteratorReturn === void 0 ? void 0 : iteratorReturn();
    }).catch(function(err) {
      reject(err);
    });
  });
}
function fetcherReturnToPromise(fetcherResult) {
  return Promise.resolve(fetcherResult).then(function(fetcherResult2) {
    if (isAsyncIterable2(fetcherResult2)) {
      return asyncIterableToPromise(fetcherResult2);
    } else if (isObservable(fetcherResult2)) {
      return observableToPromise(fetcherResult2);
    }
    return fetcherResult2;
  });
}
function isChildComponentType(child, component) {
  var _a2;
  if (((_a2 = child === null || child === void 0 ? void 0 : child.type) === null || _a2 === void 0 ? void 0 : _a2.displayName) && child.type.displayName === component.displayName) {
    return true;
  }
  return child.type === component;
}

// node_modules/graphiql/esm/components/ToolbarSelect.js
init_define_process_env();
var import_react24 = __toModule(require_react());
var __extends16 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t2) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t2[p2] = s[p2];
    }
    return t2;
  };
  return __assign8.apply(this, arguments);
};
function hasProps(child) {
  if (!child || typeof child !== "object" || !("props" in child)) {
    return false;
  }
  return true;
}
var ToolbarSelect = function(_super) {
  __extends16(ToolbarSelect2, _super);
  function ToolbarSelect2(props) {
    var _this = _super.call(this, props) || this;
    _this._node = null;
    _this._listener = null;
    _this.handleOpen = function(e) {
      preventDefault2(e);
      _this.setState({ visible: true });
      _this._subscribe();
    };
    _this.state = { visible: false };
    return _this;
  }
  ToolbarSelect2.prototype.componentWillUnmount = function() {
    this._release();
  };
  ToolbarSelect2.prototype.render = function() {
    var _this = this;
    var selectedChild;
    var visible = this.state.visible;
    var optionChildren = import_react24.default.Children.map(this.props.children, function(child, i) {
      if (!hasProps(child)) {
        return null;
      }
      if (!selectedChild || child.props.selected) {
        selectedChild = child;
      }
      var onChildSelect = child.props.onSelect || _this.props.onSelect && _this.props.onSelect.bind(null, child.props.value, i);
      return import_react24.default.createElement(ToolbarSelectOption, __assign8({}, child.props, { onSelect: onChildSelect }));
    });
    return import_react24.default.createElement("a", { className: "toolbar-select toolbar-button", onClick: this.handleOpen.bind(this), onMouseDown: preventDefault2, ref: function(node) {
      _this._node = node;
    }, title: this.props.title }, selectedChild === null || selectedChild === void 0 ? void 0 : selectedChild.props.label, import_react24.default.createElement("svg", { width: "13", height: "10" }, import_react24.default.createElement("path", { fill: "#666", d: "M 5 5 L 13 5 L 9 1 z" }), import_react24.default.createElement("path", { fill: "#666", d: "M 5 6 L 13 6 L 9 10 z" })), import_react24.default.createElement("ul", { className: "toolbar-select-options" + (visible ? " open" : "") }, optionChildren));
  };
  ToolbarSelect2.prototype._subscribe = function() {
    if (!this._listener) {
      this._listener = this.handleClick.bind(this);
      document.addEventListener("click", this._listener);
    }
  };
  ToolbarSelect2.prototype._release = function() {
    if (this._listener) {
      document.removeEventListener("click", this._listener);
      this._listener = null;
    }
  };
  ToolbarSelect2.prototype.handleClick = function(e) {
    if (this._node !== e.target) {
      preventDefault2(e);
      this.setState({ visible: false });
      this._release();
    }
  };
  return ToolbarSelect2;
}(import_react24.default.Component);
function ToolbarSelectOption(_a2) {
  var onSelect = _a2.onSelect, label = _a2.label, selected = _a2.selected;
  return import_react24.default.createElement("li", { onMouseOver: function(e) {
    e.currentTarget.className = "hover";
  }, onMouseOut: function(e) {
    e.currentTarget.className = "";
  }, onMouseDown: preventDefault2, onMouseUp: onSelect }, label, selected && import_react24.default.createElement("svg", { width: "13", height: "13" }, import_react24.default.createElement("polygon", { points: "4.851,10.462 0,5.611 2.314,3.297 4.851,5.835\n    10.686,0 13,2.314 4.851,10.462" })));
}
function preventDefault2(e) {
  e.preventDefault();
}

// node_modules/graphiql/esm/index.js
var esm_default = GraphiQL;

// dep:graphiql
var graphiql_default = esm_default;
export {
  DocExplorer,
  GraphiQL,
  QueryEditor,
  ToolbarButton,
  ToolbarGroup,
  ToolbarMenu,
  ToolbarSelect,
  VariableEditor,
  graphiql_default as default,
  fillLeafs,
  getQueryFacts,
  getSelectedOperationName,
  mergeAST as mergeAst,
  onHasCompletion
};
//# sourceMappingURL=graphiql.js.map
