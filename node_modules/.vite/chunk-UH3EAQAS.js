import {
  __spreadValues as __spreadValues2,
  checkBlocknativeAppId
} from "./chunk-ADZUHRBV.js";
import {
  notification_default
} from "./chunk-HEP2YWA5.js";
import {
  parseProviderOrSigner
} from "./chunk-OWP2YEHI.js";
import {
  ethers_exports
} from "./chunk-B5PQFD23.js";
import {
  BigNumber
} from "./chunk-SVV6QRWF.js";
import {
  __commonJS,
  __objRest,
  __spreadProps,
  __spreadValues,
  __toModule
} from "./chunk-MDAI7X5T.js";

// node_modules/regenerator-runtime/runtime.js
var require_runtime = __commonJS({
  "node_modules/regenerator-runtime/runtime.js"(exports, module) {
    var runtime = function(exports2) {
      "use strict";
      var Op = Object.prototype;
      var hasOwn = Op.hasOwnProperty;
      var defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
      };
      var undefined2;
      var $Symbol = typeof Symbol === "function" ? Symbol : {};
      var iteratorSymbol = $Symbol.iterator || "@@iterator";
      var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
      var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
        return obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self2, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
        var generator = Object.create(protoGenerator.prototype);
        var context = new Context(tryLocsList || []);
        defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self2, context) });
        return generator;
      }
      exports2.wrap = wrap;
      function tryCatch(fn, obj, arg) {
        try {
          return { type: "normal", arg: fn.call(obj, arg) };
        } catch (err) {
          return { type: "throw", arg: err };
        }
      }
      var GenStateSuspendedStart = "suspendedStart";
      var GenStateSuspendedYield = "suspendedYield";
      var GenStateExecuting = "executing";
      var GenStateCompleted = "completed";
      var ContinueSentinel = {};
      function Generator() {
      }
      function GeneratorFunction() {
      }
      function GeneratorFunctionPrototype() {
      }
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function() {
        return this;
      });
      var getProto = Object.getPrototypeOf;
      var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
        IteratorPrototype = NativeIteratorPrototype;
      }
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      GeneratorFunction.prototype = GeneratorFunctionPrototype;
      defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
      defineProperty(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: true });
      GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction");
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function(method) {
          define(prototype, method, function(arg) {
            return this._invoke(method, arg);
          });
        });
      }
      exports2.isGeneratorFunction = function(genFun) {
        var ctor = typeof genFun === "function" && genFun.constructor;
        return ctor ? ctor === GeneratorFunction || (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
      };
      exports2.mark = function(genFun) {
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
        } else {
          genFun.__proto__ = GeneratorFunctionPrototype;
          define(genFun, toStringTagSymbol, "GeneratorFunction");
        }
        genFun.prototype = Object.create(Gp);
        return genFun;
      };
      exports2.awrap = function(arg) {
        return { __await: arg };
      };
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if (record.type === "throw") {
            reject(record.arg);
          } else {
            var result = record.arg;
            var value = result.value;
            if (value && typeof value === "object" && hasOwn.call(value, "__await")) {
              return PromiseImpl.resolve(value.__await).then(function(value2) {
                invoke("next", value2, resolve, reject);
              }, function(err) {
                invoke("throw", err, resolve, reject);
              });
            }
            return PromiseImpl.resolve(value).then(function(unwrapped) {
              result.value = unwrapped;
              resolve(result);
            }, function(error) {
              return invoke("throw", error, resolve, reject);
            });
          }
        }
        var previousPromise;
        function enqueue(method, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
        defineProperty(this, "_invoke", { value: enqueue });
      }
      defineIteratorMethods(AsyncIterator.prototype);
      define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
      });
      exports2.AsyncIterator = AsyncIterator;
      exports2.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
        if (PromiseImpl === void 0)
          PromiseImpl = Promise;
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
        return exports2.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
      };
      function makeInvokeMethod(innerFn, self2, context) {
        var state = GenStateSuspendedStart;
        return function invoke(method, arg) {
          if (state === GenStateExecuting) {
            throw new Error("Generator is already running");
          }
          if (state === GenStateCompleted) {
            if (method === "throw") {
              throw arg;
            }
            return doneResult();
          }
          context.method = method;
          context.arg = arg;
          while (true) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel)
                  continue;
                return delegateResult;
              }
            }
            if (context.method === "next") {
              context.sent = context._sent = context.arg;
            } else if (context.method === "throw") {
              if (state === GenStateSuspendedStart) {
                state = GenStateCompleted;
                throw context.arg;
              }
              context.dispatchException(context.arg);
            } else if (context.method === "return") {
              context.abrupt("return", context.arg);
            }
            state = GenStateExecuting;
            var record = tryCatch(innerFn, self2, context);
            if (record.type === "normal") {
              state = context.done ? GenStateCompleted : GenStateSuspendedYield;
              if (record.arg === ContinueSentinel) {
                continue;
              }
              return {
                value: record.arg,
                done: context.done
              };
            } else if (record.type === "throw") {
              state = GenStateCompleted;
              context.method = "throw";
              context.arg = record.arg;
            }
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method;
        var method = delegate.iterator[methodName];
        if (method === undefined2) {
          context.delegate = null;
          if (methodName === "throw" && delegate.iterator["return"]) {
            context.method = "return";
            context.arg = undefined2;
            maybeInvokeDelegate(delegate, context);
            if (context.method === "throw") {
              return ContinueSentinel;
            }
          }
          if (methodName !== "return") {
            context.method = "throw";
            context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if (record.type === "throw") {
          context.method = "throw";
          context.arg = record.arg;
          context.delegate = null;
          return ContinueSentinel;
        }
        var info = record.arg;
        if (!info) {
          context.method = "throw";
          context.arg = new TypeError("iterator result is not an object");
          context.delegate = null;
          return ContinueSentinel;
        }
        if (info.done) {
          context[delegate.resultName] = info.value;
          context.next = delegate.nextLoc;
          if (context.method !== "return") {
            context.method = "next";
            context.arg = undefined2;
          }
        } else {
          return info;
        }
        context.delegate = null;
        return ContinueSentinel;
      }
      defineIteratorMethods(Gp);
      define(Gp, toStringTagSymbol, "Generator");
      define(Gp, iteratorSymbol, function() {
        return this;
      });
      define(Gp, "toString", function() {
        return "[object Generator]";
      });
      function pushTryEntry(locs) {
        var entry = { tryLoc: locs[0] };
        if (1 in locs) {
          entry.catchLoc = locs[1];
        }
        if (2 in locs) {
          entry.finallyLoc = locs[2];
          entry.afterLoc = locs[3];
        }
        this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal";
        delete record.arg;
        entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{ tryLoc: "root" }];
        tryLocsList.forEach(pushTryEntry, this);
        this.reset(true);
      }
      exports2.keys = function(val) {
        var object = Object(val);
        var keys = [];
        for (var key in object) {
          keys.push(key);
        }
        keys.reverse();
        return function next() {
          while (keys.length) {
            var key2 = keys.pop();
            if (key2 in object) {
              next.value = key2;
              next.done = false;
              return next;
            }
          }
          next.done = true;
          return next;
        };
      };
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) {
            return iteratorMethod.call(iterable);
          }
          if (typeof iterable.next === "function") {
            return iterable;
          }
          if (!isNaN(iterable.length)) {
            var i2 = -1, next = function next2() {
              while (++i2 < iterable.length) {
                if (hasOwn.call(iterable, i2)) {
                  next2.value = iterable[i2];
                  next2.done = false;
                  return next2;
                }
              }
              next2.value = undefined2;
              next2.done = true;
              return next2;
            };
            return next.next = next;
          }
        }
        return { next: doneResult };
      }
      exports2.values = values;
      function doneResult() {
        return { value: undefined2, done: true };
      }
      Context.prototype = {
        constructor: Context,
        reset: function(skipTempReset) {
          this.prev = 0;
          this.next = 0;
          this.sent = this._sent = undefined2;
          this.done = false;
          this.delegate = null;
          this.method = "next";
          this.arg = undefined2;
          this.tryEntries.forEach(resetTryEntry);
          if (!skipTempReset) {
            for (var name in this) {
              if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
                this[name] = undefined2;
              }
            }
          }
        },
        stop: function() {
          this.done = true;
          var rootEntry = this.tryEntries[0];
          var rootRecord = rootEntry.completion;
          if (rootRecord.type === "throw") {
            throw rootRecord.arg;
          }
          return this.rval;
        },
        dispatchException: function(exception) {
          if (this.done) {
            throw exception;
          }
          var context = this;
          function handle(loc, caught) {
            record.type = "throw";
            record.arg = exception;
            context.next = loc;
            if (caught) {
              context.method = "next";
              context.arg = undefined2;
            }
            return !!caught;
          }
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            var record = entry.completion;
            if (entry.tryLoc === "root") {
              return handle("end");
            }
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc");
              var hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                } else if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) {
                  return handle(entry.catchLoc, true);
                }
              } else if (hasFinally) {
                if (this.prev < entry.finallyLoc) {
                  return handle(entry.finallyLoc);
                }
              } else {
                throw new Error("try statement without catch or finally");
              }
            }
          }
        },
        abrupt: function(type, arg) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
            finallyEntry = null;
          }
          var record = finallyEntry ? finallyEntry.completion : {};
          record.type = type;
          record.arg = arg;
          if (finallyEntry) {
            this.method = "next";
            this.next = finallyEntry.finallyLoc;
            return ContinueSentinel;
          }
          return this.complete(record);
        },
        complete: function(record, afterLoc) {
          if (record.type === "throw") {
            throw record.arg;
          }
          if (record.type === "break" || record.type === "continue") {
            this.next = record.arg;
          } else if (record.type === "return") {
            this.rval = this.arg = record.arg;
            this.method = "return";
            this.next = "end";
          } else if (record.type === "normal" && afterLoc) {
            this.next = afterLoc;
          }
          return ContinueSentinel;
        },
        finish: function(finallyLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.finallyLoc === finallyLoc) {
              this.complete(entry.completion, entry.afterLoc);
              resetTryEntry(entry);
              return ContinueSentinel;
            }
          }
        },
        "catch": function(tryLoc) {
          for (var i2 = this.tryEntries.length - 1; i2 >= 0; --i2) {
            var entry = this.tryEntries[i2];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if (record.type === "throw") {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function(iterable, resultName, nextLoc) {
          this.delegate = {
            iterator: values(iterable),
            resultName,
            nextLoc
          };
          if (this.method === "next") {
            this.arg = undefined2;
          }
          return ContinueSentinel;
        }
      };
      return exports2;
    }(typeof module === "object" ? module.exports : {});
    try {
      regeneratorRuntime = runtime;
    } catch (accidentalStrictMode) {
      if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
      } else {
        Function("r", "regeneratorRuntime = r")(runtime);
      }
    }
  }
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.defaults/index.js"(exports, module) {
    var MAX_SAFE_INTEGER2 = 9007199254740991;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function baseTimes(n2, iteratee) {
      var index = -1, result = Array(n2);
      while (++index < n2) {
        result[index] = iteratee(index);
      }
      return result;
    }
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex2(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignInDefaults(objValue, srcValue, key, object) {
      if (objValue === void 0 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
        return srcValue;
      }
      return objValue;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function baseKeysIn(object) {
      if (!isObject3(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object), result = [];
      for (var key in object) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    function baseRest(func, start) {
      start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
      return function() {
        var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = array;
        return apply(func, this, otherArgs);
      };
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
        customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? void 0 : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }
    function isIndex2(value, length) {
      length = length == null ? MAX_SAFE_INTEGER2 : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isIterateeCall(value, index, object) {
      if (!isObject3(object)) {
        return false;
      }
      var type = typeof index;
      if (type == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type == "string" && index in object) {
        return eq(object[index], value);
      }
      return false;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray2 = Array.isArray;
    function isArrayLike2(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike2(value);
    }
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });
    var defaults = baseRest(function(args) {
      args.push(void 0, assignInDefaults);
      return apply(assignInWith, void 0, args);
    });
    function keysIn(object) {
      return isArrayLike2(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }
    module.exports = defaults;
  }
});

// node_modules/sturdy-websocket/dist/index.js
var require_dist = __commonJS({
  "node_modules/sturdy-websocket/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var defaults = require_lodash();
    var SHOULD_RECONNECT_FALSE_MESSAGE = "Provided shouldReconnect() returned false. Closing permanently.";
    var SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = "Provided shouldReconnect() resolved to false. Closing permanently.";
    var SturdyWebSocket2 = function() {
      function SturdyWebSocket3(url, protocolsOrOptions, options) {
        this.url = url;
        this.onclose = null;
        this.onerror = null;
        this.onmessage = null;
        this.onopen = null;
        this.ondown = null;
        this.onreopen = null;
        this.CONNECTING = SturdyWebSocket3.CONNECTING;
        this.OPEN = SturdyWebSocket3.OPEN;
        this.CLOSING = SturdyWebSocket3.CLOSING;
        this.CLOSED = SturdyWebSocket3.CLOSED;
        this.hasBeenOpened = false;
        this.isClosed = false;
        this.messageBuffer = [];
        this.nextRetryTime = 0;
        this.reconnectCount = 0;
        this.lastKnownExtensions = "";
        this.lastKnownProtocol = "";
        this.listeners = {};
        if (protocolsOrOptions == null || typeof protocolsOrOptions === "string" || Array.isArray(protocolsOrOptions)) {
          this.protocols = protocolsOrOptions;
        } else {
          options = protocolsOrOptions;
        }
        this.options = defaults({}, options, SturdyWebSocket3.DEFAULT_OPTIONS);
        if (!this.options.wsConstructor) {
          if (typeof WebSocket !== "undefined") {
            this.options.wsConstructor = WebSocket;
          } else {
            throw new Error("WebSocket not present in global scope and no wsConstructor option was provided.");
          }
        }
        this.openNewWebSocket();
      }
      Object.defineProperty(SturdyWebSocket3.prototype, "binaryType", {
        get: function() {
          return this.binaryTypeInternal || "blob";
        },
        set: function(binaryType) {
          this.binaryTypeInternal = binaryType;
          if (this.ws) {
            this.ws.binaryType = binaryType;
          }
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "bufferedAmount", {
        get: function() {
          var sum = this.ws ? this.ws.bufferedAmount : 0;
          var hasUnknownAmount = false;
          this.messageBuffer.forEach(function(data) {
            var byteLength = getDataByteLength(data);
            if (byteLength != null) {
              sum += byteLength;
            } else {
              hasUnknownAmount = true;
            }
          });
          if (hasUnknownAmount) {
            this.debugLog("Some buffered data had unknown length. bufferedAmount() return value may be below the correct amount.");
          }
          return sum;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "extensions", {
        get: function() {
          return this.ws ? this.ws.extensions : this.lastKnownExtensions;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "protocol", {
        get: function() {
          return this.ws ? this.ws.protocol : this.lastKnownProtocol;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(SturdyWebSocket3.prototype, "readyState", {
        get: function() {
          return this.isClosed ? SturdyWebSocket3.CLOSED : SturdyWebSocket3.OPEN;
        },
        enumerable: true,
        configurable: true
      });
      SturdyWebSocket3.prototype.close = function(code, reason) {
        if (this.ws) {
          this.ws.close(code, reason);
        }
        this.shutdown();
        this.debugLog("WebSocket permanently closed by client.");
      };
      SturdyWebSocket3.prototype.send = function(data) {
        if (this.ws && this.ws.readyState === this.OPEN) {
          this.ws.send(data);
        } else {
          this.messageBuffer.push(data);
        }
      };
      SturdyWebSocket3.prototype.addEventListener = function(type, listener) {
        if (!this.listeners[type]) {
          this.listeners[type] = [];
        }
        this.listeners[type].push(listener);
      };
      SturdyWebSocket3.prototype.dispatchEvent = function(event2) {
        return this.dispatchEventOfType(event2.type, event2);
      };
      SturdyWebSocket3.prototype.removeEventListener = function(type, listener) {
        if (this.listeners[type]) {
          this.listeners[type] = this.listeners[type].filter(function(l2) {
            return l2 !== listener;
          });
        }
      };
      SturdyWebSocket3.prototype.openNewWebSocket = function() {
        var _this = this;
        if (this.isClosed) {
          return;
        }
        var _a = this.options, connectTimeout = _a.connectTimeout, wsConstructor = _a.wsConstructor;
        this.debugLog("Opening new WebSocket to " + this.url + ".");
        var ws = new wsConstructor(this.url, this.protocols);
        ws.onclose = function(event2) {
          return _this.handleClose(event2);
        };
        ws.onerror = function(event2) {
          return _this.handleError(event2);
        };
        ws.onmessage = function(event2) {
          return _this.handleMessage(event2);
        };
        ws.onopen = function(event2) {
          return _this.handleOpen(event2);
        };
        this.connectTimeoutId = setTimeout(function() {
          _this.clearConnectTimeout();
          ws.close();
        }, connectTimeout);
        this.ws = ws;
      };
      SturdyWebSocket3.prototype.handleOpen = function(event2) {
        var _this = this;
        if (!this.ws || this.isClosed) {
          return;
        }
        var allClearResetTime = this.options.allClearResetTime;
        this.debugLog("WebSocket opened.");
        if (this.binaryTypeInternal != null) {
          this.ws.binaryType = this.binaryTypeInternal;
        } else {
          this.binaryTypeInternal = this.ws.binaryType;
        }
        this.clearConnectTimeout();
        if (this.hasBeenOpened) {
          this.dispatchEventOfType("reopen", event2);
        } else {
          this.dispatchEventOfType("open", event2);
          this.hasBeenOpened = true;
        }
        this.messageBuffer.forEach(function(message) {
          return _this.send(message);
        });
        this.messageBuffer = [];
        this.allClearTimeoutId = setTimeout(function() {
          _this.clearAllClearTimeout();
          _this.nextRetryTime = 0;
          _this.reconnectCount = 0;
          var openTime = allClearResetTime / 1e3 | 0;
          _this.debugLog("WebSocket remained open for " + openTime + " seconds. Resetting retry time and count.");
        }, allClearResetTime);
      };
      SturdyWebSocket3.prototype.handleMessage = function(event2) {
        if (this.isClosed) {
          return;
        }
        this.dispatchEventOfType("message", event2);
      };
      SturdyWebSocket3.prototype.handleClose = function(event2) {
        var _this = this;
        if (this.isClosed) {
          return;
        }
        var _a = this.options, maxReconnectAttempts = _a.maxReconnectAttempts, shouldReconnect = _a.shouldReconnect;
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
        if (this.ws) {
          this.lastKnownExtensions = this.ws.extensions;
          this.lastKnownProtocol = this.ws.protocol;
          this.ws = void 0;
        }
        this.dispatchEventOfType("down", event2);
        if (this.reconnectCount >= maxReconnectAttempts) {
          this.stopReconnecting(event2, this.getTooManyFailedReconnectsMessage());
          return;
        }
        var willReconnect = shouldReconnect(event2);
        if (typeof willReconnect === "boolean") {
          this.handleWillReconnect(willReconnect, event2, SHOULD_RECONNECT_FALSE_MESSAGE);
        } else {
          willReconnect.then(function(willReconnectResolved) {
            if (_this.isClosed) {
              return;
            }
            _this.handleWillReconnect(willReconnectResolved, event2, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);
          });
        }
      };
      SturdyWebSocket3.prototype.handleError = function(event2) {
        this.dispatchEventOfType("error", event2);
        this.debugLog("WebSocket encountered an error.");
      };
      SturdyWebSocket3.prototype.handleWillReconnect = function(willReconnect, event2, denialReason) {
        if (willReconnect) {
          this.reconnect();
        } else {
          this.stopReconnecting(event2, denialReason);
        }
      };
      SturdyWebSocket3.prototype.reconnect = function() {
        var _this = this;
        var _a = this.options, minReconnectDelay = _a.minReconnectDelay, maxReconnectDelay = _a.maxReconnectDelay, reconnectBackoffFactor = _a.reconnectBackoffFactor;
        this.reconnectCount++;
        var retryTime = this.nextRetryTime;
        this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));
        setTimeout(function() {
          return _this.openNewWebSocket();
        }, retryTime);
        var retryTimeSeconds = retryTime / 1e3 | 0;
        this.debugLog("WebSocket was closed. Re-opening in " + retryTimeSeconds + " seconds.");
      };
      SturdyWebSocket3.prototype.stopReconnecting = function(event2, debugReason) {
        this.debugLog(debugReason);
        this.shutdown();
        this.dispatchEventOfType("close", event2);
      };
      SturdyWebSocket3.prototype.shutdown = function() {
        this.isClosed = true;
        this.clearAllTimeouts();
        this.messageBuffer = [];
      };
      SturdyWebSocket3.prototype.clearAllTimeouts = function() {
        this.clearConnectTimeout();
        this.clearAllClearTimeout();
      };
      SturdyWebSocket3.prototype.clearConnectTimeout = function() {
        if (this.connectTimeoutId != null) {
          clearTimeout(this.connectTimeoutId);
          this.connectTimeoutId = void 0;
        }
      };
      SturdyWebSocket3.prototype.clearAllClearTimeout = function() {
        if (this.allClearTimeoutId != null) {
          clearTimeout(this.allClearTimeoutId);
          this.allClearTimeoutId = void 0;
        }
      };
      SturdyWebSocket3.prototype.dispatchEventOfType = function(type, event2) {
        var _this = this;
        switch (type) {
          case "close":
            if (this.onclose) {
              this.onclose(event2);
            }
            break;
          case "error":
            if (this.onerror) {
              this.onerror(event2);
            }
            break;
          case "message":
            if (this.onmessage) {
              this.onmessage(event2);
            }
            break;
          case "open":
            if (this.onopen) {
              this.onopen(event2);
            }
            break;
          case "down":
            if (this.ondown) {
              this.ondown(event2);
            }
            break;
          case "reopen":
            if (this.onreopen) {
              this.onreopen(event2);
            }
            break;
        }
        if (type in this.listeners) {
          this.listeners[type].slice().forEach(function(listener) {
            return _this.callListener(listener, event2);
          });
        }
        return !event2 || !event2.defaultPrevented;
      };
      SturdyWebSocket3.prototype.callListener = function(listener, event2) {
        if (typeof listener === "function") {
          listener.call(this, event2);
        } else {
          listener.handleEvent.call(this, event2);
        }
      };
      SturdyWebSocket3.prototype.debugLog = function(message) {
        if (this.options.debug) {
          console.log(message);
        }
      };
      SturdyWebSocket3.prototype.getTooManyFailedReconnectsMessage = function() {
        var maxReconnectAttempts = this.options.maxReconnectAttempts;
        return "Failed to reconnect after " + maxReconnectAttempts + " " + pluralize("attempt", maxReconnectAttempts) + ". Closing permanently.";
      };
      SturdyWebSocket3.DEFAULT_OPTIONS = {
        allClearResetTime: 5e3,
        connectTimeout: 5e3,
        debug: false,
        minReconnectDelay: 1e3,
        maxReconnectDelay: 3e4,
        maxReconnectAttempts: Number.POSITIVE_INFINITY,
        reconnectBackoffFactor: 1.5,
        shouldReconnect: function() {
          return true;
        },
        wsConstructor: void 0
      };
      SturdyWebSocket3.CONNECTING = 0;
      SturdyWebSocket3.OPEN = 1;
      SturdyWebSocket3.CLOSING = 2;
      SturdyWebSocket3.CLOSED = 3;
      return SturdyWebSocket3;
    }();
    exports.default = SturdyWebSocket2;
    function getDataByteLength(data) {
      if (typeof data === "string") {
        return 2 * data.length;
      } else if (data instanceof ArrayBuffer) {
        return data.byteLength;
      } else if (data instanceof Blob) {
        return data.size;
      } else {
        return void 0;
      }
    }
    function pluralize(s2, n2) {
      return n2 === 1 ? s2 : s2 + "s";
    }
  }
});

// node_modules/uuid/lib/rng-browser.js
var require_rng_browser = __commonJS({
  "node_modules/uuid/lib/rng-browser.js"(exports, module) {
    var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof window.msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
    if (getRandomValues) {
      rnds8 = new Uint8Array(16);
      module.exports = function whatwgRNG() {
        getRandomValues(rnds8);
        return rnds8;
      };
    } else {
      rnds = new Array(16);
      module.exports = function mathRNG() {
        for (var i2 = 0, r2; i2 < 16; i2++) {
          if ((i2 & 3) === 0)
            r2 = Math.random() * 4294967296;
          rnds[i2] = r2 >>> ((i2 & 3) << 3) & 255;
        }
        return rnds;
      };
    }
    var rnds8;
    var rnds;
  }
});

// node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "node_modules/uuid/lib/bytesToUuid.js"(exports, module) {
    var byteToHex = [];
    for (i2 = 0; i2 < 256; ++i2) {
      byteToHex[i2] = (i2 + 256).toString(16).substr(1);
    }
    var i2;
    function bytesToUuid(buf, offset) {
      var i3 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        "-",
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]],
        bth[buf[i3++]]
      ].join("");
    }
    module.exports = bytesToUuid;
  }
});

// node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/v4.js"(exports, module) {
    var rng = require_rng_browser();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i2 = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i2 + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module.exports = v4;
  }
});

// node_modules/lodash.debounce/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.debounce/index.js"(exports, module) {
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now2 = function() {
      return root.Date.now();
    };
    function debounce2(func, wait3, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait3 = toNumber(wait3) || 0;
      if (isObject3(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait3) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait3);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait3 - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait3 || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now2();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now2());
      }
      function debounced() {
        var time = now2(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait3);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait3);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    function isObject3(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module.exports = debounce2;
  }
});

// node_modules/bnc-notify/dist/notify.js
var import_runtime = __toModule(require_runtime());

// node_modules/bnc-sdk/dist/esm/index.js
var import_sturdy_websocket = __toModule(require_dist());

// node_modules/crypto-es/lib/core.js
var Base = class {
  static create(...args) {
    return new this(...args);
  }
  mixIn(properties) {
    return Object.assign(this, properties);
  }
  clone() {
    const clone2 = new this.constructor();
    Object.assign(clone2, this);
    return clone2;
  }
};
var WordArray = class extends Base {
  constructor(words = [], sigBytes = words.length * 4) {
    super();
    let typedArray = words;
    if (typedArray instanceof ArrayBuffer) {
      typedArray = new Uint8Array(typedArray);
    }
    if (typedArray instanceof Int8Array || typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
    }
    if (typedArray instanceof Uint8Array) {
      const typedArrayByteLength = typedArray.byteLength;
      const _words = [];
      for (let i2 = 0; i2 < typedArrayByteLength; i2 += 1) {
        _words[i2 >>> 2] |= typedArray[i2] << 24 - i2 % 4 * 8;
      }
      this.words = _words;
      this.sigBytes = typedArrayByteLength;
    } else {
      this.words = words;
      this.sigBytes = sigBytes;
    }
  }
  static random(nBytes) {
    const words = [];
    const r2 = (m_w) => {
      let _m_w = m_w;
      let _m_z = 987654321;
      const mask = 4294967295;
      return () => {
        _m_z = 36969 * (_m_z & 65535) + (_m_z >> 16) & mask;
        _m_w = 18e3 * (_m_w & 65535) + (_m_w >> 16) & mask;
        let result = (_m_z << 16) + _m_w & mask;
        result /= 4294967296;
        result += 0.5;
        return result * (Math.random() > 0.5 ? 1 : -1);
      };
    };
    for (let i2 = 0, rcache; i2 < nBytes; i2 += 4) {
      const _r = r2((rcache || Math.random()) * 4294967296);
      rcache = _r() * 987654071;
      words.push(_r() * 4294967296 | 0);
    }
    return new WordArray(words, nBytes);
  }
  toString(encoder = Hex) {
    return encoder.stringify(this);
  }
  concat(wordArray) {
    const thisWords = this.words;
    const thatWords = wordArray.words;
    const thisSigBytes = this.sigBytes;
    const thatSigBytes = wordArray.sigBytes;
    this.clamp();
    if (thisSigBytes % 4) {
      for (let i2 = 0; i2 < thatSigBytes; i2 += 1) {
        const thatByte = thatWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
        thisWords[thisSigBytes + i2 >>> 2] |= thatByte << 24 - (thisSigBytes + i2) % 4 * 8;
      }
    } else {
      for (let i2 = 0; i2 < thatSigBytes; i2 += 4) {
        thisWords[thisSigBytes + i2 >>> 2] = thatWords[i2 >>> 2];
      }
    }
    this.sigBytes += thatSigBytes;
    return this;
  }
  clamp() {
    const { words, sigBytes } = this;
    words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
    words.length = Math.ceil(sigBytes / 4);
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2.words = this.words.slice(0);
    return clone2;
  }
};
var Hex = {
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const hexChars = [];
    for (let i2 = 0; i2 < sigBytes; i2 += 1) {
      const bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      hexChars.push((bite >>> 4).toString(16));
      hexChars.push((bite & 15).toString(16));
    }
    return hexChars.join("");
  },
  parse(hexStr) {
    const hexStrLength = hexStr.length;
    const words = [];
    for (let i2 = 0; i2 < hexStrLength; i2 += 2) {
      words[i2 >>> 3] |= parseInt(hexStr.substr(i2, 2), 16) << 24 - i2 % 8 * 4;
    }
    return new WordArray(words, hexStrLength / 2);
  }
};
var Latin1 = {
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const latin1Chars = [];
    for (let i2 = 0; i2 < sigBytes; i2 += 1) {
      const bite = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      latin1Chars.push(String.fromCharCode(bite));
    }
    return latin1Chars.join("");
  },
  parse(latin1Str) {
    const latin1StrLength = latin1Str.length;
    const words = [];
    for (let i2 = 0; i2 < latin1StrLength; i2 += 1) {
      words[i2 >>> 2] |= (latin1Str.charCodeAt(i2) & 255) << 24 - i2 % 4 * 8;
    }
    return new WordArray(words, latin1StrLength);
  }
};
var Utf8 = {
  stringify(wordArray) {
    try {
      return decodeURIComponent(escape(Latin1.stringify(wordArray)));
    } catch (e) {
      throw new Error("Malformed UTF-8 data");
    }
  },
  parse(utf8Str) {
    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
  }
};
var BufferedBlockAlgorithm = class extends Base {
  constructor() {
    super();
    this._minBufferSize = 0;
  }
  reset() {
    this._data = new WordArray();
    this._nDataBytes = 0;
  }
  _append(data) {
    let m_data = data;
    if (typeof m_data === "string") {
      m_data = Utf8.parse(m_data);
    }
    this._data.concat(m_data);
    this._nDataBytes += m_data.sigBytes;
  }
  _process(doFlush) {
    let processedWords;
    const { _data: data, blockSize } = this;
    const dataWords = data.words;
    const dataSigBytes = data.sigBytes;
    const blockSizeBytes = blockSize * 4;
    let nBlocksReady = dataSigBytes / blockSizeBytes;
    if (doFlush) {
      nBlocksReady = Math.ceil(nBlocksReady);
    } else {
      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
    }
    const nWordsReady = nBlocksReady * blockSize;
    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);
    if (nWordsReady) {
      for (let offset = 0; offset < nWordsReady; offset += blockSize) {
        this._doProcessBlock(dataWords, offset);
      }
      processedWords = dataWords.splice(0, nWordsReady);
      data.sigBytes -= nBytesReady;
    }
    return new WordArray(processedWords, nBytesReady);
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._data = this._data.clone();
    return clone2;
  }
};
var Hasher = class extends BufferedBlockAlgorithm {
  constructor(cfg) {
    super();
    this.blockSize = 512 / 32;
    this.cfg = Object.assign(new Base(), cfg);
    this.reset();
  }
  static _createHelper(SubHasher) {
    return (message, cfg) => new SubHasher(cfg).finalize(message);
  }
  static _createHmacHelper(SubHasher) {
    return (message, key) => new HMAC(SubHasher, key).finalize(message);
  }
  reset() {
    super.reset.call(this);
    this._doReset();
  }
  update(messageUpdate) {
    this._append(messageUpdate);
    this._process();
    return this;
  }
  finalize(messageUpdate) {
    if (messageUpdate) {
      this._append(messageUpdate);
    }
    const hash2 = this._doFinalize();
    return hash2;
  }
};
var HMAC = class extends Base {
  constructor(SubHasher, key) {
    super();
    const hasher = new SubHasher();
    this._hasher = hasher;
    let _key = key;
    if (typeof _key === "string") {
      _key = Utf8.parse(_key);
    }
    const hasherBlockSize = hasher.blockSize;
    const hasherBlockSizeBytes = hasherBlockSize * 4;
    if (_key.sigBytes > hasherBlockSizeBytes) {
      _key = hasher.finalize(key);
    }
    _key.clamp();
    const oKey = _key.clone();
    this._oKey = oKey;
    const iKey = _key.clone();
    this._iKey = iKey;
    const oKeyWords = oKey.words;
    const iKeyWords = iKey.words;
    for (let i2 = 0; i2 < hasherBlockSize; i2 += 1) {
      oKeyWords[i2] ^= 1549556828;
      iKeyWords[i2] ^= 909522486;
    }
    oKey.sigBytes = hasherBlockSizeBytes;
    iKey.sigBytes = hasherBlockSizeBytes;
    this.reset();
  }
  reset() {
    const hasher = this._hasher;
    hasher.reset();
    hasher.update(this._iKey);
  }
  update(messageUpdate) {
    this._hasher.update(messageUpdate);
    return this;
  }
  finalize(messageUpdate) {
    const hasher = this._hasher;
    const innerHash = hasher.finalize(messageUpdate);
    hasher.reset();
    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
    return hmac;
  }
};

// node_modules/crypto-es/lib/x64-core.js
var X32WordArray = WordArray;
var X64Word = class extends Base {
  constructor(high, low) {
    super();
    this.high = high;
    this.low = low;
  }
};
var X64WordArray = class extends Base {
  constructor(words = [], sigBytes = words.length * 8) {
    super();
    this.words = words;
    this.sigBytes = sigBytes;
  }
  toX32() {
    const x64Words = this.words;
    const x64WordsLength = x64Words.length;
    const x32Words = [];
    for (let i2 = 0; i2 < x64WordsLength; i2 += 1) {
      const x64Word = x64Words[i2];
      x32Words.push(x64Word.high);
      x32Words.push(x64Word.low);
    }
    return X32WordArray.create(x32Words, this.sigBytes);
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2.words = this.words.slice(0);
    const { words } = clone2;
    const wordsLength = words.length;
    for (let i2 = 0; i2 < wordsLength; i2 += 1) {
      words[i2] = words[i2].clone();
    }
    return clone2;
  }
};

// node_modules/crypto-es/lib/enc-base64.js
var parseLoop = (base64Str, base64StrLength, reverseMap) => {
  const words = [];
  let nBytes = 0;
  for (let i2 = 0; i2 < base64StrLength; i2 += 1) {
    if (i2 % 4) {
      const bits1 = reverseMap[base64Str.charCodeAt(i2 - 1)] << i2 % 4 * 2;
      const bits2 = reverseMap[base64Str.charCodeAt(i2)] >>> 6 - i2 % 4 * 2;
      const bitsCombined = bits1 | bits2;
      words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
      nBytes += 1;
    }
  }
  return WordArray.create(words, nBytes);
};
var Base64 = {
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const map = this._map;
    wordArray.clamp();
    const base64Chars = [];
    for (let i2 = 0; i2 < sigBytes; i2 += 3) {
      const byte1 = words[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255;
      const byte2 = words[i2 + 1 >>> 2] >>> 24 - (i2 + 1) % 4 * 8 & 255;
      const byte3 = words[i2 + 2 >>> 2] >>> 24 - (i2 + 2) % 4 * 8 & 255;
      const triplet = byte1 << 16 | byte2 << 8 | byte3;
      for (let j2 = 0; j2 < 4 && i2 + j2 * 0.75 < sigBytes; j2 += 1) {
        base64Chars.push(map.charAt(triplet >>> 6 * (3 - j2) & 63));
      }
    }
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      while (base64Chars.length % 4) {
        base64Chars.push(paddingChar);
      }
    }
    return base64Chars.join("");
  },
  parse(base64Str) {
    let base64StrLength = base64Str.length;
    const map = this._map;
    let reverseMap = this._reverseMap;
    if (!reverseMap) {
      this._reverseMap = [];
      reverseMap = this._reverseMap;
      for (let j2 = 0; j2 < map.length; j2 += 1) {
        reverseMap[map.charCodeAt(j2)] = j2;
      }
    }
    const paddingChar = map.charAt(64);
    if (paddingChar) {
      const paddingIndex = base64Str.indexOf(paddingChar);
      if (paddingIndex !== -1) {
        base64StrLength = paddingIndex;
      }
    }
    return parseLoop(base64Str, base64StrLength, reverseMap);
  },
  _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
};

// node_modules/crypto-es/lib/md5.js
var T = [];
for (let i2 = 0; i2 < 64; i2 += 1) {
  T[i2] = Math.abs(Math.sin(i2 + 1)) * 4294967296 | 0;
}
var FF = (a2, b2, c2, d3, x3, s2, t) => {
  const n2 = a2 + (b2 & c2 | ~b2 & d3) + x3 + t;
  return (n2 << s2 | n2 >>> 32 - s2) + b2;
};
var GG = (a2, b2, c2, d3, x3, s2, t) => {
  const n2 = a2 + (b2 & d3 | c2 & ~d3) + x3 + t;
  return (n2 << s2 | n2 >>> 32 - s2) + b2;
};
var HH = (a2, b2, c2, d3, x3, s2, t) => {
  const n2 = a2 + (b2 ^ c2 ^ d3) + x3 + t;
  return (n2 << s2 | n2 >>> 32 - s2) + b2;
};
var II = (a2, b2, c2, d3, x3, s2, t) => {
  const n2 = a2 + (c2 ^ (b2 | ~d3)) + x3 + t;
  return (n2 << s2 | n2 >>> 32 - s2) + b2;
};
var MD5Algo = class extends Hasher {
  _doReset() {
    this._hash = new WordArray([
      1732584193,
      4023233417,
      2562383102,
      271733878
    ]);
  }
  _doProcessBlock(M2, offset) {
    const _M = M2;
    for (let i2 = 0; i2 < 16; i2 += 1) {
      const offset_i = offset + i2;
      const M_offset_i = M2[offset_i];
      _M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
    }
    const H3 = this._hash.words;
    const M_offset_0 = _M[offset + 0];
    const M_offset_1 = _M[offset + 1];
    const M_offset_2 = _M[offset + 2];
    const M_offset_3 = _M[offset + 3];
    const M_offset_4 = _M[offset + 4];
    const M_offset_5 = _M[offset + 5];
    const M_offset_6 = _M[offset + 6];
    const M_offset_7 = _M[offset + 7];
    const M_offset_8 = _M[offset + 8];
    const M_offset_9 = _M[offset + 9];
    const M_offset_10 = _M[offset + 10];
    const M_offset_11 = _M[offset + 11];
    const M_offset_12 = _M[offset + 12];
    const M_offset_13 = _M[offset + 13];
    const M_offset_14 = _M[offset + 14];
    const M_offset_15 = _M[offset + 15];
    let a2 = H3[0];
    let b2 = H3[1];
    let c2 = H3[2];
    let d3 = H3[3];
    a2 = FF(a2, b2, c2, d3, M_offset_0, 7, T[0]);
    d3 = FF(d3, a2, b2, c2, M_offset_1, 12, T[1]);
    c2 = FF(c2, d3, a2, b2, M_offset_2, 17, T[2]);
    b2 = FF(b2, c2, d3, a2, M_offset_3, 22, T[3]);
    a2 = FF(a2, b2, c2, d3, M_offset_4, 7, T[4]);
    d3 = FF(d3, a2, b2, c2, M_offset_5, 12, T[5]);
    c2 = FF(c2, d3, a2, b2, M_offset_6, 17, T[6]);
    b2 = FF(b2, c2, d3, a2, M_offset_7, 22, T[7]);
    a2 = FF(a2, b2, c2, d3, M_offset_8, 7, T[8]);
    d3 = FF(d3, a2, b2, c2, M_offset_9, 12, T[9]);
    c2 = FF(c2, d3, a2, b2, M_offset_10, 17, T[10]);
    b2 = FF(b2, c2, d3, a2, M_offset_11, 22, T[11]);
    a2 = FF(a2, b2, c2, d3, M_offset_12, 7, T[12]);
    d3 = FF(d3, a2, b2, c2, M_offset_13, 12, T[13]);
    c2 = FF(c2, d3, a2, b2, M_offset_14, 17, T[14]);
    b2 = FF(b2, c2, d3, a2, M_offset_15, 22, T[15]);
    a2 = GG(a2, b2, c2, d3, M_offset_1, 5, T[16]);
    d3 = GG(d3, a2, b2, c2, M_offset_6, 9, T[17]);
    c2 = GG(c2, d3, a2, b2, M_offset_11, 14, T[18]);
    b2 = GG(b2, c2, d3, a2, M_offset_0, 20, T[19]);
    a2 = GG(a2, b2, c2, d3, M_offset_5, 5, T[20]);
    d3 = GG(d3, a2, b2, c2, M_offset_10, 9, T[21]);
    c2 = GG(c2, d3, a2, b2, M_offset_15, 14, T[22]);
    b2 = GG(b2, c2, d3, a2, M_offset_4, 20, T[23]);
    a2 = GG(a2, b2, c2, d3, M_offset_9, 5, T[24]);
    d3 = GG(d3, a2, b2, c2, M_offset_14, 9, T[25]);
    c2 = GG(c2, d3, a2, b2, M_offset_3, 14, T[26]);
    b2 = GG(b2, c2, d3, a2, M_offset_8, 20, T[27]);
    a2 = GG(a2, b2, c2, d3, M_offset_13, 5, T[28]);
    d3 = GG(d3, a2, b2, c2, M_offset_2, 9, T[29]);
    c2 = GG(c2, d3, a2, b2, M_offset_7, 14, T[30]);
    b2 = GG(b2, c2, d3, a2, M_offset_12, 20, T[31]);
    a2 = HH(a2, b2, c2, d3, M_offset_5, 4, T[32]);
    d3 = HH(d3, a2, b2, c2, M_offset_8, 11, T[33]);
    c2 = HH(c2, d3, a2, b2, M_offset_11, 16, T[34]);
    b2 = HH(b2, c2, d3, a2, M_offset_14, 23, T[35]);
    a2 = HH(a2, b2, c2, d3, M_offset_1, 4, T[36]);
    d3 = HH(d3, a2, b2, c2, M_offset_4, 11, T[37]);
    c2 = HH(c2, d3, a2, b2, M_offset_7, 16, T[38]);
    b2 = HH(b2, c2, d3, a2, M_offset_10, 23, T[39]);
    a2 = HH(a2, b2, c2, d3, M_offset_13, 4, T[40]);
    d3 = HH(d3, a2, b2, c2, M_offset_0, 11, T[41]);
    c2 = HH(c2, d3, a2, b2, M_offset_3, 16, T[42]);
    b2 = HH(b2, c2, d3, a2, M_offset_6, 23, T[43]);
    a2 = HH(a2, b2, c2, d3, M_offset_9, 4, T[44]);
    d3 = HH(d3, a2, b2, c2, M_offset_12, 11, T[45]);
    c2 = HH(c2, d3, a2, b2, M_offset_15, 16, T[46]);
    b2 = HH(b2, c2, d3, a2, M_offset_2, 23, T[47]);
    a2 = II(a2, b2, c2, d3, M_offset_0, 6, T[48]);
    d3 = II(d3, a2, b2, c2, M_offset_7, 10, T[49]);
    c2 = II(c2, d3, a2, b2, M_offset_14, 15, T[50]);
    b2 = II(b2, c2, d3, a2, M_offset_5, 21, T[51]);
    a2 = II(a2, b2, c2, d3, M_offset_12, 6, T[52]);
    d3 = II(d3, a2, b2, c2, M_offset_3, 10, T[53]);
    c2 = II(c2, d3, a2, b2, M_offset_10, 15, T[54]);
    b2 = II(b2, c2, d3, a2, M_offset_1, 21, T[55]);
    a2 = II(a2, b2, c2, d3, M_offset_8, 6, T[56]);
    d3 = II(d3, a2, b2, c2, M_offset_15, 10, T[57]);
    c2 = II(c2, d3, a2, b2, M_offset_6, 15, T[58]);
    b2 = II(b2, c2, d3, a2, M_offset_13, 21, T[59]);
    a2 = II(a2, b2, c2, d3, M_offset_4, 6, T[60]);
    d3 = II(d3, a2, b2, c2, M_offset_11, 10, T[61]);
    c2 = II(c2, d3, a2, b2, M_offset_2, 15, T[62]);
    b2 = II(b2, c2, d3, a2, M_offset_9, 21, T[63]);
    H3[0] = H3[0] + a2 | 0;
    H3[1] = H3[1] + b2 | 0;
    H3[2] = H3[2] + c2 | 0;
    H3[3] = H3[3] + d3 | 0;
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    const nBitsTotalH = Math.floor(nBitsTotal / 4294967296);
    const nBitsTotalL = nBitsTotal;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
    data.sigBytes = (dataWords.length + 1) * 4;
    this._process();
    const hash2 = this._hash;
    const H3 = hash2.words;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      const H_i = H3[i2];
      H3[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
    }
    return hash2;
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._hash = this._hash.clone();
    return clone2;
  }
};
var MD5 = Hasher._createHelper(MD5Algo);
var HmacMD5 = Hasher._createHmacHelper(MD5Algo);

// node_modules/crypto-es/lib/evpkdf.js
var EvpKDFAlgo = class extends Base {
  constructor(cfg) {
    super();
    this.cfg = Object.assign(new Base(), {
      keySize: 128 / 32,
      hasher: MD5Algo,
      iterations: 1
    }, cfg);
  }
  compute(password, salt) {
    let block;
    const { cfg } = this;
    const hasher = cfg.hasher.create();
    const derivedKey = WordArray.create();
    const derivedKeyWords = derivedKey.words;
    const { keySize, iterations } = cfg;
    while (derivedKeyWords.length < keySize) {
      if (block) {
        hasher.update(block);
      }
      block = hasher.update(password).finalize(salt);
      hasher.reset();
      for (let i2 = 1; i2 < iterations; i2 += 1) {
        block = hasher.finalize(block);
        hasher.reset();
      }
      derivedKey.concat(block);
    }
    derivedKey.sigBytes = keySize * 4;
    return derivedKey;
  }
};
var EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);

// node_modules/crypto-es/lib/cipher-core.js
var Cipher = class extends BufferedBlockAlgorithm {
  constructor(xformMode, key, cfg) {
    super();
    this.cfg = Object.assign(new Base(), cfg);
    this._xformMode = xformMode;
    this._key = key;
    this.reset();
  }
  static createEncryptor(key, cfg) {
    return this.create(this._ENC_XFORM_MODE, key, cfg);
  }
  static createDecryptor(key, cfg) {
    return this.create(this._DEC_XFORM_MODE, key, cfg);
  }
  static _createHelper(SubCipher) {
    const selectCipherStrategy = (key) => {
      if (typeof key === "string") {
        return PasswordBasedCipher;
      }
      return SerializableCipher;
    };
    return {
      encrypt(message, key, cfg) {
        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);
      },
      decrypt(ciphertext, key, cfg) {
        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);
      }
    };
  }
  reset() {
    super.reset.call(this);
    this._doReset();
  }
  process(dataUpdate) {
    this._append(dataUpdate);
    return this._process();
  }
  finalize(dataUpdate) {
    if (dataUpdate) {
      this._append(dataUpdate);
    }
    const finalProcessedData = this._doFinalize();
    return finalProcessedData;
  }
};
Cipher._ENC_XFORM_MODE = 1;
Cipher._DEC_XFORM_MODE = 2;
Cipher.keySize = 128 / 32;
Cipher.ivSize = 128 / 32;
var StreamCipher = class extends Cipher {
  constructor(...args) {
    super(...args);
    this.blockSize = 1;
  }
  _doFinalize() {
    const finalProcessedBlocks = this._process(true);
    return finalProcessedBlocks;
  }
};
var BlockCipherMode = class extends Base {
  constructor(cipher, iv) {
    super();
    this._cipher = cipher;
    this._iv = iv;
  }
  static createEncryptor(cipher, iv) {
    return this.Encryptor.create(cipher, iv);
  }
  static createDecryptor(cipher, iv) {
    return this.Decryptor.create(cipher, iv);
  }
};
function xorBlock(words, offset, blockSize) {
  const _words = words;
  let block;
  const iv = this._iv;
  if (iv) {
    block = iv;
    this._iv = void 0;
  } else {
    block = this._prevBlock;
  }
  for (let i2 = 0; i2 < blockSize; i2 += 1) {
    _words[offset + i2] ^= block[i2];
  }
}
var CBC = class extends BlockCipherMode {
};
CBC.Encryptor = class extends CBC {
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    xorBlock.call(this, words, offset, blockSize);
    cipher.encryptBlock(words, offset);
    this._prevBlock = words.slice(offset, offset + blockSize);
  }
};
CBC.Decryptor = class extends CBC {
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const thisBlock = words.slice(offset, offset + blockSize);
    cipher.decryptBlock(words, offset);
    xorBlock.call(this, words, offset, blockSize);
    this._prevBlock = thisBlock;
  }
};
var Pkcs7 = {
  pad(data, blockSize) {
    const blockSizeBytes = blockSize * 4;
    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
    const paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
    const paddingWords = [];
    for (let i2 = 0; i2 < nPaddingBytes; i2 += 4) {
      paddingWords.push(paddingWord);
    }
    const padding = WordArray.create(paddingWords, nPaddingBytes);
    data.concat(padding);
  },
  unpad(data) {
    const _data = data;
    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 255;
    _data.sigBytes -= nPaddingBytes;
  }
};
var BlockCipher = class extends Cipher {
  constructor(xformMode, key, cfg) {
    super(xformMode, key, Object.assign({
      mode: CBC,
      padding: Pkcs7
    }, cfg));
    this.blockSize = 128 / 32;
  }
  reset() {
    let modeCreator;
    super.reset.call(this);
    const { cfg } = this;
    const { iv, mode } = cfg;
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      modeCreator = mode.createEncryptor;
    } else {
      modeCreator = mode.createDecryptor;
      this._minBufferSize = 1;
    }
    this._mode = modeCreator.call(mode, this, iv && iv.words);
    this._mode.__creator = modeCreator;
  }
  _doProcessBlock(words, offset) {
    this._mode.processBlock(words, offset);
  }
  _doFinalize() {
    let finalProcessedBlocks;
    const { padding } = this.cfg;
    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {
      padding.pad(this._data, this.blockSize);
      finalProcessedBlocks = this._process(true);
    } else {
      finalProcessedBlocks = this._process(true);
      padding.unpad(finalProcessedBlocks);
    }
    return finalProcessedBlocks;
  }
};
var CipherParams = class extends Base {
  constructor(cipherParams) {
    super();
    this.mixIn(cipherParams);
  }
  toString(formatter2) {
    return (formatter2 || this.formatter).stringify(this);
  }
};
var OpenSSLFormatter = {
  stringify(cipherParams) {
    let wordArray;
    const { ciphertext, salt } = cipherParams;
    if (salt) {
      wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
    } else {
      wordArray = ciphertext;
    }
    return wordArray.toString(Base64);
  },
  parse(openSSLStr) {
    let salt;
    const ciphertext = Base64.parse(openSSLStr);
    const ciphertextWords = ciphertext.words;
    if (ciphertextWords[0] === 1398893684 && ciphertextWords[1] === 1701076831) {
      salt = WordArray.create(ciphertextWords.slice(2, 4));
      ciphertextWords.splice(0, 4);
      ciphertext.sigBytes -= 16;
    }
    return CipherParams.create({ ciphertext, salt });
  }
};
var SerializableCipher = class extends Base {
  static encrypt(cipher, message, key, cfg) {
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    const encryptor = cipher.createEncryptor(key, _cfg);
    const ciphertext = encryptor.finalize(message);
    const cipherCfg = encryptor.cfg;
    return CipherParams.create({
      ciphertext,
      key,
      iv: cipherCfg.iv,
      algorithm: cipher,
      mode: cipherCfg.mode,
      padding: cipherCfg.padding,
      blockSize: encryptor.blockSize,
      formatter: _cfg.format
    });
  }
  static decrypt(cipher, ciphertext, key, cfg) {
    let _ciphertext = ciphertext;
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    _ciphertext = this._parse(_ciphertext, _cfg.format);
    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);
    return plaintext;
  }
  static _parse(ciphertext, format) {
    if (typeof ciphertext === "string") {
      return format.parse(ciphertext, this);
    }
    return ciphertext;
  }
};
SerializableCipher.cfg = Object.assign(new Base(), { format: OpenSSLFormatter });
var OpenSSLKdf = {
  execute(password, keySize, ivSize, salt) {
    let _salt = salt;
    if (!_salt) {
      _salt = WordArray.random(64 / 8);
    }
    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);
    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
    key.sigBytes = keySize * 4;
    return CipherParams.create({ key, iv, salt: _salt });
  }
};
var PasswordBasedCipher = class extends SerializableCipher {
  static encrypt(cipher, message, password, cfg) {
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);
    _cfg.iv = derivedParams.iv;
    const ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, _cfg);
    ciphertext.mixIn(derivedParams);
    return ciphertext;
  }
  static decrypt(cipher, ciphertext, password, cfg) {
    let _ciphertext = ciphertext;
    const _cfg = Object.assign(new Base(), this.cfg, cfg);
    _ciphertext = this._parse(_ciphertext, _cfg.format);
    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);
    _cfg.iv = derivedParams.iv;
    const plaintext = SerializableCipher.decrypt.call(this, cipher, _ciphertext, derivedParams.key, _cfg);
    return plaintext;
  }
};
PasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });

// node_modules/crypto-es/lib/enc-utf16.js
var swapEndian = (word) => word << 8 & 4278255360 | word >>> 8 & 16711935;
var Utf16BE = {
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const utf16Chars = [];
    for (let i2 = 0; i2 < sigBytes; i2 += 2) {
      const codePoint = words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535;
      utf16Chars.push(String.fromCharCode(codePoint));
    }
    return utf16Chars.join("");
  },
  parse(utf16Str) {
    const utf16StrLength = utf16Str.length;
    const words = [];
    for (let i2 = 0; i2 < utf16StrLength; i2 += 1) {
      words[i2 >>> 1] |= utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16;
    }
    return WordArray.create(words, utf16StrLength * 2);
  }
};
var Utf16 = Utf16BE;
var Utf16LE = {
  stringify(wordArray) {
    const { words, sigBytes } = wordArray;
    const utf16Chars = [];
    for (let i2 = 0; i2 < sigBytes; i2 += 2) {
      const codePoint = swapEndian(words[i2 >>> 2] >>> 16 - i2 % 4 * 8 & 65535);
      utf16Chars.push(String.fromCharCode(codePoint));
    }
    return utf16Chars.join("");
  },
  parse(utf16Str) {
    const utf16StrLength = utf16Str.length;
    const words = [];
    for (let i2 = 0; i2 < utf16StrLength; i2 += 1) {
      words[i2 >>> 1] |= swapEndian(utf16Str.charCodeAt(i2) << 16 - i2 % 2 * 16);
    }
    return WordArray.create(words, utf16StrLength * 2);
  }
};

// node_modules/crypto-es/lib/sha1.js
var W = [];
var SHA1Algo = class extends Hasher {
  _doReset() {
    this._hash = new WordArray([
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ]);
  }
  _doProcessBlock(M2, offset) {
    const H3 = this._hash.words;
    let a2 = H3[0];
    let b2 = H3[1];
    let c2 = H3[2];
    let d3 = H3[3];
    let e = H3[4];
    for (let i2 = 0; i2 < 80; i2 += 1) {
      if (i2 < 16) {
        W[i2] = M2[offset + i2] | 0;
      } else {
        const n2 = W[i2 - 3] ^ W[i2 - 8] ^ W[i2 - 14] ^ W[i2 - 16];
        W[i2] = n2 << 1 | n2 >>> 31;
      }
      let t = (a2 << 5 | a2 >>> 27) + e + W[i2];
      if (i2 < 20) {
        t += (b2 & c2 | ~b2 & d3) + 1518500249;
      } else if (i2 < 40) {
        t += (b2 ^ c2 ^ d3) + 1859775393;
      } else if (i2 < 60) {
        t += (b2 & c2 | b2 & d3 | c2 & d3) - 1894007588;
      } else {
        t += (b2 ^ c2 ^ d3) - 899497514;
      }
      e = d3;
      d3 = c2;
      c2 = b2 << 30 | b2 >>> 2;
      b2 = a2;
      a2 = t;
    }
    H3[0] = H3[0] + a2 | 0;
    H3[1] = H3[1] + b2 | 0;
    H3[2] = H3[2] + c2 | 0;
    H3[3] = H3[3] + d3 | 0;
    H3[4] = H3[4] + e | 0;
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    data.sigBytes = dataWords.length * 4;
    this._process();
    return this._hash;
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._hash = this._hash.clone();
    return clone2;
  }
};
var SHA1 = Hasher._createHelper(SHA1Algo);
var HmacSHA1 = Hasher._createHmacHelper(SHA1Algo);

// node_modules/crypto-es/lib/sha256.js
var H = [];
var K = [];
var isPrime = (n2) => {
  const sqrtN = Math.sqrt(n2);
  for (let factor = 2; factor <= sqrtN; factor += 1) {
    if (!(n2 % factor)) {
      return false;
    }
  }
  return true;
};
var getFractionalBits = (n2) => (n2 - (n2 | 0)) * 4294967296 | 0;
var n = 2;
var nPrime = 0;
while (nPrime < 64) {
  if (isPrime(n)) {
    if (nPrime < 8) {
      H[nPrime] = getFractionalBits(n ** (1 / 2));
    }
    K[nPrime] = getFractionalBits(n ** (1 / 3));
    nPrime += 1;
  }
  n += 1;
}
var W2 = [];
var SHA256Algo = class extends Hasher {
  _doReset() {
    this._hash = new WordArray(H.slice(0));
  }
  _doProcessBlock(M2, offset) {
    const _H = this._hash.words;
    let a2 = _H[0];
    let b2 = _H[1];
    let c2 = _H[2];
    let d3 = _H[3];
    let e = _H[4];
    let f6 = _H[5];
    let g2 = _H[6];
    let h2 = _H[7];
    for (let i2 = 0; i2 < 64; i2 += 1) {
      if (i2 < 16) {
        W2[i2] = M2[offset + i2] | 0;
      } else {
        const gamma0x = W2[i2 - 15];
        const gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
        const gamma1x = W2[i2 - 2];
        const gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
        W2[i2] = gamma0 + W2[i2 - 7] + gamma1 + W2[i2 - 16];
      }
      const ch = e & f6 ^ ~e & g2;
      const maj = a2 & b2 ^ a2 & c2 ^ b2 & c2;
      const sigma0 = (a2 << 30 | a2 >>> 2) ^ (a2 << 19 | a2 >>> 13) ^ (a2 << 10 | a2 >>> 22);
      const sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
      const t1 = h2 + sigma1 + ch + K[i2] + W2[i2];
      const t2 = sigma0 + maj;
      h2 = g2;
      g2 = f6;
      f6 = e;
      e = d3 + t1 | 0;
      d3 = c2;
      c2 = b2;
      b2 = a2;
      a2 = t1 + t2 | 0;
    }
    _H[0] = _H[0] + a2 | 0;
    _H[1] = _H[1] + b2 | 0;
    _H[2] = _H[2] + c2 | 0;
    _H[3] = _H[3] + d3 | 0;
    _H[4] = _H[4] + e | 0;
    _H[5] = _H[5] + f6 | 0;
    _H[6] = _H[6] + g2 | 0;
    _H[7] = _H[7] + h2 | 0;
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
    data.sigBytes = dataWords.length * 4;
    this._process();
    return this._hash;
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._hash = this._hash.clone();
    return clone2;
  }
};
var SHA256 = Hasher._createHelper(SHA256Algo);
var HmacSHA256 = Hasher._createHmacHelper(SHA256Algo);

// node_modules/crypto-es/lib/sha224.js
var SHA224Algo = class extends SHA256Algo {
  _doReset() {
    this._hash = new WordArray([
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ]);
  }
  _doFinalize() {
    const hash2 = super._doFinalize.call(this);
    hash2.sigBytes -= 4;
    return hash2;
  }
};
var SHA224 = SHA256Algo._createHelper(SHA224Algo);
var HmacSHA224 = SHA256Algo._createHmacHelper(SHA224Algo);

// node_modules/crypto-es/lib/sha512.js
var K2 = [
  new X64Word(1116352408, 3609767458),
  new X64Word(1899447441, 602891725),
  new X64Word(3049323471, 3964484399),
  new X64Word(3921009573, 2173295548),
  new X64Word(961987163, 4081628472),
  new X64Word(1508970993, 3053834265),
  new X64Word(2453635748, 2937671579),
  new X64Word(2870763221, 3664609560),
  new X64Word(3624381080, 2734883394),
  new X64Word(310598401, 1164996542),
  new X64Word(607225278, 1323610764),
  new X64Word(1426881987, 3590304994),
  new X64Word(1925078388, 4068182383),
  new X64Word(2162078206, 991336113),
  new X64Word(2614888103, 633803317),
  new X64Word(3248222580, 3479774868),
  new X64Word(3835390401, 2666613458),
  new X64Word(4022224774, 944711139),
  new X64Word(264347078, 2341262773),
  new X64Word(604807628, 2007800933),
  new X64Word(770255983, 1495990901),
  new X64Word(1249150122, 1856431235),
  new X64Word(1555081692, 3175218132),
  new X64Word(1996064986, 2198950837),
  new X64Word(2554220882, 3999719339),
  new X64Word(2821834349, 766784016),
  new X64Word(2952996808, 2566594879),
  new X64Word(3210313671, 3203337956),
  new X64Word(3336571891, 1034457026),
  new X64Word(3584528711, 2466948901),
  new X64Word(113926993, 3758326383),
  new X64Word(338241895, 168717936),
  new X64Word(666307205, 1188179964),
  new X64Word(773529912, 1546045734),
  new X64Word(1294757372, 1522805485),
  new X64Word(1396182291, 2643833823),
  new X64Word(1695183700, 2343527390),
  new X64Word(1986661051, 1014477480),
  new X64Word(2177026350, 1206759142),
  new X64Word(2456956037, 344077627),
  new X64Word(2730485921, 1290863460),
  new X64Word(2820302411, 3158454273),
  new X64Word(3259730800, 3505952657),
  new X64Word(3345764771, 106217008),
  new X64Word(3516065817, 3606008344),
  new X64Word(3600352804, 1432725776),
  new X64Word(4094571909, 1467031594),
  new X64Word(275423344, 851169720),
  new X64Word(430227734, 3100823752),
  new X64Word(506948616, 1363258195),
  new X64Word(659060556, 3750685593),
  new X64Word(883997877, 3785050280),
  new X64Word(958139571, 3318307427),
  new X64Word(1322822218, 3812723403),
  new X64Word(1537002063, 2003034995),
  new X64Word(1747873779, 3602036899),
  new X64Word(1955562222, 1575990012),
  new X64Word(2024104815, 1125592928),
  new X64Word(2227730452, 2716904306),
  new X64Word(2361852424, 442776044),
  new X64Word(2428436474, 593698344),
  new X64Word(2756734187, 3733110249),
  new X64Word(3204031479, 2999351573),
  new X64Word(3329325298, 3815920427),
  new X64Word(3391569614, 3928383900),
  new X64Word(3515267271, 566280711),
  new X64Word(3940187606, 3454069534),
  new X64Word(4118630271, 4000239992),
  new X64Word(116418474, 1914138554),
  new X64Word(174292421, 2731055270),
  new X64Word(289380356, 3203993006),
  new X64Word(460393269, 320620315),
  new X64Word(685471733, 587496836),
  new X64Word(852142971, 1086792851),
  new X64Word(1017036298, 365543100),
  new X64Word(1126000580, 2618297676),
  new X64Word(1288033470, 3409855158),
  new X64Word(1501505948, 4234509866),
  new X64Word(1607167915, 987167468),
  new X64Word(1816402316, 1246189591)
];
var W3 = [];
for (let i2 = 0; i2 < 80; i2 += 1) {
  W3[i2] = new X64Word();
}
var SHA512Algo = class extends Hasher {
  constructor() {
    super();
    this.blockSize = 1024 / 32;
  }
  _doReset() {
    this._hash = new X64WordArray([
      new X64Word(1779033703, 4089235720),
      new X64Word(3144134277, 2227873595),
      new X64Word(1013904242, 4271175723),
      new X64Word(2773480762, 1595750129),
      new X64Word(1359893119, 2917565137),
      new X64Word(2600822924, 725511199),
      new X64Word(528734635, 4215389547),
      new X64Word(1541459225, 327033209)
    ]);
  }
  _doProcessBlock(M2, offset) {
    const H3 = this._hash.words;
    const H0 = H3[0];
    const H1 = H3[1];
    const H22 = H3[2];
    const H32 = H3[3];
    const H4 = H3[4];
    const H5 = H3[5];
    const H6 = H3[6];
    const H7 = H3[7];
    const H0h = H0.high;
    let H0l = H0.low;
    const H1h = H1.high;
    let H1l = H1.low;
    const H2h = H22.high;
    let H2l = H22.low;
    const H3h = H32.high;
    let H3l = H32.low;
    const H4h = H4.high;
    let H4l = H4.low;
    const H5h = H5.high;
    let H5l = H5.low;
    const H6h = H6.high;
    let H6l = H6.low;
    const H7h = H7.high;
    let H7l = H7.low;
    let ah = H0h;
    let al = H0l;
    let bh = H1h;
    let bl = H1l;
    let ch = H2h;
    let cl = H2l;
    let dh = H3h;
    let dl = H3l;
    let eh = H4h;
    let el = H4l;
    let fh = H5h;
    let fl = H5l;
    let gh = H6h;
    let gl = H6l;
    let hh = H7h;
    let hl = H7l;
    for (let i2 = 0; i2 < 80; i2 += 1) {
      let Wil;
      let Wih;
      const Wi = W3[i2];
      if (i2 < 16) {
        Wi.high = M2[offset + i2 * 2] | 0;
        Wih = Wi.high;
        Wi.low = M2[offset + i2 * 2 + 1] | 0;
        Wil = Wi.low;
      } else {
        const gamma0x = W3[i2 - 15];
        const gamma0xh = gamma0x.high;
        const gamma0xl = gamma0x.low;
        const gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
        const gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
        const gamma1x = W3[i2 - 2];
        const gamma1xh = gamma1x.high;
        const gamma1xl = gamma1x.low;
        const gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
        const gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
        const Wi7 = W3[i2 - 7];
        const Wi7h = Wi7.high;
        const Wi7l = Wi7.low;
        const Wi16 = W3[i2 - 16];
        const Wi16h = Wi16.high;
        const Wi16l = Wi16.low;
        Wil = gamma0l + Wi7l;
        Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
        Wil += gamma1l;
        Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
        Wil += Wi16l;
        Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
        Wi.high = Wih;
        Wi.low = Wil;
      }
      const chh = eh & fh ^ ~eh & gh;
      const chl = el & fl ^ ~el & gl;
      const majh = ah & bh ^ ah & ch ^ bh & ch;
      const majl = al & bl ^ al & cl ^ bl & cl;
      const sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
      const sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
      const sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
      const sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
      const Ki = K2[i2];
      const Kih = Ki.high;
      const Kil = Ki.low;
      let t1l = hl + sigma1l;
      let t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
      t1l += chl;
      t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
      t1l += Kil;
      t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
      t1l += Wil;
      t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
      const t2l = sigma0l + majl;
      const t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      el = dl + t1l | 0;
      eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      al = t1l + t2l | 0;
      ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
    }
    H0.low = H0l + al;
    H0l = H0.low;
    H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
    H1.low = H1l + bl;
    H1l = H1.low;
    H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
    H22.low = H2l + cl;
    H2l = H22.low;
    H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
    H32.low = H3l + dl;
    H3l = H32.low;
    H32.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
    H4.low = H4l + el;
    H4l = H4.low;
    H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
    H5.low = H5l + fl;
    H5l = H5.low;
    H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
    H6.low = H6l + gl;
    H6l = H6.low;
    H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
    H7.low = H7l + hl;
    H7l = H7.low;
    H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
    dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
    data.sigBytes = dataWords.length * 4;
    this._process();
    const hash2 = this._hash.toX32();
    return hash2;
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._hash = this._hash.clone();
    return clone2;
  }
};
var SHA512 = Hasher._createHelper(SHA512Algo);
var HmacSHA512 = Hasher._createHmacHelper(SHA512Algo);

// node_modules/crypto-es/lib/sha384.js
var SHA384Algo = class extends SHA512Algo {
  _doReset() {
    this._hash = new X64WordArray([
      new X64Word(3418070365, 3238371032),
      new X64Word(1654270250, 914150663),
      new X64Word(2438529370, 812702999),
      new X64Word(355462360, 4144912697),
      new X64Word(1731405415, 4290775857),
      new X64Word(2394180231, 1750603025),
      new X64Word(3675008525, 1694076839),
      new X64Word(1203062813, 3204075428)
    ]);
  }
  _doFinalize() {
    const hash2 = super._doFinalize.call(this);
    hash2.sigBytes -= 16;
    return hash2;
  }
};
var SHA384 = SHA512Algo._createHelper(SHA384Algo);
var HmacSHA384 = SHA512Algo._createHmacHelper(SHA384Algo);

// node_modules/crypto-es/lib/sha3.js
var RHO_OFFSETS = [];
var PI_INDEXES = [];
var ROUND_CONSTANTS = [];
var _x = 1;
var _y = 0;
for (let t = 0; t < 24; t += 1) {
  RHO_OFFSETS[_x + 5 * _y] = (t + 1) * (t + 2) / 2 % 64;
  const newX = _y % 5;
  const newY = (2 * _x + 3 * _y) % 5;
  _x = newX;
  _y = newY;
}
for (let x3 = 0; x3 < 5; x3 += 1) {
  for (let y2 = 0; y2 < 5; y2 += 1) {
    PI_INDEXES[x3 + 5 * y2] = y2 + (2 * x3 + 3 * y2) % 5 * 5;
  }
}
var LFSR = 1;
for (let i2 = 0; i2 < 24; i2 += 1) {
  let roundConstantMsw = 0;
  let roundConstantLsw = 0;
  for (let j2 = 0; j2 < 7; j2 += 1) {
    if (LFSR & 1) {
      const bitPosition = (1 << j2) - 1;
      if (bitPosition < 32) {
        roundConstantLsw ^= 1 << bitPosition;
      } else {
        roundConstantMsw ^= 1 << bitPosition - 32;
      }
    }
    if (LFSR & 128) {
      LFSR = LFSR << 1 ^ 113;
    } else {
      LFSR <<= 1;
    }
  }
  ROUND_CONSTANTS[i2] = X64Word.create(roundConstantMsw, roundConstantLsw);
}
var T2 = [];
for (let i2 = 0; i2 < 25; i2 += 1) {
  T2[i2] = X64Word.create();
}
var SHA3Algo = class extends Hasher {
  constructor(cfg) {
    super(Object.assign({ outputLength: 512 }, cfg));
  }
  _doReset() {
    this._state = [];
    const state = this._state;
    for (let i2 = 0; i2 < 25; i2 += 1) {
      state[i2] = new X64Word();
    }
    this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
  }
  _doProcessBlock(M2, offset) {
    const state = this._state;
    const nBlockSizeLanes = this.blockSize / 2;
    for (let i2 = 0; i2 < nBlockSizeLanes; i2 += 1) {
      let M2i = M2[offset + 2 * i2];
      let M2i1 = M2[offset + 2 * i2 + 1];
      M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
      M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
      const lane = state[i2];
      lane.high ^= M2i1;
      lane.low ^= M2i;
    }
    for (let round = 0; round < 24; round += 1) {
      for (let x3 = 0; x3 < 5; x3 += 1) {
        let tMsw = 0;
        let tLsw = 0;
        for (let y2 = 0; y2 < 5; y2 += 1) {
          const lane2 = state[x3 + 5 * y2];
          tMsw ^= lane2.high;
          tLsw ^= lane2.low;
        }
        const Tx = T2[x3];
        Tx.high = tMsw;
        Tx.low = tLsw;
      }
      for (let x3 = 0; x3 < 5; x3 += 1) {
        const Tx4 = T2[(x3 + 4) % 5];
        const Tx1 = T2[(x3 + 1) % 5];
        const Tx1Msw = Tx1.high;
        const Tx1Lsw = Tx1.low;
        const tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
        const tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
        for (let y2 = 0; y2 < 5; y2 += 1) {
          const lane2 = state[x3 + 5 * y2];
          lane2.high ^= tMsw;
          lane2.low ^= tLsw;
        }
      }
      for (let laneIndex = 1; laneIndex < 25; laneIndex += 1) {
        let tMsw;
        let tLsw;
        const lane2 = state[laneIndex];
        const laneMsw = lane2.high;
        const laneLsw = lane2.low;
        const rhoOffset = RHO_OFFSETS[laneIndex];
        if (rhoOffset < 32) {
          tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
          tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
        } else {
          tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
          tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
        }
        const TPiLane = T2[PI_INDEXES[laneIndex]];
        TPiLane.high = tMsw;
        TPiLane.low = tLsw;
      }
      const T0 = T2[0];
      const state0 = state[0];
      T0.high = state0.high;
      T0.low = state0.low;
      for (let x3 = 0; x3 < 5; x3 += 1) {
        for (let y2 = 0; y2 < 5; y2 += 1) {
          const laneIndex = x3 + 5 * y2;
          const lane2 = state[laneIndex];
          const TLane = T2[laneIndex];
          const Tx1Lane = T2[(x3 + 1) % 5 + 5 * y2];
          const Tx2Lane = T2[(x3 + 2) % 5 + 5 * y2];
          lane2.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
          lane2.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
        }
      }
      const lane = state[0];
      const roundConstant = ROUND_CONSTANTS[round];
      lane.high ^= roundConstant.high;
      lane.low ^= roundConstant.low;
    }
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsLeft = data.sigBytes * 8;
    const blockSizeBits = this.blockSize * 32;
    dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
    dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
    data.sigBytes = dataWords.length * 4;
    this._process();
    const state = this._state;
    const outputLengthBytes = this.cfg.outputLength / 8;
    const outputLengthLanes = outputLengthBytes / 8;
    const hashWords = [];
    for (let i2 = 0; i2 < outputLengthLanes; i2 += 1) {
      const lane = state[i2];
      let laneMsw = lane.high;
      let laneLsw = lane.low;
      laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
      laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
      hashWords.push(laneLsw);
      hashWords.push(laneMsw);
    }
    return new WordArray(hashWords, outputLengthBytes);
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._state = this._state.slice(0);
    const state = clone2._state;
    for (let i2 = 0; i2 < 25; i2 += 1) {
      state[i2] = state[i2].clone();
    }
    return clone2;
  }
};
var SHA3 = Hasher._createHelper(SHA3Algo);
var HmacSHA3 = Hasher._createHmacHelper(SHA3Algo);

// node_modules/crypto-es/lib/ripemd160.js
var _zl = WordArray.create([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
]);
var _zr = WordArray.create([
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
]);
var _sl = WordArray.create([
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
]);
var _sr = WordArray.create([
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
]);
var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var f1 = (x3, y2, z2) => x3 ^ y2 ^ z2;
var f2 = (x3, y2, z2) => x3 & y2 | ~x3 & z2;
var f3 = (x3, y2, z2) => (x3 | ~y2) ^ z2;
var f4 = (x3, y2, z2) => x3 & z2 | y2 & ~z2;
var f5 = (x3, y2, z2) => x3 ^ (y2 | ~z2);
var rotl = (x3, n2) => x3 << n2 | x3 >>> 32 - n2;
var RIPEMD160Algo = class extends Hasher {
  _doReset() {
    this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
  }
  _doProcessBlock(M2, offset) {
    const _M = M2;
    for (let i2 = 0; i2 < 16; i2 += 1) {
      const offset_i = offset + i2;
      const M_offset_i = _M[offset_i];
      _M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
    }
    const H3 = this._hash.words;
    const hl = _hl.words;
    const hr = _hr.words;
    const zl = _zl.words;
    const zr = _zr.words;
    const sl = _sl.words;
    const sr = _sr.words;
    let al = H3[0];
    let bl = H3[1];
    let cl = H3[2];
    let dl = H3[3];
    let el = H3[4];
    let ar = H3[0];
    let br = H3[1];
    let cr = H3[2];
    let dr = H3[3];
    let er = H3[4];
    let t;
    for (let i2 = 0; i2 < 80; i2 += 1) {
      t = al + _M[offset + zl[i2]] | 0;
      if (i2 < 16) {
        t += f1(bl, cl, dl) + hl[0];
      } else if (i2 < 32) {
        t += f2(bl, cl, dl) + hl[1];
      } else if (i2 < 48) {
        t += f3(bl, cl, dl) + hl[2];
      } else if (i2 < 64) {
        t += f4(bl, cl, dl) + hl[3];
      } else {
        t += f5(bl, cl, dl) + hl[4];
      }
      t |= 0;
      t = rotl(t, sl[i2]);
      t = t + el | 0;
      al = el;
      el = dl;
      dl = rotl(cl, 10);
      cl = bl;
      bl = t;
      t = ar + _M[offset + zr[i2]] | 0;
      if (i2 < 16) {
        t += f5(br, cr, dr) + hr[0];
      } else if (i2 < 32) {
        t += f4(br, cr, dr) + hr[1];
      } else if (i2 < 48) {
        t += f3(br, cr, dr) + hr[2];
      } else if (i2 < 64) {
        t += f2(br, cr, dr) + hr[3];
      } else {
        t += f1(br, cr, dr) + hr[4];
      }
      t |= 0;
      t = rotl(t, sr[i2]);
      t = t + er | 0;
      ar = er;
      er = dr;
      dr = rotl(cr, 10);
      cr = br;
      br = t;
    }
    t = H3[1] + cl + dr | 0;
    H3[1] = H3[2] + dl + er | 0;
    H3[2] = H3[3] + el + ar | 0;
    H3[3] = H3[4] + al + br | 0;
    H3[4] = H3[0] + bl + cr | 0;
    H3[0] = t;
  }
  _doFinalize() {
    const data = this._data;
    const dataWords = data.words;
    const nBitsTotal = this._nDataBytes * 8;
    const nBitsLeft = data.sigBytes * 8;
    dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
    dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
    data.sigBytes = (dataWords.length + 1) * 4;
    this._process();
    const hash2 = this._hash;
    const H3 = hash2.words;
    for (let i2 = 0; i2 < 5; i2 += 1) {
      const H_i = H3[i2];
      H3[i2] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
    }
    return hash2;
  }
  clone() {
    const clone2 = super.clone.call(this);
    clone2._hash = this._hash.clone();
    return clone2;
  }
};
var RIPEMD160 = Hasher._createHelper(RIPEMD160Algo);
var HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160Algo);

// node_modules/crypto-es/lib/pbkdf2.js
var PBKDF2Algo = class extends Base {
  constructor(cfg) {
    super();
    this.cfg = Object.assign(new Base(), {
      keySize: 128 / 32,
      hasher: SHA1Algo,
      iterations: 1
    }, cfg);
  }
  compute(password, salt) {
    const { cfg } = this;
    const hmac = HMAC.create(cfg.hasher, password);
    const derivedKey = WordArray.create();
    const blockIndex = WordArray.create([1]);
    const derivedKeyWords = derivedKey.words;
    const blockIndexWords = blockIndex.words;
    const { keySize, iterations } = cfg;
    while (derivedKeyWords.length < keySize) {
      const block = hmac.update(salt).finalize(blockIndex);
      hmac.reset();
      const blockWords = block.words;
      const blockWordsLength = blockWords.length;
      let intermediate = block;
      for (let i2 = 1; i2 < iterations; i2 += 1) {
        intermediate = hmac.finalize(intermediate);
        hmac.reset();
        const intermediateWords = intermediate.words;
        for (let j2 = 0; j2 < blockWordsLength; j2 += 1) {
          blockWords[j2] ^= intermediateWords[j2];
        }
      }
      derivedKey.concat(block);
      blockIndexWords[0] += 1;
    }
    derivedKey.sigBytes = keySize * 4;
    return derivedKey;
  }
};
var PBKDF2 = (password, salt, cfg) => PBKDF2Algo.create(cfg).compute(password, salt);

// node_modules/crypto-es/lib/aes.js
var _SBOX = [];
var INV_SBOX = [];
var _SUB_MIX_0 = [];
var _SUB_MIX_1 = [];
var _SUB_MIX_2 = [];
var _SUB_MIX_3 = [];
var INV_SUB_MIX_0 = [];
var INV_SUB_MIX_1 = [];
var INV_SUB_MIX_2 = [];
var INV_SUB_MIX_3 = [];
var d = [];
for (let i2 = 0; i2 < 256; i2 += 1) {
  if (i2 < 128) {
    d[i2] = i2 << 1;
  } else {
    d[i2] = i2 << 1 ^ 283;
  }
}
var x = 0;
var xi = 0;
for (let i2 = 0; i2 < 256; i2 += 1) {
  let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
  sx = sx >>> 8 ^ sx & 255 ^ 99;
  _SBOX[x] = sx;
  INV_SBOX[sx] = x;
  const x22 = d[x];
  const x4 = d[x22];
  const x8 = d[x4];
  let t = d[sx] * 257 ^ sx * 16843008;
  _SUB_MIX_0[x] = t << 24 | t >>> 8;
  _SUB_MIX_1[x] = t << 16 | t >>> 16;
  _SUB_MIX_2[x] = t << 8 | t >>> 24;
  _SUB_MIX_3[x] = t;
  t = x8 * 16843009 ^ x4 * 65537 ^ x22 * 257 ^ x * 16843008;
  INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
  INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
  INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
  INV_SUB_MIX_3[sx] = t;
  if (!x) {
    xi = 1;
    x = xi;
  } else {
    x = x22 ^ d[d[d[x8 ^ x22]]];
    xi ^= d[d[xi]];
  }
}
var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
var AESAlgo = class extends BlockCipher {
  _doReset() {
    let t;
    if (this._nRounds && this._keyPriorReset === this._key) {
      return;
    }
    this._keyPriorReset = this._key;
    const key = this._keyPriorReset;
    const keyWords = key.words;
    const keySize = key.sigBytes / 4;
    this._nRounds = keySize + 6;
    const nRounds = this._nRounds;
    const ksRows = (nRounds + 1) * 4;
    this._keySchedule = [];
    const keySchedule = this._keySchedule;
    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {
      if (ksRow < keySize) {
        keySchedule[ksRow] = keyWords[ksRow];
      } else {
        t = keySchedule[ksRow - 1];
        if (!(ksRow % keySize)) {
          t = t << 8 | t >>> 24;
          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 255] << 16 | _SBOX[t >>> 8 & 255] << 8 | _SBOX[t & 255];
          t ^= RCON[ksRow / keySize | 0] << 24;
        } else if (keySize > 6 && ksRow % keySize === 4) {
          t = _SBOX[t >>> 24] << 24 | _SBOX[t >>> 16 & 255] << 16 | _SBOX[t >>> 8 & 255] << 8 | _SBOX[t & 255];
        }
        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
      }
    }
    this._invKeySchedule = [];
    const invKeySchedule = this._invKeySchedule;
    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {
      const ksRow = ksRows - invKsRow;
      if (invKsRow % 4) {
        t = keySchedule[ksRow];
      } else {
        t = keySchedule[ksRow - 4];
      }
      if (invKsRow < 4 || ksRow <= 4) {
        invKeySchedule[invKsRow] = t;
      } else {
        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]] ^ INV_SUB_MIX_1[_SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[_SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[_SBOX[t & 255]];
      }
    }
  }
  encryptBlock(M2, offset) {
    this._doCryptBlock(M2, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX);
  }
  decryptBlock(M2, offset) {
    const _M = M2;
    let t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;
    this._doCryptBlock(_M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
    t = _M[offset + 1];
    _M[offset + 1] = _M[offset + 3];
    _M[offset + 3] = t;
  }
  _doCryptBlock(M2, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
    const _M = M2;
    const nRounds = this._nRounds;
    let s0 = _M[offset] ^ keySchedule[0];
    let s1 = _M[offset + 1] ^ keySchedule[1];
    let s2 = _M[offset + 2] ^ keySchedule[2];
    let s3 = _M[offset + 3] ^ keySchedule[3];
    let ksRow = 4;
    for (let round = 1; round < nRounds; round += 1) {
      const t02 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 255] ^ SUB_MIX_2[s2 >>> 8 & 255] ^ SUB_MIX_3[s3 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t12 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 255] ^ SUB_MIX_2[s3 >>> 8 & 255] ^ SUB_MIX_3[s0 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t22 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 255] ^ SUB_MIX_2[s0 >>> 8 & 255] ^ SUB_MIX_3[s1 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      const t32 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 255] ^ SUB_MIX_2[s1 >>> 8 & 255] ^ SUB_MIX_3[s2 & 255] ^ keySchedule[ksRow];
      ksRow += 1;
      s0 = t02;
      s1 = t12;
      s2 = t22;
      s3 = t32;
    }
    const t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 255] << 16 | SBOX[s2 >>> 8 & 255] << 8 | SBOX[s3 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 255] << 16 | SBOX[s3 >>> 8 & 255] << 8 | SBOX[s0 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 255] << 16 | SBOX[s0 >>> 8 & 255] << 8 | SBOX[s1 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    const t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 255] << 16 | SBOX[s1 >>> 8 & 255] << 8 | SBOX[s2 & 255]) ^ keySchedule[ksRow];
    ksRow += 1;
    _M[offset] = t0;
    _M[offset + 1] = t1;
    _M[offset + 2] = t2;
    _M[offset + 3] = t3;
  }
};
AESAlgo.keySize = 256 / 32;
var AES = BlockCipher._createHelper(AESAlgo);

// node_modules/crypto-es/lib/tripledes.js
var PC1 = [
  57,
  49,
  41,
  33,
  25,
  17,
  9,
  1,
  58,
  50,
  42,
  34,
  26,
  18,
  10,
  2,
  59,
  51,
  43,
  35,
  27,
  19,
  11,
  3,
  60,
  52,
  44,
  36,
  63,
  55,
  47,
  39,
  31,
  23,
  15,
  7,
  62,
  54,
  46,
  38,
  30,
  22,
  14,
  6,
  61,
  53,
  45,
  37,
  29,
  21,
  13,
  5,
  28,
  20,
  12,
  4
];
var PC2 = [
  14,
  17,
  11,
  24,
  1,
  5,
  3,
  28,
  15,
  6,
  21,
  10,
  23,
  19,
  12,
  4,
  26,
  8,
  16,
  7,
  27,
  20,
  13,
  2,
  41,
  52,
  31,
  37,
  47,
  55,
  30,
  40,
  51,
  45,
  33,
  48,
  44,
  49,
  39,
  56,
  34,
  53,
  46,
  42,
  50,
  36,
  29,
  32
];
var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
var SBOX_P = [
  {
    0: 8421888,
    268435456: 32768,
    536870912: 8421378,
    805306368: 2,
    1073741824: 512,
    1342177280: 8421890,
    1610612736: 8389122,
    1879048192: 8388608,
    2147483648: 514,
    2415919104: 8389120,
    2684354560: 33280,
    2952790016: 8421376,
    3221225472: 32770,
    3489660928: 8388610,
    3758096384: 0,
    4026531840: 33282,
    134217728: 0,
    402653184: 8421890,
    671088640: 33282,
    939524096: 32768,
    1207959552: 8421888,
    1476395008: 512,
    1744830464: 8421378,
    2013265920: 2,
    2281701376: 8389120,
    2550136832: 33280,
    2818572288: 8421376,
    3087007744: 8389122,
    3355443200: 8388610,
    3623878656: 32770,
    3892314112: 514,
    4160749568: 8388608,
    1: 32768,
    268435457: 2,
    536870913: 8421888,
    805306369: 8388608,
    1073741825: 8421378,
    1342177281: 33280,
    1610612737: 512,
    1879048193: 8389122,
    2147483649: 8421890,
    2415919105: 8421376,
    2684354561: 8388610,
    2952790017: 33282,
    3221225473: 514,
    3489660929: 8389120,
    3758096385: 32770,
    4026531841: 0,
    134217729: 8421890,
    402653185: 8421376,
    671088641: 8388608,
    939524097: 512,
    1207959553: 32768,
    1476395009: 8388610,
    1744830465: 2,
    2013265921: 33282,
    2281701377: 32770,
    2550136833: 8389122,
    2818572289: 514,
    3087007745: 8421888,
    3355443201: 8389120,
    3623878657: 0,
    3892314113: 33280,
    4160749569: 8421378
  },
  {
    0: 1074282512,
    16777216: 16384,
    33554432: 524288,
    50331648: 1074266128,
    67108864: 1073741840,
    83886080: 1074282496,
    100663296: 1073758208,
    117440512: 16,
    134217728: 540672,
    150994944: 1073758224,
    167772160: 1073741824,
    184549376: 540688,
    201326592: 524304,
    218103808: 0,
    234881024: 16400,
    251658240: 1074266112,
    8388608: 1073758208,
    25165824: 540688,
    41943040: 16,
    58720256: 1073758224,
    75497472: 1074282512,
    92274688: 1073741824,
    109051904: 524288,
    125829120: 1074266128,
    142606336: 524304,
    159383552: 0,
    176160768: 16384,
    192937984: 1074266112,
    209715200: 1073741840,
    226492416: 540672,
    243269632: 1074282496,
    260046848: 16400,
    268435456: 0,
    285212672: 1074266128,
    301989888: 1073758224,
    318767104: 1074282496,
    335544320: 1074266112,
    352321536: 16,
    369098752: 540688,
    385875968: 16384,
    402653184: 16400,
    419430400: 524288,
    436207616: 524304,
    452984832: 1073741840,
    469762048: 540672,
    486539264: 1073758208,
    503316480: 1073741824,
    520093696: 1074282512,
    276824064: 540688,
    293601280: 524288,
    310378496: 1074266112,
    327155712: 16384,
    343932928: 1073758208,
    360710144: 1074282512,
    377487360: 16,
    394264576: 1073741824,
    411041792: 1074282496,
    427819008: 1073741840,
    444596224: 1073758224,
    461373440: 524304,
    478150656: 0,
    494927872: 16400,
    511705088: 1074266128,
    528482304: 540672
  },
  {
    0: 260,
    1048576: 0,
    2097152: 67109120,
    3145728: 65796,
    4194304: 65540,
    5242880: 67108868,
    6291456: 67174660,
    7340032: 67174400,
    8388608: 67108864,
    9437184: 67174656,
    10485760: 65792,
    11534336: 67174404,
    12582912: 67109124,
    13631488: 65536,
    14680064: 4,
    15728640: 256,
    524288: 67174656,
    1572864: 67174404,
    2621440: 0,
    3670016: 67109120,
    4718592: 67108868,
    5767168: 65536,
    6815744: 65540,
    7864320: 260,
    8912896: 4,
    9961472: 256,
    11010048: 67174400,
    12058624: 65796,
    13107200: 65792,
    14155776: 67109124,
    15204352: 67174660,
    16252928: 67108864,
    16777216: 67174656,
    17825792: 65540,
    18874368: 65536,
    19922944: 67109120,
    20971520: 256,
    22020096: 67174660,
    23068672: 67108868,
    24117248: 0,
    25165824: 67109124,
    26214400: 67108864,
    27262976: 4,
    28311552: 65792,
    29360128: 67174400,
    30408704: 260,
    31457280: 65796,
    32505856: 67174404,
    17301504: 67108864,
    18350080: 260,
    19398656: 67174656,
    20447232: 0,
    21495808: 65540,
    22544384: 67109120,
    23592960: 256,
    24641536: 67174404,
    25690112: 65536,
    26738688: 67174660,
    27787264: 65796,
    28835840: 67108868,
    29884416: 67109124,
    30932992: 67174400,
    31981568: 4,
    33030144: 65792
  },
  {
    0: 2151682048,
    65536: 2147487808,
    131072: 4198464,
    196608: 2151677952,
    262144: 0,
    327680: 4198400,
    393216: 2147483712,
    458752: 4194368,
    524288: 2147483648,
    589824: 4194304,
    655360: 64,
    720896: 2147487744,
    786432: 2151678016,
    851968: 4160,
    917504: 4096,
    983040: 2151682112,
    32768: 2147487808,
    98304: 64,
    163840: 2151678016,
    229376: 2147487744,
    294912: 4198400,
    360448: 2151682112,
    425984: 0,
    491520: 2151677952,
    557056: 4096,
    622592: 2151682048,
    688128: 4194304,
    753664: 4160,
    819200: 2147483648,
    884736: 4194368,
    950272: 4198464,
    1015808: 2147483712,
    1048576: 4194368,
    1114112: 4198400,
    1179648: 2147483712,
    1245184: 0,
    1310720: 4160,
    1376256: 2151678016,
    1441792: 2151682048,
    1507328: 2147487808,
    1572864: 2151682112,
    1638400: 2147483648,
    1703936: 2151677952,
    1769472: 4198464,
    1835008: 2147487744,
    1900544: 4194304,
    1966080: 64,
    2031616: 4096,
    1081344: 2151677952,
    1146880: 2151682112,
    1212416: 0,
    1277952: 4198400,
    1343488: 4194368,
    1409024: 2147483648,
    1474560: 2147487808,
    1540096: 64,
    1605632: 2147483712,
    1671168: 4096,
    1736704: 2147487744,
    1802240: 2151678016,
    1867776: 4160,
    1933312: 2151682048,
    1998848: 4194304,
    2064384: 4198464
  },
  {
    0: 128,
    4096: 17039360,
    8192: 262144,
    12288: 536870912,
    16384: 537133184,
    20480: 16777344,
    24576: 553648256,
    28672: 262272,
    32768: 16777216,
    36864: 537133056,
    40960: 536871040,
    45056: 553910400,
    49152: 553910272,
    53248: 0,
    57344: 17039488,
    61440: 553648128,
    2048: 17039488,
    6144: 553648256,
    10240: 128,
    14336: 17039360,
    18432: 262144,
    22528: 537133184,
    26624: 553910272,
    30720: 536870912,
    34816: 537133056,
    38912: 0,
    43008: 553910400,
    47104: 16777344,
    51200: 536871040,
    55296: 553648128,
    59392: 16777216,
    63488: 262272,
    65536: 262144,
    69632: 128,
    73728: 536870912,
    77824: 553648256,
    81920: 16777344,
    86016: 553910272,
    90112: 537133184,
    94208: 16777216,
    98304: 553910400,
    102400: 553648128,
    106496: 17039360,
    110592: 537133056,
    114688: 262272,
    118784: 536871040,
    122880: 0,
    126976: 17039488,
    67584: 553648256,
    71680: 16777216,
    75776: 17039360,
    79872: 537133184,
    83968: 536870912,
    88064: 17039488,
    92160: 128,
    96256: 553910272,
    100352: 262272,
    104448: 553910400,
    108544: 0,
    112640: 553648128,
    116736: 16777344,
    120832: 262144,
    124928: 537133056,
    129024: 536871040
  },
  {
    0: 268435464,
    256: 8192,
    512: 270532608,
    768: 270540808,
    1024: 268443648,
    1280: 2097152,
    1536: 2097160,
    1792: 268435456,
    2048: 0,
    2304: 268443656,
    2560: 2105344,
    2816: 8,
    3072: 270532616,
    3328: 2105352,
    3584: 8200,
    3840: 270540800,
    128: 270532608,
    384: 270540808,
    640: 8,
    896: 2097152,
    1152: 2105352,
    1408: 268435464,
    1664: 268443648,
    1920: 8200,
    2176: 2097160,
    2432: 8192,
    2688: 268443656,
    2944: 270532616,
    3200: 0,
    3456: 270540800,
    3712: 2105344,
    3968: 268435456,
    4096: 268443648,
    4352: 270532616,
    4608: 270540808,
    4864: 8200,
    5120: 2097152,
    5376: 268435456,
    5632: 268435464,
    5888: 2105344,
    6144: 2105352,
    6400: 0,
    6656: 8,
    6912: 270532608,
    7168: 8192,
    7424: 268443656,
    7680: 270540800,
    7936: 2097160,
    4224: 8,
    4480: 2105344,
    4736: 2097152,
    4992: 268435464,
    5248: 268443648,
    5504: 8200,
    5760: 270540808,
    6016: 270532608,
    6272: 270540800,
    6528: 270532616,
    6784: 8192,
    7040: 2105352,
    7296: 2097160,
    7552: 0,
    7808: 268435456,
    8064: 268443656
  },
  {
    0: 1048576,
    16: 33555457,
    32: 1024,
    48: 1049601,
    64: 34604033,
    80: 0,
    96: 1,
    112: 34603009,
    128: 33555456,
    144: 1048577,
    160: 33554433,
    176: 34604032,
    192: 34603008,
    208: 1025,
    224: 1049600,
    240: 33554432,
    8: 34603009,
    24: 0,
    40: 33555457,
    56: 34604032,
    72: 1048576,
    88: 33554433,
    104: 33554432,
    120: 1025,
    136: 1049601,
    152: 33555456,
    168: 34603008,
    184: 1048577,
    200: 1024,
    216: 34604033,
    232: 1,
    248: 1049600,
    256: 33554432,
    272: 1048576,
    288: 33555457,
    304: 34603009,
    320: 1048577,
    336: 33555456,
    352: 34604032,
    368: 1049601,
    384: 1025,
    400: 34604033,
    416: 1049600,
    432: 1,
    448: 0,
    464: 34603008,
    480: 33554433,
    496: 1024,
    264: 1049600,
    280: 33555457,
    296: 34603009,
    312: 1,
    328: 33554432,
    344: 1048576,
    360: 1025,
    376: 34604032,
    392: 33554433,
    408: 34603008,
    424: 0,
    440: 34604033,
    456: 1049601,
    472: 1024,
    488: 33555456,
    504: 1048577
  },
  {
    0: 134219808,
    1: 131072,
    2: 134217728,
    3: 32,
    4: 131104,
    5: 134350880,
    6: 134350848,
    7: 2048,
    8: 134348800,
    9: 134219776,
    10: 133120,
    11: 134348832,
    12: 2080,
    13: 0,
    14: 134217760,
    15: 133152,
    2147483648: 2048,
    2147483649: 134350880,
    2147483650: 134219808,
    2147483651: 134217728,
    2147483652: 134348800,
    2147483653: 133120,
    2147483654: 133152,
    2147483655: 32,
    2147483656: 134217760,
    2147483657: 2080,
    2147483658: 131104,
    2147483659: 134350848,
    2147483660: 0,
    2147483661: 134348832,
    2147483662: 134219776,
    2147483663: 131072,
    16: 133152,
    17: 134350848,
    18: 32,
    19: 2048,
    20: 134219776,
    21: 134217760,
    22: 134348832,
    23: 131072,
    24: 0,
    25: 131104,
    26: 134348800,
    27: 134219808,
    28: 134350880,
    29: 133120,
    30: 2080,
    31: 134217728,
    2147483664: 131072,
    2147483665: 2048,
    2147483666: 134348832,
    2147483667: 133152,
    2147483668: 32,
    2147483669: 134348800,
    2147483670: 134217728,
    2147483671: 134219808,
    2147483672: 134350880,
    2147483673: 134217760,
    2147483674: 134219776,
    2147483675: 0,
    2147483676: 133120,
    2147483677: 2080,
    2147483678: 131104,
    2147483679: 134350848
  }
];
var SBOX_MASK = [
  4160749569,
  528482304,
  33030144,
  2064384,
  129024,
  8064,
  504,
  2147483679
];
function exchangeLR(offset, mask) {
  const t = (this._lBlock >>> offset ^ this._rBlock) & mask;
  this._rBlock ^= t;
  this._lBlock ^= t << offset;
}
function exchangeRL(offset, mask) {
  const t = (this._rBlock >>> offset ^ this._lBlock) & mask;
  this._lBlock ^= t;
  this._rBlock ^= t << offset;
}
var DESAlgo = class extends BlockCipher {
  _doReset() {
    const key = this._key;
    const keyWords = key.words;
    const keyBits = [];
    for (let i2 = 0; i2 < 56; i2 += 1) {
      const keyBitPos = PC1[i2] - 1;
      keyBits[i2] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
    }
    this._subKeys = [];
    const subKeys = this._subKeys;
    for (let nSubKey = 0; nSubKey < 16; nSubKey += 1) {
      subKeys[nSubKey] = [];
      const subKey = subKeys[nSubKey];
      const bitShift = BIT_SHIFTS[nSubKey];
      for (let i2 = 0; i2 < 24; i2 += 1) {
        subKey[i2 / 6 | 0] |= keyBits[(PC2[i2] - 1 + bitShift) % 28] << 31 - i2 % 6;
        subKey[4 + (i2 / 6 | 0)] |= keyBits[28 + (PC2[i2 + 24] - 1 + bitShift) % 28] << 31 - i2 % 6;
      }
      subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
      for (let i2 = 1; i2 < 7; i2 += 1) {
        subKey[i2] >>>= (i2 - 1) * 4 + 3;
      }
      subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
    }
    this._invSubKeys = [];
    const invSubKeys = this._invSubKeys;
    for (let i2 = 0; i2 < 16; i2 += 1) {
      invSubKeys[i2] = subKeys[15 - i2];
    }
  }
  encryptBlock(M2, offset) {
    this._doCryptBlock(M2, offset, this._subKeys);
  }
  decryptBlock(M2, offset) {
    this._doCryptBlock(M2, offset, this._invSubKeys);
  }
  _doCryptBlock(M2, offset, subKeys) {
    const _M = M2;
    this._lBlock = M2[offset];
    this._rBlock = M2[offset + 1];
    exchangeLR.call(this, 4, 252645135);
    exchangeLR.call(this, 16, 65535);
    exchangeRL.call(this, 2, 858993459);
    exchangeRL.call(this, 8, 16711935);
    exchangeLR.call(this, 1, 1431655765);
    for (let round = 0; round < 16; round += 1) {
      const subKey = subKeys[round];
      const lBlock = this._lBlock;
      const rBlock = this._rBlock;
      let f6 = 0;
      for (let i2 = 0; i2 < 8; i2 += 1) {
        f6 |= SBOX_P[i2][((rBlock ^ subKey[i2]) & SBOX_MASK[i2]) >>> 0];
      }
      this._lBlock = rBlock;
      this._rBlock = lBlock ^ f6;
    }
    const t = this._lBlock;
    this._lBlock = this._rBlock;
    this._rBlock = t;
    exchangeLR.call(this, 1, 1431655765);
    exchangeRL.call(this, 8, 16711935);
    exchangeRL.call(this, 2, 858993459);
    exchangeLR.call(this, 16, 65535);
    exchangeLR.call(this, 4, 252645135);
    _M[offset] = this._lBlock;
    _M[offset + 1] = this._rBlock;
  }
};
DESAlgo.keySize = 64 / 32;
DESAlgo.ivSize = 64 / 32;
DESAlgo.blockSize = 64 / 32;
var DES = BlockCipher._createHelper(DESAlgo);
var TripleDESAlgo = class extends BlockCipher {
  _doReset() {
    const key = this._key;
    const keyWords = key.words;
    if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
      throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
    }
    const key1 = keyWords.slice(0, 2);
    const key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
    const key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
    this._des1 = DESAlgo.createEncryptor(WordArray.create(key1));
    this._des2 = DESAlgo.createEncryptor(WordArray.create(key2));
    this._des3 = DESAlgo.createEncryptor(WordArray.create(key3));
  }
  encryptBlock(M2, offset) {
    this._des1.encryptBlock(M2, offset);
    this._des2.decryptBlock(M2, offset);
    this._des3.encryptBlock(M2, offset);
  }
  decryptBlock(M2, offset) {
    this._des3.decryptBlock(M2, offset);
    this._des2.encryptBlock(M2, offset);
    this._des1.decryptBlock(M2, offset);
  }
};
TripleDESAlgo.keySize = 192 / 32;
TripleDESAlgo.ivSize = 64 / 32;
TripleDESAlgo.blockSize = 64 / 32;
var TripleDES = BlockCipher._createHelper(TripleDESAlgo);

// node_modules/crypto-es/lib/rabbit.js
var S = [];
var C_ = [];
var G = [];
function nextState() {
  const X2 = this._X;
  const C2 = this._C;
  for (let i2 = 0; i2 < 8; i2 += 1) {
    C_[i2] = C2[i2];
  }
  C2[0] = C2[0] + 1295307597 + this._b | 0;
  C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
  C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
  C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
  C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
  C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
  C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
  C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
  this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
  for (let i2 = 0; i2 < 8; i2 += 1) {
    const gx = X2[i2] + C2[i2];
    const ga = gx & 65535;
    const gb = gx >>> 16;
    const gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
    const gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
    G[i2] = gh ^ gl;
  }
  X2[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
  X2[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
  X2[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
  X2[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
  X2[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
  X2[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
  X2[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
  X2[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
}
var RabbitAlgo = class extends StreamCipher {
  constructor(...args) {
    super(...args);
    this.blockSize = 128 / 32;
    this.ivSize = 64 / 32;
  }
  _doReset() {
    const K4 = this._key.words;
    const { iv } = this.cfg;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      K4[i2] = (K4[i2] << 8 | K4[i2] >>> 24) & 16711935 | (K4[i2] << 24 | K4[i2] >>> 8) & 4278255360;
    }
    this._X = [
      K4[0],
      K4[3] << 16 | K4[2] >>> 16,
      K4[1],
      K4[0] << 16 | K4[3] >>> 16,
      K4[2],
      K4[1] << 16 | K4[0] >>> 16,
      K4[3],
      K4[2] << 16 | K4[1] >>> 16
    ];
    const X2 = this._X;
    this._C = [
      K4[2] << 16 | K4[2] >>> 16,
      K4[0] & 4294901760 | K4[1] & 65535,
      K4[3] << 16 | K4[3] >>> 16,
      K4[1] & 4294901760 | K4[2] & 65535,
      K4[0] << 16 | K4[0] >>> 16,
      K4[2] & 4294901760 | K4[3] & 65535,
      K4[1] << 16 | K4[1] >>> 16,
      K4[3] & 4294901760 | K4[0] & 65535
    ];
    const C2 = this._C;
    this._b = 0;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      nextState.call(this);
    }
    for (let i2 = 0; i2 < 8; i2 += 1) {
      C2[i2] ^= X2[i2 + 4 & 7];
    }
    if (iv) {
      const IV = iv.words;
      const IV_0 = IV[0];
      const IV_1 = IV[1];
      const i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
      const i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
      const i1 = i0 >>> 16 | i2 & 4294901760;
      const i3 = i2 << 16 | i0 & 65535;
      C2[0] ^= i0;
      C2[1] ^= i1;
      C2[2] ^= i2;
      C2[3] ^= i3;
      C2[4] ^= i0;
      C2[5] ^= i1;
      C2[6] ^= i2;
      C2[7] ^= i3;
      for (let i4 = 0; i4 < 4; i4 += 1) {
        nextState.call(this);
      }
    }
  }
  _doProcessBlock(M2, offset) {
    const _M = M2;
    const X2 = this._X;
    nextState.call(this);
    S[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
    S[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
    S[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
    S[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      S[i2] = (S[i2] << 8 | S[i2] >>> 24) & 16711935 | (S[i2] << 24 | S[i2] >>> 8) & 4278255360;
      _M[offset + i2] ^= S[i2];
    }
  }
};
var Rabbit = StreamCipher._createHelper(RabbitAlgo);

// node_modules/crypto-es/lib/rabbit-legacy.js
var S2 = [];
var C_2 = [];
var G2 = [];
function nextState2() {
  const X2 = this._X;
  const C2 = this._C;
  for (let i2 = 0; i2 < 8; i2 += 1) {
    C_2[i2] = C2[i2];
  }
  C2[0] = C2[0] + 1295307597 + this._b | 0;
  C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_2[0] >>> 0 ? 1 : 0) | 0;
  C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_2[1] >>> 0 ? 1 : 0) | 0;
  C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_2[2] >>> 0 ? 1 : 0) | 0;
  C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_2[3] >>> 0 ? 1 : 0) | 0;
  C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_2[4] >>> 0 ? 1 : 0) | 0;
  C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_2[5] >>> 0 ? 1 : 0) | 0;
  C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_2[6] >>> 0 ? 1 : 0) | 0;
  this._b = C2[7] >>> 0 < C_2[7] >>> 0 ? 1 : 0;
  for (let i2 = 0; i2 < 8; i2 += 1) {
    const gx = X2[i2] + C2[i2];
    const ga = gx & 65535;
    const gb = gx >>> 16;
    const gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
    const gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
    G2[i2] = gh ^ gl;
  }
  X2[0] = G2[0] + (G2[7] << 16 | G2[7] >>> 16) + (G2[6] << 16 | G2[6] >>> 16) | 0;
  X2[1] = G2[1] + (G2[0] << 8 | G2[0] >>> 24) + G2[7] | 0;
  X2[2] = G2[2] + (G2[1] << 16 | G2[1] >>> 16) + (G2[0] << 16 | G2[0] >>> 16) | 0;
  X2[3] = G2[3] + (G2[2] << 8 | G2[2] >>> 24) + G2[1] | 0;
  X2[4] = G2[4] + (G2[3] << 16 | G2[3] >>> 16) + (G2[2] << 16 | G2[2] >>> 16) | 0;
  X2[5] = G2[5] + (G2[4] << 8 | G2[4] >>> 24) + G2[3] | 0;
  X2[6] = G2[6] + (G2[5] << 16 | G2[5] >>> 16) + (G2[4] << 16 | G2[4] >>> 16) | 0;
  X2[7] = G2[7] + (G2[6] << 8 | G2[6] >>> 24) + G2[5] | 0;
}
var RabbitLegacyAlgo = class extends StreamCipher {
  constructor(...args) {
    super(...args);
    this.blockSize = 128 / 32;
    this.ivSize = 64 / 32;
  }
  _doReset() {
    const K4 = this._key.words;
    const { iv } = this.cfg;
    this._X = [
      K4[0],
      K4[3] << 16 | K4[2] >>> 16,
      K4[1],
      K4[0] << 16 | K4[3] >>> 16,
      K4[2],
      K4[1] << 16 | K4[0] >>> 16,
      K4[3],
      K4[2] << 16 | K4[1] >>> 16
    ];
    const X2 = this._X;
    this._C = [
      K4[2] << 16 | K4[2] >>> 16,
      K4[0] & 4294901760 | K4[1] & 65535,
      K4[3] << 16 | K4[3] >>> 16,
      K4[1] & 4294901760 | K4[2] & 65535,
      K4[0] << 16 | K4[0] >>> 16,
      K4[2] & 4294901760 | K4[3] & 65535,
      K4[1] << 16 | K4[1] >>> 16,
      K4[3] & 4294901760 | K4[0] & 65535
    ];
    const C2 = this._C;
    this._b = 0;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      nextState2.call(this);
    }
    for (let i2 = 0; i2 < 8; i2 += 1) {
      C2[i2] ^= X2[i2 + 4 & 7];
    }
    if (iv) {
      const IV = iv.words;
      const IV_0 = IV[0];
      const IV_1 = IV[1];
      const i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
      const i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
      const i1 = i0 >>> 16 | i2 & 4294901760;
      const i3 = i2 << 16 | i0 & 65535;
      C2[0] ^= i0;
      C2[1] ^= i1;
      C2[2] ^= i2;
      C2[3] ^= i3;
      C2[4] ^= i0;
      C2[5] ^= i1;
      C2[6] ^= i2;
      C2[7] ^= i3;
      for (let i4 = 0; i4 < 4; i4 += 1) {
        nextState2.call(this);
      }
    }
  }
  _doProcessBlock(M2, offset) {
    const _M = M2;
    const X2 = this._X;
    nextState2.call(this);
    S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
    S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
    S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
    S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
    for (let i2 = 0; i2 < 4; i2 += 1) {
      S2[i2] = (S2[i2] << 8 | S2[i2] >>> 24) & 16711935 | (S2[i2] << 24 | S2[i2] >>> 8) & 4278255360;
      _M[offset + i2] ^= S2[i2];
    }
  }
};
var RabbitLegacy = StreamCipher._createHelper(RabbitLegacyAlgo);

// node_modules/crypto-es/lib/rc4.js
function generateKeystreamWord() {
  const S4 = this._S;
  let i2 = this._i;
  let j2 = this._j;
  let keystreamWord = 0;
  for (let n2 = 0; n2 < 4; n2 += 1) {
    i2 = (i2 + 1) % 256;
    j2 = (j2 + S4[i2]) % 256;
    const t = S4[i2];
    S4[i2] = S4[j2];
    S4[j2] = t;
    keystreamWord |= S4[(S4[i2] + S4[j2]) % 256] << 24 - n2 * 8;
  }
  this._i = i2;
  this._j = j2;
  return keystreamWord;
}
var RC4Algo = class extends StreamCipher {
  _doReset() {
    const key = this._key;
    const keyWords = key.words;
    const keySigBytes = key.sigBytes;
    this._S = [];
    const S4 = this._S;
    for (let i2 = 0; i2 < 256; i2 += 1) {
      S4[i2] = i2;
    }
    for (let i2 = 0, j2 = 0; i2 < 256; i2 += 1) {
      const keyByteIndex = i2 % keySigBytes;
      const keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
      j2 = (j2 + S4[i2] + keyByte) % 256;
      const t = S4[i2];
      S4[i2] = S4[j2];
      S4[j2] = t;
    }
    this._j = 0;
    this._i = this._j;
  }
  _doProcessBlock(M2, offset) {
    const _M = M2;
    _M[offset] ^= generateKeystreamWord.call(this);
  }
};
RC4Algo.keySize = 256 / 32;
RC4Algo.ivSize = 0;
var RC4 = StreamCipher._createHelper(RC4Algo);
var RC4DropAlgo = class extends RC4Algo {
  constructor(...args) {
    super(...args);
    Object.assign(this.cfg, { drop: 192 });
  }
  _doReset() {
    super._doReset.call(this);
    for (let i2 = this.cfg.drop; i2 > 0; i2 -= 1) {
      generateKeystreamWord.call(this);
    }
  }
};
var RC4Drop = StreamCipher._createHelper(RC4DropAlgo);

// node_modules/crypto-es/lib/mode-cfb.js
function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
  const _words = words;
  let keystream;
  const iv = this._iv;
  if (iv) {
    keystream = iv.slice(0);
    this._iv = void 0;
  } else {
    keystream = this._prevBlock;
  }
  cipher.encryptBlock(keystream, 0);
  for (let i2 = 0; i2 < blockSize; i2 += 1) {
    _words[offset + i2] ^= keystream[i2];
  }
}
var CFB = class extends BlockCipherMode {
};
CFB.Encryptor = class extends CFB {
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
    this._prevBlock = words.slice(offset, offset + blockSize);
  }
};
CFB.Decryptor = class extends CFB {
  processBlock(words, offset) {
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const thisBlock = words.slice(offset, offset + blockSize);
    generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
    this._prevBlock = thisBlock;
  }
};

// node_modules/crypto-es/lib/mode-ctr.js
var CTR = class extends BlockCipherMode {
};
CTR.Encryptor = class extends CTR {
  processBlock(words, offset) {
    const _words = words;
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const iv = this._iv;
    let counter2 = this._counter;
    if (iv) {
      this._counter = iv.slice(0);
      counter2 = this._counter;
      this._iv = void 0;
    }
    const keystream = counter2.slice(0);
    cipher.encryptBlock(keystream, 0);
    counter2[blockSize - 1] = counter2[blockSize - 1] + 1 | 0;
    for (let i2 = 0; i2 < blockSize; i2 += 1) {
      _words[offset + i2] ^= keystream[i2];
    }
  }
};
CTR.Decryptor = CTR.Encryptor;

// node_modules/crypto-es/lib/mode-ctr-gladman.js
var incWord = (word) => {
  let _word = word;
  if ((word >> 24 & 255) === 255) {
    let b1 = word >> 16 & 255;
    let b2 = word >> 8 & 255;
    let b3 = word & 255;
    if (b1 === 255) {
      b1 = 0;
      if (b2 === 255) {
        b2 = 0;
        if (b3 === 255) {
          b3 = 0;
        } else {
          b3 += 1;
        }
      } else {
        b2 += 1;
      }
    } else {
      b1 += 1;
    }
    _word = 0;
    _word += b1 << 16;
    _word += b2 << 8;
    _word += b3;
  } else {
    _word += 1 << 24;
  }
  return _word;
};
var incCounter = (counter2) => {
  const _counter = counter2;
  _counter[0] = incWord(_counter[0]);
  if (_counter[0] === 0) {
    _counter[1] = incWord(_counter[1]);
  }
  return _counter;
};
var CTRGladman = class extends BlockCipherMode {
};
CTRGladman.Encryptor = class extends CTRGladman {
  processBlock(words, offset) {
    const _words = words;
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const iv = this._iv;
    let counter2 = this._counter;
    if (iv) {
      this._counter = iv.slice(0);
      counter2 = this._counter;
      this._iv = void 0;
    }
    incCounter(counter2);
    const keystream = counter2.slice(0);
    cipher.encryptBlock(keystream, 0);
    for (let i2 = 0; i2 < blockSize; i2 += 1) {
      _words[offset + i2] ^= keystream[i2];
    }
  }
};
CTRGladman.Decryptor = CTRGladman.Encryptor;

// node_modules/crypto-es/lib/mode-ecb.js
var ECB = class extends BlockCipherMode {
};
ECB.Encryptor = class extends ECB {
  processBlock(words, offset) {
    this._cipher.encryptBlock(words, offset);
  }
};
ECB.Decryptor = class extends ECB {
  processBlock(words, offset) {
    this._cipher.decryptBlock(words, offset);
  }
};

// node_modules/crypto-es/lib/mode-ofb.js
var OFB = class extends BlockCipherMode {
};
OFB.Encryptor = class extends OFB {
  processBlock(words, offset) {
    const _words = words;
    const cipher = this._cipher;
    const { blockSize } = cipher;
    const iv = this._iv;
    let keystream = this._keystream;
    if (iv) {
      this._keystream = iv.slice(0);
      keystream = this._keystream;
      this._iv = void 0;
    }
    cipher.encryptBlock(keystream, 0);
    for (let i2 = 0; i2 < blockSize; i2 += 1) {
      _words[offset + i2] ^= keystream[i2];
    }
  }
};
OFB.Decryptor = OFB.Encryptor;

// node_modules/crypto-es/lib/pad-ansix923.js
var AnsiX923 = {
  pad(data, blockSize) {
    const _data = data;
    const dataSigBytes = _data.sigBytes;
    const blockSizeBytes = blockSize * 4;
    const nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
    const lastBytePos = dataSigBytes + nPaddingBytes - 1;
    _data.clamp();
    _data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
    _data.sigBytes += nPaddingBytes;
  },
  unpad(data) {
    const _data = data;
    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 255;
    _data.sigBytes -= nPaddingBytes;
  }
};

// node_modules/crypto-es/lib/pad-iso10126.js
var Iso10126 = {
  pad(data, blockSize) {
    const blockSizeBytes = blockSize * 4;
    const nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
    data.concat(WordArray.random(nPaddingBytes - 1)).concat(WordArray.create([nPaddingBytes << 24], 1));
  },
  unpad(data) {
    const _data = data;
    const nPaddingBytes = _data.words[_data.sigBytes - 1 >>> 2] & 255;
    _data.sigBytes -= nPaddingBytes;
  }
};

// node_modules/crypto-es/lib/pad-zeropadding.js
var ZeroPadding = {
  pad(data, blockSize) {
    const _data = data;
    const blockSizeBytes = blockSize * 4;
    _data.clamp();
    _data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
  },
  unpad(data) {
    const _data = data;
    const dataWords = _data.words;
    for (let i2 = _data.sigBytes - 1; i2 >= 0; i2 -= 1) {
      if (dataWords[i2 >>> 2] >>> 24 - i2 % 4 * 8 & 255) {
        _data.sigBytes = i2 + 1;
        break;
      }
    }
  }
};

// node_modules/crypto-es/lib/pad-iso97971.js
var Iso97971 = {
  pad(data, blockSize) {
    data.concat(WordArray.create([2147483648], 1));
    ZeroPadding.pad(data, blockSize);
  },
  unpad(data) {
    const _data = data;
    ZeroPadding.unpad(_data);
    _data.sigBytes -= 1;
  }
};

// node_modules/crypto-es/lib/pad-nopadding.js
var NoPadding = {
  pad() {
  },
  unpad() {
  }
};

// node_modules/crypto-es/lib/format-hex.js
var HexFormatter = {
  stringify(cipherParams) {
    return cipherParams.ciphertext.toString(Hex);
  },
  parse(input) {
    const ciphertext = Hex.parse(input);
    return CipherParams.create({ ciphertext });
  }
};

// node_modules/crypto-es/lib/index.js
var lib_default = {
  lib: {
    Base,
    WordArray,
    BufferedBlockAlgorithm,
    Hasher,
    Cipher,
    StreamCipher,
    BlockCipherMode,
    BlockCipher,
    CipherParams,
    SerializableCipher,
    PasswordBasedCipher
  },
  x64: {
    Word: X64Word,
    WordArray: X64WordArray
  },
  enc: {
    Hex,
    Latin1,
    Utf8,
    Utf16,
    Utf16BE,
    Utf16LE,
    Base64
  },
  algo: {
    HMAC,
    MD5: MD5Algo,
    SHA1: SHA1Algo,
    SHA224: SHA224Algo,
    SHA256: SHA256Algo,
    SHA384: SHA384Algo,
    SHA512: SHA512Algo,
    SHA3: SHA3Algo,
    RIPEMD160: RIPEMD160Algo,
    PBKDF2: PBKDF2Algo,
    EvpKDF: EvpKDFAlgo,
    AES: AESAlgo,
    DES: DESAlgo,
    TripleDES: TripleDESAlgo,
    Rabbit: RabbitAlgo,
    RabbitLegacy: RabbitLegacyAlgo,
    RC4: RC4Algo,
    RC4Drop: RC4DropAlgo
  },
  mode: {
    CBC,
    CFB,
    CTR,
    CTRGladman,
    ECB,
    OFB
  },
  pad: {
    Pkcs7,
    AnsiX923,
    Iso10126,
    Iso97971,
    NoPadding,
    ZeroPadding
  },
  format: {
    OpenSSL: OpenSSLFormatter,
    Hex: HexFormatter
  },
  kdf: {
    OpenSSL: OpenSSLKdf
  },
  MD5,
  HmacMD5,
  SHA1,
  HmacSHA1,
  SHA224,
  HmacSHA224,
  SHA256,
  HmacSHA256,
  SHA384,
  HmacSHA384,
  SHA512,
  HmacSHA512,
  SHA3,
  HmacSHA3,
  RIPEMD160,
  HmacRIPEMD160,
  PBKDF2,
  EvpKDF,
  AES,
  DES,
  TripleDES,
  Rabbit,
  RabbitLegacy,
  RC4,
  RC4Drop
};

// node_modules/bnc-sdk/dist/esm/index.js
var networks = {
  bitcoin: {
    "1": "main",
    "2": "testnet"
  },
  ethereum: {
    "1": "main",
    "3": "ropsten",
    "4": "rinkeby",
    "5": "goerli",
    "42": "kovan",
    "56": "bsc-main",
    "100": "xdai",
    "137": "matic-main"
  }
};
var DEFAULT_RATE_LIMIT_RULES = {
  points: 150,
  duration: 1
};
var QUEUE_LIMIT = 1e4;
function createEmitter() {
  return {
    listeners: {},
    on: function(eventCode, listener) {
      switch (eventCode) {
        case "txSent":
        case "txPool":
        case "txConfirmed":
        case "txSpeedUp":
        case "txCancel":
        case "txFailed":
        case "txDropped":
        case "txRequest":
        case "nsfFail":
        case "txRepeat":
        case "txAwaitingApproval":
        case "txConfirmReminder":
        case "txSendFail":
        case "txError":
        case "txUnderPriced":
        case "txPoolSimulation":
        case "all":
          break;
        default:
          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://docs.blocknative.com/notify-sdk#event-codes`);
      }
      if (typeof listener !== "function") {
        throw new Error("Listener must be a function");
      }
      this.listeners[eventCode] = listener;
    },
    off: function(eventCode) {
      delete this.listeners[eventCode];
    },
    emit: function(state) {
      if (this.listeners[state.eventCode]) {
        return this.listeners[state.eventCode](state);
      }
      if (this.listeners.all) {
        return this.listeners.all(state);
      }
    }
  };
}
function networkName(blockchain, id) {
  return networks[blockchain][id];
}
function serverEcho(eventCode) {
  switch (eventCode) {
    case "txRequest":
    case "nsfFail":
    case "txRepeat":
    case "txAwaitingApproval":
    case "txConfirmReminder":
    case "txSendFail":
    case "txError":
    case "txUnderPriced":
    case "txSent":
      return true;
    default:
      return false;
  }
}
function last(arr) {
  return arr.reverse()[0];
}
function isAddress(blockchain, addressOrHash) {
  switch (blockchain) {
    case "ethereum":
      return addressOrHash.length === 42;
    case "bitcoin":
      return addressOrHash.length !== 64;
    default:
      return false;
  }
}
function isTxid(blockchain, addressOrHash) {
  switch (blockchain) {
    case "ethereum":
      return addressOrHash.length === 66;
    case "bitcoin":
      return addressOrHash.length === 64;
    default:
      return false;
  }
}
function wait(time) {
  return new Promise((resolve) => {
    setTimeout(resolve, time);
  });
}
var jsonPreserveUndefined = (k2, v2) => v2 === void 0 ? "undefined" : v2;
function transaction(hash2, id) {
  if (this._destroyed)
    throw new Error("The WebSocket instance has been destroyed, re-initialize to continue making requests.");
  const startTime = Date.now();
  const emitter = createEmitter();
  const eventCode = "txSent";
  this._watchedTransactions.push({
    hash: hash2,
    emitter
  });
  const transaction2 = {
    [this._system === "ethereum" ? "hash" : "txid"]: hash2,
    id: id || hash2,
    startTime,
    status: "sent"
  };
  const newState = __spreadProps(__spreadValues({}, transaction2), {
    eventCode
  });
  this._sendMessage({
    eventCode,
    categoryCode: "activeTransaction",
    transaction: transaction2
  });
  const transactionObj = {
    details: newState,
    emitter
  };
  function emitState() {
    const emitterResult = emitter.emit(newState);
    this._transactionHandlers.forEach((handler) => handler({
      transaction: newState,
      emitterResult
    }));
  }
  setTimeout(emitState.bind(this), 5);
  return transactionObj;
}
function account(address) {
  if (this._destroyed)
    throw new Error("The WebSocket instance has been destroyed, re-initialize to continue making requests.");
  address = this._system === "ethereum" ? address.toLowerCase() : address;
  const emitter = createEmitter();
  const eventCode = "watch";
  const existingAddressWatcher = this._watchedAccounts.find((ac) => ac.address === address);
  if (existingAddressWatcher) {
    existingAddressWatcher.emitters.push(emitter);
  } else {
    this._watchedAccounts.push({
      address,
      emitters: [emitter]
    });
  }
  this._sendMessage({
    eventCode,
    categoryCode: "accountAddress",
    account: {
      address
    }
  });
  return {
    emitter,
    details: {
      address
    }
  };
}
function event(eventObj) {
  if (this._destroyed)
    throw new Error("The WebSocket instance has been destroyed, re-initialize to continue making requests.");
  this._sendMessage(eventObj);
}
function unsubscribe(addressOrHash) {
  if (this._destroyed)
    throw new Error("The WebSocket instance has been destroyed, re-initialize to continue making requests.");
  const address = isAddress(this._system, addressOrHash);
  const txid = isTxid(this._system, addressOrHash);
  if (address) {
    const normalizedAddress = this._system === "ethereum" ? addressOrHash.toLowerCase() : addressOrHash;
    this._watchedAccounts = this._watchedAccounts.filter((ac) => ac.address !== normalizedAddress);
    this._sendMessage({
      categoryCode: "accountAddress",
      eventCode: "unwatch",
      account: {
        address: normalizedAddress
      }
    });
  } else if (txid) {
    this._watchedTransactions = this._watchedTransactions.filter((tx) => tx.hash !== addressOrHash);
    this._sendMessage({
      categoryCode: "activeTransaction",
      eventCode: "unwatch",
      transaction: {
        [this._system === "ethereum" ? "hash" : "txid"]: addressOrHash,
        id: addressOrHash,
        status: "unsubscribed"
      }
    });
  } else {
    throw new Error(`Error trying to unsubscribe ${addressOrHash}: not a valid address or transaction id/hash`);
  }
}
var extendStatics = function(d3, b2) {
  extendStatics = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d4, b3) {
    d4.__proto__ = b3;
  } || function(d4, b3) {
    for (var p2 in b3)
      if (b3.hasOwnProperty(p2))
        d4[p2] = b3[p2];
  };
  return extendStatics(d3, b2);
};
function __extends(d3, b2) {
  extendStatics(d3, b2);
  function __() {
    this.constructor = d3;
  }
  d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function isFunction(x3) {
  return typeof x3 === "function";
}
var _enable_super_gross_mode_that_will_cause_bad_things = false;
var config = {
  Promise: void 0,
  set useDeprecatedSynchronousErrorHandling(value) {
    if (value) {
      var error = new Error();
      console.warn("DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" + error.stack);
    }
    _enable_super_gross_mode_that_will_cause_bad_things = value;
  },
  get useDeprecatedSynchronousErrorHandling() {
    return _enable_super_gross_mode_that_will_cause_bad_things;
  }
};
function hostReportError(err) {
  setTimeout(function() {
    throw err;
  }, 0);
}
var empty = {
  closed: true,
  next: function(value) {
  },
  error: function(err) {
    if (config.useDeprecatedSynchronousErrorHandling) {
      throw err;
    } else {
      hostReportError(err);
    }
  },
  complete: function() {
  }
};
var isArray = function() {
  return Array.isArray || function(x3) {
    return x3 && typeof x3.length === "number";
  };
}();
function isObject(x3) {
  return x3 !== null && typeof x3 === "object";
}
var UnsubscriptionErrorImpl = function() {
  function UnsubscriptionErrorImpl2(errors) {
    Error.call(this);
    this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map(function(err, i2) {
      return i2 + 1 + ") " + err.toString();
    }).join("\n  ") : "";
    this.name = "UnsubscriptionError";
    this.errors = errors;
    return this;
  }
  UnsubscriptionErrorImpl2.prototype = Object.create(Error.prototype);
  return UnsubscriptionErrorImpl2;
}();
var UnsubscriptionError = UnsubscriptionErrorImpl;
var Subscription = function() {
  function Subscription2(unsubscribe2) {
    this.closed = false;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (unsubscribe2) {
      this._ctorUnsubscribe = true;
      this._unsubscribe = unsubscribe2;
    }
  }
  Subscription2.prototype.unsubscribe = function() {
    var errors;
    if (this.closed) {
      return;
    }
    var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
    this.closed = true;
    this._parentOrParents = null;
    this._subscriptions = null;
    if (_parentOrParents instanceof Subscription2) {
      _parentOrParents.remove(this);
    } else if (_parentOrParents !== null) {
      for (var index = 0; index < _parentOrParents.length; ++index) {
        var parent_1 = _parentOrParents[index];
        parent_1.remove(this);
      }
    }
    if (isFunction(_unsubscribe)) {
      if (_ctorUnsubscribe) {
        this._unsubscribe = void 0;
      }
      try {
        _unsubscribe.call(this);
      } catch (e) {
        errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];
      }
    }
    if (isArray(_subscriptions)) {
      var index = -1;
      var len = _subscriptions.length;
      while (++index < len) {
        var sub = _subscriptions[index];
        if (isObject(sub)) {
          try {
            sub.unsubscribe();
          } catch (e) {
            errors = errors || [];
            if (e instanceof UnsubscriptionError) {
              errors = errors.concat(flattenUnsubscriptionErrors(e.errors));
            } else {
              errors.push(e);
            }
          }
        }
      }
    }
    if (errors) {
      throw new UnsubscriptionError(errors);
    }
  };
  Subscription2.prototype.add = function(teardown) {
    var subscription = teardown;
    if (!teardown) {
      return Subscription2.EMPTY;
    }
    switch (typeof teardown) {
      case "function":
        subscription = new Subscription2(teardown);
      case "object":
        if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== "function") {
          return subscription;
        } else if (this.closed) {
          subscription.unsubscribe();
          return subscription;
        } else if (!(subscription instanceof Subscription2)) {
          var tmp = subscription;
          subscription = new Subscription2();
          subscription._subscriptions = [tmp];
        }
        break;
      default: {
        throw new Error("unrecognized teardown " + teardown + " added to Subscription.");
      }
    }
    var _parentOrParents = subscription._parentOrParents;
    if (_parentOrParents === null) {
      subscription._parentOrParents = this;
    } else if (_parentOrParents instanceof Subscription2) {
      if (_parentOrParents === this) {
        return subscription;
      }
      subscription._parentOrParents = [_parentOrParents, this];
    } else if (_parentOrParents.indexOf(this) === -1) {
      _parentOrParents.push(this);
    } else {
      return subscription;
    }
    var subscriptions = this._subscriptions;
    if (subscriptions === null) {
      this._subscriptions = [subscription];
    } else {
      subscriptions.push(subscription);
    }
    return subscription;
  };
  Subscription2.prototype.remove = function(subscription) {
    var subscriptions = this._subscriptions;
    if (subscriptions) {
      var subscriptionIndex = subscriptions.indexOf(subscription);
      if (subscriptionIndex !== -1) {
        subscriptions.splice(subscriptionIndex, 1);
      }
    }
  };
  Subscription2.EMPTY = function(empty3) {
    empty3.closed = true;
    return empty3;
  }(new Subscription2());
  return Subscription2;
}();
function flattenUnsubscriptionErrors(errors) {
  return errors.reduce(function(errs, err) {
    return errs.concat(err instanceof UnsubscriptionError ? err.errors : err);
  }, []);
}
var rxSubscriber = function() {
  return typeof Symbol === "function" ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random();
}();
var Subscriber = function(_super) {
  __extends(Subscriber2, _super);
  function Subscriber2(destinationOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this.syncErrorValue = null;
    _this.syncErrorThrown = false;
    _this.syncErrorThrowable = false;
    _this.isStopped = false;
    switch (arguments.length) {
      case 0:
        _this.destination = empty;
        break;
      case 1:
        if (!destinationOrNext) {
          _this.destination = empty;
          break;
        }
        if (typeof destinationOrNext === "object") {
          if (destinationOrNext instanceof Subscriber2) {
            _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;
            _this.destination = destinationOrNext;
            destinationOrNext.add(_this);
          } else {
            _this.syncErrorThrowable = true;
            _this.destination = new SafeSubscriber(_this, destinationOrNext);
          }
          break;
        }
      default:
        _this.syncErrorThrowable = true;
        _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
        break;
    }
    return _this;
  }
  Subscriber2.prototype[rxSubscriber] = function() {
    return this;
  };
  Subscriber2.create = function(next, error, complete) {
    var subscriber = new Subscriber2(next, error, complete);
    subscriber.syncErrorThrowable = false;
    return subscriber;
  };
  Subscriber2.prototype.next = function(value) {
    if (!this.isStopped) {
      this._next(value);
    }
  };
  Subscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      this.isStopped = true;
      this._error(err);
    }
  };
  Subscriber2.prototype.complete = function() {
    if (!this.isStopped) {
      this.isStopped = true;
      this._complete();
    }
  };
  Subscriber2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.isStopped = true;
    _super.prototype.unsubscribe.call(this);
  };
  Subscriber2.prototype._next = function(value) {
    this.destination.next(value);
  };
  Subscriber2.prototype._error = function(err) {
    this.destination.error(err);
    this.unsubscribe();
  };
  Subscriber2.prototype._complete = function() {
    this.destination.complete();
    this.unsubscribe();
  };
  Subscriber2.prototype._unsubscribeAndRecycle = function() {
    var _parentOrParents = this._parentOrParents;
    this._parentOrParents = null;
    this.unsubscribe();
    this.closed = false;
    this.isStopped = false;
    this._parentOrParents = _parentOrParents;
    return this;
  };
  return Subscriber2;
}(Subscription);
var SafeSubscriber = function(_super) {
  __extends(SafeSubscriber2, _super);
  function SafeSubscriber2(_parentSubscriber, observerOrNext, error, complete) {
    var _this = _super.call(this) || this;
    _this._parentSubscriber = _parentSubscriber;
    var next;
    var context = _this;
    if (isFunction(observerOrNext)) {
      next = observerOrNext;
    } else if (observerOrNext) {
      next = observerOrNext.next;
      error = observerOrNext.error;
      complete = observerOrNext.complete;
      if (observerOrNext !== empty) {
        context = Object.create(observerOrNext);
        if (isFunction(context.unsubscribe)) {
          _this.add(context.unsubscribe.bind(context));
        }
        context.unsubscribe = _this.unsubscribe.bind(_this);
      }
    }
    _this._context = context;
    _this._next = next;
    _this._error = error;
    _this._complete = complete;
    return _this;
  }
  SafeSubscriber2.prototype.next = function(value) {
    if (!this.isStopped && this._next) {
      var _parentSubscriber = this._parentSubscriber;
      if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
        this.__tryOrUnsub(this._next, value);
      } else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.error = function(err) {
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
      if (this._error) {
        if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(this._error, err);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, this._error, err);
          this.unsubscribe();
        }
      } else if (!_parentSubscriber.syncErrorThrowable) {
        this.unsubscribe();
        if (useDeprecatedSynchronousErrorHandling) {
          throw err;
        }
        hostReportError(err);
      } else {
        if (useDeprecatedSynchronousErrorHandling) {
          _parentSubscriber.syncErrorValue = err;
          _parentSubscriber.syncErrorThrown = true;
        } else {
          hostReportError(err);
        }
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.complete = function() {
    var _this = this;
    if (!this.isStopped) {
      var _parentSubscriber = this._parentSubscriber;
      if (this._complete) {
        var wrappedComplete = function() {
          return _this._complete.call(_this._context);
        };
        if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
          this.__tryOrUnsub(wrappedComplete);
          this.unsubscribe();
        } else {
          this.__tryOrSetError(_parentSubscriber, wrappedComplete);
          this.unsubscribe();
        }
      } else {
        this.unsubscribe();
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrUnsub = function(fn, value) {
    try {
      fn.call(this._context, value);
    } catch (err) {
      this.unsubscribe();
      if (config.useDeprecatedSynchronousErrorHandling) {
        throw err;
      } else {
        hostReportError(err);
      }
    }
  };
  SafeSubscriber2.prototype.__tryOrSetError = function(parent, fn, value) {
    if (!config.useDeprecatedSynchronousErrorHandling) {
      throw new Error("bad call");
    }
    try {
      fn.call(this._context, value);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        parent.syncErrorValue = err;
        parent.syncErrorThrown = true;
        return true;
      } else {
        hostReportError(err);
        return true;
      }
    }
    return false;
  };
  SafeSubscriber2.prototype._unsubscribe = function() {
    var _parentSubscriber = this._parentSubscriber;
    this._context = null;
    this._parentSubscriber = null;
    _parentSubscriber.unsubscribe();
  };
  return SafeSubscriber2;
}(Subscriber);
function canReportError(observer) {
  while (observer) {
    var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;
    if (closed_1 || isStopped) {
      return false;
    } else if (destination && destination instanceof Subscriber) {
      observer = destination;
    } else {
      observer = null;
    }
  }
  return true;
}
function toSubscriber(nextOrObserver, error, complete) {
  if (nextOrObserver) {
    if (nextOrObserver instanceof Subscriber) {
      return nextOrObserver;
    }
    if (nextOrObserver[rxSubscriber]) {
      return nextOrObserver[rxSubscriber]();
    }
  }
  if (!nextOrObserver && !error && !complete) {
    return new Subscriber(empty);
  }
  return new Subscriber(nextOrObserver, error, complete);
}
var observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
function identity(x3) {
  return x3;
}
function pipeFromArray(fns) {
  if (fns.length === 0) {
    return identity;
  }
  if (fns.length === 1) {
    return fns[0];
  }
  return function piped(input) {
    return fns.reduce(function(prev, fn) {
      return fn(prev);
    }, input);
  };
}
var Observable = function() {
  function Observable2(subscribe2) {
    this._isScalar = false;
    if (subscribe2) {
      this._subscribe = subscribe2;
    }
  }
  Observable2.prototype.lift = function(operator) {
    var observable2 = new Observable2();
    observable2.source = this;
    observable2.operator = operator;
    return observable2;
  };
  Observable2.prototype.subscribe = function(observerOrNext, error, complete) {
    var operator = this.operator;
    var sink = toSubscriber(observerOrNext, error, complete);
    if (operator) {
      sink.add(operator.call(sink, this.source));
    } else {
      sink.add(this.source || config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
    }
    if (config.useDeprecatedSynchronousErrorHandling) {
      if (sink.syncErrorThrowable) {
        sink.syncErrorThrowable = false;
        if (sink.syncErrorThrown) {
          throw sink.syncErrorValue;
        }
      }
    }
    return sink;
  };
  Observable2.prototype._trySubscribe = function(sink) {
    try {
      return this._subscribe(sink);
    } catch (err) {
      if (config.useDeprecatedSynchronousErrorHandling) {
        sink.syncErrorThrown = true;
        sink.syncErrorValue = err;
      }
      if (canReportError(sink)) {
        sink.error(err);
      } else {
        console.warn(err);
      }
    }
  };
  Observable2.prototype.forEach = function(next, promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var subscription;
      subscription = _this.subscribe(function(value) {
        try {
          next(value);
        } catch (err) {
          reject(err);
          if (subscription) {
            subscription.unsubscribe();
          }
        }
      }, reject, resolve);
    });
  };
  Observable2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    return source && source.subscribe(subscriber);
  };
  Observable2.prototype[observable] = function() {
    return this;
  };
  Observable2.prototype.pipe = function() {
    var operations = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      operations[_i] = arguments[_i];
    }
    if (operations.length === 0) {
      return this;
    }
    return pipeFromArray(operations)(this);
  };
  Observable2.prototype.toPromise = function(promiseCtor) {
    var _this = this;
    promiseCtor = getPromiseCtor(promiseCtor);
    return new promiseCtor(function(resolve, reject) {
      var value;
      _this.subscribe(function(x3) {
        return value = x3;
      }, function(err) {
        return reject(err);
      }, function() {
        return resolve(value);
      });
    });
  };
  Observable2.create = function(subscribe2) {
    return new Observable2(subscribe2);
  };
  return Observable2;
}();
function getPromiseCtor(promiseCtor) {
  if (!promiseCtor) {
    promiseCtor = Promise;
  }
  if (!promiseCtor) {
    throw new Error("no Promise impl found");
  }
  return promiseCtor;
}
var ObjectUnsubscribedErrorImpl = function() {
  function ObjectUnsubscribedErrorImpl2() {
    Error.call(this);
    this.message = "object unsubscribed";
    this.name = "ObjectUnsubscribedError";
    return this;
  }
  ObjectUnsubscribedErrorImpl2.prototype = Object.create(Error.prototype);
  return ObjectUnsubscribedErrorImpl2;
}();
var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;
var SubjectSubscription = function(_super) {
  __extends(SubjectSubscription2, _super);
  function SubjectSubscription2(subject, subscriber) {
    var _this = _super.call(this) || this;
    _this.subject = subject;
    _this.subscriber = subscriber;
    _this.closed = false;
    return _this;
  }
  SubjectSubscription2.prototype.unsubscribe = function() {
    if (this.closed) {
      return;
    }
    this.closed = true;
    var subject = this.subject;
    var observers = subject.observers;
    this.subject = null;
    if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
      return;
    }
    var subscriberIndex = observers.indexOf(this.subscriber);
    if (subscriberIndex !== -1) {
      observers.splice(subscriberIndex, 1);
    }
  };
  return SubjectSubscription2;
}(Subscription);
var SubjectSubscriber = function(_super) {
  __extends(SubjectSubscriber2, _super);
  function SubjectSubscriber2(destination) {
    var _this = _super.call(this, destination) || this;
    _this.destination = destination;
    return _this;
  }
  return SubjectSubscriber2;
}(Subscriber);
var Subject = function(_super) {
  __extends(Subject2, _super);
  function Subject2() {
    var _this = _super.call(this) || this;
    _this.observers = [];
    _this.closed = false;
    _this.isStopped = false;
    _this.hasError = false;
    _this.thrownError = null;
    return _this;
  }
  Subject2.prototype[rxSubscriber] = function() {
    return new SubjectSubscriber(this);
  };
  Subject2.prototype.lift = function(operator) {
    var subject = new AnonymousSubject(this, this);
    subject.operator = operator;
    return subject;
  };
  Subject2.prototype.next = function(value) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    if (!this.isStopped) {
      var observers = this.observers;
      var len = observers.length;
      var copy = observers.slice();
      for (var i2 = 0; i2 < len; i2++) {
        copy[i2].next(value);
      }
    }
  };
  Subject2.prototype.error = function(err) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.hasError = true;
    this.thrownError = err;
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].error(err);
    }
    this.observers.length = 0;
  };
  Subject2.prototype.complete = function() {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    }
    this.isStopped = true;
    var observers = this.observers;
    var len = observers.length;
    var copy = observers.slice();
    for (var i2 = 0; i2 < len; i2++) {
      copy[i2].complete();
    }
    this.observers.length = 0;
  };
  Subject2.prototype.unsubscribe = function() {
    this.isStopped = true;
    this.closed = true;
    this.observers = null;
  };
  Subject2.prototype._trySubscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else {
      return _super.prototype._trySubscribe.call(this, subscriber);
    }
  };
  Subject2.prototype._subscribe = function(subscriber) {
    if (this.closed) {
      throw new ObjectUnsubscribedError();
    } else if (this.hasError) {
      subscriber.error(this.thrownError);
      return Subscription.EMPTY;
    } else if (this.isStopped) {
      subscriber.complete();
      return Subscription.EMPTY;
    } else {
      this.observers.push(subscriber);
      return new SubjectSubscription(this, subscriber);
    }
  };
  Subject2.prototype.asObservable = function() {
    var observable2 = new Observable();
    observable2.source = this;
    return observable2;
  };
  Subject2.create = function(destination, source) {
    return new AnonymousSubject(destination, source);
  };
  return Subject2;
}(Observable);
var AnonymousSubject = function(_super) {
  __extends(AnonymousSubject2, _super);
  function AnonymousSubject2(destination, source) {
    var _this = _super.call(this) || this;
    _this.destination = destination;
    _this.source = source;
    return _this;
  }
  AnonymousSubject2.prototype.next = function(value) {
    var destination = this.destination;
    if (destination && destination.next) {
      destination.next(value);
    }
  };
  AnonymousSubject2.prototype.error = function(err) {
    var destination = this.destination;
    if (destination && destination.error) {
      this.destination.error(err);
    }
  };
  AnonymousSubject2.prototype.complete = function() {
    var destination = this.destination;
    if (destination && destination.complete) {
      this.destination.complete();
    }
  };
  AnonymousSubject2.prototype._subscribe = function(subscriber) {
    var source = this.source;
    if (source) {
      return this.source.subscribe(subscriber);
    } else {
      return Subscription.EMPTY;
    }
  };
  return AnonymousSubject2;
}(Subject);
var Action = function(_super) {
  __extends(Action2, _super);
  function Action2(scheduler, work) {
    return _super.call(this) || this;
  }
  Action2.prototype.schedule = function(state, delay) {
    return this;
  };
  return Action2;
}(Subscription);
var AsyncAction = function(_super) {
  __extends(AsyncAction2, _super);
  function AsyncAction2(scheduler, work) {
    var _this = _super.call(this, scheduler, work) || this;
    _this.scheduler = scheduler;
    _this.work = work;
    _this.pending = false;
    return _this;
  }
  AsyncAction2.prototype.schedule = function(state, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (this.closed) {
      return this;
    }
    this.state = state;
    var id = this.id;
    var scheduler = this.scheduler;
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, delay);
    }
    this.pending = true;
    this.delay = delay;
    this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
    return this;
  };
  AsyncAction2.prototype.requestAsyncId = function(scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    return setInterval(scheduler.flush.bind(scheduler, this), delay);
  };
  AsyncAction2.prototype.recycleAsyncId = function(scheduler, id, delay) {
    if (delay === void 0) {
      delay = 0;
    }
    if (delay !== null && this.delay === delay && this.pending === false) {
      return id;
    }
    clearInterval(id);
    return void 0;
  };
  AsyncAction2.prototype.execute = function(state, delay) {
    if (this.closed) {
      return new Error("executing a cancelled action");
    }
    this.pending = false;
    var error = this._execute(state, delay);
    if (error) {
      return error;
    } else if (this.pending === false && this.id != null) {
      this.id = this.recycleAsyncId(this.scheduler, this.id, null);
    }
  };
  AsyncAction2.prototype._execute = function(state, delay) {
    var errored = false;
    var errorValue = void 0;
    try {
      this.work(state);
    } catch (e) {
      errored = true;
      errorValue = !!e && e || new Error(e);
    }
    if (errored) {
      this.unsubscribe();
      return errorValue;
    }
  };
  AsyncAction2.prototype._unsubscribe = function() {
    var id = this.id;
    var scheduler = this.scheduler;
    var actions = scheduler.actions;
    var index = actions.indexOf(this);
    this.work = null;
    this.state = null;
    this.pending = false;
    this.scheduler = null;
    if (index !== -1) {
      actions.splice(index, 1);
    }
    if (id != null) {
      this.id = this.recycleAsyncId(scheduler, id, null);
    }
    this.delay = null;
  };
  return AsyncAction2;
}(Action);
var Scheduler = function() {
  function Scheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler2.now;
    }
    this.SchedulerAction = SchedulerAction;
    this.now = now2;
  }
  Scheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    return new this.SchedulerAction(this, work).schedule(state, delay);
  };
  Scheduler2.now = function() {
    return Date.now();
  };
  return Scheduler2;
}();
var AsyncScheduler = function(_super) {
  __extends(AsyncScheduler2, _super);
  function AsyncScheduler2(SchedulerAction, now2) {
    if (now2 === void 0) {
      now2 = Scheduler.now;
    }
    var _this = _super.call(this, SchedulerAction, function() {
      if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== _this) {
        return AsyncScheduler2.delegate.now();
      } else {
        return now2();
      }
    }) || this;
    _this.actions = [];
    _this.active = false;
    _this.scheduled = void 0;
    return _this;
  }
  AsyncScheduler2.prototype.schedule = function(work, delay, state) {
    if (delay === void 0) {
      delay = 0;
    }
    if (AsyncScheduler2.delegate && AsyncScheduler2.delegate !== this) {
      return AsyncScheduler2.delegate.schedule(work, delay, state);
    } else {
      return _super.prototype.schedule.call(this, work, delay, state);
    }
  };
  AsyncScheduler2.prototype.flush = function(action) {
    var actions = this.actions;
    if (this.active) {
      actions.push(action);
      return;
    }
    var error;
    this.active = true;
    do {
      if (error = action.execute(action.state, action.delay)) {
        break;
      }
    } while (action = actions.shift());
    this.active = false;
    if (error) {
      while (action = actions.shift()) {
        action.unsubscribe();
      }
      throw error;
    }
  };
  return AsyncScheduler2;
}(Scheduler);
var EMPTY = new Observable(function(subscriber) {
  return subscriber.complete();
});
function empty$1(scheduler) {
  return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
  return new Observable(function(subscriber) {
    return scheduler.schedule(function() {
      return subscriber.complete();
    });
  });
}
var subscribeToArray = function(array) {
  return function(subscriber) {
    for (var i2 = 0, len = array.length; i2 < len && !subscriber.closed; i2++) {
      subscriber.next(array[i2]);
    }
    subscriber.complete();
  };
};
function throwError(error, scheduler) {
  if (!scheduler) {
    return new Observable(function(subscriber) {
      return subscriber.error(error);
    });
  } else {
    return new Observable(function(subscriber) {
      return scheduler.schedule(dispatch, 0, {
        error,
        subscriber
      });
    });
  }
}
function dispatch(_a) {
  var error = _a.error, subscriber = _a.subscriber;
  subscriber.error(error);
}
var asyncScheduler = new AsyncScheduler(AsyncAction);
var async = asyncScheduler;
var ArgumentOutOfRangeErrorImpl = function() {
  function ArgumentOutOfRangeErrorImpl2() {
    Error.call(this);
    this.message = "argument out of range";
    this.name = "ArgumentOutOfRangeError";
    return this;
  }
  ArgumentOutOfRangeErrorImpl2.prototype = Object.create(Error.prototype);
  return ArgumentOutOfRangeErrorImpl2;
}();
var ArgumentOutOfRangeError = ArgumentOutOfRangeErrorImpl;
var TimeoutErrorImpl = function() {
  function TimeoutErrorImpl2() {
    Error.call(this);
    this.message = "Timeout has occurred";
    this.name = "TimeoutError";
    return this;
  }
  TimeoutErrorImpl2.prototype = Object.create(Error.prototype);
  return TimeoutErrorImpl2;
}();
var TimeoutError = TimeoutErrorImpl;
var subscribeToPromise = function(promise2) {
  return function(subscriber) {
    promise2.then(function(value) {
      if (!subscriber.closed) {
        subscriber.next(value);
        subscriber.complete();
      }
    }, function(err) {
      return subscriber.error(err);
    }).then(null, hostReportError);
    return subscriber;
  };
};
function getSymbolIterator() {
  if (typeof Symbol !== "function" || !Symbol.iterator) {
    return "@@iterator";
  }
  return Symbol.iterator;
}
var iterator = getSymbolIterator();
var subscribeToIterable = function(iterable) {
  return function(subscriber) {
    var iterator$1 = iterable[iterator]();
    do {
      var item = void 0;
      try {
        item = iterator$1.next();
      } catch (err) {
        subscriber.error(err);
        return subscriber;
      }
      if (item.done) {
        subscriber.complete();
        break;
      }
      subscriber.next(item.value);
      if (subscriber.closed) {
        break;
      }
    } while (true);
    if (typeof iterator$1.return === "function") {
      subscriber.add(function() {
        if (iterator$1.return) {
          iterator$1.return();
        }
      });
    }
    return subscriber;
  };
};
var subscribeToObservable = function(obj) {
  return function(subscriber) {
    var obs = obj[observable]();
    if (typeof obs.subscribe !== "function") {
      throw new TypeError("Provided object does not correctly implement Symbol.observable");
    } else {
      return obs.subscribe(subscriber);
    }
  };
};
var isArrayLike = function(x3) {
  return x3 && typeof x3.length === "number" && typeof x3 !== "function";
};
function isPromise(value) {
  return !!value && typeof value.subscribe !== "function" && typeof value.then === "function";
}
var subscribeTo = function(result) {
  if (!!result && typeof result[observable] === "function") {
    return subscribeToObservable(result);
  } else if (isArrayLike(result)) {
    return subscribeToArray(result);
  } else if (isPromise(result)) {
    return subscribeToPromise(result);
  } else if (!!result && typeof result[iterator] === "function") {
    return subscribeToIterable(result);
  } else {
    var value = isObject(result) ? "an invalid object" : "'" + result + "'";
    var msg = "You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.";
    throw new TypeError(msg);
  }
};
var SimpleInnerSubscriber = function(_super) {
  __extends(SimpleInnerSubscriber2, _super);
  function SimpleInnerSubscriber2(parent) {
    var _this = _super.call(this) || this;
    _this.parent = parent;
    return _this;
  }
  SimpleInnerSubscriber2.prototype._next = function(value) {
    this.parent.notifyNext(value);
  };
  SimpleInnerSubscriber2.prototype._error = function(error) {
    this.parent.notifyError(error);
    this.unsubscribe();
  };
  SimpleInnerSubscriber2.prototype._complete = function() {
    this.parent.notifyComplete();
    this.unsubscribe();
  };
  return SimpleInnerSubscriber2;
}(Subscriber);
var SimpleOuterSubscriber = function(_super) {
  __extends(SimpleOuterSubscriber2, _super);
  function SimpleOuterSubscriber2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  SimpleOuterSubscriber2.prototype.notifyNext = function(innerValue) {
    this.destination.next(innerValue);
  };
  SimpleOuterSubscriber2.prototype.notifyError = function(err) {
    this.destination.error(err);
  };
  SimpleOuterSubscriber2.prototype.notifyComplete = function() {
    this.destination.complete();
  };
  return SimpleOuterSubscriber2;
}(Subscriber);
function innerSubscribe(result, innerSubscriber) {
  if (innerSubscriber.closed) {
    return void 0;
  }
  if (result instanceof Observable) {
    return result.subscribe(innerSubscriber);
  }
  return subscribeTo(result)(innerSubscriber);
}
function isDate(value) {
  return value instanceof Date && !isNaN(+value);
}
function take(count) {
  return function(source) {
    if (count === 0) {
      return empty$1();
    } else {
      return source.lift(new TakeOperator(count));
    }
  };
}
var TakeOperator = function() {
  function TakeOperator2(total) {
    this.total = total;
    if (this.total < 0) {
      throw new ArgumentOutOfRangeError();
    }
  }
  TakeOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TakeSubscriber(subscriber, this.total));
  };
  return TakeOperator2;
}();
var TakeSubscriber = function(_super) {
  __extends(TakeSubscriber2, _super);
  function TakeSubscriber2(destination, total) {
    var _this = _super.call(this, destination) || this;
    _this.total = total;
    _this.count = 0;
    return _this;
  }
  TakeSubscriber2.prototype._next = function(value) {
    var total = this.total;
    var count = ++this.count;
    if (count <= total) {
      this.destination.next(value);
      if (count === total) {
        this.destination.complete();
        this.unsubscribe();
      }
    }
  };
  return TakeSubscriber2;
}(Subscriber);
function timeoutWith(due, withObservable, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return function(source) {
    var absoluteTimeout = isDate(due);
    var waitFor = absoluteTimeout ? +due - scheduler.now() : Math.abs(due);
    return source.lift(new TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler));
  };
}
var TimeoutWithOperator = function() {
  function TimeoutWithOperator2(waitFor, absoluteTimeout, withObservable, scheduler) {
    this.waitFor = waitFor;
    this.absoluteTimeout = absoluteTimeout;
    this.withObservable = withObservable;
    this.scheduler = scheduler;
  }
  TimeoutWithOperator2.prototype.call = function(subscriber, source) {
    return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
  };
  return TimeoutWithOperator2;
}();
var TimeoutWithSubscriber = function(_super) {
  __extends(TimeoutWithSubscriber2, _super);
  function TimeoutWithSubscriber2(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
    var _this = _super.call(this, destination) || this;
    _this.absoluteTimeout = absoluteTimeout;
    _this.waitFor = waitFor;
    _this.withObservable = withObservable;
    _this.scheduler = scheduler;
    _this.scheduleTimeout();
    return _this;
  }
  TimeoutWithSubscriber2.dispatchTimeout = function(subscriber) {
    var withObservable = subscriber.withObservable;
    subscriber._unsubscribeAndRecycle();
    subscriber.add(innerSubscribe(withObservable, new SimpleInnerSubscriber(subscriber)));
  };
  TimeoutWithSubscriber2.prototype.scheduleTimeout = function() {
    var action = this.action;
    if (action) {
      this.action = action.schedule(this, this.waitFor);
    } else {
      this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber2.dispatchTimeout, this.waitFor, this));
    }
  };
  TimeoutWithSubscriber2.prototype._next = function(value) {
    if (!this.absoluteTimeout) {
      this.scheduleTimeout();
    }
    _super.prototype._next.call(this, value);
  };
  TimeoutWithSubscriber2.prototype._unsubscribe = function() {
    this.action = void 0;
    this.scheduler = null;
    this.withObservable = null;
  };
  return TimeoutWithSubscriber2;
}(SimpleOuterSubscriber);
function timeout(due, scheduler) {
  if (scheduler === void 0) {
    scheduler = async;
  }
  return timeoutWith(due, throwError(new TimeoutError()), scheduler);
}
function configuration(config2) {
  if (this._destroyed) {
    throw new Error("The WebSocket instance has been destroyed, re-initialize to continue making requests.");
  }
  const casedScope = this._system === "ethereum" ? config2.scope.toLowerCase() : config2.scope;
  const previousConfiguration = this._configurations.get(casedScope);
  previousConfiguration && previousConfiguration.subscription && previousConfiguration.subscription.next();
  const subscription = new Subject();
  const emitter = config2.watchAddress ? {
    emitter: createEmitter()
  } : {};
  this._configurations.set(casedScope, __spreadProps(__spreadValues(__spreadValues({}, config2), emitter), {
    subscription
  }));
  this._sendMessage({
    categoryCode: "configs",
    eventCode: "put",
    config: config2
  });
  return new Promise((resolve, reject) => {
    subscription.pipe(take(1), timeout(5e3)).subscribe({
      next: () => resolve(__spreadProps(__spreadValues({}, emitter), {
        details: {
          config: config2
        }
      })),
      error: (error) => {
        const message = error.message === "Timeout has occurred" ? `Configuration with scope: ${config2.scope} has been sent to the Blocknative server, but has not received a reply within 5 seconds.` : error.message;
        if (this._onerror) {
          this._onerror({
            message
          });
          resolve(`Error: ${message}`);
        } else {
          reject(message);
        }
      }
    });
  });
}
var version = "3.7.0";
function sendMessage(msg) {
  if (this._queuedMessages.length > QUEUE_LIMIT) {
    throw new Error(`Queue limit of ${QUEUE_LIMIT} messages has been reached.`);
  }
  this._queuedMessages.push(createEventLog.bind(this)(msg));
  if (!this._processingQueue) {
    this._processQueue();
  }
}
async function processQueue() {
  this._processingQueue = true;
  if (!this._connected) {
    await waitForConnectionOpen.bind(this)();
  }
  while (this._queuedMessages.length > 0) {
    await wait(1);
    if (this._waitToRetry !== null) {
      await this._waitToRetry;
      this._waitToRetry = null;
    }
    const msg = this._queuedMessages.shift();
    const delay = this._limitRules.duration / this._limitRules.points * 1e3;
    await wait(delay);
    this._socket.send(msg);
  }
  this._processingQueue = false;
  this._limitRules = DEFAULT_RATE_LIMIT_RULES;
}
function handleMessage(msg) {
  const {
    status,
    reason,
    event: event2,
    connectionId,
    serverVersion,
    retryMs,
    limitRules,
    blockedMsg,
    dispatchTimestamp
  } = JSON.parse(msg.data);
  if (connectionId) {
    if (typeof window !== "undefined") {
      window.localStorage.setItem(this._storageKey, connectionId);
    }
    this._connectionId = connectionId;
  }
  if (status === "error") {
    if (reason.includes("ratelimit") && !reason.match(/IP (PendingSimulation|Notification) ratelimit reached/)) {
      this._waitToRetry = wait(retryMs);
      this._limitRules = limitRules;
      blockedMsg && this._queuedMessages.unshift(blockedMsg);
      return;
    }
    if (reason.includes("not a valid API key")) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });
        return;
      } else {
        throw new Error(reason);
      }
    }
    if (reason.includes("network not supported")) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });
        return;
      } else {
        throw new Error(reason);
      }
    }
    if (reason.includes("maximum allowed amount")) {
      if (this._onerror) {
        this._onerror({
          message: reason
        });
        return;
      } else {
        throw new Error(reason);
      }
    }
    if (reason.includes("invalid txid")) {
      const reason2 = `${event2.transaction.txid} is an invalid txid`;
      if (this._onerror) {
        this._onerror({
          message: reason2,
          transaction: event2.transaction.txid
        });
        return;
      } else {
        throw new Error(reason2);
      }
    }
    if (reason.includes("invalid hash")) {
      const reason2 = `${event2.transaction.hash} is an invalid transaction hash`;
      if (this._onerror) {
        this._onerror({
          message: reason2,
          transaction: event2.transaction.hash
        });
        return;
      } else {
        throw new Error(reason2);
      }
    }
    if (reason.includes("invalid address")) {
      const reason2 = `${event2.account.address} is an invalid address`;
      if (this._onerror) {
        this._onerror({
          message: reason2,
          account: event2.account.address
        });
        return;
      } else {
        throw new Error(reason2);
      }
    }
    if (reason.includes("not a valid Bitcoin")) {
      if (this._onerror) {
        this._onerror({
          message: reason,
          account: event2.account.address
        });
        return;
      } else {
        throw new Error(reason);
      }
    }
    if (reason.includes("not a valid Ethereum")) {
      if (this._onerror) {
        this._onerror({
          message: reason,
          account: event2.account.address
        });
        return;
      } else {
        throw new Error(reason);
      }
    }
    if (event2 && event2.config) {
      const configuration2 = this._configurations.get(event2.config.scope);
      if (configuration2 && configuration2.subscription) {
        configuration2.subscription.error({
          message: reason
        });
      }
      return;
    }
    if (this._onerror) {
      this._onerror({
        message: reason
      });
      return;
    } else {
      throw new Error(reason);
    }
  }
  if (event2 && event2.config) {
    const casedScope = this._system === "ethereum" ? event2.config.scope.toLowerCase() : event2.config.scope;
    const configuration2 = this._configurations.get(casedScope);
    if (configuration2 && configuration2.subscription) {
      configuration2.subscription.next();
    }
  }
  if (event2 && event2.transaction) {
    const {
      transaction: transaction2,
      eventCode,
      contractCall,
      timeStamp,
      blockchain: {
        system,
        network
      }
    } = event2;
    const newState = this._system === "ethereum" ? __spreadProps(__spreadValues({}, transaction2), {
      serverVersion,
      eventCode,
      timeStamp,
      dispatchTimestamp,
      system,
      network,
      contractCall
    }) : __spreadProps(__spreadValues({}, transaction2), {
      serverVersion,
      eventCode,
      timeStamp,
      dispatchTimestamp,
      system,
      network
    });
    if (serverEcho(eventCode) || transaction2.status === "unsubscribed") {
      return;
    }
    if (newState.originalHash) {
      newState.replaceHash = newState.originalHash;
      delete newState.originalHash;
    }
    if (eventCode === "txSpeedUp" && newState.status !== "speedup") {
      newState.status = "speedup";
    }
    if (eventCode === "txCancel" && newState.status !== "cancel") {
      newState.status = "cancel";
    }
    if (eventCode === "txSpeedUp" || eventCode === "txCancel") {
      this._watchedTransactions = this._watchedTransactions.map((tx) => {
        if (tx.hash === newState.replaceHash) {
          tx.hash = transaction2.hash || transaction2.txid;
        }
        return tx;
      });
    }
    const watchedAddress = transaction2.watchedAddress && this._system === "ethereum" ? transaction2.watchedAddress.toLowerCase() : transaction2.watchedAddress;
    if (watchedAddress) {
      const accountObj = this._watchedAccounts.find((ac) => ac.address === watchedAddress);
      const accountEmitterResult = accountObj ? last(accountObj.emitters.map((emitter) => emitter.emit(newState))) : false;
      const configuration2 = this._configurations.get(watchedAddress);
      const emitterResult = configuration2 && configuration2.emitter ? configuration2.emitter.emit(newState) || accountEmitterResult : accountEmitterResult;
      this._transactionHandlers.forEach((handler) => handler({
        transaction: newState,
        emitterResult
      }));
    } else {
      const transactionObj = this._watchedTransactions.find((tx) => tx.hash === transaction2.hash || transaction2.txid);
      const emitterResult = transactionObj && transactionObj.emitter.emit(newState);
      this._transactionHandlers.forEach((handler) => handler({
        transaction: newState,
        emitterResult
      }));
    }
  }
}
function createEventLog(msg) {
  return JSON.stringify(__spreadValues({
    timeStamp: new Date().toISOString(),
    dappId: this._dappId,
    version,
    appName: this._appName,
    appVersion: this._appVersion,
    blockchain: {
      system: this._system,
      network: networkName(this._system, this._networkId) || "local"
    }
  }, msg), msg.categoryCode === "configs" ? jsonPreserveUndefined : void 0);
}
function waitForConnectionOpen() {
  return new Promise((resolve) => {
    const interval = setInterval(() => {
      if (this._connected) {
        setTimeout(resolve, 100);
        clearInterval(interval);
      }
    });
  });
}
function validateType(options) {
  const {
    name,
    value,
    type,
    optional,
    customValidation
  } = options;
  if (!optional && typeof value === "undefined") {
    throw new Error(`"${name}" is required`);
  }
  if (typeof value !== "undefined" && (type === "array" ? Array.isArray(type) : typeof value !== type)) {
    throw new Error(`"${name}" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);
  }
  if (typeof value !== "undefined" && customValidation && !customValidation(value)) {
    throw new Error(`"${value}" is not a valid "${name}"`);
  }
}
function validateOptions(options) {
  validateType({
    name: "sdk options",
    value: options,
    type: "object"
  });
  const _a = options, {
    dappId,
    system,
    name,
    appVersion,
    networkId,
    transactionHandlers,
    apiUrl,
    ws,
    onopen,
    ondown,
    onreopen,
    onerror,
    onclose
  } = _a, otherParams = __objRest(_a, [
    "dappId",
    "system",
    "name",
    "appVersion",
    "networkId",
    "transactionHandlers",
    "apiUrl",
    "ws",
    "onopen",
    "ondown",
    "onreopen",
    "onerror",
    "onclose"
  ]);
  invalidParams(otherParams, ["dappId", "system", "name", "appVersion", "networkId", "transactionHandlers", "apiUrl", "ws", "onopen", "ondown", "onreopen", "onerror", "onclose"], "Initialization Options");
  validateType({
    name: "dappId",
    value: dappId,
    type: "string"
  });
  validateType({
    name: "system",
    value: system,
    type: "string",
    optional: true,
    customValidation: validSystem
  });
  validateType({
    name: "name",
    value: name,
    type: "string",
    optional: true
  });
  validateType({
    name: "appVersion",
    value: appVersion,
    type: "string",
    optional: true
  });
  validateType({
    name: "networkId",
    value: networkId,
    type: "number"
  });
  validateType({
    name: "transactionHandler",
    value: transactionHandlers,
    type: "array",
    optional: true
  });
  if (transactionHandlers) {
    transactionHandlers.forEach((handler) => validateType({
      name: "transactionHandler",
      value: handler,
      type: "function"
    }));
  }
  validateType({
    name: "apiUrl",
    value: apiUrl,
    type: "string",
    optional: true
  });
  validateType({
    name: "ws",
    value: ws,
    type: "function",
    optional: true
  });
  validateType({
    name: "onopen",
    value: onopen,
    type: "function",
    optional: true
  });
  validateType({
    name: "ondown",
    value: ondown,
    type: "function",
    optional: true
  });
  validateType({
    name: "onreopen",
    value: onreopen,
    type: "function",
    optional: true
  });
  validateType({
    name: "onerror",
    value: onerror,
    type: "function",
    optional: true
  });
  validateType({
    name: "onclose",
    value: onclose,
    type: "function",
    optional: true
  });
}
function validSystem(system) {
  return !!networks[system];
}
function invalidParams(params, validParams, functionName) {
  const invalid = Object.keys(params);
  if (invalid.length > 0) {
    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(", ")}`);
  }
}
var DEFAULT_APP_NAME = "unknown";
var DEFAULT_APP_VERSION = "unknown";
var DEFAULT_SYSTEM = "ethereum";
var Blocknative = class {
  constructor(options) {
    validateOptions(options);
    const {
      dappId,
      system = DEFAULT_SYSTEM,
      name = DEFAULT_APP_NAME,
      appVersion = DEFAULT_APP_VERSION,
      networkId,
      transactionHandlers = [],
      apiUrl,
      ws,
      onopen,
      ondown,
      onreopen,
      onerror,
      onclose
    } = options;
    const timeout2 = {
      connectTimeout: 1e4
    };
    const socket = new import_sturdy_websocket.default(apiUrl || "wss://api.blocknative.com/v0", ws ? __spreadValues({
      wsConstructor: ws
    }, timeout2) : __spreadValues({}, timeout2));
    socket.onopen = onOpen.bind(this, onopen);
    socket.ondown = onDown.bind(this, ondown);
    socket.onreopen = onReopen.bind(this, onreopen);
    socket.onmessage = handleMessage.bind(this);
    socket.onerror = (error) => onerror && onerror({
      message: "There was a WebSocket error",
      error
    });
    socket.onclose = () => {
      this._pingTimeout && clearInterval(this._pingTimeout);
      onclose && onclose();
    };
    const storageKey = lib_default.SHA1(`${dappId} - ${name}`).toString();
    const storedConnectionId = typeof window !== "undefined" && window.localStorage.getItem(storageKey);
    this._storageKey = storageKey;
    this._connectionId = storedConnectionId || void 0;
    this._dappId = dappId;
    this._system = system;
    this._networkId = networkId;
    this._appName = name;
    this._appVersion = appVersion;
    this._transactionHandlers = transactionHandlers;
    this._socket = socket;
    this._connected = false;
    this._sendMessage = sendMessage.bind(this);
    this._watchedTransactions = [];
    this._watchedAccounts = [];
    this._configurations = new Map();
    this._pingTimeout = void 0;
    this._destroyed = false;
    this._onerror = onerror;
    this._queuedMessages = [];
    this._limitRules = DEFAULT_RATE_LIMIT_RULES;
    this._waitToRetry = null;
    this._processingQueue = false;
    this._processQueue = processQueue.bind(this);
    if (this._socket.ws.on) {
      this._heartbeat = () => {
        this._pingTimeout && clearTimeout(this._pingTimeout);
        this._pingTimeout = setTimeout(() => {
          this._socket.ws.terminate();
        }, 3e4 + 1e3);
      };
      this._socket.ws.on("ping", () => {
        this._heartbeat && this._heartbeat();
      });
    }
    this.transaction = transaction.bind(this);
    this.account = account.bind(this);
    this.event = event.bind(this);
    this.unsubscribe = unsubscribe.bind(this);
    this.configuration = configuration.bind(this);
    this.destroy = () => {
      this._socket.close();
      this._destroyed = true;
      this._socket.onclose();
    };
  }
};
function onOpen(handler) {
  this._connected = true;
  const msg = {
    categoryCode: "initialize",
    eventCode: "checkDappId",
    connectionId: this._connectionId
  };
  this._socket.send(createEventLog.bind(this)(msg));
  this._heartbeat && this._heartbeat();
  handler && handler();
}
function onDown(handler, closeEvent) {
  this._connected = false;
  if (handler) {
    handler(closeEvent);
  }
  this._pingTimeout && clearTimeout(this._pingTimeout);
}
async function onReopen(handler) {
  this._connected = true;
  const msg = {
    categoryCode: "initialize",
    eventCode: "checkDappId",
    connectionId: this._connectionId
  };
  this._socket.send(createEventLog.bind(this)(msg));
  const configurations = Array.from(this._configurations.values());
  const globalConfiguration = this._configurations.get("global");
  if (globalConfiguration) {
    try {
      const _a = globalConfiguration, {
        emitter,
        subscription
      } = _a, config2 = __objRest(_a, [
        "emitter",
        "subscription"
      ]);
      await this.configuration(config2);
    } catch (error) {
      console.warn("Error re-sending global configuration upon reconnection:", error);
    }
  }
  const addressConfigurations = configurations.filter(({
    scope
  }) => scope !== "global");
  addressConfigurations.forEach((enhancedConfig) => {
    const _a2 = enhancedConfig, {
      emitter,
      subscription
    } = _a2, config2 = __objRest(_a2, [
      "emitter",
      "subscription"
    ]);
    this._sendMessage({
      categoryCode: "configs",
      eventCode: "put",
      config: config2
    });
  });
  this._watchedAccounts.forEach((account2) => {
    this._sendMessage({
      eventCode: "accountAddress",
      categoryCode: "watch",
      account: {
        address: account2.address
      }
    });
  });
  if (handler) {
    handler();
  }
  if (this._socket.ws.on) {
    this._socket.ws.on("ping", () => {
      this._heartbeat && this._heartbeat();
    });
    this._heartbeat();
  }
}
var esm_default = Blocknative;

// node_modules/bnc-notify/dist/notify.js
var import_v4 = __toModule(require_v4());
var import_lodash = __toModule(require_lodash2());

// node_modules/bignumber.js/bignumber.mjs
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i;
var mathceil = Math.ceil;
var mathfloor = Math.floor;
var bignumberError = "[BigNumber Error] ";
var tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ";
var BASE = 1e14;
var LOG_BASE = 14;
var MAX_SAFE_INTEGER = 9007199254740991;
var POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13];
var SQRT_BASE = 1e7;
var MAX = 1e9;
function clone(configObject) {
  var div, convertBase, parseNumeric, P2 = BigNumber3.prototype = { constructor: BigNumber3, toString: null, valueOf: null }, ONE = new BigNumber3(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: "\xA0",
    suffix: ""
  }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
  function BigNumber3(v2, b2) {
    var alphabet, c2, caseChanged, e, i2, isNum, len, str, x3 = this;
    if (!(x3 instanceof BigNumber3))
      return new BigNumber3(v2, b2);
    if (b2 == null) {
      if (v2 && v2._isBigNumber === true) {
        x3.s = v2.s;
        if (!v2.c || v2.e > MAX_EXP) {
          x3.c = x3.e = null;
        } else if (v2.e < MIN_EXP) {
          x3.c = [x3.e = 0];
        } else {
          x3.e = v2.e;
          x3.c = v2.c.slice();
        }
        return;
      }
      if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
        x3.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
        if (v2 === ~~v2) {
          for (e = 0, i2 = v2; i2 >= 10; i2 /= 10, e++)
            ;
          if (e > MAX_EXP) {
            x3.c = x3.e = null;
          } else {
            x3.e = e;
            x3.c = [v2];
          }
          return;
        }
        str = String(v2);
      } else {
        if (!isNumeric.test(str = String(v2)))
          return parseNumeric(x3, str, isNum);
        x3.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
      }
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      if ((i2 = str.search(/e/i)) > 0) {
        if (e < 0)
          e = i2;
        e += +str.slice(i2 + 1);
        str = str.substring(0, i2);
      } else if (e < 0) {
        e = str.length;
      }
    } else {
      intCheck(b2, 2, ALPHABET.length, "Base");
      if (b2 == 10) {
        x3 = new BigNumber3(v2);
        return round(x3, DECIMAL_PLACES + x3.e + 1, ROUNDING_MODE);
      }
      str = String(v2);
      if (isNum = typeof v2 == "number") {
        if (v2 * 0 != 0)
          return parseNumeric(x3, str, isNum, b2);
        x3.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
        if (BigNumber3.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
          throw Error(tooManyDigits + v2);
        }
      } else {
        x3.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
      }
      alphabet = ALPHABET.slice(0, b2);
      e = i2 = 0;
      for (len = str.length; i2 < len; i2++) {
        if (alphabet.indexOf(c2 = str.charAt(i2)) < 0) {
          if (c2 == ".") {
            if (i2 > e) {
              e = len;
              continue;
            }
          } else if (!caseChanged) {
            if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
              caseChanged = true;
              i2 = -1;
              e = 0;
              continue;
            }
          }
          return parseNumeric(x3, String(v2), isNum, b2);
        }
      }
      isNum = false;
      str = convertBase(str, b2, 10, x3.s);
      if ((e = str.indexOf(".")) > -1)
        str = str.replace(".", "");
      else
        e = str.length;
    }
    for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
      ;
    for (len = str.length; str.charCodeAt(--len) === 48; )
      ;
    if (str = str.slice(i2, ++len)) {
      len -= i2;
      if (isNum && BigNumber3.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
        throw Error(tooManyDigits + x3.s * v2);
      }
      if ((e = e - i2 - 1) > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (e < MIN_EXP) {
        x3.c = [x3.e = 0];
      } else {
        x3.e = e;
        x3.c = [];
        i2 = (e + 1) % LOG_BASE;
        if (e < 0)
          i2 += LOG_BASE;
        if (i2 < len) {
          if (i2)
            x3.c.push(+str.slice(0, i2));
          for (len -= LOG_BASE; i2 < len; ) {
            x3.c.push(+str.slice(i2, i2 += LOG_BASE));
          }
          i2 = LOG_BASE - (str = str.slice(i2)).length;
        } else {
          i2 -= len;
        }
        for (; i2--; str += "0")
          ;
        x3.c.push(+str);
      }
    } else {
      x3.c = [x3.e = 0];
    }
  }
  BigNumber3.clone = clone;
  BigNumber3.ROUND_UP = 0;
  BigNumber3.ROUND_DOWN = 1;
  BigNumber3.ROUND_CEIL = 2;
  BigNumber3.ROUND_FLOOR = 3;
  BigNumber3.ROUND_HALF_UP = 4;
  BigNumber3.ROUND_HALF_DOWN = 5;
  BigNumber3.ROUND_HALF_EVEN = 6;
  BigNumber3.ROUND_HALF_CEIL = 7;
  BigNumber3.ROUND_HALF_FLOOR = 8;
  BigNumber3.EUCLID = 9;
  BigNumber3.config = BigNumber3.set = function(obj) {
    var p2, v2;
    if (obj != null) {
      if (typeof obj == "object") {
        if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          DECIMAL_PLACES = v2;
        }
        if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 8, p2);
          ROUNDING_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, 0, p2);
            intCheck(v2[1], 0, MAX, p2);
            TO_EXP_NEG = v2[0];
            TO_EXP_POS = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "RANGE")) {
          v2 = obj[p2];
          if (v2 && v2.pop) {
            intCheck(v2[0], -MAX, -1, p2);
            intCheck(v2[1], 1, MAX, p2);
            MIN_EXP = v2[0];
            MAX_EXP = v2[1];
          } else {
            intCheck(v2, -MAX, MAX, p2);
            if (v2) {
              MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
            } else {
              throw Error(bignumberError + p2 + " cannot be zero: " + v2);
            }
          }
        }
        if (obj.hasOwnProperty(p2 = "CRYPTO")) {
          v2 = obj[p2];
          if (v2 === !!v2) {
            if (v2) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                CRYPTO = v2;
              } else {
                CRYPTO = !v2;
                throw Error(bignumberError + "crypto unavailable");
              }
            } else {
              CRYPTO = v2;
            }
          } else {
            throw Error(bignumberError + p2 + " not true or false: " + v2);
          }
        }
        if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
          v2 = obj[p2];
          intCheck(v2, 0, 9, p2);
          MODULO_MODE = v2;
        }
        if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
          v2 = obj[p2];
          intCheck(v2, 0, MAX, p2);
          POW_PRECISION = v2;
        }
        if (obj.hasOwnProperty(p2 = "FORMAT")) {
          v2 = obj[p2];
          if (typeof v2 == "object")
            FORMAT = v2;
          else
            throw Error(bignumberError + p2 + " not an object: " + v2);
        }
        if (obj.hasOwnProperty(p2 = "ALPHABET")) {
          v2 = obj[p2];
          if (typeof v2 == "string" && !/^.$|[+-.\s]|(.).*\1/.test(v2)) {
            ALPHABET = v2;
          } else {
            throw Error(bignumberError + p2 + " invalid: " + v2);
          }
        }
      } else {
        throw Error(bignumberError + "Object expected: " + obj);
      }
    }
    return {
      DECIMAL_PLACES,
      ROUNDING_MODE,
      EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
      RANGE: [MIN_EXP, MAX_EXP],
      CRYPTO,
      MODULO_MODE,
      POW_PRECISION,
      FORMAT,
      ALPHABET
    };
  };
  BigNumber3.isBigNumber = function(v2) {
    if (!v2 || v2._isBigNumber !== true)
      return false;
    if (!BigNumber3.DEBUG)
      return true;
    var i2, n2, c2 = v2.c, e = v2.e, s2 = v2.s;
    out:
      if ({}.toString.call(c2) == "[object Array]") {
        if ((s2 === 1 || s2 === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
          if (c2[0] === 0) {
            if (e === 0 && c2.length === 1)
              return true;
            break out;
          }
          i2 = (e + 1) % LOG_BASE;
          if (i2 < 1)
            i2 += LOG_BASE;
          if (String(c2[0]).length == i2) {
            for (i2 = 0; i2 < c2.length; i2++) {
              n2 = c2[i2];
              if (n2 < 0 || n2 >= BASE || n2 !== mathfloor(n2))
                break out;
            }
            if (n2 !== 0)
              return true;
          }
        }
      } else if (c2 === null && e === null && (s2 === null || s2 === 1 || s2 === -1)) {
        return true;
      }
    throw Error(bignumberError + "Invalid BigNumber: " + v2);
  };
  BigNumber3.maximum = BigNumber3.max = function() {
    return maxOrMin(arguments, P2.lt);
  };
  BigNumber3.minimum = BigNumber3.min = function() {
    return maxOrMin(arguments, P2.gt);
  };
  BigNumber3.random = function() {
    var pow2_53 = 9007199254740992;
    var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
      return mathfloor(Math.random() * pow2_53);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(dp) {
      var a2, b2, e, k2, v2, i2 = 0, c2 = [], rand = new BigNumber3(ONE);
      if (dp == null)
        dp = DECIMAL_PLACES;
      else
        intCheck(dp, 0, MAX);
      k2 = mathceil(dp / LOG_BASE);
      if (CRYPTO) {
        if (crypto.getRandomValues) {
          a2 = crypto.getRandomValues(new Uint32Array(k2 *= 2));
          for (; i2 < k2; ) {
            v2 = a2[i2] * 131072 + (a2[i2 + 1] >>> 11);
            if (v2 >= 9e15) {
              b2 = crypto.getRandomValues(new Uint32Array(2));
              a2[i2] = b2[0];
              a2[i2 + 1] = b2[1];
            } else {
              c2.push(v2 % 1e14);
              i2 += 2;
            }
          }
          i2 = k2 / 2;
        } else if (crypto.randomBytes) {
          a2 = crypto.randomBytes(k2 *= 7);
          for (; i2 < k2; ) {
            v2 = (a2[i2] & 31) * 281474976710656 + a2[i2 + 1] * 1099511627776 + a2[i2 + 2] * 4294967296 + a2[i2 + 3] * 16777216 + (a2[i2 + 4] << 16) + (a2[i2 + 5] << 8) + a2[i2 + 6];
            if (v2 >= 9e15) {
              crypto.randomBytes(7).copy(a2, i2);
            } else {
              c2.push(v2 % 1e14);
              i2 += 7;
            }
          }
          i2 = k2 / 7;
        } else {
          CRYPTO = false;
          throw Error(bignumberError + "crypto unavailable");
        }
      }
      if (!CRYPTO) {
        for (; i2 < k2; ) {
          v2 = random53bitInt();
          if (v2 < 9e15)
            c2[i2++] = v2 % 1e14;
        }
      }
      k2 = c2[--i2];
      dp %= LOG_BASE;
      if (k2 && dp) {
        v2 = POWS_TEN[LOG_BASE - dp];
        c2[i2] = mathfloor(k2 / v2) * v2;
      }
      for (; c2[i2] === 0; c2.pop(), i2--)
        ;
      if (i2 < 0) {
        c2 = [e = 0];
      } else {
        for (e = -1; c2[0] === 0; c2.splice(0, 1), e -= LOG_BASE)
          ;
        for (i2 = 1, v2 = c2[0]; v2 >= 10; v2 /= 10, i2++)
          ;
        if (i2 < LOG_BASE)
          e -= LOG_BASE - i2;
      }
      rand.e = e;
      rand.c = c2;
      return rand;
    };
  }();
  BigNumber3.sum = function() {
    var i2 = 1, args = arguments, sum = new BigNumber3(args[0]);
    for (; i2 < args.length; )
      sum = sum.plus(args[i2++]);
    return sum;
  };
  convertBase = function() {
    var decimal = "0123456789";
    function toBaseOut(str, baseIn, baseOut, alphabet) {
      var j2, arr = [0], arrL, i2 = 0, len = str.length;
      for (; i2 < len; ) {
        for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
          ;
        arr[0] += alphabet.indexOf(str.charAt(i2++));
        for (j2 = 0; j2 < arr.length; j2++) {
          if (arr[j2] > baseOut - 1) {
            if (arr[j2 + 1] == null)
              arr[j2 + 1] = 0;
            arr[j2 + 1] += arr[j2] / baseOut | 0;
            arr[j2] %= baseOut;
          }
        }
      }
      return arr.reverse();
    }
    return function(str, baseIn, baseOut, sign, callerIsToString) {
      var alphabet, d3, e, k2, r2, x3, xc, y2, i2 = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
      if (i2 >= 0) {
        k2 = POW_PRECISION;
        POW_PRECISION = 0;
        str = str.replace(".", "");
        y2 = new BigNumber3(baseIn);
        x3 = y2.pow(str.length - i2);
        POW_PRECISION = k2;
        y2.c = toBaseOut(toFixedPoint(coeffToString(x3.c), x3.e, "0"), 10, baseOut, decimal);
        y2.e = y2.c.length;
      }
      xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
      e = k2 = xc.length;
      for (; xc[--k2] == 0; xc.pop())
        ;
      if (!xc[0])
        return alphabet.charAt(0);
      if (i2 < 0) {
        --e;
      } else {
        x3.c = xc;
        x3.e = e;
        x3.s = sign;
        x3 = div(x3, y2, dp, rm, baseOut);
        xc = x3.c;
        r2 = x3.r;
        e = x3.e;
      }
      d3 = e + dp + 1;
      i2 = xc[d3];
      k2 = baseOut / 2;
      r2 = r2 || d3 < 0 || xc[d3 + 1] != null;
      r2 = rm < 4 ? (i2 != null || r2) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : i2 > k2 || i2 == k2 && (rm == 4 || r2 || rm == 6 && xc[d3 - 1] & 1 || rm == (x3.s < 0 ? 8 : 7));
      if (d3 < 1 || !xc[0]) {
        str = r2 ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
      } else {
        xc.length = d3;
        if (r2) {
          for (--baseOut; ++xc[--d3] > baseOut; ) {
            xc[d3] = 0;
            if (!d3) {
              ++e;
              xc = [1].concat(xc);
            }
          }
        }
        for (k2 = xc.length; !xc[--k2]; )
          ;
        for (i2 = 0, str = ""; i2 <= k2; str += alphabet.charAt(xc[i2++]))
          ;
        str = toFixedPoint(str, e, alphabet.charAt(0));
      }
      return str;
    };
  }();
  div = function() {
    function multiply(x3, k2, base) {
      var m2, temp, xlo, xhi, carry = 0, i2 = x3.length, klo = k2 % SQRT_BASE, khi = k2 / SQRT_BASE | 0;
      for (x3 = x3.slice(); i2--; ) {
        xlo = x3[i2] % SQRT_BASE;
        xhi = x3[i2] / SQRT_BASE | 0;
        m2 = khi * xlo + xhi * klo;
        temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
        carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
        x3[i2] = temp % base;
      }
      if (carry)
        x3 = [carry].concat(x3);
      return x3;
    }
    function compare2(a2, b2, aL, bL) {
      var i2, cmp;
      if (aL != bL) {
        cmp = aL > bL ? 1 : -1;
      } else {
        for (i2 = cmp = 0; i2 < aL; i2++) {
          if (a2[i2] != b2[i2]) {
            cmp = a2[i2] > b2[i2] ? 1 : -1;
            break;
          }
        }
      }
      return cmp;
    }
    function subtract(a2, b2, aL, base) {
      var i2 = 0;
      for (; aL--; ) {
        a2[aL] -= i2;
        i2 = a2[aL] < b2[aL] ? 1 : 0;
        a2[aL] = i2 * base + a2[aL] - b2[aL];
      }
      for (; !a2[0] && a2.length > 1; a2.splice(0, 1))
        ;
    }
    return function(x3, y2, dp, rm, base) {
      var cmp, e, i2, more, n2, prod, prodL, q2, qc, rem, remL, rem0, xi2, xL, yc0, yL, yz, s2 = x3.s == y2.s ? 1 : -1, xc = x3.c, yc = y2.c;
      if (!xc || !xc[0] || !yc || !yc[0]) {
        return new BigNumber3(!x3.s || !y2.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s2 * 0 : s2 / 0);
      }
      q2 = new BigNumber3(s2);
      qc = q2.c = [];
      e = x3.e - y2.e;
      s2 = dp + e + 1;
      if (!base) {
        base = BASE;
        e = bitFloor(x3.e / LOG_BASE) - bitFloor(y2.e / LOG_BASE);
        s2 = s2 / LOG_BASE | 0;
      }
      for (i2 = 0; yc[i2] == (xc[i2] || 0); i2++)
        ;
      if (yc[i2] > (xc[i2] || 0))
        e--;
      if (s2 < 0) {
        qc.push(1);
        more = true;
      } else {
        xL = xc.length;
        yL = yc.length;
        i2 = 0;
        s2 += 2;
        n2 = mathfloor(base / (yc[0] + 1));
        if (n2 > 1) {
          yc = multiply(yc, n2, base);
          xc = multiply(xc, n2, base);
          yL = yc.length;
          xL = xc.length;
        }
        xi2 = yL;
        rem = xc.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; rem[remL++] = 0)
          ;
        yz = yc.slice();
        yz = [0].concat(yz);
        yc0 = yc[0];
        if (yc[1] >= base / 2)
          yc0++;
        do {
          n2 = 0;
          cmp = compare2(yc, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            n2 = mathfloor(rem0 / yc0);
            if (n2 > 1) {
              if (n2 >= base)
                n2 = base - 1;
              prod = multiply(yc, n2, base);
              prodL = prod.length;
              remL = rem.length;
              while (compare2(prod, rem, prodL, remL) == 1) {
                n2--;
                subtract(prod, yL < prodL ? yz : yc, prodL, base);
                prodL = prod.length;
                cmp = 1;
              }
            } else {
              if (n2 == 0) {
                cmp = n2 = 1;
              }
              prod = yc.slice();
              prodL = prod.length;
            }
            if (prodL < remL)
              prod = [0].concat(prod);
            subtract(rem, prod, remL, base);
            remL = rem.length;
            if (cmp == -1) {
              while (compare2(yc, rem, yL, remL) < 1) {
                n2++;
                subtract(rem, yL < remL ? yz : yc, remL, base);
                remL = rem.length;
              }
            }
          } else if (cmp === 0) {
            n2++;
            rem = [0];
          }
          qc[i2++] = n2;
          if (rem[0]) {
            rem[remL++] = xc[xi2] || 0;
          } else {
            rem = [xc[xi2]];
            remL = 1;
          }
        } while ((xi2++ < xL || rem[0] != null) && s2--);
        more = rem[0] != null;
        if (!qc[0])
          qc.splice(0, 1);
      }
      if (base == BASE) {
        for (i2 = 1, s2 = qc[0]; s2 >= 10; s2 /= 10, i2++)
          ;
        round(q2, dp + (q2.e = i2 + e * LOG_BASE - 1) + 1, rm, more);
      } else {
        q2.e = e;
        q2.r = +more;
      }
      return q2;
    };
  }();
  function format(n2, i2, rm, id) {
    var c0, e, ne, len, str;
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    if (!n2.c)
      return n2.toString();
    c0 = n2.c[0];
    ne = n2.e;
    if (i2 == null) {
      str = coeffToString(n2.c);
      str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
    } else {
      n2 = round(new BigNumber3(n2), i2, rm);
      e = n2.e;
      str = coeffToString(n2.c);
      len = str.length;
      if (id == 1 || id == 2 && (i2 <= e || e <= TO_EXP_NEG)) {
        for (; len < i2; str += "0", len++)
          ;
        str = toExponential(str, e);
      } else {
        i2 -= ne;
        str = toFixedPoint(str, e, "0");
        if (e + 1 > len) {
          if (--i2 > 0)
            for (str += "."; i2--; str += "0")
              ;
        } else {
          i2 += e - len;
          if (i2 > 0) {
            if (e + 1 == len)
              str += ".";
            for (; i2--; str += "0")
              ;
          }
        }
      }
    }
    return n2.s < 0 && c0 ? "-" + str : str;
  }
  function maxOrMin(args, method) {
    var n2, i2 = 1, m2 = new BigNumber3(args[0]);
    for (; i2 < args.length; i2++) {
      n2 = new BigNumber3(args[i2]);
      if (!n2.s) {
        m2 = n2;
        break;
      } else if (method.call(m2, n2)) {
        m2 = n2;
      }
    }
    return m2;
  }
  function normalise(n2, c2, e) {
    var i2 = 1, j2 = c2.length;
    for (; !c2[--j2]; c2.pop())
      ;
    for (j2 = c2[0]; j2 >= 10; j2 /= 10, i2++)
      ;
    if ((e = i2 + e * LOG_BASE - 1) > MAX_EXP) {
      n2.c = n2.e = null;
    } else if (e < MIN_EXP) {
      n2.c = [n2.e = 0];
    } else {
      n2.e = e;
      n2.c = c2;
    }
    return n2;
  }
  parseNumeric = function() {
    var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(x3, str, isNum, b2) {
      var base, s2 = isNum ? str : str.replace(whitespaceOrPlus, "");
      if (isInfinityOrNaN.test(s2)) {
        x3.s = isNaN(s2) ? null : s2 < 0 ? -1 : 1;
      } else {
        if (!isNum) {
          s2 = s2.replace(basePrefix, function(m2, p1, p2) {
            base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
            return !b2 || b2 == base ? p1 : m2;
          });
          if (b2) {
            base = b2;
            s2 = s2.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
          }
          if (str != s2)
            return new BigNumber3(s2, base);
        }
        if (BigNumber3.DEBUG) {
          throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
        }
        x3.s = null;
      }
      x3.c = x3.e = null;
    };
  }();
  function round(x3, sd, rm, r2) {
    var d3, i2, j2, k2, n2, ni, rd, xc = x3.c, pows10 = POWS_TEN;
    if (xc) {
      out: {
        for (d3 = 1, k2 = xc[0]; k2 >= 10; k2 /= 10, d3++)
          ;
        i2 = sd - d3;
        if (i2 < 0) {
          i2 += LOG_BASE;
          j2 = sd;
          n2 = xc[ni = 0];
          rd = n2 / pows10[d3 - j2 - 1] % 10 | 0;
        } else {
          ni = mathceil((i2 + 1) / LOG_BASE);
          if (ni >= xc.length) {
            if (r2) {
              for (; xc.length <= ni; xc.push(0))
                ;
              n2 = rd = 0;
              d3 = 1;
              i2 %= LOG_BASE;
              j2 = i2 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            n2 = k2 = xc[ni];
            for (d3 = 1; k2 >= 10; k2 /= 10, d3++)
              ;
            i2 %= LOG_BASE;
            j2 = i2 - LOG_BASE + d3;
            rd = j2 < 0 ? 0 : n2 / pows10[d3 - j2 - 1] % 10 | 0;
          }
        }
        r2 = r2 || sd < 0 || xc[ni + 1] != null || (j2 < 0 ? n2 : n2 % pows10[d3 - j2 - 1]);
        r2 = rm < 4 ? (rd || r2) && (rm == 0 || rm == (x3.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r2 || rm == 6 && (i2 > 0 ? j2 > 0 ? n2 / pows10[d3 - j2] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x3.s < 0 ? 8 : 7));
        if (sd < 1 || !xc[0]) {
          xc.length = 0;
          if (r2) {
            sd -= x3.e + 1;
            xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
            x3.e = -sd || 0;
          } else {
            xc[0] = x3.e = 0;
          }
          return x3;
        }
        if (i2 == 0) {
          xc.length = ni;
          k2 = 1;
          ni--;
        } else {
          xc.length = ni + 1;
          k2 = pows10[LOG_BASE - i2];
          xc[ni] = j2 > 0 ? mathfloor(n2 / pows10[d3 - j2] % pows10[j2]) * k2 : 0;
        }
        if (r2) {
          for (; ; ) {
            if (ni == 0) {
              for (i2 = 1, j2 = xc[0]; j2 >= 10; j2 /= 10, i2++)
                ;
              j2 = xc[0] += k2;
              for (k2 = 1; j2 >= 10; j2 /= 10, k2++)
                ;
              if (i2 != k2) {
                x3.e++;
                if (xc[0] == BASE)
                  xc[0] = 1;
              }
              break;
            } else {
              xc[ni] += k2;
              if (xc[ni] != BASE)
                break;
              xc[ni--] = 0;
              k2 = 1;
            }
          }
        }
        for (i2 = xc.length; xc[--i2] === 0; xc.pop())
          ;
      }
      if (x3.e > MAX_EXP) {
        x3.c = x3.e = null;
      } else if (x3.e < MIN_EXP) {
        x3.c = [x3.e = 0];
      }
    }
    return x3;
  }
  function valueOf(n2) {
    var str, e = n2.e;
    if (e === null)
      return n2.toString();
    str = coeffToString(n2.c);
    str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
    return n2.s < 0 ? "-" + str : str;
  }
  P2.absoluteValue = P2.abs = function() {
    var x3 = new BigNumber3(this);
    if (x3.s < 0)
      x3.s = 1;
    return x3;
  };
  P2.comparedTo = function(y2, b2) {
    return compare(this, new BigNumber3(y2, b2));
  };
  P2.decimalPlaces = P2.dp = function(dp, rm) {
    var c2, n2, v2, x3 = this;
    if (dp != null) {
      intCheck(dp, 0, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber3(x3), dp + x3.e + 1, rm);
    }
    if (!(c2 = x3.c))
      return null;
    n2 = ((v2 = c2.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
    if (v2 = c2[v2])
      for (; v2 % 10 == 0; v2 /= 10, n2--)
        ;
    if (n2 < 0)
      n2 = 0;
    return n2;
  };
  P2.dividedBy = P2.div = function(y2, b2) {
    return div(this, new BigNumber3(y2, b2), DECIMAL_PLACES, ROUNDING_MODE);
  };
  P2.dividedToIntegerBy = P2.idiv = function(y2, b2) {
    return div(this, new BigNumber3(y2, b2), 0, 1);
  };
  P2.exponentiatedBy = P2.pow = function(n2, m2) {
    var half, isModExp, i2, k2, more, nIsBig, nIsNeg, nIsOdd, y2, x3 = this;
    n2 = new BigNumber3(n2);
    if (n2.c && !n2.isInteger()) {
      throw Error(bignumberError + "Exponent not an integer: " + valueOf(n2));
    }
    if (m2 != null)
      m2 = new BigNumber3(m2);
    nIsBig = n2.e > 14;
    if (!x3.c || !x3.c[0] || x3.c[0] == 1 && !x3.e && x3.c.length == 1 || !n2.c || !n2.c[0]) {
      y2 = new BigNumber3(Math.pow(+valueOf(x3), nIsBig ? 2 - isOdd(n2) : +valueOf(n2)));
      return m2 ? y2.mod(m2) : y2;
    }
    nIsNeg = n2.s < 0;
    if (m2) {
      if (m2.c ? !m2.c[0] : !m2.s)
        return new BigNumber3(NaN);
      isModExp = !nIsNeg && x3.isInteger() && m2.isInteger();
      if (isModExp)
        x3 = x3.mod(m2);
    } else if (n2.e > 9 && (x3.e > 0 || x3.e < -1 || (x3.e == 0 ? x3.c[0] > 1 || nIsBig && x3.c[1] >= 24e7 : x3.c[0] < 8e13 || nIsBig && x3.c[0] <= 9999975e7))) {
      k2 = x3.s < 0 && isOdd(n2) ? -0 : 0;
      if (x3.e > -1)
        k2 = 1 / k2;
      return new BigNumber3(nIsNeg ? 1 / k2 : k2);
    } else if (POW_PRECISION) {
      k2 = mathceil(POW_PRECISION / LOG_BASE + 2);
    }
    if (nIsBig) {
      half = new BigNumber3(0.5);
      if (nIsNeg)
        n2.s = 1;
      nIsOdd = isOdd(n2);
    } else {
      i2 = Math.abs(+valueOf(n2));
      nIsOdd = i2 % 2;
    }
    y2 = new BigNumber3(ONE);
    for (; ; ) {
      if (nIsOdd) {
        y2 = y2.times(x3);
        if (!y2.c)
          break;
        if (k2) {
          if (y2.c.length > k2)
            y2.c.length = k2;
        } else if (isModExp) {
          y2 = y2.mod(m2);
        }
      }
      if (i2) {
        i2 = mathfloor(i2 / 2);
        if (i2 === 0)
          break;
        nIsOdd = i2 % 2;
      } else {
        n2 = n2.times(half);
        round(n2, n2.e + 1, 1);
        if (n2.e > 14) {
          nIsOdd = isOdd(n2);
        } else {
          i2 = +valueOf(n2);
          if (i2 === 0)
            break;
          nIsOdd = i2 % 2;
        }
      }
      x3 = x3.times(x3);
      if (k2) {
        if (x3.c && x3.c.length > k2)
          x3.c.length = k2;
      } else if (isModExp) {
        x3 = x3.mod(m2);
      }
    }
    if (isModExp)
      return y2;
    if (nIsNeg)
      y2 = ONE.div(y2);
    return m2 ? y2.mod(m2) : k2 ? round(y2, POW_PRECISION, ROUNDING_MODE, more) : y2;
  };
  P2.integerValue = function(rm) {
    var n2 = new BigNumber3(this);
    if (rm == null)
      rm = ROUNDING_MODE;
    else
      intCheck(rm, 0, 8);
    return round(n2, n2.e + 1, rm);
  };
  P2.isEqualTo = P2.eq = function(y2, b2) {
    return compare(this, new BigNumber3(y2, b2)) === 0;
  };
  P2.isFinite = function() {
    return !!this.c;
  };
  P2.isGreaterThan = P2.gt = function(y2, b2) {
    return compare(this, new BigNumber3(y2, b2)) > 0;
  };
  P2.isGreaterThanOrEqualTo = P2.gte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber3(y2, b2))) === 1 || b2 === 0;
  };
  P2.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  };
  P2.isLessThan = P2.lt = function(y2, b2) {
    return compare(this, new BigNumber3(y2, b2)) < 0;
  };
  P2.isLessThanOrEqualTo = P2.lte = function(y2, b2) {
    return (b2 = compare(this, new BigNumber3(y2, b2))) === -1 || b2 === 0;
  };
  P2.isNaN = function() {
    return !this.s;
  };
  P2.isNegative = function() {
    return this.s < 0;
  };
  P2.isPositive = function() {
    return this.s > 0;
  };
  P2.isZero = function() {
    return !!this.c && this.c[0] == 0;
  };
  P2.minus = function(y2, b2) {
    var i2, j2, t, xLTy, x3 = this, a2 = x3.s;
    y2 = new BigNumber3(y2, b2);
    b2 = y2.s;
    if (!a2 || !b2)
      return new BigNumber3(NaN);
    if (a2 != b2) {
      y2.s = -b2;
      return x3.plus(y2);
    }
    var xe = x3.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x3.c, yc = y2.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return xc ? (y2.s = -b2, y2) : new BigNumber3(yc ? x3 : NaN);
      if (!xc[0] || !yc[0]) {
        return yc[0] ? (y2.s = -b2, y2) : new BigNumber3(xc[0] ? x3 : ROUNDING_MODE == 3 ? -0 : 0);
      }
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a2 = xe - ye) {
      if (xLTy = a2 < 0) {
        a2 = -a2;
        t = xc;
      } else {
        ye = xe;
        t = yc;
      }
      t.reverse();
      for (b2 = a2; b2--; t.push(0))
        ;
      t.reverse();
    } else {
      j2 = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
      for (a2 = b2 = 0; b2 < j2; b2++) {
        if (xc[b2] != yc[b2]) {
          xLTy = xc[b2] < yc[b2];
          break;
        }
      }
    }
    if (xLTy)
      t = xc, xc = yc, yc = t, y2.s = -y2.s;
    b2 = (j2 = yc.length) - (i2 = xc.length);
    if (b2 > 0)
      for (; b2--; xc[i2++] = 0)
        ;
    b2 = BASE - 1;
    for (; j2 > a2; ) {
      if (xc[--j2] < yc[j2]) {
        for (i2 = j2; i2 && !xc[--i2]; xc[i2] = b2)
          ;
        --xc[i2];
        xc[j2] += BASE;
      }
      xc[j2] -= yc[j2];
    }
    for (; xc[0] == 0; xc.splice(0, 1), --ye)
      ;
    if (!xc[0]) {
      y2.s = ROUNDING_MODE == 3 ? -1 : 1;
      y2.c = [y2.e = 0];
      return y2;
    }
    return normalise(y2, xc, ye);
  };
  P2.modulo = P2.mod = function(y2, b2) {
    var q2, s2, x3 = this;
    y2 = new BigNumber3(y2, b2);
    if (!x3.c || !y2.s || y2.c && !y2.c[0]) {
      return new BigNumber3(NaN);
    } else if (!y2.c || x3.c && !x3.c[0]) {
      return new BigNumber3(x3);
    }
    if (MODULO_MODE == 9) {
      s2 = y2.s;
      y2.s = 1;
      q2 = div(x3, y2, 0, 3);
      y2.s = s2;
      q2.s *= s2;
    } else {
      q2 = div(x3, y2, 0, MODULO_MODE);
    }
    y2 = x3.minus(q2.times(y2));
    if (!y2.c[0] && MODULO_MODE == 1)
      y2.s = x3.s;
    return y2;
  };
  P2.multipliedBy = P2.times = function(y2, b2) {
    var c2, e, i2, j2, k2, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x3 = this, xc = x3.c, yc = (y2 = new BigNumber3(y2, b2)).c;
    if (!xc || !yc || !xc[0] || !yc[0]) {
      if (!x3.s || !y2.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
        y2.c = y2.e = y2.s = null;
      } else {
        y2.s *= x3.s;
        if (!xc || !yc) {
          y2.c = y2.e = null;
        } else {
          y2.c = [0];
          y2.e = 0;
        }
      }
      return y2;
    }
    e = bitFloor(x3.e / LOG_BASE) + bitFloor(y2.e / LOG_BASE);
    y2.s *= x3.s;
    xcL = xc.length;
    ycL = yc.length;
    if (xcL < ycL)
      zc = xc, xc = yc, yc = zc, i2 = xcL, xcL = ycL, ycL = i2;
    for (i2 = xcL + ycL, zc = []; i2--; zc.push(0))
      ;
    base = BASE;
    sqrtBase = SQRT_BASE;
    for (i2 = ycL; --i2 >= 0; ) {
      c2 = 0;
      ylo = yc[i2] % sqrtBase;
      yhi = yc[i2] / sqrtBase | 0;
      for (k2 = xcL, j2 = i2 + k2; j2 > i2; ) {
        xlo = xc[--k2] % sqrtBase;
        xhi = xc[k2] / sqrtBase | 0;
        m2 = yhi * xlo + xhi * ylo;
        xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j2] + c2;
        c2 = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
        zc[j2--] = xlo % base;
      }
      zc[j2] = c2;
    }
    if (c2) {
      ++e;
    } else {
      zc.splice(0, 1);
    }
    return normalise(y2, zc, e);
  };
  P2.negated = function() {
    var x3 = new BigNumber3(this);
    x3.s = -x3.s || null;
    return x3;
  };
  P2.plus = function(y2, b2) {
    var t, x3 = this, a2 = x3.s;
    y2 = new BigNumber3(y2, b2);
    b2 = y2.s;
    if (!a2 || !b2)
      return new BigNumber3(NaN);
    if (a2 != b2) {
      y2.s = -b2;
      return x3.minus(y2);
    }
    var xe = x3.e / LOG_BASE, ye = y2.e / LOG_BASE, xc = x3.c, yc = y2.c;
    if (!xe || !ye) {
      if (!xc || !yc)
        return new BigNumber3(a2 / 0);
      if (!xc[0] || !yc[0])
        return yc[0] ? y2 : new BigNumber3(xc[0] ? x3 : a2 * 0);
    }
    xe = bitFloor(xe);
    ye = bitFloor(ye);
    xc = xc.slice();
    if (a2 = xe - ye) {
      if (a2 > 0) {
        ye = xe;
        t = yc;
      } else {
        a2 = -a2;
        t = xc;
      }
      t.reverse();
      for (; a2--; t.push(0))
        ;
      t.reverse();
    }
    a2 = xc.length;
    b2 = yc.length;
    if (a2 - b2 < 0)
      t = yc, yc = xc, xc = t, b2 = a2;
    for (a2 = 0; b2; ) {
      a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
      xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
    }
    if (a2) {
      xc = [a2].concat(xc);
      ++ye;
    }
    return normalise(y2, xc, ye);
  };
  P2.precision = P2.sd = function(sd, rm) {
    var c2, n2, v2, x3 = this;
    if (sd != null && sd !== !!sd) {
      intCheck(sd, 1, MAX);
      if (rm == null)
        rm = ROUNDING_MODE;
      else
        intCheck(rm, 0, 8);
      return round(new BigNumber3(x3), sd, rm);
    }
    if (!(c2 = x3.c))
      return null;
    v2 = c2.length - 1;
    n2 = v2 * LOG_BASE + 1;
    if (v2 = c2[v2]) {
      for (; v2 % 10 == 0; v2 /= 10, n2--)
        ;
      for (v2 = c2[0]; v2 >= 10; v2 /= 10, n2++)
        ;
    }
    if (sd && x3.e + 1 > n2)
      n2 = x3.e + 1;
    return n2;
  };
  P2.shiftedBy = function(k2) {
    intCheck(k2, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
    return this.times("1e" + k2);
  };
  P2.squareRoot = P2.sqrt = function() {
    var m2, n2, r2, rep, t, x3 = this, c2 = x3.c, s2 = x3.s, e = x3.e, dp = DECIMAL_PLACES + 4, half = new BigNumber3("0.5");
    if (s2 !== 1 || !c2 || !c2[0]) {
      return new BigNumber3(!s2 || s2 < 0 && (!c2 || c2[0]) ? NaN : c2 ? x3 : 1 / 0);
    }
    s2 = Math.sqrt(+valueOf(x3));
    if (s2 == 0 || s2 == 1 / 0) {
      n2 = coeffToString(c2);
      if ((n2.length + e) % 2 == 0)
        n2 += "0";
      s2 = Math.sqrt(+n2);
      e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
      if (s2 == 1 / 0) {
        n2 = "5e" + e;
      } else {
        n2 = s2.toExponential();
        n2 = n2.slice(0, n2.indexOf("e") + 1) + e;
      }
      r2 = new BigNumber3(n2);
    } else {
      r2 = new BigNumber3(s2 + "");
    }
    if (r2.c[0]) {
      e = r2.e;
      s2 = e + dp;
      if (s2 < 3)
        s2 = 0;
      for (; ; ) {
        t = r2;
        r2 = half.times(t.plus(div(x3, t, dp, 1)));
        if (coeffToString(t.c).slice(0, s2) === (n2 = coeffToString(r2.c)).slice(0, s2)) {
          if (r2.e < e)
            --s2;
          n2 = n2.slice(s2 - 3, s2 + 1);
          if (n2 == "9999" || !rep && n2 == "4999") {
            if (!rep) {
              round(t, t.e + DECIMAL_PLACES + 2, 0);
              if (t.times(t).eq(x3)) {
                r2 = t;
                break;
              }
            }
            dp += 4;
            s2 += 4;
            rep = 1;
          } else {
            if (!+n2 || !+n2.slice(1) && n2.charAt(0) == "5") {
              round(r2, r2.e + DECIMAL_PLACES + 2, 1);
              m2 = !r2.times(r2).eq(x3);
            }
            break;
          }
        }
      }
    }
    return round(r2, r2.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
  };
  P2.toExponential = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp++;
    }
    return format(this, dp, rm, 1);
  };
  P2.toFixed = function(dp, rm) {
    if (dp != null) {
      intCheck(dp, 0, MAX);
      dp = dp + this.e + 1;
    }
    return format(this, dp, rm);
  };
  P2.toFormat = function(dp, rm, format2) {
    var str, x3 = this;
    if (format2 == null) {
      if (dp != null && rm && typeof rm == "object") {
        format2 = rm;
        rm = null;
      } else if (dp && typeof dp == "object") {
        format2 = dp;
        dp = rm = null;
      } else {
        format2 = FORMAT;
      }
    } else if (typeof format2 != "object") {
      throw Error(bignumberError + "Argument not an object: " + format2);
    }
    str = x3.toFixed(dp, rm);
    if (x3.c) {
      var i2, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x3.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
      if (g2)
        i2 = g1, g1 = g2, g2 = i2, len -= i2;
      if (g1 > 0 && len > 0) {
        i2 = len % g1 || g1;
        intPart = intDigits.substr(0, i2);
        for (; i2 < len; i2 += g1)
          intPart += groupSeparator + intDigits.substr(i2, g1);
        if (g2 > 0)
          intPart += groupSeparator + intDigits.slice(i2);
        if (isNeg)
          intPart = "-" + intPart;
      }
      str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
    }
    return (format2.prefix || "") + str + (format2.suffix || "");
  };
  P2.toFraction = function(md) {
    var d3, d0, d1, d22, e, exp, n2, n0, n1, q2, r2, s2, x3 = this, xc = x3.c;
    if (md != null) {
      n2 = new BigNumber3(md);
      if (!n2.isInteger() && (n2.c || n2.s !== 1) || n2.lt(ONE)) {
        throw Error(bignumberError + "Argument " + (n2.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n2));
      }
    }
    if (!xc)
      return new BigNumber3(x3);
    d3 = new BigNumber3(ONE);
    n1 = d0 = new BigNumber3(ONE);
    d1 = n0 = new BigNumber3(ONE);
    s2 = coeffToString(xc);
    e = d3.e = s2.length - x3.e - 1;
    d3.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
    md = !md || n2.comparedTo(d3) > 0 ? e > 0 ? d3 : n1 : n2;
    exp = MAX_EXP;
    MAX_EXP = 1 / 0;
    n2 = new BigNumber3(s2);
    n0.c[0] = 0;
    for (; ; ) {
      q2 = div(n2, d3, 0, 1);
      d22 = d0.plus(q2.times(d1));
      if (d22.comparedTo(md) == 1)
        break;
      d0 = d1;
      d1 = d22;
      n1 = n0.plus(q2.times(d22 = n1));
      n0 = d22;
      d3 = n2.minus(q2.times(d22 = d3));
      n2 = d22;
    }
    d22 = div(md.minus(d0), d1, 0, 1);
    n0 = n0.plus(d22.times(n1));
    d0 = d0.plus(d22.times(d1));
    n0.s = n1.s = x3.s;
    e = e * 2;
    r2 = div(n1, d1, e, ROUNDING_MODE).minus(x3).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x3).abs()) < 1 ? [n1, d1] : [n0, d0];
    MAX_EXP = exp;
    return r2;
  };
  P2.toNumber = function() {
    return +valueOf(this);
  };
  P2.toPrecision = function(sd, rm) {
    if (sd != null)
      intCheck(sd, 1, MAX);
    return format(this, sd, rm, 2);
  };
  P2.toString = function(b2) {
    var str, n2 = this, s2 = n2.s, e = n2.e;
    if (e === null) {
      if (s2) {
        str = "Infinity";
        if (s2 < 0)
          str = "-" + str;
      } else {
        str = "NaN";
      }
    } else {
      if (b2 == null) {
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n2.c), e) : toFixedPoint(coeffToString(n2.c), e, "0");
      } else if (b2 === 10) {
        n2 = round(new BigNumber3(n2), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
        str = toFixedPoint(coeffToString(n2.c), n2.e, "0");
      } else {
        intCheck(b2, 2, ALPHABET.length, "Base");
        str = convertBase(toFixedPoint(coeffToString(n2.c), e, "0"), 10, b2, s2, true);
      }
      if (s2 < 0 && n2.c[0])
        str = "-" + str;
    }
    return str;
  };
  P2.valueOf = P2.toJSON = function() {
    return valueOf(this);
  };
  P2._isBigNumber = true;
  P2[Symbol.toStringTag] = "BigNumber";
  P2[Symbol.for("nodejs.util.inspect.custom")] = P2.valueOf;
  if (configObject != null)
    BigNumber3.set(configObject);
  return BigNumber3;
}
function bitFloor(n2) {
  var i2 = n2 | 0;
  return n2 > 0 || n2 === i2 ? i2 : i2 - 1;
}
function coeffToString(a2) {
  var s2, z2, i2 = 1, j2 = a2.length, r2 = a2[0] + "";
  for (; i2 < j2; ) {
    s2 = a2[i2++] + "";
    z2 = LOG_BASE - s2.length;
    for (; z2--; s2 = "0" + s2)
      ;
    r2 += s2;
  }
  for (j2 = r2.length; r2.charCodeAt(--j2) === 48; )
    ;
  return r2.slice(0, j2 + 1 || 1);
}
function compare(x3, y2) {
  var a2, b2, xc = x3.c, yc = y2.c, i2 = x3.s, j2 = y2.s, k2 = x3.e, l2 = y2.e;
  if (!i2 || !j2)
    return null;
  a2 = xc && !xc[0];
  b2 = yc && !yc[0];
  if (a2 || b2)
    return a2 ? b2 ? 0 : -j2 : i2;
  if (i2 != j2)
    return i2;
  a2 = i2 < 0;
  b2 = k2 == l2;
  if (!xc || !yc)
    return b2 ? 0 : !xc ^ a2 ? 1 : -1;
  if (!b2)
    return k2 > l2 ^ a2 ? 1 : -1;
  j2 = (k2 = xc.length) < (l2 = yc.length) ? k2 : l2;
  for (i2 = 0; i2 < j2; i2++)
    if (xc[i2] != yc[i2])
      return xc[i2] > yc[i2] ^ a2 ? 1 : -1;
  return k2 == l2 ? 0 : k2 > l2 ^ a2 ? 1 : -1;
}
function intCheck(n2, min, max, name) {
  if (n2 < min || n2 > max || n2 !== mathfloor(n2)) {
    throw Error(bignumberError + (name || "Argument") + (typeof n2 == "number" ? n2 < min || n2 > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n2));
  }
}
function isOdd(n2) {
  var k2 = n2.c.length - 1;
  return bitFloor(n2.e / LOG_BASE) == k2 && n2.c[k2] % 2 != 0;
}
function toExponential(str, e) {
  return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
}
function toFixedPoint(str, e, z2) {
  var len, zs;
  if (e < 0) {
    for (zs = z2 + "."; ++e; zs += z2)
      ;
    str = zs + str;
  } else {
    len = str.length;
    if (++e > len) {
      for (zs = z2, e -= len; --e; zs += z2)
        ;
      str += zs;
    } else if (e < len) {
      str = str.slice(0, e) + "." + str.slice(e);
    }
  }
  return str;
}
var BigNumber2 = clone();
var bignumber_default = BigNumber2;

// node_modules/bnc-notify/dist/notify.js
function noop() {
}
var identity2 = (x3) => x3;
function run(fn) {
  return fn();
}
function blank_object() {
  return Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a2, b2) {
  return a2 != a2 ? b2 == b2 : a2 !== b2 || (a2 && typeof a2 === "object" || typeof a2 === "function");
}
function subscribe(store, ...callbacks2) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks2);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_2) => value = _2)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  node.parentNode.removeChild(node);
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty2() {
  return text("");
}
function listen(node, event2, handler, options) {
  node.addEventListener(event2, handler, options);
  return () => node.removeEventListener(event2, handler, options);
}
function stop_propagation(fn) {
  return function(event2) {
    event2.stopPropagation();
    return fn.call(this, event2);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.wholeText !== data)
    text2.data = data;
}
function set_style(node, key, value, important) {
  node.style.setProperty(key, value, important ? "important" : "");
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, false, false, detail);
  return e;
}
var active_docs = new Set();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_rule(node, a2, b2, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p2 = 0; p2 <= 1; p2 += step) {
    const t = a2 + (b2 - a2) * ease(p2);
    keyframes += p2 * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b2, 1 - b2)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = node.ownerDocument;
  active_docs.add(doc);
  const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element("style")).sheet);
  const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
  if (!current_rules[name]) {
    current_rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1);
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    active_docs.forEach((doc) => {
      const stylesheet = doc.__svelte_stylesheet;
      let i2 = stylesheet.cssRules.length;
      while (i2--)
        stylesheet.deleteRule(i2);
      doc.__svelte_rules = {};
    });
    active_docs.clear();
  });
}
function create_animation(node, from, fn, params) {
  if (!from)
    return noop;
  const to = node.getBoundingClientRect();
  if (from.left === to.left && from.right === to.right && from.top === to.top && from.bottom === to.bottom)
    return noop;
  const {
    delay = 0,
    duration = 300,
    easing = identity2,
    start: start_time = now() + delay,
    end = start_time + duration,
    tick = noop,
    css
  } = fn(node, { from, to }, params);
  let running = true;
  let started = false;
  let name;
  function start() {
    if (css) {
      name = create_rule(node, 0, 1, duration, delay, easing, css);
    }
    if (!delay) {
      started = true;
    }
  }
  function stop() {
    if (css)
      delete_rule(node, name);
    running = false;
  }
  loop((now2) => {
    if (!started && now2 >= start_time) {
      started = true;
    }
    if (started && now2 >= end) {
      tick(1, 0);
      stop();
    }
    if (!running) {
      return false;
    }
    if (started) {
      const p2 = now2 - start_time;
      const t = 0 + 1 * easing(p2 / duration);
      tick(t, 1 - t);
    }
    return true;
  });
  start();
  tick(0, 1);
  return stop;
}
function fix_position(node) {
  const style = getComputedStyle(node);
  if (style.position !== "absolute" && style.position !== "fixed") {
    const { width, height } = style;
    const a2 = node.getBoundingClientRect();
    node.style.position = "absolute";
    node.style.width = width;
    node.style.height = height;
    add_transform(node, a2);
  }
}
function add_transform(node, a2) {
  const b2 = node.getBoundingClientRect();
  if (a2.left !== b2.left || a2.top !== b2.top) {
    const style = getComputedStyle(node);
    const transform = style.transform === "none" ? "" : style.transform;
    node.style.transform = `${transform} translate(${a2.left - b2.left}px, ${a2.top - b2.top}px)`;
  }
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error(`Function called outside component initialization`);
  return current_component;
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var flushing = false;
var seen_callbacks = new Set();
function flush() {
  if (flushing)
    return;
  flushing = true;
  do {
    for (let i2 = 0; i2 < dirty_components.length; i2 += 1) {
      const component = dirty_components[i2];
      set_current_component(component);
      update(component.$$);
    }
    dirty_components.length = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  flushing = false;
  seen_callbacks.clear();
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
var promise;
function wait2() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch2(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  }
}
var null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  let config2 = fn(node, params);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const { delay = 0, duration = 300, easing = identity2, tick = noop, css } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch2(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(1, 0);
          dispatch2(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      delete_rule(node);
      if (is_function(config2)) {
        config2 = config2();
        wait2().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  let config2 = fn(node, params);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  function go() {
    const { delay = 0, duration = 300, easing = identity2, tick = noop, css } = config2 || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch2(node, false, "start"));
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(0, 1);
          dispatch2(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config2)) {
    wait2().then(() => {
      config2 = config2();
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && config2.tick) {
        config2.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function fix_and_outro_and_destroy_block(block, lookup) {
  block.f();
  outro_and_destroy_block(block, lookup);
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o2 = old_blocks.length;
  let n2 = list.length;
  let i2 = o2;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = new Map();
  const deltas = new Map();
  i2 = n2;
  while (i2--) {
    const child_ctx = get_context(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      block.p(child_ctx, dirty);
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = new Set();
  const did_move = new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n2--;
  }
  while (o2 && n2) {
    const new_block = new_blocks[n2 - 1];
    const old_block = old_blocks[o2 - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o2--;
      n2--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o2--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o2--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o2--;
    }
  }
  while (o2--) {
    const old_block = old_blocks[o2];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n2)
    insert2(new_blocks[n2 - 1]);
  return new_blocks;
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, on_mount, on_destroy, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = on_mount.map(run).filter(is_function);
    if (on_destroy) {
      on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init(component, options, instance2, create_fragment2, not_equal, props, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const prop_values = options.props || {};
  const $$ = component.$$ = {
    fragment: null,
    ctx: null,
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    on_mount: [],
    on_destroy: [],
    before_update: [],
    after_update: [],
    context: new Map(parent_component ? parent_component.$$.context : []),
    callbacks: blank_object(),
    dirty
  };
  let ready = false;
  $$.ctx = instance2 ? instance2(component, prop_values, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if ($$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    const callbacks2 = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks2.push(callback);
    return () => {
      const index = callbacks2.indexOf(callback);
      if (index !== -1)
        callbacks2.splice(index, 1);
    };
  }
  $set() {
  }
};
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = [];
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (let i2 = 0; i2 < subscribers.length; i2 += 1) {
          const s2 = subscribers[i2];
          s2[1]();
          subscriber_queue.push(s2, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.push(subscriber);
    if (subscribers.length === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      const index = subscribers.indexOf(subscriber);
      if (index !== -1) {
        subscribers.splice(index, 1);
      }
      if (subscribers.length === 0) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function noop$1() {
}
function detectEval() {
  if (typeof chrome !== "undefined" && chrome.app && chrome.app.runtime) {
    return false;
  }
  if (typeof navigator != "undefined" && navigator.getDeviceStorage) {
    return false;
  }
  try {
    var f6 = new Function("", "return true;");
    return f6();
  } catch (ex) {
    return false;
  }
}
var hasEval = detectEval();
function isIndex(s2) {
  return +s2 === s2 >>> 0 && s2 !== "";
}
function isObject2(obj) {
  return obj === Object(obj);
}
var createObject = "__proto__" in {} ? function(obj) {
  return obj;
} : function(obj) {
  var proto = obj.__proto__;
  if (!proto)
    return obj;
  var newObject = Object.create(proto);
  Object.getOwnPropertyNames(obj).forEach(function(name) {
    Object.defineProperty(newObject, name, Object.getOwnPropertyDescriptor(obj, name));
  });
  return newObject;
};
function parsePath(path2) {
  var keys = [];
  var index = -1;
  var c2, newChar, key, type, transition, action, typeMap, mode = "beforePath";
  var actions = {
    push: function() {
      if (key === void 0)
        return;
      keys.push(key);
      key = void 0;
    },
    append: function() {
      if (key === void 0)
        key = newChar;
      else
        key += newChar;
    }
  };
  function maybeUnescapeQuote() {
    if (index >= path2.length)
      return;
    var nextChar = path2[index + 1];
    if (mode == "inSingleQuote" && nextChar == "'" || mode == "inDoubleQuote" && nextChar == '"') {
      index++;
      newChar = nextChar;
      actions.append();
      return true;
    }
  }
  while (mode) {
    index++;
    c2 = path2[index];
    if (c2 == "\\" && maybeUnescapeQuote())
      continue;
    type = getPathCharType(c2);
    typeMap = pathStateMachine[mode];
    transition = typeMap[type] || typeMap["else"] || "error";
    if (transition == "error")
      return;
    mode = transition[0];
    action = actions[transition[1]] || noop$1;
    newChar = transition[2] === void 0 ? c2 : transition[2];
    action();
    if (mode === "afterPath") {
      return keys;
    }
  }
  return;
}
var identStart = "[$_a-zA-Z]";
var identPart = "[$_a-zA-Z0-9]";
var identRegExp = new RegExp("^" + identStart + "+" + identPart + "*$");
function isIdent(s2) {
  return identRegExp.test(s2);
}
var constructorIsPrivate = {};
function Path(parts, privateToken) {
  if (privateToken !== constructorIsPrivate)
    throw Error("Use Path.get to retrieve path objects");
  for (var i2 = 0; i2 < parts.length; i2++) {
    this.push(String(parts[i2]));
  }
  if (hasEval && this.length) {
    this.getValueFrom = this.compiledGetValueFromFn();
  }
}
var pathCache = {};
function getPath(pathString) {
  if (pathString instanceof Path)
    return pathString;
  if (pathString == null || pathString.length == 0)
    pathString = "";
  if (typeof pathString != "string") {
    if (isIndex(pathString.length)) {
      return new Path(pathString, constructorIsPrivate);
    }
    pathString = String(pathString);
  }
  var path2 = pathCache[pathString];
  if (path2)
    return path2;
  var parts = parsePath(pathString);
  if (!parts)
    return invalidPath;
  var path2 = new Path(parts, constructorIsPrivate);
  pathCache[pathString] = path2;
  return path2;
}
Path.get = getPath;
function formatAccessor(key) {
  if (isIndex(key)) {
    return "[" + key + "]";
  } else {
    return '["' + key.replace(/"/g, '\\"') + '"]';
  }
}
Path.prototype = createObject({
  __proto__: [],
  valid: true,
  toString: function() {
    var pathString = "";
    for (var i2 = 0; i2 < this.length; i2++) {
      var key = this[i2];
      if (isIdent(key)) {
        pathString += i2 ? "." + key : key;
      } else {
        pathString += formatAccessor(key);
      }
    }
    return pathString;
  },
  getValueFrom: function(obj, directObserver) {
    for (var i2 = 0; i2 < this.length; i2++) {
      if (obj == null)
        return;
      obj = obj[this[i2]];
    }
    return obj;
  },
  iterateObjects: function(obj, observe) {
    for (var i2 = 0; i2 < this.length; i2++) {
      if (i2)
        obj = obj[this[i2 - 1]];
      if (!isObject2(obj))
        return;
      observe(obj, this[i2]);
    }
  },
  compiledGetValueFromFn: function() {
    var str = "";
    var pathString = "obj";
    str += "if (obj != null";
    var i2 = 0;
    var key;
    for (; i2 < this.length - 1; i2++) {
      key = this[i2];
      pathString += isIdent(key) ? "." + key : formatAccessor(key);
      str += " &&\n     " + pathString + " != null";
    }
    str += ")\n";
    var key = this[i2];
    pathString += isIdent(key) ? "." + key : formatAccessor(key);
    str += "  return " + pathString + ";\nelse\n  return undefined;";
    return new Function("obj", str);
  },
  setValueFrom: function(obj, value) {
    if (!this.length)
      return false;
    for (var i2 = 0; i2 < this.length - 1; i2++) {
      if (!isObject2(obj))
        return false;
      obj = obj[this[i2]];
    }
    if (!isObject2(obj))
      return false;
    obj[this[i2]] = value;
    return true;
  }
});
function getPathCharType(char) {
  if (char === void 0)
    return "eof";
  var code = char.charCodeAt(0);
  switch (code) {
    case 91:
    case 93:
    case 46:
    case 34:
    case 39:
    case 48:
      return char;
    case 95:
    case 36:
      return "ident";
    case 32:
    case 9:
    case 10:
    case 13:
    case 160:
    case 65279:
    case 8232:
    case 8233:
      return "ws";
  }
  if (97 <= code && code <= 122 || 65 <= code && code <= 90)
    return "ident";
  if (49 <= code && code <= 57)
    return "number";
  return "else";
}
var pathStateMachine = {
  "beforePath": {
    "ws": ["beforePath"],
    "ident": ["inIdent", "append"],
    "[": ["beforeElement"],
    "eof": ["afterPath"]
  },
  "inPath": {
    "ws": ["inPath"],
    ".": ["beforeIdent"],
    "[": ["beforeElement"],
    "eof": ["afterPath"]
  },
  "beforeIdent": {
    "ws": ["beforeIdent"],
    "ident": ["inIdent", "append"]
  },
  "inIdent": {
    "ident": ["inIdent", "append"],
    "0": ["inIdent", "append"],
    "number": ["inIdent", "append"],
    "ws": ["inPath", "push"],
    ".": ["beforeIdent", "push"],
    "[": ["beforeElement", "push"],
    "eof": ["afterPath", "push"]
  },
  "beforeElement": {
    "ws": ["beforeElement"],
    "0": ["afterZero", "append"],
    "number": ["inIndex", "append"],
    "'": ["inSingleQuote", "append", ""],
    '"': ["inDoubleQuote", "append", ""]
  },
  "afterZero": {
    "ws": ["afterElement", "push"],
    "]": ["inPath", "push"]
  },
  "inIndex": {
    "0": ["inIndex", "append"],
    "number": ["inIndex", "append"],
    "ws": ["afterElement"],
    "]": ["inPath", "push"]
  },
  "inSingleQuote": {
    "'": ["afterElement"],
    "eof": ["error"],
    "else": ["inSingleQuote", "append"]
  },
  "inDoubleQuote": {
    '"': ["afterElement"],
    "eof": ["error"],
    "else": ["inDoubleQuote", "append"]
  },
  "afterElement": {
    "ws": ["afterElement"],
    "]": ["inPath", "push"]
  }
};
var invalidPath = new Path("", constructorIsPrivate);
invalidPath.valid = false;
invalidPath.getValueFrom = invalidPath.setValueFrom = function() {
};
var path = Path;
var objectResolvePath = function(o2, path$1) {
  if (typeof path$1 !== "string") {
    throw new TypeError("path must be a string");
  }
  if (typeof o2 !== "object") {
    throw new TypeError("object must be passed");
  }
  var pathObj = path.get(path$1);
  if (!pathObj.valid) {
    throw new Error("path is not a valid object path");
  }
  return pathObj.getValueFrom(o2);
};
var TYPE;
(function(TYPE2) {
  TYPE2[TYPE2["literal"] = 0] = "literal";
  TYPE2[TYPE2["argument"] = 1] = "argument";
  TYPE2[TYPE2["number"] = 2] = "number";
  TYPE2[TYPE2["date"] = 3] = "date";
  TYPE2[TYPE2["time"] = 4] = "time";
  TYPE2[TYPE2["select"] = 5] = "select";
  TYPE2[TYPE2["plural"] = 6] = "plural";
  TYPE2[TYPE2["pound"] = 7] = "pound";
})(TYPE || (TYPE = {}));
function isLiteralElement(el) {
  return el.type === TYPE.literal;
}
function isArgumentElement(el) {
  return el.type === TYPE.argument;
}
function isNumberElement(el) {
  return el.type === TYPE.number;
}
function isDateElement(el) {
  return el.type === TYPE.date;
}
function isTimeElement(el) {
  return el.type === TYPE.time;
}
function isSelectElement(el) {
  return el.type === TYPE.select;
}
function isPluralElement(el) {
  return el.type === TYPE.plural;
}
function isPoundElement(el) {
  return el.type === TYPE.pound;
}
function isNumberSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === 0);
}
function isDateTimeSkeleton(el) {
  return !!(el && typeof el === "object" && el.type === 1);
}
var __extends2 = function() {
  var extendStatics2 = function(d3, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
      d4.__proto__ = b3;
    } || function(d4, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d4[p2] = b3[p2];
    };
    return extendStatics2(d3, b2);
  };
  return function(d3, b2) {
    extendStatics2(d3, b2);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var SyntaxError = function(_super) {
  __extends2(SyntaxError2, _super);
  function SyntaxError2(message, expected, found, location) {
    var _this = _super.call(this) || this;
    _this.message = message;
    _this.expected = expected;
    _this.found = found;
    _this.location = location;
    _this.name = "SyntaxError";
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(_this, SyntaxError2);
    }
    return _this;
  }
  SyntaxError2.buildMessage = function(expected, found) {
    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }
    function literalEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function classEscape(s2) {
      return s2.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(ch) {
        return "\\x0" + hex(ch);
      }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) {
        return "\\x" + hex(ch);
      });
    }
    function describeExpectation(expectation) {
      switch (expectation.type) {
        case "literal":
          return '"' + literalEscape(expectation.text) + '"';
        case "class":
          var escapedParts = expectation.parts.map(function(part) {
            return Array.isArray(part) ? classEscape(part[0]) + "-" + classEscape(part[1]) : classEscape(part);
          });
          return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
        case "any":
          return "any character";
        case "end":
          return "end of input";
        case "other":
          return expectation.description;
      }
    }
    function describeExpected(expected1) {
      var descriptions = expected1.map(describeExpectation);
      var i2;
      var j2;
      descriptions.sort();
      if (descriptions.length > 0) {
        for (i2 = 1, j2 = 1; i2 < descriptions.length; i2++) {
          if (descriptions[i2 - 1] !== descriptions[i2]) {
            descriptions[j2] = descriptions[i2];
            j2++;
          }
        }
        descriptions.length = j2;
      }
      switch (descriptions.length) {
        case 1:
          return descriptions[0];
        case 2:
          return descriptions[0] + " or " + descriptions[1];
        default:
          return descriptions.slice(0, -1).join(", ") + ", or " + descriptions[descriptions.length - 1];
      }
    }
    function describeFound(found1) {
      return found1 ? '"' + literalEscape(found1) + '"' : "end of input";
    }
    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };
  return SyntaxError2;
}(Error);
function peg$parse(input, options) {
  options = options !== void 0 ? options : {};
  var peg$FAILED = {};
  var peg$startRuleFunctions = { start: peg$parsestart };
  var peg$startRuleFunction = peg$parsestart;
  var peg$c0 = function(parts) {
    return parts.join("");
  };
  var peg$c1 = function(messageText) {
    return __assign({ type: TYPE.literal, value: messageText }, insertLocation());
  };
  var peg$c2 = "#";
  var peg$c3 = peg$literalExpectation("#", false);
  var peg$c4 = function() {
    return __assign({ type: TYPE.pound }, insertLocation());
  };
  var peg$c5 = peg$otherExpectation("argumentElement");
  var peg$c6 = "{";
  var peg$c7 = peg$literalExpectation("{", false);
  var peg$c8 = "}";
  var peg$c9 = peg$literalExpectation("}", false);
  var peg$c10 = function(value) {
    return __assign({ type: TYPE.argument, value }, insertLocation());
  };
  var peg$c11 = peg$otherExpectation("numberSkeletonId");
  var peg$c12 = /^['\/{}]/;
  var peg$c13 = peg$classExpectation(["'", "/", "{", "}"], false, false);
  var peg$c14 = peg$anyExpectation();
  var peg$c15 = peg$otherExpectation("numberSkeletonTokenOption");
  var peg$c16 = "/";
  var peg$c17 = peg$literalExpectation("/", false);
  var peg$c18 = function(option) {
    return option;
  };
  var peg$c19 = peg$otherExpectation("numberSkeletonToken");
  var peg$c20 = function(stem, options2) {
    return { stem, options: options2 };
  };
  var peg$c21 = function(tokens) {
    return __assign({ type: 0, tokens }, insertLocation());
  };
  var peg$c22 = "::";
  var peg$c23 = peg$literalExpectation("::", false);
  var peg$c24 = function(skeleton) {
    return skeleton;
  };
  var peg$c25 = function() {
    messageCtx.push("numberArgStyle");
    return true;
  };
  var peg$c26 = function(style) {
    messageCtx.pop();
    return style.replace(/\s*$/, "");
  };
  var peg$c27 = ",";
  var peg$c28 = peg$literalExpectation(",", false);
  var peg$c29 = "number";
  var peg$c30 = peg$literalExpectation("number", false);
  var peg$c31 = function(value, type, style) {
    return __assign({ type: type === "number" ? TYPE.number : type === "date" ? TYPE.date : TYPE.time, style: style && style[2], value }, insertLocation());
  };
  var peg$c32 = "'";
  var peg$c33 = peg$literalExpectation("'", false);
  var peg$c34 = /^[^']/;
  var peg$c35 = peg$classExpectation(["'"], true, false);
  var peg$c36 = /^[^a-zA-Z'{}]/;
  var peg$c37 = peg$classExpectation([["a", "z"], ["A", "Z"], "'", "{", "}"], true, false);
  var peg$c38 = /^[a-zA-Z]/;
  var peg$c39 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false);
  var peg$c40 = function(pattern) {
    return __assign({ type: 1, pattern }, insertLocation());
  };
  var peg$c41 = function() {
    messageCtx.push("dateOrTimeArgStyle");
    return true;
  };
  var peg$c42 = "date";
  var peg$c43 = peg$literalExpectation("date", false);
  var peg$c44 = "time";
  var peg$c45 = peg$literalExpectation("time", false);
  var peg$c46 = "plural";
  var peg$c47 = peg$literalExpectation("plural", false);
  var peg$c48 = "selectordinal";
  var peg$c49 = peg$literalExpectation("selectordinal", false);
  var peg$c50 = "offset:";
  var peg$c51 = peg$literalExpectation("offset:", false);
  var peg$c52 = function(value, pluralType, offset, options2) {
    return __assign({ type: TYPE.plural, pluralType: pluralType === "plural" ? "cardinal" : "ordinal", value, offset: offset ? offset[2] : 0, options: options2.reduce(function(all, _a) {
      var id = _a.id, value2 = _a.value, optionLocation = _a.location;
      if (id in all) {
        error('Duplicate option "' + id + '" in plural element: "' + text2() + '"', location());
      }
      all[id] = {
        value: value2,
        location: optionLocation
      };
      return all;
    }, {}) }, insertLocation());
  };
  var peg$c53 = "select";
  var peg$c54 = peg$literalExpectation("select", false);
  var peg$c55 = function(value, options2) {
    return __assign({ type: TYPE.select, value, options: options2.reduce(function(all, _a) {
      var id = _a.id, value2 = _a.value, optionLocation = _a.location;
      if (id in all) {
        error('Duplicate option "' + id + '" in select element: "' + text2() + '"', location());
      }
      all[id] = {
        value: value2,
        location: optionLocation
      };
      return all;
    }, {}) }, insertLocation());
  };
  var peg$c56 = "=";
  var peg$c57 = peg$literalExpectation("=", false);
  var peg$c58 = function(id) {
    messageCtx.push("select");
    return true;
  };
  var peg$c59 = function(id, value) {
    messageCtx.pop();
    return __assign({
      id,
      value
    }, insertLocation());
  };
  var peg$c60 = function(id) {
    messageCtx.push("plural");
    return true;
  };
  var peg$c61 = function(id, value) {
    messageCtx.pop();
    return __assign({
      id,
      value
    }, insertLocation());
  };
  var peg$c62 = peg$otherExpectation("whitespace");
  var peg$c63 = /^[\t-\r \x85\xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
  var peg$c64 = peg$classExpectation([["	", "\r"], " ", "\x85", "\xA0", "\u1680", ["\u2000", "\u200A"], "\u2028", "\u2029", "\u202F", "\u205F", "\u3000"], false, false);
  var peg$c65 = peg$otherExpectation("syntax pattern");
  var peg$c66 = /^[!-\/:-@[-\^`{-~\xA1-\xA7\xA9\xAB\xAC\xAE\xB0\xB1\xB6\xBB\xBF\xD7\xF7\u2010-\u2027\u2030-\u203E\u2041-\u2053\u2055-\u205E\u2190-\u245F\u2500-\u2775\u2794-\u2BFF\u2E00-\u2E7F\u3001-\u3003\u3008-\u3020\u3030\uFD3E\uFD3F\uFE45\uFE46]/;
  var peg$c67 = peg$classExpectation([["!", "/"], [":", "@"], ["[", "^"], "`", ["{", "~"], ["\xA1", "\xA7"], "\xA9", "\xAB", "\xAC", "\xAE", "\xB0", "\xB1", "\xB6", "\xBB", "\xBF", "\xD7", "\xF7", ["\u2010", "\u2027"], ["\u2030", "\u203E"], ["\u2041", "\u2053"], ["\u2055", "\u205E"], ["\u2190", "\u245F"], ["\u2500", "\u2775"], ["\u2794", "\u2BFF"], ["\u2E00", "\u2E7F"], ["\u3001", "\u3003"], ["\u3008", "\u3020"], "\u3030", "\uFD3E", "\uFD3F", "\uFE45", "\uFE46"], false, false);
  var peg$c68 = peg$otherExpectation("optional whitespace");
  var peg$c69 = peg$otherExpectation("number");
  var peg$c70 = "-";
  var peg$c71 = peg$literalExpectation("-", false);
  var peg$c72 = function(negative, num) {
    return num ? negative ? -num : num : 0;
  };
  var peg$c74 = peg$otherExpectation("double apostrophes");
  var peg$c75 = "''";
  var peg$c76 = peg$literalExpectation("''", false);
  var peg$c77 = function() {
    return "'";
  };
  var peg$c78 = function(escapedChar, quotedChars) {
    return escapedChar + quotedChars.replace("''", "'");
  };
  var peg$c79 = function(x3) {
    return x3 !== "{" && !(isInPluralOption() && x3 === "#") && !(isNestedMessageText() && x3 === "}");
  };
  var peg$c80 = "\n";
  var peg$c81 = peg$literalExpectation("\n", false);
  var peg$c82 = function(x3) {
    return x3 === "{" || x3 === "}" || isInPluralOption() && x3 === "#";
  };
  var peg$c83 = peg$otherExpectation("argNameOrNumber");
  var peg$c84 = peg$otherExpectation("argNumber");
  var peg$c85 = "0";
  var peg$c86 = peg$literalExpectation("0", false);
  var peg$c87 = function() {
    return 0;
  };
  var peg$c88 = /^[1-9]/;
  var peg$c89 = peg$classExpectation([["1", "9"]], false, false);
  var peg$c90 = /^[0-9]/;
  var peg$c91 = peg$classExpectation([["0", "9"]], false, false);
  var peg$c92 = function(digits) {
    return parseInt(digits.join(""), 10);
  };
  var peg$c93 = peg$otherExpectation("argName");
  var peg$currPos = 0;
  var peg$savedPos = 0;
  var peg$posDetailsCache = [{ line: 1, column: 1 }];
  var peg$maxFailPos = 0;
  var peg$maxFailExpected = [];
  var peg$silentFails = 0;
  var peg$result;
  if (options.startRule !== void 0) {
    if (!(options.startRule in peg$startRuleFunctions)) {
      throw new Error(`Can't start parsing from rule "` + options.startRule + '".');
    }
    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
  }
  function text2() {
    return input.substring(peg$savedPos, peg$currPos);
  }
  function location() {
    return peg$computeLocation(peg$savedPos, peg$currPos);
  }
  function error(message, location1) {
    location1 = location1 !== void 0 ? location1 : peg$computeLocation(peg$savedPos, peg$currPos);
    throw peg$buildSimpleError(message, location1);
  }
  function peg$literalExpectation(text1, ignoreCase) {
    return { type: "literal", text: text1, ignoreCase };
  }
  function peg$classExpectation(parts, inverted, ignoreCase) {
    return { type: "class", parts, inverted, ignoreCase };
  }
  function peg$anyExpectation() {
    return { type: "any" };
  }
  function peg$endExpectation() {
    return { type: "end" };
  }
  function peg$otherExpectation(description) {
    return { type: "other", description };
  }
  function peg$computePosDetails(pos) {
    var details = peg$posDetailsCache[pos];
    var p2;
    if (details) {
      return details;
    } else {
      p2 = pos - 1;
      while (!peg$posDetailsCache[p2]) {
        p2--;
      }
      details = peg$posDetailsCache[p2];
      details = {
        line: details.line,
        column: details.column
      };
      while (p2 < pos) {
        if (input.charCodeAt(p2) === 10) {
          details.line++;
          details.column = 1;
        } else {
          details.column++;
        }
        p2++;
      }
      peg$posDetailsCache[pos] = details;
      return details;
    }
  }
  function peg$computeLocation(startPos, endPos) {
    var startPosDetails = peg$computePosDetails(startPos);
    var endPosDetails = peg$computePosDetails(endPos);
    return {
      start: {
        offset: startPos,
        line: startPosDetails.line,
        column: startPosDetails.column
      },
      end: {
        offset: endPos,
        line: endPosDetails.line,
        column: endPosDetails.column
      }
    };
  }
  function peg$fail(expected1) {
    if (peg$currPos < peg$maxFailPos) {
      return;
    }
    if (peg$currPos > peg$maxFailPos) {
      peg$maxFailPos = peg$currPos;
      peg$maxFailExpected = [];
    }
    peg$maxFailExpected.push(expected1);
  }
  function peg$buildSimpleError(message, location1) {
    return new SyntaxError(message, [], "", location1);
  }
  function peg$buildStructuredError(expected1, found, location1) {
    return new SyntaxError(SyntaxError.buildMessage(expected1, found), expected1, found, location1);
  }
  function peg$parsestart() {
    var s0;
    s0 = peg$parsemessage();
    return s0;
  }
  function peg$parsemessage() {
    var s0, s1;
    s0 = [];
    s1 = peg$parsemessageElement();
    while (s1 !== peg$FAILED) {
      s0.push(s1);
      s1 = peg$parsemessageElement();
    }
    return s0;
  }
  function peg$parsemessageElement() {
    var s0;
    s0 = peg$parseliteralElement();
    if (s0 === peg$FAILED) {
      s0 = peg$parseargumentElement();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesimpleFormatElement();
        if (s0 === peg$FAILED) {
          s0 = peg$parsepluralElement();
          if (s0 === peg$FAILED) {
            s0 = peg$parseselectElement();
            if (s0 === peg$FAILED) {
              s0 = peg$parsepoundElement();
            }
          }
        }
      }
    }
    return s0;
  }
  function peg$parsemessageText() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsedoubleApostrophes();
    if (s2 === peg$FAILED) {
      s2 = peg$parsequotedString();
      if (s2 === peg$FAILED) {
        s2 = peg$parseunquotedString();
      }
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsedoubleApostrophes();
        if (s2 === peg$FAILED) {
          s2 = peg$parsequotedString();
          if (s2 === peg$FAILED) {
            s2 = peg$parseunquotedString();
          }
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c0(s1);
    }
    s0 = s1;
    return s0;
  }
  function peg$parseliteralElement() {
    var s0, s1;
    s0 = peg$currPos;
    s1 = peg$parsemessageText();
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c1(s1);
    }
    s0 = s1;
    return s0;
  }
  function peg$parsepoundElement() {
    var s0, s1;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 35) {
      s1 = peg$c2;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c3);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c4();
    }
    s0 = s1;
    return s0;
  }
  function peg$parseargumentElement() {
    var s0, s1, s2, s3, s4, s5;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargNameOrNumber();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s5 = peg$c8;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c9);
              }
            }
            if (s5 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c10(s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c5);
      }
    }
    return s0;
  }
  function peg$parsenumberSkeletonId() {
    var s0, s1, s2, s3, s4;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parsewhiteSpace();
    if (s4 === peg$FAILED) {
      if (peg$c12.test(input.charAt(peg$currPos))) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c13);
        }
      }
    }
    peg$silentFails--;
    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c14);
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsewhiteSpace();
        if (s4 === peg$FAILED) {
          if (peg$c12.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c13);
            }
          }
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c14);
            }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c11);
      }
    }
    return s0;
  }
  function peg$parsenumberSkeletonTokenOption() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 47) {
      s1 = peg$c16;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c17);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenumberSkeletonId();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c18(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c15);
      }
    }
    return s0;
  }
  function peg$parsenumberSkeletonToken() {
    var s0, s1, s2, s3, s4;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenumberSkeletonId();
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsenumberSkeletonTokenOption();
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsenumberSkeletonTokenOption();
        }
        if (s3 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c20(s2, s3);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c19);
      }
    }
    return s0;
  }
  function peg$parsenumberSkeleton() {
    var s0, s1, s2;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsenumberSkeletonToken();
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsenumberSkeletonToken();
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c21(s1);
    }
    s0 = s1;
    return s0;
  }
  function peg$parsenumberArgStyle() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c22) {
      s1 = peg$c22;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c23);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsenumberSkeleton();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c24(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      peg$savedPos = peg$currPos;
      s1 = peg$c25();
      if (s1) {
        s1 = void 0;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemessageText();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsenumberFormatElement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargNameOrNumber();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c27;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c29) {
                  s7 = peg$c29;
                  peg$currPos += 6;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c30);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s10 = peg$c27;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c28);
                      }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parsenumberArgStyle();
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s11 = peg$c8;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c9);
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c31(s3, s7, s9);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsedateTimeSkeletonLiteral() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c32;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c33);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = [];
      s3 = peg$parsedoubleApostrophes();
      if (s3 === peg$FAILED) {
        if (peg$c34.test(input.charAt(peg$currPos))) {
          s3 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c35);
          }
        }
      }
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsedoubleApostrophes();
          if (s3 === peg$FAILED) {
            if (peg$c34.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
          }
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 39) {
          s3 = peg$c32;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c33);
          }
        }
        if (s3 !== peg$FAILED) {
          s1 = [s1, s2, s3];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = [];
      s1 = peg$parsedoubleApostrophes();
      if (s1 === peg$FAILED) {
        if (peg$c36.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c37);
          }
        }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsedoubleApostrophes();
          if (s1 === peg$FAILED) {
            if (peg$c36.test(input.charAt(peg$currPos))) {
              s1 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s1 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c37);
              }
            }
          }
        }
      } else {
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsedateTimeSkeletonPattern() {
    var s0, s1;
    s0 = [];
    if (peg$c38.test(input.charAt(peg$currPos))) {
      s1 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c39);
      }
    }
    if (s1 !== peg$FAILED) {
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c38.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c39);
          }
        }
      }
    } else {
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsedateTimeSkeleton() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$currPos;
    s2 = [];
    s3 = peg$parsedateTimeSkeletonLiteral();
    if (s3 === peg$FAILED) {
      s3 = peg$parsedateTimeSkeletonPattern();
    }
    if (s3 !== peg$FAILED) {
      while (s3 !== peg$FAILED) {
        s2.push(s3);
        s3 = peg$parsedateTimeSkeletonLiteral();
        if (s3 === peg$FAILED) {
          s3 = peg$parsedateTimeSkeletonPattern();
        }
      }
    } else {
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      s1 = input.substring(s1, peg$currPos);
    } else {
      s1 = s2;
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c40(s1);
    }
    s0 = s1;
    return s0;
  }
  function peg$parsedateOrTimeArgStyle() {
    var s0, s1, s2;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c22) {
      s1 = peg$c22;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c23);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parsedateTimeSkeleton();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c24(s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      peg$savedPos = peg$currPos;
      s1 = peg$c41();
      if (s1) {
        s1 = void 0;
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsemessageText();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c26(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    }
    return s0;
  }
  function peg$parsedateOrTimeFormatElement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargNameOrNumber();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c27;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 4) === peg$c42) {
                  s7 = peg$c42;
                  peg$currPos += 4;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c43);
                  }
                }
                if (s7 === peg$FAILED) {
                  if (input.substr(peg$currPos, 4) === peg$c44) {
                    s7 = peg$c44;
                    peg$currPos += 4;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c45);
                    }
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    s9 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s10 = peg$c27;
                      peg$currPos++;
                    } else {
                      s10 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c28);
                      }
                    }
                    if (s10 !== peg$FAILED) {
                      s11 = peg$parse_();
                      if (s11 !== peg$FAILED) {
                        s12 = peg$parsedateOrTimeArgStyle();
                        if (s12 !== peg$FAILED) {
                          s10 = [s10, s11, s12];
                          s9 = s10;
                        } else {
                          peg$currPos = s9;
                          s9 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s9;
                        s9 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s9;
                      s9 = peg$FAILED;
                    }
                    if (s9 === peg$FAILED) {
                      s9 = null;
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        if (input.charCodeAt(peg$currPos) === 125) {
                          s11 = peg$c8;
                          peg$currPos++;
                        } else {
                          s11 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c9);
                          }
                        }
                        if (s11 !== peg$FAILED) {
                          peg$savedPos = s0;
                          s1 = peg$c31(s3, s7, s9);
                          s0 = s1;
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsesimpleFormatElement() {
    var s0;
    s0 = peg$parsenumberFormatElement();
    if (s0 === peg$FAILED) {
      s0 = peg$parsedateOrTimeFormatElement();
    }
    return s0;
  }
  function peg$parsepluralElement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13, s14, s15;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargNameOrNumber();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c27;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c46) {
                  s7 = peg$c46;
                  peg$currPos += 6;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c47);
                  }
                }
                if (s7 === peg$FAILED) {
                  if (input.substr(peg$currPos, 13) === peg$c48) {
                    s7 = peg$c48;
                    peg$currPos += 13;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) {
                      peg$fail(peg$c49);
                    }
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c27;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c28);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = peg$currPos;
                        if (input.substr(peg$currPos, 7) === peg$c50) {
                          s12 = peg$c50;
                          peg$currPos += 7;
                        } else {
                          s12 = peg$FAILED;
                          if (peg$silentFails === 0) {
                            peg$fail(peg$c51);
                          }
                        }
                        if (s12 !== peg$FAILED) {
                          s13 = peg$parse_();
                          if (s13 !== peg$FAILED) {
                            s14 = peg$parsenumber();
                            if (s14 !== peg$FAILED) {
                              s12 = [s12, s13, s14];
                              s11 = s12;
                            } else {
                              peg$currPos = s11;
                              s11 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s11;
                            s11 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s11;
                          s11 = peg$FAILED;
                        }
                        if (s11 === peg$FAILED) {
                          s11 = null;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            s13 = [];
                            s14 = peg$parsepluralOption();
                            if (s14 !== peg$FAILED) {
                              while (s14 !== peg$FAILED) {
                                s13.push(s14);
                                s14 = peg$parsepluralOption();
                              }
                            } else {
                              s13 = peg$FAILED;
                            }
                            if (s13 !== peg$FAILED) {
                              s14 = peg$parse_();
                              if (s14 !== peg$FAILED) {
                                if (input.charCodeAt(peg$currPos) === 125) {
                                  s15 = peg$c8;
                                  peg$currPos++;
                                } else {
                                  s15 = peg$FAILED;
                                  if (peg$silentFails === 0) {
                                    peg$fail(peg$c9);
                                  }
                                }
                                if (s15 !== peg$FAILED) {
                                  peg$savedPos = s0;
                                  s1 = peg$c52(s3, s7, s11, s13);
                                  s0 = s1;
                                } else {
                                  peg$currPos = s0;
                                  s0 = peg$FAILED;
                                }
                              } else {
                                peg$currPos = s0;
                                s0 = peg$FAILED;
                              }
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseselectElement() {
    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11, s12, s13;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 123) {
      s1 = peg$c6;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c7);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parse_();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseargNameOrNumber();
        if (s3 !== peg$FAILED) {
          s4 = peg$parse_();
          if (s4 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 44) {
              s5 = peg$c27;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c28);
              }
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parse_();
              if (s6 !== peg$FAILED) {
                if (input.substr(peg$currPos, 6) === peg$c53) {
                  s7 = peg$c53;
                  peg$currPos += 6;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c54);
                  }
                }
                if (s7 !== peg$FAILED) {
                  s8 = peg$parse_();
                  if (s8 !== peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 44) {
                      s9 = peg$c27;
                      peg$currPos++;
                    } else {
                      s9 = peg$FAILED;
                      if (peg$silentFails === 0) {
                        peg$fail(peg$c28);
                      }
                    }
                    if (s9 !== peg$FAILED) {
                      s10 = peg$parse_();
                      if (s10 !== peg$FAILED) {
                        s11 = [];
                        s12 = peg$parseselectOption();
                        if (s12 !== peg$FAILED) {
                          while (s12 !== peg$FAILED) {
                            s11.push(s12);
                            s12 = peg$parseselectOption();
                          }
                        } else {
                          s11 = peg$FAILED;
                        }
                        if (s11 !== peg$FAILED) {
                          s12 = peg$parse_();
                          if (s12 !== peg$FAILED) {
                            if (input.charCodeAt(peg$currPos) === 125) {
                              s13 = peg$c8;
                              peg$currPos++;
                            } else {
                              s13 = peg$FAILED;
                              if (peg$silentFails === 0) {
                                peg$fail(peg$c9);
                              }
                            }
                            if (s13 !== peg$FAILED) {
                              peg$savedPos = s0;
                              s1 = peg$c55(s3, s11);
                              s0 = s1;
                            } else {
                              peg$currPos = s0;
                              s0 = peg$FAILED;
                            }
                          } else {
                            peg$currPos = s0;
                            s0 = peg$FAILED;
                          }
                        } else {
                          peg$currPos = s0;
                          s0 = peg$FAILED;
                        }
                      } else {
                        peg$currPos = s0;
                        s0 = peg$FAILED;
                      }
                    } else {
                      peg$currPos = s0;
                      s0 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsepluralRuleSelectValue() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 61) {
      s2 = peg$c56;
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c57);
      }
    }
    if (s2 !== peg$FAILED) {
      s3 = peg$parsenumber();
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    if (s0 === peg$FAILED) {
      s0 = peg$parseargName();
    }
    return s0;
  }
  function peg$parseselectOption() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parseargName();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s4 = peg$c6;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s5 = peg$c58();
            if (s5) {
              s5 = void 0;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsemessage();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c8;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c59(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsepluralOption() {
    var s0, s1, s2, s3, s4, s5, s6, s7;
    s0 = peg$currPos;
    s1 = peg$parse_();
    if (s1 !== peg$FAILED) {
      s2 = peg$parsepluralRuleSelectValue();
      if (s2 !== peg$FAILED) {
        s3 = peg$parse_();
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 123) {
            s4 = peg$c6;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c7);
            }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = peg$currPos;
            s5 = peg$c60();
            if (s5) {
              s5 = void 0;
            } else {
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              s6 = peg$parsemessage();
              if (s6 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 125) {
                  s7 = peg$c8;
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) {
                    peg$fail(peg$c9);
                  }
                }
                if (s7 !== peg$FAILED) {
                  peg$savedPos = s0;
                  s1 = peg$c61(s2, s6);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parsewhiteSpace() {
    var s0;
    peg$silentFails++;
    if (peg$c63.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c64);
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c62);
      }
    }
    return s0;
  }
  function peg$parsepatternSyntax() {
    var s0;
    peg$silentFails++;
    if (peg$c66.test(input.charAt(peg$currPos))) {
      s0 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s0 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c67);
      }
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      if (peg$silentFails === 0) {
        peg$fail(peg$c65);
      }
    }
    return s0;
  }
  function peg$parse_() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$parsewhiteSpace();
    while (s2 !== peg$FAILED) {
      s1.push(s2);
      s2 = peg$parsewhiteSpace();
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c68);
      }
    }
    return s0;
  }
  function peg$parsenumber() {
    var s0, s1, s2;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 45) {
      s1 = peg$c70;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c71);
      }
    }
    if (s1 === peg$FAILED) {
      s1 = null;
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseargNumber();
      if (s2 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c72(s1, s2);
        s0 = s1;
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c69);
      }
    }
    return s0;
  }
  function peg$parsedoubleApostrophes() {
    var s0, s1;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.substr(peg$currPos, 2) === peg$c75) {
      s1 = peg$c75;
      peg$currPos += 2;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c76);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c77();
    }
    s0 = s1;
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c74);
      }
    }
    return s0;
  }
  function peg$parsequotedString() {
    var s0, s1, s2, s3, s4, s5;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 39) {
      s1 = peg$c32;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c33);
      }
    }
    if (s1 !== peg$FAILED) {
      s2 = peg$parseescapedChar();
      if (s2 !== peg$FAILED) {
        s3 = peg$currPos;
        s4 = [];
        if (input.substr(peg$currPos, 2) === peg$c75) {
          s5 = peg$c75;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c76);
          }
        }
        if (s5 === peg$FAILED) {
          if (peg$c34.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c35);
            }
          }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          if (input.substr(peg$currPos, 2) === peg$c75) {
            s5 = peg$c75;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c76);
            }
          }
          if (s5 === peg$FAILED) {
            if (peg$c34.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) {
                peg$fail(peg$c35);
              }
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = input.substring(s3, peg$currPos);
        } else {
          s3 = s4;
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s4 = peg$c32;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c33);
            }
          }
          if (s4 === peg$FAILED) {
            s4 = null;
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c78(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
    } else {
      peg$currPos = s0;
      s0 = peg$FAILED;
    }
    return s0;
  }
  function peg$parseunquotedString() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.length > peg$currPos) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c14);
      }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s3 = peg$c79(s2);
      if (s3) {
        s3 = void 0;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 === peg$FAILED) {
      if (input.charCodeAt(peg$currPos) === 10) {
        s1 = peg$c80;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c81);
        }
      }
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    return s0;
  }
  function peg$parseescapedChar() {
    var s0, s1, s2, s3;
    s0 = peg$currPos;
    s1 = peg$currPos;
    if (input.length > peg$currPos) {
      s2 = input.charAt(peg$currPos);
      peg$currPos++;
    } else {
      s2 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c14);
      }
    }
    if (s2 !== peg$FAILED) {
      peg$savedPos = peg$currPos;
      s3 = peg$c82(s2);
      if (s3) {
        s3 = void 0;
      } else {
        s3 = peg$FAILED;
      }
      if (s3 !== peg$FAILED) {
        s2 = [s2, s3];
        s1 = s2;
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
    } else {
      peg$currPos = s1;
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    return s0;
  }
  function peg$parseargNameOrNumber() {
    var s0, s1;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = peg$parseargNumber();
    if (s1 === peg$FAILED) {
      s1 = peg$parseargName();
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c83);
      }
    }
    return s0;
  }
  function peg$parseargNumber() {
    var s0, s1, s2, s3, s4;
    peg$silentFails++;
    s0 = peg$currPos;
    if (input.charCodeAt(peg$currPos) === 48) {
      s1 = peg$c85;
      peg$currPos++;
    } else {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c86);
      }
    }
    if (s1 !== peg$FAILED) {
      peg$savedPos = s0;
      s1 = peg$c87();
    }
    s0 = s1;
    if (s0 === peg$FAILED) {
      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c88.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c89);
        }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c90.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) {
            peg$fail(peg$c91);
          }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c90.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c91);
            }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c92(s1);
      }
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c84);
      }
    }
    return s0;
  }
  function peg$parseargName() {
    var s0, s1, s2, s3, s4;
    peg$silentFails++;
    s0 = peg$currPos;
    s1 = [];
    s2 = peg$currPos;
    s3 = peg$currPos;
    peg$silentFails++;
    s4 = peg$parsewhiteSpace();
    if (s4 === peg$FAILED) {
      s4 = peg$parsepatternSyntax();
    }
    peg$silentFails--;
    if (s4 === peg$FAILED) {
      s3 = void 0;
    } else {
      peg$currPos = s3;
      s3 = peg$FAILED;
    }
    if (s3 !== peg$FAILED) {
      if (input.length > peg$currPos) {
        s4 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s4 = peg$FAILED;
        if (peg$silentFails === 0) {
          peg$fail(peg$c14);
        }
      }
      if (s4 !== peg$FAILED) {
        s3 = [s3, s4];
        s2 = s3;
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
    } else {
      peg$currPos = s2;
      s2 = peg$FAILED;
    }
    if (s2 !== peg$FAILED) {
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$currPos;
        s3 = peg$currPos;
        peg$silentFails++;
        s4 = peg$parsewhiteSpace();
        if (s4 === peg$FAILED) {
          s4 = peg$parsepatternSyntax();
        }
        peg$silentFails--;
        if (s4 === peg$FAILED) {
          s3 = void 0;
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        if (s3 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) {
              peg$fail(peg$c14);
            }
          }
          if (s4 !== peg$FAILED) {
            s3 = [s3, s4];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      }
    } else {
      s1 = peg$FAILED;
    }
    if (s1 !== peg$FAILED) {
      s0 = input.substring(s0, peg$currPos);
    } else {
      s0 = s1;
    }
    peg$silentFails--;
    if (s0 === peg$FAILED) {
      s1 = peg$FAILED;
      if (peg$silentFails === 0) {
        peg$fail(peg$c93);
      }
    }
    return s0;
  }
  var messageCtx = ["root"];
  function isNestedMessageText() {
    return messageCtx.length > 1;
  }
  function isInPluralOption() {
    return messageCtx[messageCtx.length - 1] === "plural";
  }
  function insertLocation() {
    return options && options.captureLocation ? {
      location: location()
    } : {};
  }
  peg$result = peg$startRuleFunction();
  if (peg$result !== peg$FAILED && peg$currPos === input.length) {
    return peg$result;
  } else {
    if (peg$result !== peg$FAILED && peg$currPos < input.length) {
      peg$fail(peg$endExpectation());
    }
    throw peg$buildStructuredError(peg$maxFailExpected, peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null, peg$maxFailPos < input.length ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1) : peg$computeLocation(peg$maxFailPos, peg$maxFailPos));
  }
}
var pegParse = peg$parse;
var __spreadArrays = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var PLURAL_HASHTAG_REGEX = /(^|[^\\])#/g;
function normalizeHashtagInPlural(els) {
  els.forEach(function(el) {
    if (!isPluralElement(el) && !isSelectElement(el)) {
      return;
    }
    Object.keys(el.options).forEach(function(id) {
      var _a;
      var opt = el.options[id];
      var matchingLiteralElIndex = -1;
      var literalEl = void 0;
      for (var i2 = 0; i2 < opt.value.length; i2++) {
        var el_1 = opt.value[i2];
        if (isLiteralElement(el_1) && PLURAL_HASHTAG_REGEX.test(el_1.value)) {
          matchingLiteralElIndex = i2;
          literalEl = el_1;
          break;
        }
      }
      if (literalEl) {
        var newValue = literalEl.value.replace(PLURAL_HASHTAG_REGEX, "$1{" + el.value + ", number}");
        var newEls = pegParse(newValue);
        (_a = opt.value).splice.apply(_a, __spreadArrays([matchingLiteralElIndex, 1], newEls));
      }
      normalizeHashtagInPlural(opt.value);
    });
  });
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
var DATE_TIME_REGEX = /(?:[Eec]{1,6}|G{1,5}|[Qq]{1,5}|(?:[yYur]+|U{1,5})|[ML]{1,5}|d{1,2}|D{1,3}|F{1}|[abB]{1,5}|[hkHK]{1,2}|w{1,2}|W{1}|m{1,2}|s{1,2}|[zZOvVxX]{1,4})(?=([^']*'[^']*')*[^']*$)/g;
function parseDateTimeSkeleton(skeleton) {
  var result = {};
  skeleton.replace(DATE_TIME_REGEX, function(match) {
    var len = match.length;
    switch (match[0]) {
      case "G":
        result.era = len === 4 ? "long" : len === 5 ? "narrow" : "short";
        break;
      case "y":
        result.year = len === 2 ? "2-digit" : "numeric";
        break;
      case "Y":
      case "u":
      case "U":
      case "r":
        throw new RangeError("`Y/u/U/r` (year) patterns are not supported, use `y` instead");
      case "q":
      case "Q":
        throw new RangeError("`q/Q` (quarter) patterns are not supported");
      case "M":
      case "L":
        result.month = ["numeric", "2-digit", "short", "long", "narrow"][len - 1];
        break;
      case "w":
      case "W":
        throw new RangeError("`w/W` (week) patterns are not supported");
      case "d":
        result.day = ["numeric", "2-digit"][len - 1];
        break;
      case "D":
      case "F":
      case "g":
        throw new RangeError("`D/F/g` (day) patterns are not supported, use `d` instead");
      case "E":
        result.weekday = len === 4 ? "short" : len === 5 ? "narrow" : "short";
        break;
      case "e":
        if (len < 4) {
          throw new RangeError("`e..eee` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "c":
        if (len < 4) {
          throw new RangeError("`c..ccc` (weekday) patterns are not supported");
        }
        result.weekday = ["short", "long", "narrow", "short"][len - 4];
        break;
      case "a":
        result.hour12 = true;
        break;
      case "b":
      case "B":
        throw new RangeError("`b/B` (period) patterns are not supported, use `a` instead");
      case "h":
        result.hourCycle = "h12";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "H":
        result.hourCycle = "h23";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "K":
        result.hourCycle = "h11";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "k":
        result.hourCycle = "h24";
        result.hour = ["numeric", "2-digit"][len - 1];
        break;
      case "j":
      case "J":
      case "C":
        throw new RangeError("`j/J/C` (hour) patterns are not supported, use `h/H/K/k` instead");
      case "m":
        result.minute = ["numeric", "2-digit"][len - 1];
        break;
      case "s":
        result.second = ["numeric", "2-digit"][len - 1];
        break;
      case "S":
      case "A":
        throw new RangeError("`S/A` (second) pattenrs are not supported, use `s` instead");
      case "z":
        result.timeZoneName = len < 4 ? "short" : "long";
        break;
      case "Z":
      case "O":
      case "v":
      case "V":
      case "X":
      case "x":
        throw new RangeError("`Z/O/v/V/X/x` (timeZone) pattenrs are not supported, use `z` instead");
    }
    return "";
  });
  return result;
}
function icuUnitToEcma(unit) {
  return unit.replace(/^(.*?)-/, "");
}
var FRACTION_PRECISION_REGEX = /^\.(?:(0+)(\+|#+)?)?$/g;
var SIGNIFICANT_PRECISION_REGEX = /^(@+)?(\+|#+)?$/g;
function parseSignificantPrecision(str) {
  var result = {};
  str.replace(SIGNIFICANT_PRECISION_REGEX, function(_2, g1, g2) {
    if (typeof g2 !== "string") {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length;
    } else if (g2 === "+") {
      result.minimumSignificantDigits = g1.length;
    } else if (g1[0] === "#") {
      result.maximumSignificantDigits = g1.length;
    } else {
      result.minimumSignificantDigits = g1.length;
      result.maximumSignificantDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
    }
    return "";
  });
  return result;
}
function parseSign(str) {
  switch (str) {
    case "sign-auto":
      return {
        signDisplay: "auto"
      };
    case "sign-accounting":
      return {
        currencySign: "accounting"
      };
    case "sign-always":
      return {
        signDisplay: "always"
      };
    case "sign-accounting-always":
      return {
        signDisplay: "always",
        currencySign: "accounting"
      };
    case "sign-except-zero":
      return {
        signDisplay: "exceptZero"
      };
    case "sign-accounting-except-zero":
      return {
        signDisplay: "exceptZero",
        currencySign: "accounting"
      };
    case "sign-never":
      return {
        signDisplay: "never"
      };
  }
}
function parseNotationOptions(opt) {
  var result = {};
  var signOpts = parseSign(opt);
  if (signOpts) {
    return signOpts;
  }
  return result;
}
function convertNumberSkeletonToNumberFormatOptions(tokens) {
  var result = {};
  for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
    var token = tokens_1[_i];
    switch (token.stem) {
      case "percent":
        result.style = "percent";
        continue;
      case "currency":
        result.style = "currency";
        result.currency = token.options[0];
        continue;
      case "group-off":
        result.useGrouping = false;
        continue;
      case "precision-integer":
        result.maximumFractionDigits = 0;
        continue;
      case "measure-unit":
        result.style = "unit";
        result.unit = icuUnitToEcma(token.options[0]);
        continue;
      case "compact-short":
        result.notation = "compact";
        result.compactDisplay = "short";
        continue;
      case "compact-long":
        result.notation = "compact";
        result.compactDisplay = "long";
        continue;
      case "scientific":
        result = __assign$1(__assign$1(__assign$1({}, result), { notation: "scientific" }), token.options.reduce(function(all, opt) {
          return __assign$1(__assign$1({}, all), parseNotationOptions(opt));
        }, {}));
        continue;
      case "engineering":
        result = __assign$1(__assign$1(__assign$1({}, result), { notation: "engineering" }), token.options.reduce(function(all, opt) {
          return __assign$1(__assign$1({}, all), parseNotationOptions(opt));
        }, {}));
        continue;
      case "notation-simple":
        result.notation = "standard";
        continue;
      case "unit-width-narrow":
        result.currencyDisplay = "narrowSymbol";
        result.unitDisplay = "narrow";
        continue;
      case "unit-width-short":
        result.currencyDisplay = "code";
        result.unitDisplay = "short";
        continue;
      case "unit-width-full-name":
        result.currencyDisplay = "name";
        result.unitDisplay = "long";
        continue;
      case "unit-width-iso-code":
        result.currencyDisplay = "symbol";
        continue;
    }
    if (FRACTION_PRECISION_REGEX.test(token.stem)) {
      if (token.options.length > 1) {
        throw new RangeError("Fraction-precision stems only accept a single optional option");
      }
      token.stem.replace(FRACTION_PRECISION_REGEX, function(match, g1, g2) {
        if (match === ".") {
          result.maximumFractionDigits = 0;
        } else if (g2 === "+") {
          result.minimumFractionDigits = g2.length;
        } else if (g1[0] === "#") {
          result.maximumFractionDigits = g1.length;
        } else {
          result.minimumFractionDigits = g1.length;
          result.maximumFractionDigits = g1.length + (typeof g2 === "string" ? g2.length : 0);
        }
        return "";
      });
      if (token.options.length) {
        result = __assign$1(__assign$1({}, result), parseSignificantPrecision(token.options[0]));
      }
      continue;
    }
    if (SIGNIFICANT_PRECISION_REGEX.test(token.stem)) {
      result = __assign$1(__assign$1({}, result), parseSignificantPrecision(token.stem));
      continue;
    }
    var signOpts = parseSign(token.stem);
    if (signOpts) {
      result = __assign$1(__assign$1({}, result), signOpts);
    }
  }
  return result;
}
function parse(input, opts) {
  var els = pegParse(input, opts);
  if (!opts || opts.normalizeHashtagInPlural !== false) {
    normalizeHashtagInPlural(els);
  }
  return els;
}
var __spreadArrays$1 = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
function getCacheId(inputs) {
  return JSON.stringify(inputs.map(function(input) {
    return input && typeof input === "object" ? orderedProps(input) : input;
  }));
}
function orderedProps(obj) {
  return Object.keys(obj).sort().map(function(k2) {
    var _a;
    return _a = {}, _a[k2] = obj[k2], _a;
  });
}
var memoizeFormatConstructor = function(FormatConstructor, cache) {
  if (cache === void 0) {
    cache = {};
  }
  return function() {
    var _a;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var cacheId = getCacheId(args);
    var format = cacheId && cache[cacheId];
    if (!format) {
      format = new ((_a = FormatConstructor).bind.apply(_a, __spreadArrays$1([void 0], args)))();
      if (cacheId) {
        cache[cacheId] = format;
      }
    }
    return format;
  };
};
var __extends$1 = function() {
  var extendStatics2 = function(d3, b2) {
    extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
      d4.__proto__ = b3;
    } || function(d4, b3) {
      for (var p2 in b3)
        if (b3.hasOwnProperty(p2))
          d4[p2] = b3[p2];
    };
    return extendStatics2(d3, b2);
  };
  return function(d3, b2) {
    extendStatics2(d3, b2);
    function __() {
      this.constructor = d3;
    }
    d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  };
}();
var __spreadArrays$2 = function() {
  for (var s2 = 0, i2 = 0, il = arguments.length; i2 < il; i2++)
    s2 += arguments[i2].length;
  for (var r2 = Array(s2), k2 = 0, i2 = 0; i2 < il; i2++)
    for (var a2 = arguments[i2], j2 = 0, jl = a2.length; j2 < jl; j2++, k2++)
      r2[k2] = a2[j2];
  return r2;
};
var FormatError = function(_super) {
  __extends$1(FormatError2, _super);
  function FormatError2(msg, variableId) {
    var _this = _super.call(this, msg) || this;
    _this.variableId = variableId;
    return _this;
  }
  return FormatError2;
}(Error);
function mergeLiteral(parts) {
  if (parts.length < 2) {
    return parts;
  }
  return parts.reduce(function(all, part) {
    var lastPart = all[all.length - 1];
    if (!lastPart || lastPart.type !== 0 || part.type !== 0) {
      all.push(part);
    } else {
      lastPart.value += part.value;
    }
    return all;
  }, []);
}
function formatToParts(els, locales, formatters, formats, values, currentPluralValue, originalMessage) {
  if (els.length === 1 && isLiteralElement(els[0])) {
    return [
      {
        type: 0,
        value: els[0].value
      }
    ];
  }
  var result = [];
  for (var _i = 0, els_1 = els; _i < els_1.length; _i++) {
    var el = els_1[_i];
    if (isLiteralElement(el)) {
      result.push({
        type: 0,
        value: el.value
      });
      continue;
    }
    if (isPoundElement(el)) {
      if (typeof currentPluralValue === "number") {
        result.push({
          type: 0,
          value: formatters.getNumberFormat(locales).format(currentPluralValue)
        });
      }
      continue;
    }
    var varName = el.value;
    if (!(values && varName in values)) {
      throw new FormatError('The intl string context variable "' + varName + '" was not provided to the string "' + originalMessage + '"');
    }
    var value = values[varName];
    if (isArgumentElement(el)) {
      if (!value || typeof value === "string" || typeof value === "number") {
        value = typeof value === "string" || typeof value === "number" ? String(value) : "";
      }
      result.push({
        type: 1,
        value
      });
      continue;
    }
    if (isDateElement(el)) {
      var style = typeof el.style === "string" ? formats.date[el.style] : void 0;
      result.push({
        type: 0,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isTimeElement(el)) {
      var style = typeof el.style === "string" ? formats.time[el.style] : isDateTimeSkeleton(el.style) ? parseDateTimeSkeleton(el.style.pattern) : void 0;
      result.push({
        type: 0,
        value: formatters.getDateTimeFormat(locales, style).format(value)
      });
      continue;
    }
    if (isNumberElement(el)) {
      var style = typeof el.style === "string" ? formats.number[el.style] : isNumberSkeleton(el.style) ? convertNumberSkeletonToNumberFormatOptions(el.style.tokens) : void 0;
      result.push({
        type: 0,
        value: formatters.getNumberFormat(locales, style).format(value)
      });
      continue;
    }
    if (isSelectElement(el)) {
      var opt = el.options[value] || el.options.other;
      if (!opt) {
        throw new RangeError('Invalid values for "' + el.value + '": "' + value + '". Options are "' + Object.keys(el.options).join('", "') + '"');
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values));
      continue;
    }
    if (isPluralElement(el)) {
      var opt = el.options["=" + value];
      if (!opt) {
        if (!Intl.PluralRules) {
          throw new FormatError('Intl.PluralRules is not available in this environment.\nTry polyfilling it using "@formatjs/intl-pluralrules"\n');
        }
        var rule = formatters.getPluralRules(locales, { type: el.pluralType }).select(value - (el.offset || 0));
        opt = el.options[rule] || el.options.other;
      }
      if (!opt) {
        throw new RangeError('Invalid values for "' + el.value + '": "' + value + '". Options are "' + Object.keys(el.options).join('", "') + '"');
      }
      result.push.apply(result, formatToParts(opt.value, locales, formatters, formats, values, value - (el.offset || 0)));
      continue;
    }
  }
  return mergeLiteral(result);
}
function formatToString(els, locales, formatters, formats, values, originalMessage) {
  var parts = formatToParts(els, locales, formatters, formats, values, void 0, originalMessage);
  if (parts.length === 1) {
    return parts[0].value;
  }
  return parts.reduce(function(all, part) {
    return all += part.value;
  }, "");
}
var domParser;
var TOKEN_DELIMITER = "@@";
var TOKEN_REGEX = /@@(\d+_\d+)@@/g;
var counter = 0;
function generateId() {
  return Date.now() + "_" + ++counter;
}
function restoreRichPlaceholderMessage(text2, objectParts) {
  return text2.split(TOKEN_REGEX).filter(Boolean).map(function(c2) {
    return objectParts[c2] != null ? objectParts[c2] : c2;
  }).reduce(function(all, c2) {
    if (!all.length) {
      all.push(c2);
    } else if (typeof c2 === "string" && typeof all[all.length - 1] === "string") {
      all[all.length - 1] += c2;
    } else {
      all.push(c2);
    }
    return all;
  }, []);
}
var SIMPLE_XML_REGEX = /(<([0-9a-zA-Z-_]*?)>(.*?)<\/([0-9a-zA-Z-_]*?)>)|(<[0-9a-zA-Z-_]*?\/>)/;
var TEMPLATE_ID = Date.now() + "@@";
var VOID_ELEMENTS = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
];
function formatHTMLElement(el, objectParts, values) {
  var tagName = el.tagName;
  var outerHTML = el.outerHTML, textContent = el.textContent, childNodes = el.childNodes;
  if (!tagName) {
    return restoreRichPlaceholderMessage(textContent || "", objectParts);
  }
  tagName = tagName.toLowerCase();
  var isVoidElement = ~VOID_ELEMENTS.indexOf(tagName);
  var formatFnOrValue = values[tagName];
  if (formatFnOrValue && isVoidElement) {
    throw new FormatError(tagName + " is a self-closing tag and can not be used, please use another tag name.");
  }
  if (!childNodes.length) {
    return [outerHTML];
  }
  var chunks = Array.prototype.slice.call(childNodes).reduce(function(all, child) {
    return all.concat(formatHTMLElement(child, objectParts, values));
  }, []);
  if (!formatFnOrValue) {
    return __spreadArrays$2(["<" + tagName + ">"], chunks, ["</" + tagName + ">"]);
  }
  if (typeof formatFnOrValue === "function") {
    return [formatFnOrValue.apply(void 0, chunks)];
  }
  return [formatFnOrValue];
}
function formatHTMLMessage(els, locales, formatters, formats, values, originalMessage) {
  var parts = formatToParts(els, locales, formatters, formats, values, void 0, originalMessage);
  var objectParts = {};
  var formattedMessage = parts.reduce(function(all, part) {
    if (part.type === 0) {
      return all += part.value;
    }
    var id = generateId();
    objectParts[id] = part.value;
    return all += "" + TOKEN_DELIMITER + id + TOKEN_DELIMITER;
  }, "");
  if (!SIMPLE_XML_REGEX.test(formattedMessage)) {
    return restoreRichPlaceholderMessage(formattedMessage, objectParts);
  }
  if (!values) {
    throw new FormatError("Message has placeholders but no values was given");
  }
  if (typeof DOMParser === "undefined") {
    throw new FormatError("Cannot format XML message without DOMParser");
  }
  if (!domParser) {
    domParser = new DOMParser();
  }
  var content = domParser.parseFromString('<formatted-message id="' + TEMPLATE_ID + '">' + formattedMessage + "</formatted-message>", "text/html").getElementById(TEMPLATE_ID);
  if (!content) {
    throw new FormatError("Malformed HTML message " + formattedMessage);
  }
  var tagsToFormat = Object.keys(values).filter(function(varName) {
    return !!content.getElementsByTagName(varName).length;
  });
  if (!tagsToFormat.length) {
    return restoreRichPlaceholderMessage(formattedMessage, objectParts);
  }
  var caseSensitiveTags = tagsToFormat.filter(function(tagName) {
    return tagName !== tagName.toLowerCase();
  });
  if (caseSensitiveTags.length) {
    throw new FormatError("HTML tag must be lowercased but the following tags are not: " + caseSensitiveTags.join(", "));
  }
  return Array.prototype.slice.call(content.childNodes).reduce(function(all, child) {
    return all.concat(formatHTMLElement(child, objectParts, values));
  }, []);
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function(t) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t[p2] = s2[p2];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function mergeConfig(c1, c2) {
  if (!c2) {
    return c1;
  }
  return __assign$2(__assign$2(__assign$2({}, c1 || {}), c2 || {}), Object.keys(c1).reduce(function(all, k2) {
    all[k2] = __assign$2(__assign$2({}, c1[k2]), c2[k2] || {});
    return all;
  }, {}));
}
function mergeConfigs(defaultConfig, configs) {
  if (!configs) {
    return defaultConfig;
  }
  return Object.keys(defaultConfig).reduce(function(all, k2) {
    all[k2] = mergeConfig(defaultConfig[k2], configs[k2]);
    return all;
  }, __assign$2({}, defaultConfig));
}
function createDefaultFormatters(cache) {
  if (cache === void 0) {
    cache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
  }
  return {
    getNumberFormat: memoizeFormatConstructor(Intl.NumberFormat, cache.number),
    getDateTimeFormat: memoizeFormatConstructor(Intl.DateTimeFormat, cache.dateTime),
    getPluralRules: memoizeFormatConstructor(Intl.PluralRules, cache.pluralRules)
  };
}
var IntlMessageFormat = function() {
  function IntlMessageFormat2(message, locales, overrideFormats, opts) {
    var _this = this;
    if (locales === void 0) {
      locales = IntlMessageFormat2.defaultLocale;
    }
    this.formatterCache = {
      number: {},
      dateTime: {},
      pluralRules: {}
    };
    this.format = function(values) {
      return formatToString(_this.ast, _this.locales, _this.formatters, _this.formats, values, _this.message);
    };
    this.formatToParts = function(values) {
      return formatToParts(_this.ast, _this.locales, _this.formatters, _this.formats, values, void 0, _this.message);
    };
    this.formatHTMLMessage = function(values) {
      return formatHTMLMessage(_this.ast, _this.locales, _this.formatters, _this.formats, values, _this.message);
    };
    this.resolvedOptions = function() {
      return {
        locale: Intl.NumberFormat.supportedLocalesOf(_this.locales)[0]
      };
    };
    this.getAst = function() {
      return _this.ast;
    };
    if (typeof message === "string") {
      this.message = message;
      if (!IntlMessageFormat2.__parse) {
        throw new TypeError("IntlMessageFormat.__parse must be set to process `message` of type `string`");
      }
      this.ast = IntlMessageFormat2.__parse(message, {
        normalizeHashtagInPlural: false
      });
    } else {
      this.ast = message;
    }
    if (!Array.isArray(this.ast)) {
      throw new TypeError("A message must be provided as a String or AST.");
    }
    this.formats = mergeConfigs(IntlMessageFormat2.formats, overrideFormats);
    this.locales = locales;
    this.formatters = opts && opts.formatters || createDefaultFormatters(this.formatterCache);
  }
  IntlMessageFormat2.defaultLocale = new Intl.NumberFormat().resolvedOptions().locale;
  IntlMessageFormat2.__parse = parse;
  IntlMessageFormat2.formats = {
    number: {
      currency: {
        style: "currency"
      },
      percent: {
        style: "percent"
      }
    },
    date: {
      short: {
        month: "numeric",
        day: "numeric",
        year: "2-digit"
      },
      medium: {
        month: "short",
        day: "numeric",
        year: "numeric"
      },
      long: {
        month: "long",
        day: "numeric",
        year: "numeric"
      },
      full: {
        weekday: "long",
        month: "long",
        day: "numeric",
        year: "numeric"
      }
    },
    time: {
      short: {
        hour: "numeric",
        minute: "numeric"
      },
      medium: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric"
      },
      long: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      },
      full: {
        hour: "numeric",
        minute: "numeric",
        second: "numeric",
        timeZoneName: "short"
      }
    }
  };
  return IntlMessageFormat2;
}();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn, basedir, module) {
  return module = {
    path: basedir,
    exports: {},
    require: function(path2, base) {
      return commonjsRequire(path2, base === void 0 || base === null ? module.path : base);
    }
  }, fn(module, module.exports), module.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
var microMemoize = createCommonjsModule(function(module, exports) {
  (function(global2, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    var DEFAULT_OPTIONS_KEYS = {
      isEqual: true,
      isMatchingKey: true,
      isPromise: true,
      maxSize: true,
      onCacheAdd: true,
      onCacheChange: true,
      onCacheHit: true,
      transformKey: true
    };
    var slice = Array.prototype.slice;
    function cloneArray(arrayLike) {
      var length = arrayLike.length;
      if (!length) {
        return [];
      }
      if (length === 1) {
        return [arrayLike[0]];
      }
      if (length === 2) {
        return [arrayLike[0], arrayLike[1]];
      }
      if (length === 3) {
        return [arrayLike[0], arrayLike[1], arrayLike[2]];
      }
      return slice.call(arrayLike, 0);
    }
    function getCustomOptions(options) {
      var customOptions = {};
      for (var key in options) {
        if (!DEFAULT_OPTIONS_KEYS[key]) {
          customOptions[key] = options[key];
        }
      }
      return customOptions;
    }
    function isMemoized(fn) {
      return typeof fn === "function" && fn.isMemoized;
    }
    function isSameValueZero(object1, object2) {
      return object1 === object2 || object1 !== object1 && object2 !== object2;
    }
    function mergeOptions(existingOptions, newOptions) {
      var target = {};
      for (var key in existingOptions) {
        target[key] = existingOptions[key];
      }
      for (var key in newOptions) {
        target[key] = newOptions[key];
      }
      return target;
    }
    var Cache = function() {
      function Cache2(options) {
        this.keys = [];
        this.values = [];
        this.options = options;
        var isMatchingKeyFunction = typeof options.isMatchingKey === "function";
        if (isMatchingKeyFunction) {
          this.getKeyIndex = this._getKeyIndexFromMatchingKey;
        } else if (options.maxSize > 1) {
          this.getKeyIndex = this._getKeyIndexForMany;
        } else {
          this.getKeyIndex = this._getKeyIndexForSingle;
        }
        this.canTransformKey = typeof options.transformKey === "function";
        this.shouldCloneArguments = this.canTransformKey || isMatchingKeyFunction;
        this.shouldUpdateOnAdd = typeof options.onCacheAdd === "function";
        this.shouldUpdateOnChange = typeof options.onCacheChange === "function";
        this.shouldUpdateOnHit = typeof options.onCacheHit === "function";
      }
      Object.defineProperty(Cache2.prototype, "size", {
        get: function() {
          return this.keys.length;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Cache2.prototype, "snapshot", {
        get: function() {
          return {
            keys: cloneArray(this.keys),
            size: this.size,
            values: cloneArray(this.values)
          };
        },
        enumerable: true,
        configurable: true
      });
      Cache2.prototype._getKeyIndexFromMatchingKey = function(keyToMatch) {
        var _a = this.options, isMatchingKey = _a.isMatchingKey, maxSize = _a.maxSize;
        var keys = this.keys;
        var keysLength = keys.length;
        if (!keysLength) {
          return -1;
        }
        if (isMatchingKey(keys[0], keyToMatch)) {
          return 0;
        }
        if (maxSize > 1) {
          for (var index = 1; index < keysLength; index++) {
            if (isMatchingKey(keys[index], keyToMatch)) {
              return index;
            }
          }
        }
        return -1;
      };
      Cache2.prototype._getKeyIndexForMany = function(keyToMatch) {
        var isEqual = this.options.isEqual;
        var keys = this.keys;
        var keysLength = keys.length;
        if (!keysLength) {
          return -1;
        }
        if (keysLength === 1) {
          return this._getKeyIndexForSingle(keyToMatch);
        }
        var keyLength = keyToMatch.length;
        var existingKey;
        var argIndex;
        if (keyLength > 1) {
          for (var index = 0; index < keysLength; index++) {
            existingKey = keys[index];
            if (existingKey.length === keyLength) {
              argIndex = 0;
              for (; argIndex < keyLength; argIndex++) {
                if (!isEqual(existingKey[argIndex], keyToMatch[argIndex])) {
                  break;
                }
              }
              if (argIndex === keyLength) {
                return index;
              }
            }
          }
        } else {
          for (var index = 0; index < keysLength; index++) {
            existingKey = keys[index];
            if (existingKey.length === keyLength && isEqual(existingKey[0], keyToMatch[0])) {
              return index;
            }
          }
        }
        return -1;
      };
      Cache2.prototype._getKeyIndexForSingle = function(keyToMatch) {
        var keys = this.keys;
        if (!keys.length) {
          return -1;
        }
        var existingKey = keys[0];
        var length = existingKey.length;
        if (keyToMatch.length !== length) {
          return -1;
        }
        var isEqual = this.options.isEqual;
        if (length > 1) {
          for (var index = 0; index < length; index++) {
            if (!isEqual(existingKey[index], keyToMatch[index])) {
              return -1;
            }
          }
          return 0;
        }
        return isEqual(existingKey[0], keyToMatch[0]) ? 0 : -1;
      };
      Cache2.prototype.orderByLru = function(key, value, startingIndex) {
        var keys = this.keys;
        var values = this.values;
        var currentLength = keys.length;
        var index = startingIndex;
        while (index--) {
          keys[index + 1] = keys[index];
          values[index + 1] = values[index];
        }
        keys[0] = key;
        values[0] = value;
        var maxSize = this.options.maxSize;
        if (currentLength === maxSize && startingIndex === currentLength) {
          keys.pop();
          values.pop();
        } else if (startingIndex >= maxSize) {
          keys.length = values.length = maxSize;
        }
      };
      Cache2.prototype.updateAsyncCache = function(memoized) {
        var _this = this;
        var _a = this.options, onCacheChange = _a.onCacheChange, onCacheHit = _a.onCacheHit;
        var firstKey = this.keys[0];
        var firstValue = this.values[0];
        this.values[0] = firstValue.then(function(value) {
          if (_this.shouldUpdateOnHit) {
            onCacheHit(_this, _this.options, memoized);
          }
          if (_this.shouldUpdateOnChange) {
            onCacheChange(_this, _this.options, memoized);
          }
          return value;
        }, function(error) {
          var keyIndex = _this.getKeyIndex(firstKey);
          if (keyIndex !== -1) {
            _this.keys.splice(keyIndex, 1);
            _this.values.splice(keyIndex, 1);
          }
          throw error;
        });
      };
      return Cache2;
    }();
    function createMemoizedFunction(fn, options) {
      if (options === void 0) {
        options = {};
      }
      if (isMemoized(fn)) {
        return createMemoizedFunction(fn.fn, mergeOptions(fn.options, options));
      }
      if (typeof fn !== "function") {
        throw new TypeError("You must pass a function to `memoize`.");
      }
      var _a = options.isEqual, isEqual = _a === void 0 ? isSameValueZero : _a, isMatchingKey = options.isMatchingKey, _b = options.isPromise, isPromise2 = _b === void 0 ? false : _b, _c = options.maxSize, maxSize = _c === void 0 ? 1 : _c, onCacheAdd = options.onCacheAdd, onCacheChange = options.onCacheChange, onCacheHit = options.onCacheHit, transformKey = options.transformKey;
      var normalizedOptions = mergeOptions({
        isEqual,
        isMatchingKey,
        isPromise: isPromise2,
        maxSize,
        onCacheAdd,
        onCacheChange,
        onCacheHit,
        transformKey
      }, getCustomOptions(options));
      var cache = new Cache(normalizedOptions);
      var keys = cache.keys, values = cache.values, canTransformKey = cache.canTransformKey, shouldCloneArguments = cache.shouldCloneArguments, shouldUpdateOnAdd = cache.shouldUpdateOnAdd, shouldUpdateOnChange = cache.shouldUpdateOnChange, shouldUpdateOnHit = cache.shouldUpdateOnHit;
      var memoized = function memoized2() {
        var key = shouldCloneArguments ? cloneArray(arguments) : arguments;
        if (canTransformKey) {
          key = transformKey(key);
        }
        var keyIndex = keys.length ? cache.getKeyIndex(key) : -1;
        if (keyIndex !== -1) {
          if (shouldUpdateOnHit) {
            onCacheHit(cache, normalizedOptions, memoized2);
          }
          if (keyIndex) {
            cache.orderByLru(keys[keyIndex], values[keyIndex], keyIndex);
            if (shouldUpdateOnChange) {
              onCacheChange(cache, normalizedOptions, memoized2);
            }
          }
        } else {
          var newValue = fn.apply(this, arguments);
          var newKey = shouldCloneArguments ? key : cloneArray(arguments);
          cache.orderByLru(newKey, newValue, keys.length);
          if (isPromise2) {
            cache.updateAsyncCache(memoized2);
          }
          if (shouldUpdateOnAdd) {
            onCacheAdd(cache, normalizedOptions, memoized2);
          }
          if (shouldUpdateOnChange) {
            onCacheChange(cache, normalizedOptions, memoized2);
          }
        }
        return values[0];
      };
      memoized.cache = cache;
      memoized.fn = fn;
      memoized.isMemoized = true;
      memoized.options = normalizedOptions;
      return memoized;
    }
    return createMemoizedFunction;
  });
});
function o() {
}
var r = (t) => t;
function i(t, e) {
  for (const n2 in e)
    t[n2] = e[n2];
  return t;
}
function c(t) {
  return t && typeof t == "object" && typeof t.then == "function";
}
function s(t) {
  return t();
}
function u() {
  return Object.create(null);
}
function a(t) {
  t.forEach(s);
}
function l(t) {
  return typeof t == "function";
}
function f(t, e) {
  const n2 = t.subscribe(e);
  return n2.unsubscribe ? () => n2.unsubscribe() : n2;
}
function d2(t, e, n2) {
  return t[1] ? i({}, i(e.$$scope.ctx, t[1](n2 ? n2(e) : {}))) : e.$$scope.ctx;
}
var p = (t, e) => Object.prototype.hasOwnProperty.call(t, e);
var h = typeof window != "undefined";
var _ = h ? () => window.performance.now() : () => Date.now();
var m = h ? (t) => requestAnimationFrame(t) : o;
var g = new Set();
var b;
var F = false;
function v() {
  g.forEach((t) => {
    t[0](_()) || (g.delete(t), t[1]());
  }), (F = g.size > 0) && m(v);
}
function $(t) {
  let e;
  return F || (F = true, m(v)), { promise: new Promise((n2) => {
    g.add(e = [t, n2]);
  }), abort() {
    g.delete(e);
  } };
}
function y(t, e) {
  t.appendChild(e);
}
function w(t, e, n2) {
  t.insertBefore(e, n2 || null);
}
function k(t) {
  t.parentNode.removeChild(t);
}
function x2(t) {
  return document.createElement(t);
}
function E(t) {
  return document.createElementNS("http://www.w3.org/2000/svg", t);
}
function S3(t) {
  return document.createTextNode(t);
}
function O(t, e, n2, o2) {
  return t.addEventListener(e, n2, o2), () => t.removeEventListener(e, n2, o2);
}
function C(t, e, n2) {
  n2 == null ? t.removeAttribute(e) : t.getAttribute(e) !== n2 && t.setAttribute(e, n2);
}
function D(t) {
  return Array.from(t.childNodes);
}
function j(t, e) {
  for (let n2 = 0; n2 < t.length; n2 += 1) {
    const o2 = t[n2];
    if (o2.nodeType === 3)
      return o2.data = "" + e, t.splice(n2, 1)[0];
  }
  return S3(e);
}
function A(t, e) {
  const n2 = document.createEvent("CustomEvent");
  return n2.initCustomEvent(t, false, false, e), n2;
}
var M;
var L = 0;
var P = {};
function R(t, e, n2, o2, r2, i2, c2, s2 = 0) {
  const u2 = 16.666 / o2;
  let a2 = "{\n";
  for (let t2 = 0; t2 <= 1; t2 += u2) {
    const o3 = e + (n2 - e) * i2(t2);
    a2 += 100 * t2 + `%{${c2(o3, 1 - o3)}}
`;
  }
  const l2 = a2 + `100% {${c2(n2, 1 - n2)}}
}`, f6 = `__svelte_${function(t2) {
    let e2 = 5381, n3 = t2.length;
    for (; n3--; )
      e2 = (e2 << 5) - e2 ^ t2.charCodeAt(n3);
    return e2 >>> 0;
  }(l2)}_${s2}`;
  if (!P[f6]) {
    if (!b) {
      const t2 = x2("style");
      document.head.appendChild(t2), b = t2.sheet;
    }
    P[f6] = true, b.insertRule(`@keyframes ${f6} ${l2}`, b.cssRules.length);
  }
  const d3 = t.style.animation || "";
  return t.style.animation = `${d3 ? `${d3}, ` : ""}${f6} ${o2}ms linear ${r2}ms 1 both`, L += 1, f6;
}
function q(t, e) {
  t.style.animation = (t.style.animation || "").split(", ").filter(e ? (t2) => t2.indexOf(e) < 0 : (t2) => t2.indexOf("__svelte") === -1).join(", "), e && !--L && m(() => {
    if (L)
      return;
    let t2 = b.cssRules.length;
    for (; t2--; )
      b.deleteRule(t2);
    P = {};
  });
}
function N(t, e) {
  const n2 = t.getBoundingClientRect();
  if (e.left !== n2.left || e.top !== n2.top) {
    const o2 = getComputedStyle(t), r2 = o2.transform === "none" ? "" : o2.transform;
    t.style.transform = `${r2} translate(${e.left - n2.left}px, ${e.top - n2.top}px)`;
  }
}
function T3(t) {
  M = t;
}
function z() {
  if (!M)
    throw new Error("Function called outside component initialization");
  return M;
}
var B = [];
var U = [];
var H2 = [];
var I = [];
var J = Promise.resolve();
var V;
var Y = false;
function G3() {
  Y || (Y = true, J.then(Q));
}
function K3(t) {
  H2.push(t);
}
function Q() {
  const t = new Set();
  do {
    for (; B.length; ) {
      const t2 = B.shift();
      T3(t2), W4(t2.$$);
    }
    for (; U.length; )
      U.pop()();
    for (let e = 0; e < H2.length; e += 1) {
      const n2 = H2[e];
      t.has(n2) || (n2(), t.add(n2));
    }
    H2.length = 0;
  } while (B.length);
  for (; I.length; )
    I.pop()();
  Y = false;
}
function W4(t) {
  t.fragment !== null && (t.update(t.dirty), a(t.before_update), t.fragment && t.fragment.p(t.dirty, t.ctx), t.dirty = null, t.after_update.forEach(K3));
}
function X() {
  return V || (V = Promise.resolve()).then(() => {
    V = null;
  }), V;
}
function Z(t, e, n2) {
  t.dispatchEvent(A(`${e ? "intro" : "outro"}${n2}`));
}
var tt = new Set();
var et;
function nt() {
  et = { r: 0, c: [], p: et };
}
function ot() {
  et.r || a(et.c), et = et.p;
}
function rt(t, e) {
  t && t.i && (tt.delete(t), t.i(e));
}
function it(t, e, n2, o2) {
  if (t && t.o) {
    if (tt.has(t))
      return;
    tt.add(t), et.c.push(() => {
      tt.delete(t), o2 && (n2 && t.d(1), o2());
    }), t.o(e);
  }
}
var ct = { duration: 0 };
var st = typeof window != "undefined" ? window : global;
function ut(t, e) {
  t.d(1), e.delete(t.key);
}
function at(t, e) {
  it(t, 1, 1, () => {
    e.delete(t.key);
  });
}
var lt = new Set(["allowfullscreen", "allowpaymentrequest", "async", "autofocus", "autoplay", "checked", "controls", "default", "defer", "disabled", "formnovalidate", "hidden", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "selected"]);
var ft = /[\s'">/=\u{FDD0}-\u{FDEF}\u{FFFE}\u{FFFF}\u{1FFFE}\u{1FFFF}\u{2FFFE}\u{2FFFF}\u{3FFFE}\u{3FFFF}\u{4FFFE}\u{4FFFF}\u{5FFFE}\u{5FFFF}\u{6FFFE}\u{6FFFF}\u{7FFFE}\u{7FFFF}\u{8FFFE}\u{8FFFF}\u{9FFFE}\u{9FFFF}\u{AFFFE}\u{AFFFF}\u{BFFFE}\u{BFFFF}\u{CFFFE}\u{CFFFF}\u{DFFFE}\u{DFFFF}\u{EFFFE}\u{EFFFF}\u{FFFFE}\u{FFFFF}\u{10FFFE}\u{10FFFF}]/u;
var dt = { '"': "&quot;", "'": "&#39;", "&": "&amp;", "<": "&lt;", ">": "&gt;" };
function pt(t) {
  return String(t).replace(/["'&<>]/g, (t2) => dt[t2]);
}
var ht;
var _t;
function mt(t, e, n2) {
  const { fragment: o2, on_mount: r2, on_destroy: i2, after_update: c2 } = t.$$;
  o2 && o2.m(e, n2), K3(() => {
    const e2 = r2.map(s).filter(l);
    i2 ? i2.push(...e2) : a(e2), t.$$.on_mount = [];
  }), c2.forEach(K3);
}
function gt(t, e) {
  const n2 = t.$$;
  n2.fragment !== null && (a(n2.on_destroy), n2.fragment && n2.fragment.d(e), n2.on_destroy = n2.fragment = null, n2.ctx = {});
}
typeof HTMLElement == "function" && (_t = class extends HTMLElement {
  constructor() {
    super(), this.attachShadow({ mode: "open" });
  }
  connectedCallback() {
    for (const t in this.$$.slotted)
      this.appendChild(this.$$.slotted[t]);
  }
  attributeChangedCallback(t, e, n2) {
    this[t] = n2;
  }
  $destroy() {
    gt(this, 1), this.$destroy = o;
  }
  $on(t, e) {
    const n2 = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return n2.push(e), () => {
      const t2 = n2.indexOf(e);
      t2 !== -1 && n2.splice(t2, 1);
    };
  }
  $set() {
  }
});
var bt = class {
  $destroy() {
    gt(this, 1), this.$destroy = o;
  }
  $on(t, e) {
    const n2 = this.$$.callbacks[t] || (this.$$.callbacks[t] = []);
    return n2.push(e), () => {
      const t2 = n2.indexOf(e);
      t2 !== -1 && n2.splice(t2, 1);
    };
  }
  $set() {
  }
};
function Ft(t, e) {
  document.dispatchEvent(A(t, e));
}
function vt(t) {
  Ft("SvelteDOMRemove", { node: t }), k(t);
}
var $t;
var yt;
var wt;
var kt = Object.freeze({ __proto__: null, HtmlTag: class {
  constructor(t, e = null) {
    this.e = x2("div"), this.a = e, this.u(t);
  }
  m(t, e = null) {
    for (let n2 = 0; n2 < this.n.length; n2 += 1)
      w(t, this.n[n2], e);
    this.t = t;
  }
  u(t) {
    this.e.innerHTML = t, this.n = Array.from(this.e.childNodes);
  }
  p(t) {
    this.d(), this.u(t), this.m(this.t, this.a);
  }
  d() {
    this.n.forEach(k);
  }
}, SvelteComponent: bt, SvelteComponentDev: class extends bt {
  constructor(t) {
    if (!t || !t.target && !t.$$inline)
      throw new Error("'target' is a required option");
    super();
  }
  $destroy() {
    super.$destroy(), this.$destroy = () => {
      console.warn("Component was already destroyed");
    };
  }
}, get SvelteElement() {
  return _t;
}, add_attribute: function(t, e, n2) {
  return e == null || n2 && !e ? "" : ` ${t}${e === true ? "" : `=${typeof e == "string" ? JSON.stringify(pt(e)) : `"${e}"`}`}`;
}, add_classes: function(t) {
  return t ? ` class="${t}"` : "";
}, add_flush_callback: function(t) {
  I.push(t);
}, add_location: function(t, e, n2, o2, r2) {
  t.__svelte_meta = { loc: { file: e, line: n2, column: o2, char: r2 } };
}, add_render_callback: K3, add_resize_listener: function(t, e) {
  getComputedStyle(t).position === "static" && (t.style.position = "relative");
  const n2 = document.createElement("object");
  let o2;
  return n2.setAttribute("style", "display: block; position: absolute; top: 0; left: 0; height: 100%; width: 100%; overflow: hidden; pointer-events: none; z-index: -1;"), n2.setAttribute("aria-hidden", "true"), n2.type = "text/html", n2.tabIndex = -1, n2.onload = () => {
    (o2 = n2.contentDocument.defaultView).addEventListener("resize", e);
  }, /Trident/.test(navigator.userAgent) ? (t.appendChild(n2), n2.data = "about:blank") : (n2.data = "about:blank", t.appendChild(n2)), { cancel: () => {
    o2 && o2.removeEventListener && o2.removeEventListener("resize", e), t.removeChild(n2);
  } };
}, add_transform: N, afterUpdate: function(t) {
  z().$$.after_update.push(t);
}, append: y, append_dev: function(t, e) {
  Ft("SvelteDOMInsert", { target: t, node: e }), y(t, e);
}, assign: i, attr: C, attr_dev: function(t, e, n2) {
  C(t, e, n2), n2 == null ? Ft("SvelteDOMRemoveAttribute", { node: t, attribute: e }) : Ft("SvelteDOMSetAttribute", { node: t, attribute: e, value: n2 });
}, beforeUpdate: function(t) {
  z().$$.before_update.push(t);
}, bind: function(t, e, n2) {
  p(t.$$.props, e) && (e = t.$$.props[e] || e, t.$$.bound[e] = n2, n2(t.$$.ctx[e]));
}, binding_callbacks: U, blank_object: u, bubble: function(t, e) {
  const n2 = t.$$.callbacks[e.type];
  n2 && n2.slice().forEach((t2) => t2(e));
}, check_outros: ot, children: D, claim_component: function(t, e) {
  t && t.l(e);
}, claim_element: function(t, e, n2, o2) {
  for (let o3 = 0; o3 < t.length; o3 += 1) {
    const r2 = t[o3];
    if (r2.nodeName === e) {
      for (let t2 = 0; t2 < r2.attributes.length; t2 += 1) {
        const e2 = r2.attributes[t2];
        n2[e2.name] || r2.removeAttribute(e2.name);
      }
      return t.splice(o3, 1)[0];
    }
  }
  return o2 ? E(e) : x2(e);
}, claim_space: function(t) {
  return j(t, " ");
}, claim_text: j, clear_loops: function() {
  g.forEach((t) => g.delete(t)), F = false;
}, component_subscribe: function(t, e, n2) {
  t.$$.on_destroy.push(f(e, n2));
}, createEventDispatcher: function() {
  const t = z();
  return (e, n2) => {
    const o2 = t.$$.callbacks[e];
    if (o2) {
      const r2 = A(e, n2);
      o2.slice().forEach((e2) => {
        e2.call(t, r2);
      });
    }
  };
}, create_animation: function(t, e, n2, i2) {
  if (!e)
    return o;
  const c2 = t.getBoundingClientRect();
  if (e.left === c2.left && e.right === c2.right && e.top === c2.top && e.bottom === c2.bottom)
    return o;
  const { delay: s2 = 0, duration: u2 = 300, easing: a2 = r, start: l2 = _() + s2, end: f6 = l2 + u2, tick: d3 = o, css: p2 } = n2(t, { from: e, to: c2 }, i2);
  let h2, m2 = true, g2 = false;
  function b2() {
    p2 && q(t, h2), m2 = false;
  }
  return $((t2) => {
    if (!g2 && t2 >= l2 && (g2 = true), g2 && t2 >= f6 && (d3(1, 0), b2()), !m2)
      return false;
    if (g2) {
      const e2 = 0 + 1 * a2((t2 - l2) / u2);
      d3(e2, 1 - e2);
    }
    return true;
  }), p2 && (h2 = R(t, 0, 1, u2, s2, a2, p2)), s2 || (g2 = true), d3(0, 1), b2;
}, create_bidirectional_transition: function(t, e, n2, i2) {
  let c2 = e(t, n2), s2 = i2 ? 0 : 1, u2 = null, f6 = null, d3 = null;
  function p2() {
    d3 && q(t, d3);
  }
  function h2(t2, e2) {
    const n3 = t2.b - s2;
    return e2 *= Math.abs(n3), { a: s2, b: t2.b, d: n3, duration: e2, start: t2.start, end: t2.start + e2, group: t2.group };
  }
  function m2(e2) {
    const { delay: n3 = 0, duration: i3 = 300, easing: l2 = r, tick: m3 = o, css: g2 } = c2 || ct, b2 = { start: _() + n3, b: e2 };
    e2 || (b2.group = et, et.r += 1), u2 ? f6 = b2 : (g2 && (p2(), d3 = R(t, s2, e2, i3, n3, l2, g2)), e2 && m3(0, 1), u2 = h2(b2, i3), K3(() => Z(t, e2, "start")), $((e3) => {
      if (f6 && e3 > f6.start && (u2 = h2(f6, i3), f6 = null, Z(t, u2.b, "start"), g2 && (p2(), d3 = R(t, s2, u2.b, u2.duration, 0, l2, c2.css))), u2) {
        if (e3 >= u2.end)
          m3(s2 = u2.b, 1 - s2), Z(t, u2.b, "end"), f6 || (u2.b ? p2() : --u2.group.r || a(u2.group.c)), u2 = null;
        else if (e3 >= u2.start) {
          const t2 = e3 - u2.start;
          s2 = u2.a + u2.d * l2(t2 / u2.duration), m3(s2, 1 - s2);
        }
      }
      return !(!u2 && !f6);
    }));
  }
  return { run(t2) {
    l(c2) ? X().then(() => {
      c2 = c2(), m2(t2);
    }) : m2(t2);
  }, end() {
    p2(), u2 = f6 = null;
  } };
}, create_component: function(t) {
  t && t.c();
}, create_in_transition: function(t, e, n2) {
  let i2, c2, s2 = e(t, n2), u2 = false, a2 = 0;
  function f6() {
    i2 && q(t, i2);
  }
  function d3() {
    const { delay: e2 = 0, duration: n3 = 300, easing: l2 = r, tick: d4 = o, css: p3 } = s2 || ct;
    p3 && (i2 = R(t, 0, 1, n3, e2, l2, p3, a2++)), d4(0, 1);
    const h2 = _() + e2, m2 = h2 + n3;
    c2 && c2.abort(), u2 = true, K3(() => Z(t, true, "start")), c2 = $((e3) => {
      if (u2) {
        if (e3 >= m2)
          return d4(1, 0), Z(t, true, "end"), f6(), u2 = false;
        if (e3 >= h2) {
          const t2 = l2((e3 - h2) / n3);
          d4(t2, 1 - t2);
        }
      }
      return u2;
    });
  }
  let p2 = false;
  return { start() {
    p2 || (q(t), l(s2) ? (s2 = s2(), X().then(d3)) : d3());
  }, invalidate() {
    p2 = false;
  }, end() {
    u2 && (f6(), u2 = false);
  } };
}, create_out_transition: function(t, e, n2) {
  let i2, c2 = e(t, n2), s2 = true;
  const u2 = et;
  function f6() {
    const { delay: e2 = 0, duration: n3 = 300, easing: l2 = r, tick: f7 = o, css: d3 } = c2 || ct;
    d3 && (i2 = R(t, 1, 0, n3, e2, l2, d3));
    const p2 = _() + e2, h2 = p2 + n3;
    K3(() => Z(t, false, "start")), $((e3) => {
      if (s2) {
        if (e3 >= h2)
          return f7(0, 1), Z(t, false, "end"), --u2.r || a(u2.c), false;
        if (e3 >= p2) {
          const t2 = l2((e3 - p2) / n3);
          f7(1 - t2, t2);
        }
      }
      return s2;
    });
  }
  return u2.r += 1, l(c2) ? X().then(() => {
    c2 = c2(), f6();
  }) : f6(), { end(e2) {
    e2 && c2.tick && c2.tick(1, 0), s2 && (i2 && q(t, i2), s2 = false);
  } };
}, create_slot: function(t, e, n2) {
  if (t) {
    const o2 = d2(t, e, n2);
    return t[0](o2);
  }
}, create_ssr_component: function(t) {
  function e(e2, n2, o2, r2) {
    const i2 = M;
    T3({ $$: { on_destroy: ht, context: new Map(i2 ? i2.$$.context : []), on_mount: [], before_update: [], after_update: [], callbacks: u() } });
    const c2 = t(e2, n2, o2, r2);
    return T3(i2), c2;
  }
  return { render: (t2 = {}, n2 = {}) => {
    ht = [];
    const o2 = { head: "", css: new Set() }, r2 = e(o2, t2, {}, n2);
    return a(ht), { html: r2, css: { code: Array.from(o2.css).map((t3) => t3.code).join("\n"), map: null }, head: o2.head };
  }, $$render: e };
}, get current_component() {
  return M;
}, custom_event: A, dataset_dev: function(t, e, n2) {
  t.dataset[e] = n2, Ft("SvelteDOMSetDataset", { node: t, property: e, value: n2 });
}, debug: function(t, e, n2, o2) {
  return console.log(`{@debug} ${t ? t + " " : ""}(${e}:${n2})`), console.log(o2), "";
}, destroy_block: ut, destroy_component: gt, destroy_each: function(t, e) {
  for (let n2 = 0; n2 < t.length; n2 += 1)
    t[n2] && t[n2].d(e);
}, detach: k, detach_after_dev: function(t) {
  for (; t.nextSibling; )
    vt(t.nextSibling);
}, detach_before_dev: function(t) {
  for (; t.previousSibling; )
    vt(t.previousSibling);
}, detach_between_dev: function(t, e) {
  for (; t.nextSibling && t.nextSibling !== e; )
    vt(t.nextSibling);
}, detach_dev: vt, dirty_components: B, dispatch_dev: Ft, each: function(t, e) {
  let n2 = "";
  for (let o2 = 0; o2 < t.length; o2 += 1)
    n2 += e(t[o2], o2);
  return n2;
}, element: x2, element_is: function(t, e) {
  return document.createElement(t, { is: e });
}, empty: function() {
  return S3("");
}, escape: pt, escaped: dt, exclude_internal_props: function(t) {
  const e = {};
  for (const n2 in t)
    n2[0] !== "$" && (e[n2] = t[n2]);
  return e;
}, fix_and_destroy_block: function(t, e) {
  t.f(), ut(t, e);
}, fix_and_outro_and_destroy_block: function(t, e) {
  t.f(), at(t, e);
}, fix_position: function(t) {
  const e = getComputedStyle(t);
  if (e.position !== "absolute" && e.position !== "fixed") {
    const { width: n2, height: o2 } = e, r2 = t.getBoundingClientRect();
    t.style.position = "absolute", t.style.width = n2, t.style.height = o2, N(t, r2);
  }
}, flush: Q, getContext: function(t) {
  return z().$$.context.get(t);
}, get_binding_group_value: function(t) {
  const e = [];
  for (let n2 = 0; n2 < t.length; n2 += 1)
    t[n2].checked && e.push(t[n2].__value);
  return e;
}, get_current_component: z, get_slot_changes: function(t, e, n2, o2) {
  return t[1] ? i({}, i(e.$$scope.changed || {}, t[1](o2 ? o2(n2) : {}))) : e.$$scope.changed || {};
}, get_slot_context: d2, get_spread_object: function(t) {
  return typeof t == "object" && t !== null ? t : {};
}, get_spread_update: function(t, e) {
  const n2 = {}, o2 = {}, r2 = { $$scope: 1 };
  let i2 = t.length;
  for (; i2--; ) {
    const c2 = t[i2], s2 = e[i2];
    if (s2) {
      for (const t2 in c2)
        t2 in s2 || (o2[t2] = 1);
      for (const t2 in s2)
        r2[t2] || (n2[t2] = s2[t2], r2[t2] = 1);
      t[i2] = s2;
    } else
      for (const t2 in c2)
        r2[t2] = 1;
  }
  for (const t2 in o2)
    t2 in n2 || (n2[t2] = void 0);
  return n2;
}, get_store_value: function(t) {
  let e;
  return f(t, (t2) => e = t2)(), e;
}, globals: st, group_outros: nt, handle_promise: function(t, e) {
  const n2 = e.token = {};
  function o2(t2, o3, r2, c2) {
    if (e.token !== n2)
      return;
    e.resolved = r2 && { [r2]: c2 };
    const s2 = i(i({}, e.ctx), e.resolved), u2 = t2 && (e.current = t2)(s2);
    let a2 = false;
    e.block && (e.blocks ? e.blocks.forEach((t3, n3) => {
      n3 !== o3 && t3 && (nt(), it(t3, 1, 1, () => {
        e.blocks[n3] = null;
      }), ot());
    }) : e.block.d(1), u2.c(), rt(u2, 1), u2.m(e.mount(), e.anchor), a2 = true), e.block = u2, e.blocks && (e.blocks[o3] = u2), a2 && Q();
  }
  if (c(t)) {
    const n3 = z();
    if (t.then((t2) => {
      T3(n3), o2(e.then, 1, e.value, t2), T3(null);
    }, (t2) => {
      T3(n3), o2(e.catch, 2, e.error, t2), T3(null);
    }), e.current !== e.pending)
      return o2(e.pending, 0), true;
  } else {
    if (e.current !== e.then)
      return o2(e.then, 1, e.value, t), true;
    e.resolved = { [e.value]: t };
  }
}, has_prop: p, identity: r, init: function(t, e, n2, r2, i2, c2) {
  const s2 = M;
  T3(t);
  const l2 = e.props || {}, f6 = t.$$ = { fragment: null, ctx: null, props: c2, update: o, not_equal: i2, bound: u(), on_mount: [], on_destroy: [], before_update: [], after_update: [], context: new Map(s2 ? s2.$$.context : []), callbacks: u(), dirty: null };
  let d3 = false;
  f6.ctx = n2 ? n2(t, l2, (e2, n3, o2 = n3) => (f6.ctx && i2(f6.ctx[e2], f6.ctx[e2] = o2) && (f6.bound[e2] && f6.bound[e2](o2), d3 && function(t2, e3) {
    t2.$$.dirty || (B.push(t2), G3(), t2.$$.dirty = u()), t2.$$.dirty[e3] = true;
  }(t, e2)), n3)) : l2, f6.update(), d3 = true, a(f6.before_update), f6.fragment = !!r2 && r2(f6.ctx), e.target && (e.hydrate ? f6.fragment && f6.fragment.l(D(e.target)) : f6.fragment && f6.fragment.c(), e.intro && rt(t.$$.fragment), mt(t, e.target, e.anchor), Q()), T3(s2);
}, insert: w, insert_dev: function(t, e, n2) {
  Ft("SvelteDOMInsert", { target: t, node: e, anchor: n2 }), w(t, e, n2);
}, intros: { enabled: false }, invalid_attribute_name_character: ft, is_client: h, is_function: l, is_promise: c, listen: O, listen_dev: function(t, e, n2, o2, r2, i2) {
  const c2 = o2 === true ? ["capture"] : o2 ? Array.from(Object.keys(o2)) : [];
  r2 && c2.push("preventDefault"), i2 && c2.push("stopPropagation"), Ft("SvelteDOMAddEventListener", { node: t, event: e, handler: n2, modifiers: c2 });
  const s2 = O(t, e, n2, o2);
  return () => {
    Ft("SvelteDOMRemoveEventListener", { node: t, event: e, handler: n2, modifiers: c2 }), s2();
  };
}, loop: $, loop_guard: function(t) {
  const e = Date.now();
  return () => {
    if (Date.now() - e > t)
      throw new Error("Infinite loop detected");
  };
}, measure: function(t) {
  const e = {};
  let n2 = t.length;
  for (; n2--; )
    e[t[n2].key] = t[n2].node.getBoundingClientRect();
  return e;
}, missing_component: { $$render: () => "" }, mount_component: mt, noop: o, not_equal: function(t, e) {
  return t != t ? e == e : t !== e;
}, get now() {
  return _;
}, null_to_empty: function(t) {
  return t == null ? "" : t;
}, object_without_properties: function(t, e) {
  const n2 = {};
  for (const o2 in t)
    p(t, o2) && e.indexOf(o2) === -1 && (n2[o2] = t[o2]);
  return n2;
}, onDestroy: function(t) {
  z().$$.on_destroy.push(t);
}, onMount: function(t) {
  z().$$.on_mount.push(t);
}, once: function(t) {
  let e = false;
  return function(...n2) {
    e || (e = true, t.call(this, ...n2));
  };
}, outro_and_destroy_block: at, prevent_default: function(t) {
  return function(e) {
    return e.preventDefault(), t.call(this, e);
  };
}, prop_dev: function(t, e, n2) {
  t[e] = n2, Ft("SvelteDOMSetProperty", { node: t, property: e, value: n2 });
}, get raf() {
  return m;
}, run: s, run_all: a, safe_not_equal: function(t, e) {
  return t != t ? e == e : t !== e || t && typeof t == "object" || typeof t == "function";
}, schedule_update: G3, select_multiple_value: function(t) {
  return [].map.call(t.querySelectorAll(":checked"), (t2) => t2.__value);
}, select_option: function(t, e) {
  for (let n2 = 0; n2 < t.options.length; n2 += 1) {
    const o2 = t.options[n2];
    if (o2.__value === e)
      return void (o2.selected = true);
  }
}, select_options: function(t, e) {
  for (let n2 = 0; n2 < t.options.length; n2 += 1) {
    const o2 = t.options[n2];
    o2.selected = ~e.indexOf(o2.__value);
  }
}, select_value: function(t) {
  const e = t.querySelector(":checked") || t.options[0];
  return e && e.__value;
}, self: function(t) {
  return function(e) {
    e.target === this && t.call(this, e);
  };
}, setContext: function(t, e) {
  z().$$.context.set(t, e);
}, set_attributes: function(t, e) {
  const n2 = Object.getOwnPropertyDescriptors(t.__proto__);
  for (const o2 in e)
    e[o2] == null ? t.removeAttribute(o2) : o2 === "style" ? t.style.cssText = e[o2] : n2[o2] && n2[o2].set ? t[o2] = e[o2] : C(t, o2, e[o2]);
}, set_current_component: T3, set_custom_element_data: function(t, e, n2) {
  e in t ? t[e] = n2 : C(t, e, n2);
}, set_data: function(t, e) {
  e = "" + e, t.data !== e && (t.data = e);
}, set_data_dev: function(t, e) {
  e = "" + e, t.data !== e && (Ft("SvelteDOMSetData", { node: t, data: e }), t.data = e);
}, set_input_type: function(t, e) {
  try {
    t.type = e;
  } catch (t2) {
  }
}, set_input_value: function(t, e) {
  (e != null || t.value) && (t.value = e);
}, set_now: function(t) {
  _ = t;
}, set_raf: function(t) {
  m = t;
}, set_store_value: function(t, e, n2 = e) {
  return t.set(n2), e;
}, set_style: function(t, e, n2, o2) {
  t.style.setProperty(e, n2, o2 ? "important" : "");
}, set_svg_attributes: function(t, e) {
  for (const n2 in e)
    C(t, n2, e[n2]);
}, space: function() {
  return S3(" ");
}, spread: function(t, e) {
  const n2 = Object.assign({}, ...t);
  e && (n2.class == null ? n2.class = e : n2.class += " " + e);
  let o2 = "";
  return Object.keys(n2).forEach((t2) => {
    if (ft.test(t2))
      return;
    const e2 = n2[t2];
    e2 === true ? o2 += " " + t2 : lt.has(t2.toLowerCase()) ? e2 && (o2 += " " + t2) : e2 != null && (o2 += " " + t2 + "=" + JSON.stringify(String(e2).replace(/"/g, "&#34;").replace(/'/g, "&#39;")));
  }), o2;
}, stop_propagation: function(t) {
  return function(e) {
    return e.stopPropagation(), t.call(this, e);
  };
}, subscribe: f, svg_element: E, text: S3, tick: function() {
  return G3(), J;
}, time_ranges_to_array: function(t) {
  const e = [];
  for (let n2 = 0; n2 < t.length; n2 += 1)
    e.push({ start: t.start(n2), end: t.end(n2) });
  return e;
}, to_number: function(t) {
  return t === "" ? void 0 : +t;
}, toggle_class: function(t, e, n2) {
  t.classList[n2 ? "add" : "remove"](e);
}, transition_in: rt, transition_out: it, update_keyed_each: function(t, e, n2, o2, r2, i2, c2, s2, u2, a2, l2, f6) {
  let d3 = t.length, p2 = i2.length, h2 = d3;
  const _2 = {};
  for (; h2--; )
    _2[t[h2].key] = h2;
  const m2 = [], g2 = new Map(), b2 = new Map();
  for (h2 = p2; h2--; ) {
    const t2 = f6(r2, i2, h2), s3 = n2(t2);
    let u3 = c2.get(s3);
    u3 ? o2 && u3.p(e, t2) : (u3 = a2(s3, t2)).c(), g2.set(s3, m2[h2] = u3), s3 in _2 && b2.set(s3, Math.abs(h2 - _2[s3]));
  }
  const F2 = new Set(), v2 = new Set();
  function $2(t2) {
    rt(t2, 1), t2.m(s2, l2), c2.set(t2.key, t2), l2 = t2.first, p2--;
  }
  for (; d3 && p2; ) {
    const e2 = m2[p2 - 1], n3 = t[d3 - 1], o3 = e2.key, r3 = n3.key;
    e2 === n3 ? (l2 = e2.first, d3--, p2--) : g2.has(r3) ? !c2.has(o3) || F2.has(o3) ? $2(e2) : v2.has(r3) ? d3-- : b2.get(o3) > b2.get(r3) ? (v2.add(o3), $2(e2)) : (F2.add(r3), d3--) : (u2(n3, c2), d3--);
  }
  for (; d3--; ) {
    const e2 = t[d3];
    g2.has(e2.key) || u2(e2, c2);
  }
  for (; p2; )
    $2(m2[p2 - 1]);
  return m2;
}, validate_component: function(t, e) {
  if (!t || !t.$$render)
    throw e === "svelte:component" && (e += " this={...}"), new Error(`<${e}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);
  return t;
}, validate_store: function(t, e) {
  if (!t || typeof t.subscribe != "function")
    throw new Error(`'${e}' is not a store with a 'subscribe' method`);
}, xlink_attr: function(t, e, n2) {
  t.setAttributeNS("http://www.w3.org/1999/xlink", e, n2);
} });
var xt = ($t = kt) && $t.default || $t;
var Et = (function(t, e) {
  Object.defineProperty(e, "__esModule", { value: true });
  const n2 = [];
  function o2(t2, e2) {
    return { subscribe: r2(t2, e2).subscribe };
  }
  function r2(t2, e2 = xt.noop) {
    let o3;
    const r3 = [];
    function i2(e3) {
      if (xt.safe_not_equal(t2, e3) && (t2 = e3, o3)) {
        const e4 = !n2.length;
        for (let e5 = 0; e5 < r3.length; e5 += 1) {
          const o4 = r3[e5];
          o4[1](), n2.push(o4, t2);
        }
        if (e4) {
          for (let t3 = 0; t3 < n2.length; t3 += 2)
            n2[t3][0](n2[t3 + 1]);
          n2.length = 0;
        }
      }
    }
    return { set: i2, update: function(e3) {
      i2(e3(t2));
    }, subscribe: function(n3, c2 = xt.noop) {
      const s2 = [n3, c2];
      return r3.push(s2), r3.length === 1 && (o3 = e2(i2) || xt.noop), n3(t2), () => {
        const t3 = r3.indexOf(s2);
        t3 !== -1 && r3.splice(t3, 1), r3.length === 0 && (o3(), o3 = null);
      };
    } };
  }
  Object.defineProperty(e, "get", { enumerable: true, get: function() {
    return xt.get_store_value;
  } }), e.derived = function(t2, e2, n3) {
    const r3 = !Array.isArray(t2), i2 = r3 ? [t2] : t2, c2 = e2.length < 2;
    return o2(n3, (t3) => {
      let n4 = false;
      const o3 = [];
      let s2 = 0, u2 = xt.noop;
      const a2 = () => {
        if (s2)
          return;
        u2();
        const n5 = e2(r3 ? o3[0] : o3, t3);
        c2 ? t3(n5) : u2 = xt.is_function(n5) ? n5 : xt.noop;
      }, l2 = i2.map((t4, e3) => t4.subscribe((t5) => {
        o3[e3] = t5, s2 &= ~(1 << e3), n4 && a2();
      }, () => {
        s2 |= 1 << e3;
      }));
      return n4 = true, a2(), function() {
        xt.run_all(l2), u2();
      };
    });
  }, e.readable = o2, e.writable = r2;
}(yt = { exports: {} }, yt.exports), yt.exports);
(wt = Et) && wt.__esModule && Object.prototype.hasOwnProperty.call(wt, "default") && wt.default;
var St = Et.derived;
var Ot = (Et.readable, Et.writable);
var Ct = ({ navigator: t, hash: e, search: n2, fallback: o2 } = {}) => {
  let r2;
  const i2 = (t2, e2) => {
    const n3 = t2.substr(1).split("&").find((t3) => t3.indexOf(e2) === 0);
    if (n3)
      return n3.split("=").pop();
  };
  return typeof window != "undefined" && (t && (r2 = window.navigator.language || window.navigator.languages[0]), n2 && (r2 = i2(window.location.search, n2)), e && (r2 = i2(window.location.hash, e))), r2 || o2;
};
var Dt;
var jt;
var At = { number: { scientific: { notation: "scientific" }, engineering: { notation: "engineering" }, compactLong: { notation: "compact", compactDisplay: "long" }, compactShort: { notation: "compact", compactDisplay: "short" } } };
var Lt = microMemoize((t, n2) => new IntlMessageFormat(t, n2, At));
var Pt = microMemoize((e, n2) => jt[n2][e] || objectResolvePath(jt[n2], e));
function Rt(t, { values: e, locale: n2 = Dt } = {}) {
  return Lt(t, n2).format(e);
}
function qt(t, { values: e, locale: n2 = Dt } = {}) {
  const o2 = Pt(t, n2);
  return o2 ? e ? Lt(o2, n2).format(e) : o2 : (console.warn(`[svelte-i18n] The message "${t}" was not found in the locale "${n2}".`), t);
}
qt.time = (t, { format: e = "short" } = {}) => Rt(`{t,time,${e}}`, { values: { t } }), qt.date = (t, { format: e = "short" } = {}) => Rt(`{d,date,${e}}`, { values: { d: t } }), qt.number = (t, { format: e } = {}) => Rt(`{n,number,${e}}`, { values: { n: t } }), qt.capital = (t, e) => ((t2) => t2.replace(/(^|\s)\S/, (t3) => t3.toUpperCase()))(qt(t, e)), qt.title = (t, e) => ((t2) => t2.replace(/(^|\s)\S/g, (t3) => t3.toUpperCase()))(qt(t, e)), qt.upper = (t, e) => ((t2) => t2.toLocaleUpperCase())(qt(t, e)), qt.lower = (t, e) => ((t2) => t2.toLocaleLowerCase())(qt(t, e));
var Nt = Ot({});
Nt.subscribe((t) => {
  jt = t;
});
var Tt = Ot({});
var zt = Tt.set;
Tt.set = (t) => {
  const e = function(t2) {
    if (jt[t2])
      return t2;
    if (typeof t2 == "string") {
      const e2 = t2.split("-").shift();
      if (jt[e2])
        return e2;
    }
    return null;
  }(t);
  if (e)
    return zt(e);
  throw Error(`[svelte-i18n] Locale "${t}" not found.`);
}, Tt.update = (t) => zt(t(Dt)), Tt.subscribe((t) => {
  Dt = t;
});
var Bt = St([Tt, Nt], () => qt);
function cubicOut(t) {
  const f6 = t - 1;
  return f6 * f6 * f6 + 1;
}
function quintIn(t) {
  return t * t * t * t * t;
}
function fly(node, { delay = 0, duration = 400, easing = cubicOut, x: x3 = 0, y: y2 = 0, opacity = 0 }) {
  const style = getComputedStyle(node);
  const target_opacity = +style.opacity;
  const transform = style.transform === "none" ? "" : style.transform;
  const od = target_opacity * (1 - opacity);
  return {
    delay,
    duration,
    easing,
    css: (t, u2) => `
			transform: ${transform} translate(${(1 - t) * x3}px, ${(1 - t) * y2}px);
			opacity: ${target_opacity - od * u2}`
  };
}
function flip(node, animation, params) {
  const style = getComputedStyle(node);
  const transform = style.transform === "none" ? "" : style.transform;
  const scaleX = animation.from.width / node.clientWidth;
  const scaleY = animation.from.height / node.clientHeight;
  const dx = (animation.from.left - animation.to.left) / scaleX;
  const dy = (animation.from.top - animation.to.top) / scaleY;
  const d3 = Math.sqrt(dx * dx + dy * dy);
  const { delay = 0, duration = (d4) => Math.sqrt(d4) * 120, easing = cubicOut } = params;
  return {
    delay,
    duration: is_function(duration) ? duration(d3) : duration,
    easing,
    css: (_t2, u2) => `transform: ${transform} translate(${u2 * dx}px, ${u2 * dy}px);`
  };
}
function argsEqual(args1, args2) {
  return JSON.stringify(args1) === JSON.stringify(args2);
}
function replaceOrAdd(list, predicate, data) {
  const clone2 = [...list];
  const index = clone2.findIndex(predicate);
  if (index !== -1) {
    const { startTime, contractCall, status } = clone2[index];
    if (data.status === "pending" && (status === "speedup" || status === "cancel")) {
      return clone2;
    }
    const { startTime: serverStartTime } = data;
    const contractCallMerge = contractCall ? __spreadValues({}, contractCall) : {};
    clone2[index] = __spreadProps(__spreadValues(__spreadValues({}, data), contractCallMerge), {
      startTime: startTime || serverStartTime
    });
    return clone2;
  }
  return [...list, data];
}
function extractMessageFromError(error) {
  if (!error.stack || !error.message) {
    return {
      eventCode: "txError",
      errorMsg: "An unknown error occured"
    };
  }
  const message = error.stack || error.message;
  if (message.includes("User denied transaction signature")) {
    return {
      eventCode: "txSendFail",
      errorMsg: "User denied transaction signature"
    };
  }
  if (message.includes("transaction underpriced")) {
    return {
      eventCode: "txUnderpriced",
      errorMsg: "Transaction is under priced"
    };
  }
  return {
    eventCode: "txError",
    errorMsg: message
  };
}
function createEmitter2() {
  return {
    listeners: {},
    on: function(eventCode, listener) {
      switch (eventCode) {
        case "txSent":
        case "txPool":
        case "txConfirmed":
        case "txSpeedUp":
        case "txCancel":
        case "txFailed":
        case "txRequest":
        case "nsfFail":
        case "txRepeat":
        case "txAwaitingApproval":
        case "txConfirmReminder":
        case "txSendFail":
        case "txError":
        case "txUnderPriced":
        case "all":
          break;
        default:
          throw new Error(`${eventCode} is not a valid event code, for a list of valid event codes see: https://github.com/blocknative/notify`);
      }
      if (typeof listener !== "function") {
        throw new Error("Listener must be a function");
      }
      this.listeners[eventCode] = listener;
    },
    emit: function(state) {
      if (this.listeners[state.eventCode || ""]) {
        return this.listeners[state.eventCode || ""](state);
      }
      if (this.listeners.all) {
        return this.listeners.all(state);
      }
    }
  };
}
function localNetwork(networkId) {
  switch (networkId) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 42:
    case 56:
    case 100:
    case 137:
      return false;
    default:
      return true;
  }
}
var defaultNotifyMessages = {
  en: {
    transaction: {
      txRequest: "Your transaction is waiting for you to confirm",
      nsfFail: "You have insufficient funds to complete this transaction",
      txUnderpriced: "The gas price for your transaction is too low, try again with a higher gas price",
      txRepeat: "This could be a repeat transaction",
      txAwaitingApproval: "You have a previous transaction waiting for you to confirm",
      txConfirmReminder: "Please confirm your transaction to continue, the transaction window may be behind your browser",
      txSendFail: "You rejected the transaction",
      txSent: "Your transaction has been sent to the network",
      txStallPending: "Your transaction has stalled and has not entered the transaction pool",
      txStuck: "Your transaction is stuck due to a nonce gap",
      txPool: "Your transaction has started",
      txStallConfirmed: "Your transaction has stalled and hasn't been confirmed",
      txSpeedUp: "Your transaction has been sped up",
      txCancel: "Your transaction is being canceled",
      txFailed: "Your transaction has failed",
      txConfirmed: "Your transaction has succeeded",
      txError: "Oops something went wrong, please try again"
    },
    watched: {
      txPool: "Your account is {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txSpeedUp: "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been sped up",
      txCancel: "Transaction for {formattedValue} {asset} {preposition} {counterpartyShortened} has been canceled",
      txConfirmed: "Your account successfully {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}",
      txFailed: "Your account failed to {verb} {formattedValue} {asset} {preposition} {counterpartyShortened}"
    },
    time: {
      minutes: "min",
      seconds: "sec"
    }
  },
  es: {
    transaction: {
      txRequest: "Su transacci\xF3n est\xE1 esperando que confirme",
      nsfFail: "No tiene fondos suficientes para completar esta transacci\xF3n.",
      txUnderpriced: "El precio del gas para su transacci\xF3n es demasiado bajo, intente nuevamente con un precio del gas m\xE1s alto",
      txRepeat: "Esto podr\xEDa ser una transacci\xF3n repetida",
      txAwaitingApproval: "Tienes una transacci\xF3n anterior esperando que confirmes",
      txConfirmReminder: "Confirme su transacci\xF3n para continuar, la ventana de transacci\xF3n puede estar detr\xE1s de su navegador",
      txSendFail: "Rechazaste la transacci\xF3n",
      txSent: "Su transacci\xF3n ha sido enviada a la red.",
      txStallPending: "Su transacci\xF3n se ha estancado y no ha ingresado al grupo de transacciones",
      txStuck: "Su transacci\xF3n est\xE1 atascada debido a una brecha de nonce",
      txPool: "Su transacci\xF3n ha comenzado",
      txStallConfirmed: "Su transacci\xF3n se ha estancado y no ha sido confirmada.",
      txSpeedUp: "Su transacci\xF3n ha sido acelerada",
      txCancel: "Tu transacci\xF3n est\xE1 siendo cancelada",
      txFailed: "Su transacci\xF3n ha fallado",
      txConfirmed: "Su transacci\xF3n ha tenido \xE9xito.",
      txError: "Vaya, algo sali\xF3 mal, por favor intente nuevamente"
    },
    watched: {
      txPool: "su cuenta est\xE1 {verb, select, receiving {recibiendo} sending {enviando}} {formattedValue} {asset} {preposition, select, from {desde} to {a}} {counterpartyShortened}",
      txSpeedUp: "su cuenta est\xE1 {verb, select, receiving {recibiendo} sending {enviando}} {formattedValue} {asset} {preposition, select, from {desde} to {a}} {counterpartyShortened}",
      txCancel: "su cuenta est\xE1 {verb, select, receiving {recibiendo} sending {enviando}} {formattedValue} {asset} {preposition, select, from {desde} to {a}} {counterpartyShortened}",
      txConfirmed: "su cuenta {verb, select, received {recibi\xF3} sent {ha enviado}} con \xE9xito {formattedValue} {asset} {preposition, select, from {de} to {a}} {counterpartyShortened}",
      txFailed: "su cuenta fallado {verb, select, received {recibi\xF3} sent {ha enviado}} con \xE9xito {formattedValue} {asset} {preposition, select, from {de} to {a}} {counterpartyShortened}"
    },
    time: {
      minutes: "min",
      seconds: "sec"
    }
  }
};
var app = writable({
  version: "",
  name: "",
  dappId: "",
  networkId: 1,
  nodeSynced: true,
  mobilePosition: "top",
  desktopPosition: "bottomRight",
  darkMode: false,
  txApproveReminderTimeout: 2e4,
  txStallPendingTimeout: 2e4,
  txStallConfirmedTimeout: 9e4,
  clientLocale: "en",
  notifyMessages: defaultNotifyMessages
});
var transactions = createTransactionStore([]);
var notifications = createNotificationStore([]);
function createTransactionStore(initialState) {
  const { subscribe: subscribe2, update: update2 } = writable(initialState);
  function updateQueue(transaction2, predicate) {
    update2((store) => {
      return replaceOrAdd(store, predicate, transaction2);
    });
  }
  function add(transaction2) {
    update2((store) => [...store, transaction2]);
  }
  return {
    subscribe: subscribe2,
    updateQueue,
    add
  };
}
function createNotificationStore(initialState) {
  const { subscribe: subscribe2, update: update2 } = writable(initialState);
  function add(notification) {
    update2((store) => {
      const existingNotification = store.find((n2) => n2.id === notification.id);
      if (notification.type === "hint" || !existingNotification) {
        return [...store, notification];
      }
      return [
        ...store.filter((n2) => n2.id !== notification.id),
        notification
      ];
    });
  }
  function remove(id, eventCode) {
    update2((store) => store.filter((n2) => n2.id !== id || n2.eventCode !== eventCode));
  }
  function updateId(oldId, newId) {
    update2((store) => store.map((n2) => n2.id === oldId ? __spreadProps(__spreadValues({}, n2), { id: newId }) : n2));
  }
  return {
    subscribe: subscribe2,
    add,
    remove,
    update: update2,
    updateId
  };
}
function add_css() {
  var style = element("style");
  style.id = "svelte-1nxfpxx-style";
  style.textContent = "div.svelte-1nxfpxx{display:flex;justify-content:center;align-items:center;font-size:inherit;font-family:inherit;padding:0.3em;border-radius:40px;transition:background 150ms ease-in-out}div.svelte-1nxfpxx:hover{background:#eeeeee;cursor:pointer}.bn-notify-dark-mode-close-background.svelte-1nxfpxx:hover{background:#00222c}";
  append(document.head, style);
}
function create_fragment(ctx) {
  let div;
  let svg;
  let g2;
  let path0;
  let path1;
  let g_stroke_value;
  let div_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      svg = svg_element("svg");
      g2 = svg_element("g");
      path0 = svg_element("path");
      path1 = svg_element("path");
      attr(path0, "d", "m.1.1 7.82304289 7.82304289");
      attr(path1, "d", "m.1.1 7.82304289 7.82304289");
      attr(path1, "transform", "matrix(-1 0 0 1 8 0)");
      attr(g2, "fill", "none");
      attr(g2, "stroke", g_stroke_value = ctx[0] ? ctx[1].darkMode ? "#ffffff" : "#4a4a4a" : "#9B9B9B");
      attr(g2, "stroke-linecap", "square");
      attr(g2, "stroke-width", "2");
      set_style(g2, "transition", "stroke 150ms ease-in-out");
      attr(g2, "transform", "translate(2 2)");
      attr(svg, "height", "8");
      attr(svg, "viewBox", "0 0 12 12");
      attr(svg, "width", "8");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(div, "class", div_class_value = "bn-notify-custom bn-notify-notification-close-icon " + (ctx[1].name ? `bn-notify-${ctx[1].name}` : "") + " svelte-1nxfpxx");
      toggle_class(div, "bn-notify-dark-mode-close-background", ctx[1].darkMode);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, svg);
      append(svg, g2);
      append(g2, path0);
      append(g2, path1);
      if (!mounted) {
        dispose = [
          listen(div, "mouseenter", ctx[2]),
          listen(div, "mouseleave", ctx[3])
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & 3 && g_stroke_value !== (g_stroke_value = ctx2[0] ? ctx2[1].darkMode ? "#ffffff" : "#4a4a4a" : "#9B9B9B")) {
        attr(g2, "stroke", g_stroke_value);
      }
      if (dirty & 2 && div_class_value !== (div_class_value = "bn-notify-custom bn-notify-notification-close-icon " + (ctx2[1].name ? `bn-notify-${ctx2[1].name}` : "") + " svelte-1nxfpxx")) {
        attr(div, "class", div_class_value);
      }
      if (dirty & 2) {
        toggle_class(div, "bn-notify-dark-mode-close-background", ctx2[1].darkMode);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let hovered;
  const mouseenter_handler = () => $$invalidate(0, hovered = true);
  const mouseleave_handler = () => $$invalidate(0, hovered = false);
  return [hovered, $app, mouseenter_handler, mouseleave_handler];
}
var CloseIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-1nxfpxx-style"))
      add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {});
  }
};
function add_css$1() {
  var style = element("style");
  style.id = "svelte-1rj5tzm-style";
  style.textContent = "p.svelte-1rj5tzm{margin:0;font-family:inherit;font-size:inherit}";
  append(document.head, style);
}
function create_fragment$1(ctx) {
  let p2;
  let p_class_value;
  return {
    c() {
      p2 = element("p");
      attr(p2, "class", p_class_value = "bn-notify-custom bn-notify-notification-info-message " + (ctx[1].name ? `bn-notify-${ctx[1].name}` : "") + " svelte-1rj5tzm");
    },
    m(target, anchor) {
      insert(target, p2, anchor);
      p2.innerHTML = ctx[0];
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        p2.innerHTML = ctx2[0];
      if (dirty & 2 && p_class_value !== (p_class_value = "bn-notify-custom bn-notify-notification-info-message " + (ctx2[1].name ? `bn-notify-${ctx2[1].name}` : "") + " svelte-1rj5tzm")) {
        attr(p2, "class", p_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(p2);
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { message } = $$props;
  $$self.$set = ($$props2) => {
    if ("message" in $$props2)
      $$invalidate(0, message = $$props2.message);
  };
  return [message, $app];
}
var NotificationMessage = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-1rj5tzm-style"))
      add_css$1();
    init(this, options, instance$1, create_fragment$1, safe_not_equal, { message: 0 });
  }
};
function add_css$2() {
  var style = element("style");
  style.id = "svelte-1c9mzro-style";
  style.textContent = "svg.svelte-1c9mzro{margin:0 0.25em 0 0.5em}";
  append(document.head, style);
}
function create_fragment$2(ctx) {
  let svg;
  let g2;
  let path2;
  return {
    c() {
      svg = svg_element("svg");
      g2 = svg_element("g");
      path2 = svg_element("path");
      attr(path2, "d", "M7.06681227,1.92484595 C10.9634297,1.92484595 14.1336806,5.03922755\n      14.1336806,8.86724251 C14.1336806,12.6953675 10.9634297,15.8096941\n      7.06681227,15.8096941 C3.17019489,15.8096941 1.66977543e-13,12.6953675\n      1.66977543e-13,8.86724251 C1.66977543e-13,5.03922755 3.17019489,1.92484595\n      7.06681227,1.92484595 Z M7.06681227,13.5248129 C9.68105959,13.5248129\n      11.8078517,11.4354643 11.8078517,8.8672425 C11.8078517,8.25643705\n      11.6862119,7.67319541 11.4676859,7.13820421 L7.06334005,8.88946962\n      L7.06334005,4.20972711 C4.45066084,4.2115977 2.32577285,6.30028608\n      2.32577285,8.86724251 C2.32577285,11.4354643 4.45256495,13.5248129\n      7.06681227,13.5248129 Z M5.53007392,1.22124533e-14\n      L8.61626343,1.22124533e-14 L8.61626343,1.6696743 L5.53007392,1.6696743\n      L5.53007392,1.22124533e-14 Z");
      attr(path2, "id", "transaction-timer");
      attr(path2, "fill", "#AEAEAE");
      attr(path2, "fill-rule", "nonzero");
      attr(g2, "id", "Notify-Style-Concepts");
      attr(g2, "stroke", "none");
      attr(g2, "stroke-width", "1");
      attr(g2, "fill", "none");
      attr(g2, "fill-rule", "evenodd");
      attr(svg, "width", "15px");
      attr(svg, "height", "16px");
      attr(svg, "viewBox", "0 0 15 16");
      attr(svg, "version", "1.1");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "xmlns:xlink", "http://www.w3.org/1999/xlink");
      attr(svg, "class", "svelte-1c9mzro");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, g2);
      append(g2, path2);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
var Clock = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-1c9mzro-style"))
      add_css$2();
    init(this, options, null, create_fragment$2, safe_not_equal, {});
  }
};
function add_css$3() {
  var style = element("style");
  style.id = "svelte-6oams7-style";
  style.textContent = "span.svelte-6oams7{font-size:inherit;font-family:inherit;margin-right:0.5em}";
  append(document.head, style);
}
function create_fragment$3(ctx) {
  let span;
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", span_class_value = "bn-notify-custom bn-notify-notification-info-meta-timestamp " + (ctx[1].name ? `bn-notify-${ctx[1].name}` : "") + " svelte-6oams7");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2 && span_class_value !== (span_class_value = "bn-notify-custom bn-notify-notification-info-meta-timestamp " + (ctx2[1].name ? `bn-notify-${ctx2[1].name}` : "") + " svelte-6oams7")) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { time } = $$props;
  $$self.$set = ($$props2) => {
    if ("time" in $$props2)
      $$invalidate(0, time = $$props2.time);
  };
  return [time, $app];
}
var Time = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-6oams7-style"))
      add_css$3();
    init(this, options, instance$2, create_fragment$3, safe_not_equal, { time: 0 });
  }
};
function add_css$4() {
  var style = element("style");
  style.id = "svelte-fbmqmu-style";
  style.textContent = "span.svelte-fbmqmu{font-size:inherit;font-family:inherit}";
  append(document.head, style);
}
function create_fragment$4(ctx) {
  let span;
  let t;
  let span_class_value;
  return {
    c() {
      span = element("span");
      t = text(ctx[0]);
      attr(span, "class", span_class_value = "bn-notify-custom bn-notify-notification-info-meta-duration-time " + (ctx[1].name ? `bn-notify-${ctx[1].name}` : "") + " svelte-fbmqmu");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, [dirty]) {
      if (dirty & 1)
        set_data(t, ctx2[0]);
      if (dirty & 2 && span_class_value !== (span_class_value = "bn-notify-custom bn-notify-notification-info-meta-duration-time " + (ctx2[1].name ? `bn-notify-${ctx2[1].name}` : "") + " svelte-fbmqmu")) {
        attr(span, "class", span_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(span);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { value } = $$props;
  $$self.$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
  };
  return [value, $app];
}
var Timer = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-fbmqmu-style"))
      add_css$4();
    init(this, options, instance$3, create_fragment$4, safe_not_equal, { value: 0 });
  }
};
function add_css$5() {
  var style = element("style");
  style.id = "svelte-1epeibm-style";
  style.textContent = "div.svelte-1epeibm{display:flex;flex-flow:column nowrap;justify-content:center;font-size:inherit;font-family:inherit;margin:0 1.5rem 0 0.75rem}p.svelte-1epeibm{display:flex;align-items:center;margin:0.5em 0 0 0;opacity:0.7;font-size:0.889em;line-height:1.15;font-family:inherit}span.svelte-1epeibm{font-family:inherit;display:flex;align-items:center}";
  append(document.head, style);
}
function create_if_block(ctx) {
  let span;
  let t0;
  let clock;
  let t1;
  let timer;
  let span_class_value;
  let current;
  clock = new Clock({});
  timer = new Timer({
    props: {
      value: ctx[3](ctx[1] - ctx[0].startTime)
    }
  });
  return {
    c() {
      span = element("span");
      t0 = text("-\n        ");
      create_component(clock.$$.fragment);
      t1 = space();
      create_component(timer.$$.fragment);
      attr(span, "class", span_class_value = "bn-notify-custom bn-notify-notification-info-meta-duration " + (ctx[2].name ? `bn-notify-${ctx[2].name}` : "") + " svelte-1epeibm");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      mount_component(clock, span, null);
      append(span, t1);
      mount_component(timer, span, null);
      current = true;
    },
    p(ctx2, dirty) {
      const timer_changes = {};
      if (dirty & 3)
        timer_changes.value = ctx2[3](ctx2[1] - ctx2[0].startTime);
      timer.$set(timer_changes);
      if (!current || dirty & 4 && span_class_value !== (span_class_value = "bn-notify-custom bn-notify-notification-info-meta-duration " + (ctx2[2].name ? `bn-notify-${ctx2[2].name}` : "") + " svelte-1epeibm")) {
        attr(span, "class", span_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(clock.$$.fragment, local);
      transition_in(timer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clock.$$.fragment, local);
      transition_out(timer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(span);
      destroy_component(clock);
      destroy_component(timer);
    }
  };
}
function create_fragment$5(ctx) {
  let div;
  let notificationmessage;
  let t0;
  let p2;
  let time;
  let t1;
  let p_class_value;
  let div_class_value;
  let current;
  notificationmessage = new NotificationMessage({
    props: { message: ctx[0].message }
  });
  time = new Time({
    props: {
      time: ctx[4](ctx[1])
    }
  });
  let if_block = ctx[0].type === "pending" && ctx[0].startTime && create_if_block(ctx);
  return {
    c() {
      div = element("div");
      create_component(notificationmessage.$$.fragment);
      t0 = space();
      p2 = element("p");
      create_component(time.$$.fragment);
      t1 = space();
      if (if_block)
        if_block.c();
      attr(p2, "class", p_class_value = "bn-notify-custom bn-notify-notification-info-meta " + (ctx[2].name ? `bn-notify-${ctx[2].name}` : "") + " svelte-1epeibm");
      attr(div, "class", div_class_value = "bn-notify-custom bn-notify-notification-info " + (ctx[2].name ? `bn-notify-${ctx[2].name}` : "") + " svelte-1epeibm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(notificationmessage, div, null);
      append(div, t0);
      append(div, p2);
      mount_component(time, p2, null);
      append(p2, t1);
      if (if_block)
        if_block.m(p2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const notificationmessage_changes = {};
      if (dirty & 1)
        notificationmessage_changes.message = ctx2[0].message;
      notificationmessage.$set(notificationmessage_changes);
      const time_changes = {};
      if (dirty & 2)
        time_changes.time = ctx2[4](ctx2[1]);
      time.$set(time_changes);
      if (ctx2[0].type === "pending" && ctx2[0].startTime) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(p2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & 4 && p_class_value !== (p_class_value = "bn-notify-custom bn-notify-notification-info-meta " + (ctx2[2].name ? `bn-notify-${ctx2[2].name}` : "") + " svelte-1epeibm")) {
        attr(p2, "class", p_class_value);
      }
      if (!current || dirty & 4 && div_class_value !== (div_class_value = "bn-notify-custom bn-notify-notification-info " + (ctx2[2].name ? `bn-notify-${ctx2[2].name}` : "") + " svelte-1epeibm")) {
        attr(div, "class", div_class_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(notificationmessage.$$.fragment, local);
      transition_in(time.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(notificationmessage.$$.fragment, local);
      transition_out(time.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_component(notificationmessage);
      destroy_component(time);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let $app;
  let $formatter;
  component_subscribe($$self, app, ($$value) => $$invalidate(2, $app = $$value));
  component_subscribe($$self, Bt, ($$value) => $$invalidate(5, $formatter = $$value));
  function timeString(time) {
    const seconds = Math.floor(time / 1e3);
    const formattedSeconds = seconds < 0 ? 0 : seconds;
    return formattedSeconds >= 60 ? `${Math.floor(formattedSeconds / 60).toLocaleString($app.clientLocale)} ${$formatter("time.minutes")}` : `${formattedSeconds.toLocaleString($app.clientLocale)} ${$formatter("time.seconds")}`;
  }
  function formatTime(number) {
    const time = new Date(number);
    return time.toLocaleString($app.clientLocale, {
      hour: "numeric",
      minute: "numeric",
      hour12: true
    });
  }
  let { notification } = $$props;
  let currentTime = Date.now();
  const intervalId = setInterval(() => {
    $$invalidate(1, currentTime = Date.now());
  }, 1e3);
  onDestroy(() => {
    clearInterval(intervalId);
  });
  $$self.$set = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(0, notification = $$props2.notification);
  };
  return [notification, currentTime, $app, timeString, formatTime];
}
var NotificationContent = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-1epeibm-style"))
      add_css$5();
    init(this, options, instance$4, create_fragment$5, safe_not_equal, { notification: 0 });
  }
};
function add_css$6() {
  var style = element("style");
  style.id = "svelte-ta62lj-style";
  style.textContent = "div.svelte-ta62lj{height:100%;font-size:inherit;font-family:inherit}svg.svelte-ta62lj{width:1.3rem}";
  append(document.head, style);
}
function create_if_block_3(ctx) {
  let svg;
  let style;
  let t;
  let g2;
  let g0;
  let circle0;
  let g1;
  let path2;
  let circle1;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text("@-webkit-keyframes kf_el_51c2MS41pY_an_cXFUsKhg3V {\n  50% {\n    stroke-dasharray: 553;\n  }\n  0% {\n    stroke-dasharray: 553;\n  }\n  100% {\n    stroke-dasharray: 553;\n  }\n}\n@keyframes kf_el_51c2MS41pY_an_cXFUsKhg3V {\n  50% {\n    stroke-dasharray: 553;\n  }\n  0% {\n    stroke-dasharray: 553;\n  }\n  100% {\n    stroke-dasharray: 553;\n  }\n}\n@-webkit-keyframes kf_el_51c2MS41pY_an_M-ML-YLcm {\n  50% {\n    stroke-dashoffset: 553;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 553;\n  }\n}\n@keyframes kf_el_51c2MS41pY_an_M-ML-YLcm {\n  50% {\n    stroke-dashoffset: 553;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 553;\n  }\n}\n@-webkit-keyframes kf_el_j5HR_U6Nrp_an_KGzPpGvQb {\n  50% {\n    opacity: 0;\n  }\n  56.67% {\n    opacity: 1;\n  }\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes kf_el_j5HR_U6Nrp_an_KGzPpGvQb {\n  50% {\n    opacity: 0;\n  }\n  56.67% {\n    opacity: 1;\n  }\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@-webkit-keyframes kf_el_j5HR_U6Nrp_an_al_MjoEv-F {\n  50% {\n    stroke-dasharray: 39.41;\n  }\n  0% {\n    stroke-dasharray: 39.41;\n  }\n  100% {\n    stroke-dasharray: 39.41;\n  }\n}\n@keyframes kf_el_j5HR_U6Nrp_an_al_MjoEv-F {\n  50% {\n    stroke-dasharray: 39.41;\n  }\n  0% {\n    stroke-dasharray: 39.41;\n  }\n  100% {\n    stroke-dasharray: 39.41;\n  }\n}\n@-webkit-keyframes kf_el_j5HR_U6Nrp_an_VsVMmQ1MU {\n  50% {\n    stroke-dashoffset: 39.41;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 39.41;\n  }\n}\n@keyframes kf_el_j5HR_U6Nrp_an_VsVMmQ1MU {\n  50% {\n    stroke-dashoffset: 39.41;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 39.41;\n  }\n}\n@-webkit-keyframes kf_el_TZApOLwXZU_an_dL6-SZLSH {\n  50% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  83.33% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  100% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(1, 1) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(1, 1)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  0% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n}\n@keyframes kf_el_TZApOLwXZU_an_dL6-SZLSH {\n  50% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  83.33% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  100% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(1, 1) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(1, 1)\n      translate(-88.50000762939453px, -56.5px);\n  }\n  0% {\n    -webkit-transform: translate(88.50000762939453px, 56.5px)\n      scale(0, 0) translate(-88.50000762939453px, -56.5px);\n    transform: translate(88.50000762939453px, 56.5px) scale(0, 0)\n      translate(-88.50000762939453px, -56.5px);\n  }\n}\n#el_DHAskxC2T * {\n  -webkit-animation-duration: 1s;\n  animation-duration: 1s;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el__hILOKhuR3 {\n  fill: none;\n  -webkit-transform: translate(7px, 7px);\n  transform: translate(7px, 7px);\n}\n#el_TZApOLwXZU {\n  fill: #979797;\n  -webkit-transform: matrix(1, 0, 0, -1, 0, 113);\n  transform: matrix(1, 0, 0, -1, 0, 113);\n}\n#el_fIxIrV8WbF {\n  stroke: #979797;\n  stroke-width: 14;\n}\n#el_TZApOLwXZU_an_dL6-SZLSH {\n  -webkit-animation-fill-mode: forwards;\n  animation-fill-mode: forwards;\n  -webkit-animation-name: kf_el_TZApOLwXZU_an_dL6-SZLSH;\n  animation-name: kf_el_TZApOLwXZU_an_dL6-SZLSH;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el_j5HR_U6Nrp {\n  -webkit-animation-fill-mode: forwards, forwards, forwards;\n  animation-fill-mode: forwards, forwards, forwards;\n  -webkit-animation-name: kf_el_j5HR_U6Nrp_an_VsVMmQ1MU,\n    kf_el_j5HR_U6Nrp_an_al_MjoEv-F, kf_el_j5HR_U6Nrp_an_KGzPpGvQb;\n  animation-name: kf_el_j5HR_U6Nrp_an_VsVMmQ1MU,\n    kf_el_j5HR_U6Nrp_an_al_MjoEv-F, kf_el_j5HR_U6Nrp_an_KGzPpGvQb;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1), cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1), cubic-bezier(0, 0, 1, 1);\n}\n#el_51c2MS41pY {\n  -webkit-animation-fill-mode: forwards, forwards;\n  animation-fill-mode: forwards, forwards;\n  -webkit-animation-name: kf_el_51c2MS41pY_an_M-ML-YLcm,\n    kf_el_51c2MS41pY_an_cXFUsKhg3V;\n  animation-name: kf_el_51c2MS41pY_an_M-ML-YLcm,\n    kf_el_51c2MS41pY_an_cXFUsKhg3V;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n}\n      ");
      g2 = svg_element("g");
      g0 = svg_element("g");
      circle0 = svg_element("circle");
      g1 = svg_element("g");
      path2 = svg_element("path");
      circle1 = svg_element("circle");
      attr(circle0, "cx", "88.5");
      attr(circle0, "cy", "56.5");
      attr(circle0, "r", "7.5");
      attr(circle0, "id", "el_TZApOLwXZU");
      attr(g0, "id", "el_TZApOLwXZU_an_dL6-SZLSH");
      attr(g0, "data-animator-group", "true");
      attr(g0, "data-animator-type", "2");
      attr(path2, "d", "m88.5 128v-39.4130859");
      attr(path2, "stroke-linecap", "round");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "id", "el_j5HR_U6Nrp");
      attr(circle1, "cx", "88");
      attr(circle1, "cy", "88");
      attr(circle1, "r", "88");
      attr(circle1, "id", "el_51c2MS41pY");
      attr(g1, "id", "el_fIxIrV8WbF");
      attr(g2, "fill-rule", "evenodd");
      attr(g2, "id", "el__hILOKhuR3");
      attr(svg, "viewBox", "0 0 190 190");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "id", "el_DHAskxC2T");
      attr(svg, "class", "svelte-ta62lj");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, g2);
      append(g2, g0);
      append(g0, circle0);
      append(g2, g1);
      append(g1, path2);
      append(g1, circle1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_2(ctx) {
  let svg;
  let style;
  let t;
  let g3;
  let circle;
  let g2;
  let g0;
  let path0;
  let g1;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text("@-webkit-keyframes kf_el_fv0z90vBrL_an_PwUBZ96LS {\n  0% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n  }\n  100% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n  }\n}\n@keyframes kf_el_fv0z90vBrL_an_PwUBZ96LS {\n  0% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n  }\n  100% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n  }\n}\n@-webkit-keyframes kf_el_u3QHGLTow3_an_EQ8OetHGq {\n  0% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n  }\n  50% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n  }\n  100% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(720deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(720deg)\n      translate(-88px, -87.587890625px);\n  }\n}\n@keyframes kf_el_u3QHGLTow3_an_EQ8OetHGq {\n  0% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(0deg)\n      translate(-88px, -87.587890625px);\n  }\n  50% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(360deg)\n      translate(-88px, -87.587890625px);\n  }\n  100% {\n    -webkit-transform: translate(88px, 87.587890625px) rotate(720deg)\n      translate(-88px, -87.587890625px);\n    transform: translate(88px, 87.587890625px) rotate(720deg)\n      translate(-88px, -87.587890625px);\n  }\n}\n#el_XWLVvD_rP * {\n  -webkit-animation-duration: 2s;\n  animation-duration: 2s;\n  -webkit-animation-iteration-count: infinite;\n  animation-iteration-count: infinite;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el_Uh6HOhkAVi {\n  fill: none;\n  stroke-width: 14;\n  -webkit-transform: translate(7px, 7px);\n  transform: translate(7px, 7px);\n}\n#el_PHAWgO26lN {\n  stroke: #ffbd00;\n}\n#el_A4XF5QQwhp {\n  stroke: #ffbf00;\n}\n#el_u3QHGLTow3_an_EQ8OetHGq {\n  -webkit-animation-fill-mode: backwards;\n  animation-fill-mode: backwards;\n  -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n    translate(-88px, -87.587890625px);\n  transform: translate(88px, 87.587890625px) rotate(0deg)\n    translate(-88px, -87.587890625px);\n  -webkit-animation-name: kf_el_u3QHGLTow3_an_EQ8OetHGq;\n  animation-name: kf_el_u3QHGLTow3_an_EQ8OetHGq;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el_fv0z90vBrL_an_PwUBZ96LS {\n  -webkit-animation-fill-mode: backwards;\n  animation-fill-mode: backwards;\n  -webkit-transform: translate(88px, 87.587890625px) rotate(0deg)\n    translate(-88px, -87.587890625px);\n  transform: translate(88px, 87.587890625px) rotate(0deg)\n    translate(-88px, -87.587890625px);\n  -webkit-animation-name: kf_el_fv0z90vBrL_an_PwUBZ96LS;\n  animation-name: kf_el_fv0z90vBrL_an_PwUBZ96LS;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n      ");
      g3 = svg_element("g");
      circle = svg_element("circle");
      g2 = svg_element("g");
      g0 = svg_element("g");
      path0 = svg_element("path");
      g1 = svg_element("g");
      path1 = svg_element("path");
      attr(circle, "cx", "88");
      attr(circle, "cy", "88");
      attr(circle, "r", "88");
      attr(circle, "id", "el_PHAWgO26lN");
      attr(path0, "d", "m88 25v62.5878906");
      attr(path0, "id", "el_fv0z90vBrL");
      attr(g0, "id", "el_fv0z90vBrL_an_PwUBZ96LS");
      attr(g0, "data-animator-group", "true");
      attr(g0, "data-animator-type", "1");
      attr(path1, "d", "m88 45.9160156v41.671875");
      attr(path1, "id", "el_u3QHGLTow3");
      attr(g1, "id", "el_u3QHGLTow3_an_EQ8OetHGq");
      attr(g1, "data-animator-group", "true");
      attr(g1, "data-animator-type", "1");
      attr(g2, "stroke-linecap", "round");
      attr(g2, "stroke-linejoin", "round");
      attr(g2, "id", "el_A4XF5QQwhp");
      attr(g3, "fill-rule", "evenodd");
      attr(g3, "id", "el_Uh6HOhkAVi");
      attr(svg, "viewBox", "0 0 190 190");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "id", "el_XWLVvD_rP");
      attr(svg, "class", "svelte-ta62lj");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, g3);
      append(g3, circle);
      append(g3, g2);
      append(g2, g0);
      append(g0, path0);
      append(g2, g1);
      append(g1, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block_1(ctx) {
  let svg;
  let style;
  let t;
  let path2;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text("@-webkit-keyframes kf_el_RzYtw9rUyN_an_gX4OsFPwzz {\n  0% {\n    stroke-dasharray: 473.87;\n  }\n  100% {\n    stroke-dasharray: 473.87;\n  }\n}\n@keyframes kf_el_RzYtw9rUyN_an_gX4OsFPwzz {\n  0% {\n    stroke-dasharray: 473.87;\n  }\n  100% {\n    stroke-dasharray: 473.87;\n  }\n}\n@-webkit-keyframes kf_el_RzYtw9rUyN_an_WfcYZ9pjL {\n  0% {\n    stroke-dashoffset: 473.87;\n  }\n  50% {\n    stroke-dashoffset: 473.87;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n}\n@keyframes kf_el_RzYtw9rUyN_an_WfcYZ9pjL {\n  0% {\n    stroke-dashoffset: 473.87;\n  }\n  50% {\n    stroke-dashoffset: 473.87;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n}\n#el_3OA8Szq_A * {\n  -webkit-animation-duration: 1s;\n  animation-duration: 1s;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el_RzYtw9rUyN {\n  fill: none;\n  stroke: #7ed321;\n  stroke-width: 17;\n  -webkit-animation-fill-mode: forwards, forwards;\n  animation-fill-mode: forwards, forwards;\n  -webkit-animation-name: kf_el_RzYtw9rUyN_an_WfcYZ9pjL,\n    kf_el_RzYtw9rUyN_an_gX4OsFPwzz;\n  animation-name: kf_el_RzYtw9rUyN_an_WfcYZ9pjL,\n    kf_el_RzYtw9rUyN_an_gX4OsFPwzz;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n}\n      ");
      path2 = svg_element("path");
      attr(path2, "d", "m176.126953 63.8789062-94.4130858 95.4130858-72.87402345-72.8740232\n        27.93945315-27.9394532 44.9345703 44.9345704 94.4130858-94.413086");
      attr(path2, "stroke-linecap", "round");
      attr(path2, "stroke-linejoin", "round");
      attr(path2, "id", "el_RzYtw9rUyN");
      attr(svg, "viewBox", "0 0 185 168");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "id", "el_3OA8Szq_A");
      attr(svg, "class", "svelte-ta62lj");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, path2);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_if_block$1(ctx) {
  let svg;
  let style;
  let t;
  let g1;
  let path0;
  let g0;
  let circle;
  let path1;
  return {
    c() {
      svg = svg_element("svg");
      style = svg_element("style");
      t = text("@-webkit-keyframes kf_el_IAuv9ut-2-_an_xlDuvYsRc {\n  50% {\n    opacity: 0;\n  }\n  66.67% {\n    opacity: 1;\n  }\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes kf_el_IAuv9ut-2-_an_xlDuvYsRc {\n  50% {\n    opacity: 0;\n  }\n  66.67% {\n    opacity: 1;\n  }\n  0% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@-webkit-keyframes kf_el_IAuv9ut-2-_an_29XE36SGo1 {\n  50% {\n    stroke-dasharray: 39.41;\n  }\n  0% {\n    stroke-dasharray: 39.41;\n  }\n  100% {\n    stroke-dasharray: 39.41;\n  }\n}\n@keyframes kf_el_IAuv9ut-2-_an_29XE36SGo1 {\n  50% {\n    stroke-dasharray: 39.41;\n  }\n  0% {\n    stroke-dasharray: 39.41;\n  }\n  100% {\n    stroke-dasharray: 39.41;\n  }\n}\n@-webkit-keyframes kf_el_IAuv9ut-2-_an_xo_EIWruT {\n  50% {\n    stroke-dashoffset: 39.41;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 39.41;\n  }\n}\n@keyframes kf_el_IAuv9ut-2-_an_xo_EIWruT {\n  50% {\n    stroke-dashoffset: 39.41;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 39.41;\n  }\n}\n@-webkit-keyframes kf_el_q_eIK0z3HI_an_045tZJOHl {\n  50% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  83.33% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  100% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(1, 1) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(1, 1)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  0% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n}\n@keyframes kf_el_q_eIK0z3HI_an_045tZJOHl {\n  50% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  83.33% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  100% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(1, 1) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(1, 1)\n      translate(-88.50000762939453px, -144.5px);\n  }\n  0% {\n    -webkit-transform: translate(88.50000762939453px, 144.5px)\n      scale(0, 0) translate(-88.50000762939453px, -144.5px);\n    transform: translate(88.50000762939453px, 144.5px) scale(0, 0)\n      translate(-88.50000762939453px, -144.5px);\n  }\n}\n@-webkit-keyframes kf_el_5BNAI_PBsn_an_aToWhdlG8F {\n  50% {\n    stroke-dasharray: 527.67;\n  }\n  0% {\n    stroke-dasharray: 527.67;\n  }\n  100% {\n    stroke-dasharray: 527.67;\n  }\n}\n@keyframes kf_el_5BNAI_PBsn_an_aToWhdlG8F {\n  50% {\n    stroke-dasharray: 527.67;\n  }\n  0% {\n    stroke-dasharray: 527.67;\n  }\n  100% {\n    stroke-dasharray: 527.67;\n  }\n}\n@-webkit-keyframes kf_el_5BNAI_PBsn_an_tQV_CQebU {\n  50% {\n    stroke-dashoffset: 527.67;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 527.67;\n  }\n}\n@keyframes kf_el_5BNAI_PBsn_an_tQV_CQebU {\n  50% {\n    stroke-dashoffset: 527.67;\n  }\n  100% {\n    stroke-dashoffset: 0;\n  }\n  0% {\n    stroke-dashoffset: 527.67;\n  }\n}\n#el_bYTVKD04y * {\n  -webkit-animation-duration: 1s;\n  animation-duration: 1s;\n  -webkit-animation-iteration-count: 1;\n  animation-iteration-count: 1;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n#el_doMgf96Cxx {\n  fill: none;\n  -webkit-transform: translate(1px, -5px);\n  transform: translate(1px, -5px);\n}\n#el_5BNAI_PBsn {\n  stroke: #ff0039;\n  stroke-width: 14;\n  -webkit-animation-fill-mode: forwards, forwards;\n  animation-fill-mode: forwards, forwards;\n  -webkit-animation-name: kf_el_5BNAI_PBsn_an_tQV_CQebU,\n    kf_el_5BNAI_PBsn_an_aToWhdlG8F;\n  animation-name: kf_el_5BNAI_PBsn_an_tQV_CQebU,\n    kf_el_5BNAI_PBsn_an_aToWhdlG8F;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1);\n}\n#el_q_eIK0z3HI {\n  fill: #ff0042;\n}\n#el_IAuv9ut-2- {\n  stroke: #ff0042;\n  stroke-width: 14;\n  -webkit-animation-fill-mode: forwards, forwards, forwards;\n  animation-fill-mode: forwards, forwards, forwards;\n  -webkit-animation-name: kf_el_IAuv9ut-2-_an_xo_EIWruT,\n    kf_el_IAuv9ut-2-_an_29XE36SGo1, kf_el_IAuv9ut-2-_an_xlDuvYsRc;\n  animation-name: kf_el_IAuv9ut-2-_an_xo_EIWruT,\n    kf_el_IAuv9ut-2-_an_29XE36SGo1, kf_el_IAuv9ut-2-_an_xlDuvYsRc;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1), cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1),\n    cubic-bezier(0, 0, 1, 1), cubic-bezier(0, 0, 1, 1);\n}\n#el_q_eIK0z3HI_an_045tZJOHl {\n  -webkit-animation-fill-mode: forwards;\n  animation-fill-mode: forwards;\n  -webkit-animation-name: kf_el_q_eIK0z3HI_an_045tZJOHl;\n  animation-name: kf_el_q_eIK0z3HI_an_045tZJOHl;\n  -webkit-animation-timing-function: cubic-bezier(0, 0, 1, 1);\n  animation-timing-function: cubic-bezier(0, 0, 1, 1);\n}\n      ");
      g1 = svg_element("g");
      path0 = svg_element("path");
      g0 = svg_element("g");
      circle = svg_element("circle");
      path1 = svg_element("path");
      attr(path0, "d", "m96.9442719 17.8885438 71.8196601 143.6393202c2.469893\n          4.939785.467649 10.946515-4.472136 13.416408-1.388554.694277-2.919685\n          1.055728-4.472136 1.055728h-143.6393201c-5.5228475\n          0-10.00000001-4.477153-10.00000001-10 0-1.552451.36145092-3.083582\n          1.05572809-4.472136l71.81966012-143.6393202c2.4698925-4.939785\n          8.4766229-6.9420284 13.4164079-4.4721359 1.935274.967637 3.5044989\n          2.5368619 4.4721359 4.4721359z");
      attr(path0, "stroke-linejoin", "round");
      attr(path0, "id", "el_5BNAI_PBsn");
      attr(circle, "cx", "88.5");
      attr(circle, "cy", "144.5");
      attr(circle, "r", "7.5");
      attr(circle, "id", "el_q_eIK0z3HI");
      attr(g0, "id", "el_q_eIK0z3HI_an_045tZJOHl");
      attr(g0, "data-animator-group", "true");
      attr(g0, "data-animator-type", "2");
      attr(path1, "d", "m88.5 112.413086v-39.413086");
      attr(path1, "stroke-linecap", "round");
      attr(path1, "stroke-linejoin", "round");
      attr(path1, "id", "el_IAuv9ut-2-");
      attr(g1, "fill-rule", "evenodd");
      attr(g1, "id", "el_doMgf96Cxx");
      attr(svg, "viewBox", "0 0 178 178");
      attr(svg, "xmlns", "http://www.w3.org/2000/svg");
      attr(svg, "id", "el_bYTVKD04y");
      attr(svg, "class", "svelte-ta62lj");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, style);
      append(style, t);
      append(svg, g1);
      append(g1, path0);
      append(g1, g0);
      append(g0, circle);
      append(g1, path1);
    },
    d(detaching) {
      if (detaching)
        detach(svg);
    }
  };
}
function create_fragment$6(ctx) {
  let div;
  let t0;
  let t1;
  let t2;
  let div_class_value;
  let if_block0 = ctx[0] === "hint" && create_if_block_3();
  let if_block1 = ctx[0] === "pending" && create_if_block_2();
  let if_block2 = ctx[0] === "success" && create_if_block_1();
  let if_block3 = ctx[0] === "error" && create_if_block$1();
  return {
    c() {
      div = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      attr(div, "class", div_class_value = "bn-notify-custom bn-notify-notification-status-icon " + (ctx[1].name ? `bn-notify-${ctx[1].name}` : "") + " svelte-ta62lj");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0)
        if_block0.m(div, null);
      append(div, t0);
      if (if_block1)
        if_block1.m(div, null);
      append(div, t1);
      if (if_block2)
        if_block2.m(div, null);
      append(div, t2);
      if (if_block3)
        if_block3.m(div, null);
    },
    p(ctx2, [dirty]) {
      if (ctx2[0] === "hint") {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_3();
          if_block0.c();
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (ctx2[0] === "pending") {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_2();
          if_block1.c();
          if_block1.m(div, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (ctx2[0] === "success") {
        if (if_block2)
          ;
        else {
          if_block2 = create_if_block_1();
          if_block2.c();
          if_block2.m(div, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (ctx2[0] === "error") {
        if (if_block3)
          ;
        else {
          if_block3 = create_if_block$1();
          if_block3.c();
          if_block3.m(div, null);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (dirty & 2 && div_class_value !== (div_class_value = "bn-notify-custom bn-notify-notification-status-icon " + (ctx2[1].name ? `bn-notify-${ctx2[1].name}` : "") + " svelte-ta62lj")) {
        attr(div, "class", div_class_value);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  let $app;
  component_subscribe($$self, app, ($$value) => $$invalidate(1, $app = $$value));
  let { type } = $$props;
  $$self.$set = ($$props2) => {
    if ("type" in $$props2)
      $$invalidate(0, type = $$props2.type);
  };
  return [type, $app];
}
var TypeIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-ta62lj-style"))
      add_css$6();
    init(this, options, instance$5, create_fragment$6, safe_not_equal, { type: 0 });
  }
};
function instance$6($$self, $$props, $$invalidate) {
  let { notification } = $$props;
  if (notification.autoDismiss && notification.id) {
    setTimeout(() => {
      notifications.remove(notification.id, notification.eventCode);
    }, notification.autoDismiss);
  }
  $$self.$set = ($$props2) => {
    if ("notification" in $$props2)
      $$invalidate(0, notification = $$props2.notification);
  };
  return [notification];
}
var AutoDismiss = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance$6, null, safe_not_equal, { notification: 0 });
  }
};
function add_css$7() {
  var style = element("style");
  style.id = "svelte-t2ve4g-style";
  style.textContent = "ul.svelte-t2ve4g{display:flex;flex-flow:column nowrap;position:fixed;font-size:16px;padding:0 0.75em;margin:0;list-style-type:none;width:18rem;bottom:0;right:0;font-family:'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;max-height:100vh;overflow-y:scroll;overflow-x:hidden;color:#4a4a4a;background:transparent;scrollbar-width:none;box-sizing:border-box;height:100vh;pointer-events:none;z-index:99999999}@media only screen and (max-width: 450px){ul.svelte-t2ve4g{width:100%}}.bn-notify-custom.bn-notify-dark-mode{background:#283944;color:#ffffff;background:rgba(40, 57, 68, 0.9)}.bn-notify-clickable:hover{cursor:pointer}.svelte-t2ve4g::-webkit-scrollbar{display:none}li.svelte-t2ve4g{position:relative;display:flex;padding:0.75em;font-size:0.889em;font-family:inherit;border-radius:10px;background:#ffffff;box-shadow:0px 2px 10px rgba(0, 0, 0, 0.1);color:inherit;transition:background 300ms ease-in-out, color 300ms ease-in-out;pointer-events:all;background:#ffffff;backdrop-filter:blur(5px);background:rgba(255, 255, 255, 0.9)}div.svelte-t2ve4g{position:absolute;top:0.75em;right:0.75em;font-size:inherit;font-family:inherit}a.svelte-t2ve4g{display:flex;text-decoration:none;color:inherit}";
  append(document.head, style);
}
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  return child_ctx;
}
function create_if_block$2(ctx) {
  let ul;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let ul_class_value;
  let ul_style_value;
  let current;
  let each_value = ctx[6];
  const get_key = (ctx2) => ctx2[10].key;
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      ul = element("ul");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(ul, "class", ul_class_value = "bn-notify-custom bn-notify-notifications " + (ctx[5].name ? `bn-notify-${ctx[5].name}` : "") + " svelte-t2ve4g");
      attr(ul, "style", ul_style_value = `${ctx[0]} ${ctx[4]}`);
    },
    m(target, anchor) {
      insert(target, ul, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].m(ul, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & 104) {
        const each_value2 = ctx2[6];
        group_outros();
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].r();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value2, each_1_lookup, ul, fix_and_outro_and_destroy_block, create_each_block, null, get_each_context);
        for (let i2 = 0; i2 < each_blocks.length; i2 += 1)
          each_blocks[i2].a();
        check_outros();
      }
      if (!current || dirty & 32 && ul_class_value !== (ul_class_value = "bn-notify-custom bn-notify-notifications " + (ctx2[5].name ? `bn-notify-${ctx2[5].name}` : "") + " svelte-t2ve4g")) {
        attr(ul, "class", ul_class_value);
      }
      if (!current || dirty & 17 && ul_style_value !== (ul_style_value = `${ctx2[0]} ${ctx2[4]}`)) {
        attr(ul, "style", ul_style_value);
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(ul);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_else_block(ctx) {
  let typeicon;
  let t;
  let notificationcontent;
  let current;
  typeicon = new TypeIcon({
    props: { type: ctx[10].type }
  });
  notificationcontent = new NotificationContent({
    props: { notification: ctx[10] }
  });
  return {
    c() {
      create_component(typeicon.$$.fragment);
      t = space();
      create_component(notificationcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(typeicon, target, anchor);
      insert(target, t, anchor);
      mount_component(notificationcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const typeicon_changes = {};
      if (dirty & 64)
        typeicon_changes.type = ctx2[10].type;
      typeicon.$set(typeicon_changes);
      const notificationcontent_changes = {};
      if (dirty & 64)
        notificationcontent_changes.notification = ctx2[10];
      notificationcontent.$set(notificationcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(typeicon.$$.fragment, local);
      transition_in(notificationcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typeicon.$$.fragment, local);
      transition_out(notificationcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(typeicon, detaching);
      if (detaching)
        detach(t);
      destroy_component(notificationcontent, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let a2;
  let typeicon;
  let t;
  let notificationcontent;
  let a_href_value;
  let current;
  typeicon = new TypeIcon({
    props: { type: ctx[10].type }
  });
  notificationcontent = new NotificationContent({
    props: { notification: ctx[10] }
  });
  return {
    c() {
      a2 = element("a");
      create_component(typeicon.$$.fragment);
      t = space();
      create_component(notificationcontent.$$.fragment);
      attr(a2, "class", "bn-notify-notification-link svelte-t2ve4g");
      attr(a2, "href", a_href_value = ctx[10].link);
      attr(a2, "target", "_blank");
      attr(a2, "rel", "noreferrer noopener");
    },
    m(target, anchor) {
      insert(target, a2, anchor);
      mount_component(typeicon, a2, null);
      append(a2, t);
      mount_component(notificationcontent, a2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const typeicon_changes = {};
      if (dirty & 64)
        typeicon_changes.type = ctx2[10].type;
      typeicon.$set(typeicon_changes);
      const notificationcontent_changes = {};
      if (dirty & 64)
        notificationcontent_changes.notification = ctx2[10];
      notificationcontent.$set(notificationcontent_changes);
      if (!current || dirty & 64 && a_href_value !== (a_href_value = ctx2[10].link)) {
        attr(a2, "href", a_href_value);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(typeicon.$$.fragment, local);
      transition_in(notificationcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(typeicon.$$.fragment, local);
      transition_out(notificationcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(a2);
      destroy_component(typeicon);
      destroy_component(notificationcontent);
    }
  };
}
function create_each_block(key_1, ctx) {
  let li;
  let current_block_type_index;
  let if_block;
  let t0;
  let div;
  let closeicon;
  let div_class_value;
  let t1;
  let autodismiss;
  let t2;
  let li_class_value;
  let li_intro;
  let li_outro;
  let rect;
  let stop_animation = noop;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1$1, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (ctx2[10].link)
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  closeicon = new CloseIcon({});
  function click_handler(...args) {
    return ctx[7](ctx[10], ...args);
  }
  autodismiss = new AutoDismiss({
    props: { notification: ctx[10] }
  });
  function click_handler_1(...args) {
    return ctx[8](ctx[10], ...args);
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      if_block.c();
      t0 = space();
      div = element("div");
      create_component(closeicon.$$.fragment);
      t1 = space();
      create_component(autodismiss.$$.fragment);
      t2 = space();
      attr(div, "class", div_class_value = "bn-notify-custom bn-notify-notification-close " + (ctx[5].name ? `bn-notify-${ctx[5].name}` : "") + " svelte-t2ve4g");
      attr(li, "style", ctx[3]);
      attr(li, "class", li_class_value = `bn-notify-custom bn-notify-notification bn-notify-notification-${ctx[10].type}
        ` + (ctx[5].name ? `bn-notify-${ctx[5].name}` : "") + " svelte-t2ve4g");
      toggle_class(li, "bn-notify-dark-mode", ctx[5].darkMode);
      toggle_class(li, "bn-notify-clickable", ctx[10].onclick);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if_blocks[current_block_type_index].m(li, null);
      append(li, t0);
      append(li, div);
      mount_component(closeicon, div, null);
      append(li, t1);
      mount_component(autodismiss, li, null);
      append(li, t2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", stop_propagation(click_handler)),
          listen(li, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block.c();
        }
        transition_in(if_block, 1);
        if_block.m(li, t0);
      }
      if (!current || dirty & 32 && div_class_value !== (div_class_value = "bn-notify-custom bn-notify-notification-close " + (ctx[5].name ? `bn-notify-${ctx[5].name}` : "") + " svelte-t2ve4g")) {
        attr(div, "class", div_class_value);
      }
      const autodismiss_changes = {};
      if (dirty & 64)
        autodismiss_changes.notification = ctx[10];
      autodismiss.$set(autodismiss_changes);
      if (!current || dirty & 8) {
        attr(li, "style", ctx[3]);
      }
      if (!current || dirty & 96 && li_class_value !== (li_class_value = `bn-notify-custom bn-notify-notification bn-notify-notification-${ctx[10].type}
        ` + (ctx[5].name ? `bn-notify-${ctx[5].name}` : "") + " svelte-t2ve4g")) {
        attr(li, "class", li_class_value);
      }
      if (dirty & 96) {
        toggle_class(li, "bn-notify-dark-mode", ctx[5].darkMode);
      }
      if (dirty & 96) {
        toggle_class(li, "bn-notify-clickable", ctx[10].onclick);
      }
    },
    r() {
      rect = li.getBoundingClientRect();
    },
    f() {
      fix_position(li);
      stop_animation();
      add_transform(li, rect);
    },
    a() {
      stop_animation();
      stop_animation = create_animation(li, rect, flip, { duration: 500 });
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      transition_in(closeicon.$$.fragment, local);
      transition_in(autodismiss.$$.fragment, local);
      add_render_callback(() => {
        if (li_outro)
          li_outro.end(1);
        if (!li_intro)
          li_intro = create_in_transition(li, fly, {
            duration: 1200,
            delay: 300,
            x: ctx[1],
            y: ctx[2],
            easing: elasticOut
          });
        li_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(if_block);
      transition_out(closeicon.$$.fragment, local);
      transition_out(autodismiss.$$.fragment, local);
      if (li_intro)
        li_intro.invalidate();
      li_outro = create_out_transition(li, fly, {
        duration: 400,
        x: ctx[1],
        y: ctx[2],
        easing: quintIn
      });
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(li);
      if_blocks[current_block_type_index].d();
      destroy_component(closeicon);
      destroy_component(autodismiss);
      if (detaching && li_outro)
        li_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$7(ctx) {
  let if_block_anchor;
  let current;
  let if_block = ctx[6].length > 0 && create_if_block$2(ctx);
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty2();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (ctx2[6].length > 0) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & 64) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function elasticOut(t) {
  return Math.sin(-13 * (t + 1) * Math.PI / 2) * Math.pow(2, -35 * t) + 1;
}
function instance$7($$self, $$props, $$invalidate) {
  let $app;
  let $notifications;
  component_subscribe($$self, app, ($$value) => $$invalidate(5, $app = $$value));
  component_subscribe($$self, notifications, ($$value) => $$invalidate(6, $notifications = $$value));
  let smallScreen = window.outerWidth < 450;
  let positioning;
  let x3;
  let y2;
  let notificationMargin;
  let justifyContent;
  window.addEventListener("resize", (0, import_lodash.default)(() => {
    if (window.outerWidth < 450) {
      if (!smallScreen) {
        $$invalidate(9, smallScreen = true);
      }
    } else {
      if (smallScreen) {
        $$invalidate(9, smallScreen = false);
      }
    }
  }, 300));
  const click_handler = (notification) => notifications.remove(notification.id, notification.eventCode);
  const click_handler_1 = (notification, e) => notification.onclick && notification.onclick(e);
  $$self.$$.update = () => {
    if ($$self.$$.dirty & 545) {
      if ($app.desktopPosition && !smallScreen) {
        $$invalidate(0, positioning = $app.desktopPosition === "bottomRight" ? "bottom: 0; right: 0;" : $app.desktopPosition === "bottomLeft" ? "left: 0; right: unset;" : $app.desktopPosition === "topRight" ? "top: 0;" : "top: 0; bottom: unset; left: 0; right: unset;");
        $$invalidate(1, x3 = positioning && positioning.includes("left") ? -321 : 321);
        $$invalidate(2, y2 = 0);
        if ($app.desktopPosition.includes("top")) {
          $$invalidate(4, justifyContent = "justify-content: unset;");
          $$invalidate(3, notificationMargin = "margin: 0.75rem 0 0 0;");
        } else {
          $$invalidate(4, justifyContent = "justify-content: flex-end;");
          $$invalidate(3, notificationMargin = "margin: 0 0 0.75rem 0;");
        }
      }
    }
    if ($$self.$$.dirty & 544) {
      if ($app.mobilePosition && smallScreen) {
        $$invalidate(0, positioning = $app.mobilePosition === "top" ? "top: 0; bottom: unset;" : "bottom: 0; top: unset;");
        $$invalidate(1, x3 = 0);
        if ($app.mobilePosition === "top") {
          $$invalidate(2, y2 = -50);
          $$invalidate(4, justifyContent = "justify-content: unset;");
          $$invalidate(3, notificationMargin = "margin: 0.75rem 0 0 0;");
        } else {
          $$invalidate(2, y2 = 50);
          $$invalidate(4, justifyContent = "justify-content: flex-end;");
          $$invalidate(3, notificationMargin = "margin: 0 0 0.75rem 0;");
        }
      }
    }
    if ($$self.$$.dirty & 544) {
      if (!$app.desktopPosition && !$app.mobilePosition) {
        $$invalidate(1, x3 = smallScreen ? 0 : 321);
        $$invalidate(2, y2 = smallScreen ? 50 : 0);
        $$invalidate(3, notificationMargin = "margin: 0 0 0.75rem 0;");
        $$invalidate(4, justifyContent = "justify-content: flex-end;");
        $$invalidate(0, positioning = "bottom: 0; right: 0;");
      }
    }
  };
  return [
    positioning,
    x3,
    y2,
    notificationMargin,
    justifyContent,
    $app,
    $notifications,
    click_handler,
    click_handler_1
  ];
}
var Notify = class extends SvelteComponent {
  constructor(options) {
    super();
    if (!document.getElementById("svelte-t2ve4g-style"))
      add_css$7();
    init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
  }
};
function eventToType(eventCode) {
  switch (eventCode) {
    case "txSent":
    case "txPool":
    case "txSpeedUp":
    case "txCancel":
      return "pending";
    case "txRequest":
    case "txRepeat":
    case "txAwaitingApproval":
    case "txConfirmReminder":
    case "txStallPending":
    case "txStallConfirmed":
    case "txStuck":
      return "hint";
    case "txError":
    case "txSendFail":
    case "txFailed":
    case "txDropped":
    case "nsfFail":
    case "txUnderpriced":
      return "error";
    case "txConfirmed":
      return "success";
    default:
      return "hint";
  }
}
function typeToDismissTimeout(type) {
  switch (type) {
    case "success":
    case "hint":
      return 4e3;
    default:
      return 0;
  }
}
var formatter;
Bt.subscribe((store) => formatter = store);
function createNotification(transactionDetails, customization = {}) {
  const notificationObject = transactionDetails.system === "bitcoin" ? createBitcoinNotificationObject(transactionDetails, customization) : createEthereumNotificationObject(transactionDetails, customization);
  notifications.add(notificationObject);
}
function createBitcoinNotificationObject(transactionDetails, customization) {
  const { id, txid, startTime, eventCode, watchedAddress, inputs, outputs } = transactionDetails;
  const type = eventToType(eventCode);
  const key = `${id}-${typeof customization === "object" && customization.eventCode || eventCode}`;
  const { direction, value } = getBitcoinDirectionValue(inputs, outputs, watchedAddress);
  const formatterOptions = watchedAddress ? {
    messageId: `watched['${eventCode}']`,
    values: {
      verb: eventCode === "txConfirmed" ? direction === "incoming" ? "received" : "sent" : direction === "incoming" ? "receiving" : "sending",
      formattedValue: value,
      asset: "BTC",
      preposition: "",
      counterpartyShortened: ""
    }
  } : {
    messageId: `transaction['${eventCode}']`,
    values: { value, asset: "BTC" }
  };
  const internationalizedMessage = formatter(formatterOptions.messageId, {
    values: formatterOptions.values
  });
  const noMessageAvailable = internationalizedMessage === formatterOptions.messageId;
  const message = noMessageAvailable ? defaultNotifyMessages.en[watchedAddress ? "watched" : "transaction"][eventCode || ""] : internationalizedMessage;
  let notificationObject = {
    id: id || txid,
    type,
    key,
    startTime,
    eventCode,
    message,
    autoDismiss: typeToDismissTimeout(typeof customization === "object" && customization.type || type)
  };
  if (typeof customization === "object") {
    notificationObject = __spreadValues(__spreadValues({}, notificationObject), customization);
  }
  return notificationObject;
}
function createEthereumNotificationObject(transactionDetails, customization) {
  const { id, hash: hash2, startTime, eventCode, direction, counterparty, value, asset } = transactionDetails;
  const type = eventToType(eventCode);
  const key = `${id}-${typeof customization === "object" && customization.eventCode || eventCode}`;
  const counterpartyShortened = counterparty && counterparty.substring(0, 4) + "..." + counterparty.substring(counterparty.length - 4);
  const formattedValue = new bignumber_default(value || 0).div(new bignumber_default("1000000000000000000")).toString(10);
  const formatterOptions = counterparty && value ? {
    messageId: `watched['${eventCode}']`,
    values: {
      verb: eventCode === "txConfirmed" ? direction === "incoming" ? "received" : "sent" : direction === "incoming" ? "receiving" : "sending",
      formattedValue,
      preposition: direction === "incoming" ? "from" : "to",
      counterpartyShortened,
      asset
    }
  } : {
    messageId: `transaction['${eventCode}']`,
    values: { formattedValue, asset }
  };
  const internationalizedMessage = formatter(formatterOptions.messageId, {
    values: formatterOptions.values
  });
  const noMessageAvailable = internationalizedMessage === formatterOptions.messageId;
  const message = noMessageAvailable ? defaultNotifyMessages.en[counterparty ? "watched" : "transaction"][eventCode || ""] : internationalizedMessage;
  let notificationObject = {
    id: id || hash2,
    type,
    key,
    startTime,
    eventCode,
    message,
    autoDismiss: typeToDismissTimeout(typeof customization === "object" && customization.type || type)
  };
  if (typeof customization === "object") {
    notificationObject = __spreadValues(__spreadValues({}, notificationObject), customization);
  }
  return notificationObject;
}
function getBitcoinDirectionValue(inputs, outputs, watchedAddress) {
  if (!watchedAddress)
    return { value: null, direction: "" };
  const finder = (i2) => i2.address === watchedAddress;
  const input = inputs && inputs.find(finder);
  const output = outputs && outputs.find(finder);
  return {
    direction: output ? "incoming" : "outgoing",
    value: output ? output.value : input && input.value
  };
}
var validInitKeys = [
  "dappId",
  "networkId",
  "system",
  "transactionHandler",
  "name",
  "onerror",
  "mobilePosition",
  "desktopPosition",
  "darkMode",
  "txApproveReminderTimeout",
  "txStallPendingTimeout",
  "txStallConfirmedTimeout",
  "notifyMessages",
  "clientLocale"
];
var validNotificationKeys = [
  "eventCode",
  "type",
  "message",
  "autoDismiss",
  "onclick"
];
var validTransactionKeys = [
  "sendTransaction",
  "estimateGas",
  "gasPrice",
  "balance",
  "contractCall",
  "txDetails"
];
function invalidParams2(params, validParams, functionName) {
  const invalid = Object.keys(params);
  if (invalid.length > 0) {
    throw new Error(`${invalid[0]} is not a valid parameter for ${functionName}, must be one of the following valid parameters: ${validParams.join(", ")}`);
  }
}
function validateType2({ name, value, type, optional, customValidation }) {
  if (!optional && typeof value === "undefined") {
    throw new Error(`"${name}" is required`);
  }
  if (typeof value !== "undefined" && (type === "array" ? Array.isArray(type) : typeof value !== type)) {
    throw new Error(`"${name}" must be of type: ${type}, received type: ${typeof value} from value: ${value}`);
  }
  if (typeof value !== "undefined" && customValidation) {
    customValidation(value);
  }
}
function validateInit(init2) {
  validateType2({ name: "init", value: init2, type: "object" });
  const _a = init2, { dappId, system, networkId, transactionHandler, name, apiUrl, onerror } = _a, otherParams = __objRest(_a, ["dappId", "system", "networkId", "transactionHandler", "name", "apiUrl", "onerror"]);
  validateType2({
    name: "dappId",
    value: dappId,
    type: "string",
    optional: true
  });
  validateType2({
    name: "system",
    value: system,
    type: "string",
    optional: true
  });
  validateType2({
    name: "networkId (if dappId provided)",
    value: networkId,
    type: "number",
    optional: !dappId
  });
  validateType2({ name: "name", value: name, type: "string", optional: true });
  validateType2({
    name: "apiUrl",
    value: apiUrl,
    type: "string",
    optional: true
  });
  validateType2({
    name: "transactionHandler",
    value: transactionHandler,
    type: "function",
    optional: true
  });
  validateType2({
    name: "onerror",
    value: onerror,
    type: "function",
    optional: true
  });
  validateConfig(otherParams);
}
function stringOrNumber(val) {
  return typeof val === "string" || typeof val === "number";
}
function validateTransactionOptions(options) {
  validateType2({ name: "transaction options", value: options, type: "object" });
  const _a = options, { sendTransaction, estimateGas, gasPrice, balance, contractCall, txDetails } = _a, otherParams = __objRest(_a, ["sendTransaction", "estimateGas", "gasPrice", "balance", "contractCall", "txDetails"]);
  invalidParams2(otherParams, validTransactionKeys, "Transaction Options");
  validateType2({
    name: "sendTransaction",
    value: sendTransaction,
    type: "function",
    optional: true
  });
  validateType2({
    name: "estimateGas",
    value: estimateGas,
    type: "function",
    optional: true
  });
  validateType2({
    name: "gasPrice",
    value: gasPrice,
    type: "function",
    optional: true
  });
  validateType2({
    name: "balance",
    value: balance,
    type: "string",
    optional: true
  });
  validateType2({
    name: "contractCall",
    value: contractCall,
    type: "object",
    optional: true
  });
  if (contractCall) {
    const _b = contractCall, { methodName, params } = _b, otherParams2 = __objRest(_b, ["methodName", "params"]);
    invalidParams2(otherParams2, ["methodName", "params"], "contractCall");
    validateType2({
      name: "methodName",
      value: methodName,
      type: "string",
      optional: true
    });
    validateType2({
      name: "params",
      value: params,
      type: "array",
      optional: true
    });
  }
  validateType2({
    name: "txDetails",
    value: txDetails,
    type: "object",
    optional: true
  });
  if (txDetails) {
    const _c = txDetails, { to, value, from } = _c, otherParams2 = __objRest(_c, ["to", "value", "from"]);
    invalidParams2(otherParams2, ["to", "value", "from"], "txDetails");
    validateType2({
      name: "to",
      value: to,
      type: "string",
      optional: true,
      customValidation: isAddress2
    });
    if (typeof value !== "undefined" && !stringOrNumber(value)) {
      throw new Error(`"value" must be of type: string | number, received type: ${typeof value} from value: ${value}`);
    }
    validateType2({
      name: "from",
      value: from,
      type: "string",
      optional: true,
      customValidation: isAddress2
    });
  }
}
function validateNotificationObject(notification) {
  validateType2({
    name: "notification",
    value: notification,
    type: "object"
  });
  if (typeof notification !== "object")
    return;
  const _a = notification, { eventCode, type, message, autoDismiss, onclick } = _a, otherParams = __objRest(_a, ["eventCode", "type", "message", "autoDismiss", "onclick"]);
  invalidParams2(otherParams, validNotificationKeys, "notification");
  validateType2({
    name: "eventCode",
    value: eventCode,
    type: "string",
    optional: true
  });
  validateType2({
    name: "type",
    value: type,
    type: "string",
    optional: true,
    customValidation: validNotificationType
  });
  validateType2({
    name: "message",
    value: message,
    type: "string"
  });
  validateType2({
    name: "autoDismiss",
    value: autoDismiss,
    type: "number",
    optional: true
  });
  validateType2({
    name: "onclick",
    value: onclick,
    type: "function",
    optional: true
  });
}
function validateConfig(config2) {
  validateType2({ name: "config", value: config2, type: "object" });
  const _a = config2, { networkId, system, mobilePosition, desktopPosition, darkMode, notifyMessages, clientLocale, txApproveReminderTimeout, txStallPendingTimeout, txStallConfirmedTimeout } = _a, otherParams = __objRest(_a, ["networkId", "system", "mobilePosition", "desktopPosition", "darkMode", "notifyMessages", "clientLocale", "txApproveReminderTimeout", "txStallPendingTimeout", "txStallConfirmedTimeout"]);
  invalidParams2(otherParams, validInitKeys, "config / initialize");
  validateType2({
    name: "networkId",
    value: networkId,
    type: "number",
    optional: true
  });
  validateType2({
    name: "system",
    value: system,
    type: "string",
    optional: true
  });
  validateType2({
    name: "mobilePosition",
    value: mobilePosition,
    type: "string",
    optional: true,
    customValidation: validMobilePosition
  });
  validateType2({
    name: "desktopPosition",
    value: desktopPosition,
    type: "string",
    optional: true,
    customValidation: validDesktopPosition
  });
  validateType2({
    name: "darkMode",
    value: darkMode,
    type: "boolean",
    optional: true
  });
  validateType2({
    name: "notifyMessages",
    value: notifyMessages,
    type: "object",
    optional: true
  });
  if (notifyMessages) {
    Object.keys(notifyMessages).forEach((locale) => {
      validateType2({
        name: locale,
        value: notifyMessages[locale],
        type: "object"
      });
      const _a2 = notifyMessages[locale], { transaction: transaction2, watched, time } = _a2, otherParams2 = __objRest(_a2, ["transaction", "watched", "time"]);
      invalidParams2(otherParams2, ["transaction", "watched", "time"], locale);
      validateType2({
        name: `notifyMessages.${locale}.transaction`,
        value: transaction2,
        type: "object",
        optional: true
      });
      validateType2({
        name: `notifyMessages.${locale}.watched`,
        value: watched,
        type: "object",
        optional: true
      });
      validateType2({
        name: `notifyMessages.${locale}.time`,
        value: time,
        type: "object",
        optional: true
      });
    });
  }
  validateType2({
    name: "clientLocale",
    value: clientLocale,
    type: "string",
    optional: true
  });
  validateType2({
    name: "txApproveReminderTimeout",
    value: txApproveReminderTimeout,
    type: "number",
    optional: true
  });
  validateType2({
    name: "txStallPendingTimeout",
    value: txStallPendingTimeout,
    type: "number",
    optional: true
  });
  validateType2({
    name: "txStallConfirmedTimeout",
    value: txStallConfirmedTimeout,
    type: "number",
    optional: true
  });
}
function validNotificationType(type) {
  switch (type) {
    case "hint":
    case "pending":
    case "error":
    case "success":
      return;
    default:
      throw new Error(`${type} is not a valid notification type, must be one of: 'hint', 'pending', 'error' or 'success'.`);
  }
}
function validMobilePosition(position) {
  switch (position) {
    case "top":
    case "bottom":
      return;
    default:
      throw new Error(`${position} is not a valid mobile notification position, must be one of: 'top' or 'bottom'.`);
  }
}
function validDesktopPosition(position) {
  switch (position) {
    case "bottomLeft":
    case "bottomRight":
    case "topLeft":
    case "topRight":
      return;
    default:
      throw new Error(`${position} is not a valid desktop notification position, must be one of: 'bottomLeft', 'bottomRight', 'topLeft' or 'topRight'.`);
  }
}
function isAddress2(address) {
  if (!/^(0x)?[0-9a-fA-F]{40}$/.test(address)) {
    throw new Error(`${address} is not a valid ethereum address.`);
  }
}
var transactionQueue;
transactions.subscribe((store) => transactionQueue = store);
function handlePreFlightEvent(blocknative2, preflightEvent) {
  const { eventCode, contractCall, balance, txDetails, emitter, status } = preflightEvent;
  let contract;
  if (contractCall) {
    contract = {
      methodName: contractCall.methodName,
      parameters: contractCall.params
    };
  }
  blocknative2.event({
    categoryCode: contractCall ? "activeContract" : "activeTransaction",
    eventCode,
    transaction: txDetails,
    wallet: { balance },
    contract: contractCall ? contract : void 0
  });
  const transaction2 = __spreadProps(__spreadValues({}, txDetails), {
    eventCode,
    status,
    contractCall: contract ? contractCall : void 0
  });
  const emitterResult = emitter.emit(transaction2);
  if (emitterResult) {
    validateNotificationObject(emitterResult);
  }
  handleTransactionEvent({
    transaction: transaction2,
    emitterResult
  });
}
function handleTransactionEvent(event2) {
  const { transaction: transaction2, emitterResult } = event2;
  if (!transaction2.id) {
    transaction2.id = transaction2.hash || transaction2.txid;
  }
  const predicate = (tx) => transaction2.replaceHash ? tx.id === transaction2.replaceHash : tx.id === transaction2.id;
  transactions.updateQueue(transaction2, predicate);
  if (transaction2.replaceHash) {
    notifications.updateId(transaction2.replaceHash, transaction2.hash);
  }
  if (emitterResult !== false && !localNetwork(get_store_value(app).networkId)) {
    const transactionObj = transactionQueue.find(predicate);
    if (transactionObj) {
      createNotification(transactionObj, emitterResult);
    }
  }
}
function duplicateTransactionCandidate(transaction2, contract) {
  const duplicate = transactionQueue.find((tx) => {
    if (contract && typeof tx.contractCall === "undefined")
      return false;
    if (tx.status === "confirmed" || tx.status === "failed")
      return;
    const sameMethod = contract ? contract.methodName === (tx.contractCall && tx.contractCall.methodName) : true;
    const sameParams = contract ? argsEqual(contract.params, tx.contractCall && tx.contractCall.params) : true;
    const sameVal = tx.value == transaction2.value;
    const sameTo = contract ? sameMethod : tx.to && tx.to.toLowerCase() === transaction2.to && transaction2.to.toLowerCase();
    return sameMethod && sameParams && sameVal && sameTo;
  });
  return duplicate;
}
function preflightTransaction(blocknative2, options, emitter) {
  return new Promise((resolve, reject) => {
    setTimeout(async () => {
      const { sendTransaction, estimateGas, gasPrice, balance, contractCall, txDetails } = options;
      const [gas, price] = await gasEstimates(estimateGas, gasPrice);
      const id = (0, import_v4.default)();
      const value = new bignumber_default(txDetails && txDetails.value || 0);
      const calculated = {
        value: value.toString(10),
        gas: gas && gas.toString(10),
        gasPrice: price && price.toString(10)
      };
      const txObject = txDetails ? __spreadProps(__spreadValues(__spreadValues({}, txDetails), calculated), {
        id
      }) : __spreadProps(__spreadValues({}, calculated), { id });
      if (balance && gas && price) {
        const transactionCost = gas.times(price).plus(value);
        if (transactionCost.gt(new bignumber_default(balance))) {
          const eventCode = "nsfFail";
          handlePreFlightEvent(blocknative2, {
            eventCode,
            contractCall,
            balance,
            txDetails: txObject,
            emitter
          });
          return reject("User has insufficient funds");
        }
      }
      if (txDetails && duplicateTransactionCandidate(txDetails, contractCall)) {
        const eventCode = "txRepeat";
        handlePreFlightEvent(blocknative2, {
          eventCode,
          contractCall,
          balance,
          txDetails: txObject,
          emitter
        });
      }
      const { txApproveReminderTimeout, txStallPendingTimeout, txStallConfirmedTimeout } = get_store_value(app);
      if (transactionQueue.find((tx) => tx.status === "awaitingApproval")) {
        const eventCode = "txAwaitingApproval";
        handlePreFlightEvent(blocknative2, {
          eventCode,
          contractCall,
          balance,
          txDetails: txObject,
          emitter
        });
      }
      setTimeout(() => {
        const awaitingApproval = transactionQueue.find((tx) => tx.id === id && tx.status === "awaitingApproval");
        if (awaitingApproval) {
          const eventCode = "txConfirmReminder";
          handlePreFlightEvent(blocknative2, {
            eventCode,
            contractCall,
            balance,
            txDetails: txObject,
            emitter
          });
        }
      }, txApproveReminderTimeout);
      handlePreFlightEvent(blocknative2, {
        eventCode: "txRequest",
        status: "awaitingApproval",
        contractCall,
        balance,
        txDetails: txObject,
        emitter
      });
      if (!sendTransaction) {
        return resolve(id);
      }
      let hash2;
      try {
        hash2 = await sendTransaction();
      } catch (error) {
        const { eventCode, errorMsg } = extractMessageFromError(error);
        handlePreFlightEvent(blocknative2, {
          eventCode,
          status: "failed",
          contractCall,
          balance,
          txDetails: txObject,
          emitter
        });
        return reject(errorMsg);
      }
      if (hash2 && typeof hash2 === "string") {
        const serverEmitter = blocknative2.transaction(hash2, id).emitter;
        serverEmitter.on("all", (transaction2) => {
          const result = emitter.emit(transaction2);
          return result;
        });
        setTimeout(() => {
          const transaction2 = transactionQueue.find((tx) => tx.id === id);
          if (transaction2 && transaction2.status === "sent" && blocknative2._connected) {
            const eventCode = "txStallPending";
            handlePreFlightEvent(blocknative2, {
              eventCode,
              contractCall,
              balance,
              txDetails: txObject,
              emitter
            });
          }
        }, txStallPendingTimeout);
        setTimeout(() => {
          const transaction2 = transactionQueue.find((tx) => tx.id === id);
          if (transaction2 && transaction2.status === "pending" && blocknative2._connected) {
            const eventCode = "txStallConfirmed";
            handlePreFlightEvent(blocknative2, {
              eventCode,
              contractCall,
              balance,
              txDetails: txObject,
              emitter
            });
          }
        }, txStallConfirmedTimeout);
        resolve(id);
      } else {
        reject("sendTransaction function must resolve to a transaction hash that is of type String.");
      }
    }, 10);
  });
}
function gasEstimates(gasFunc, gasPriceFunc) {
  if (!gasFunc || !gasPriceFunc) {
    return Promise.resolve([]);
  }
  const gasProm = gasFunc();
  if (!gasProm.then) {
    throw new Error("The `estimateGas` function must return a Promise");
  }
  const gasPriceProm = gasPriceFunc();
  if (!gasPriceProm.then) {
    throw new Error("The `gasPrice` function must return a Promise");
  }
  return Promise.all([gasProm, gasPriceProm]).then(([gasResult, gasPriceResult]) => {
    if (typeof gasResult !== "string") {
      throw new Error(`The Promise returned from calling 'estimateGas' must resolve with a value of type 'string'. Received a value of: ${gasResult} with a type: ${typeof gasResult}`);
    }
    if (typeof gasPriceResult !== "string") {
      throw new Error(`The Promise returned from calling 'gasPrice' must resolve with a value of type 'string'. Received a value of: ${gasPriceResult} with a type: ${typeof gasPriceResult}`);
    }
    return [new bignumber_default(gasResult), new bignumber_default(gasPriceResult)];
  }).catch((error) => {
    throw new Error(`There was an error getting gas estimates: ${error}`);
  });
}
var version2 = "1.9.1";
var notify;
var blocknative;
function init$1(options) {
  if (notify) {
    console.warn("notify has already been initialized");
    notify.$destroy();
    blocknative && blocknative.destroy();
  }
  validateInit(options);
  const _a = options, { system, transactionHandler, apiUrl } = _a, appOptions = __objRest(_a, ["system", "transactionHandler", "apiUrl"]);
  const { dappId, networkId, name, clientLocale, onerror } = appOptions;
  const transactionHandlers = [handleTransactionEvent];
  if (transactionHandler) {
    transactionHandlers.push(transactionHandler);
  }
  if (dappId) {
    blocknative = new esm_default({
      dappId,
      networkId,
      onerror,
      transactionHandlers,
      name: name || "Notify",
      apiUrl,
      system
    });
    blocknative.configuration({
      scope: "global",
      filters: [{ status: "pending-simulation", _not: true }]
    }).catch(() => {
    });
  }
  app.update((store) => __spreadProps(__spreadValues(__spreadValues({}, store), appOptions), {
    version: version2,
    clientLocale: clientLocale || Ct({
      fallback: "en",
      navigator: true
    })
  }));
  notify = new Notify({
    target: document.body
  });
  app.subscribe((store) => {
    const { notifyMessages, clientLocale: clientLocale2 } = store;
    Nt.set(notifyMessages);
    const availableLocale = notifyMessages[clientLocale2] || notifyMessages[clientLocale2.slice(0, 2)];
    Tt.set(availableLocale ? clientLocale2 : "en");
  });
  return {
    hash: hash2,
    transaction: transaction2,
    account: account2,
    unsubscribe: unsubscribe2,
    notification,
    config: config2
  };
  function account2(address) {
    if (!blocknative) {
      throw new Error("A dappId needs to be passed in when intializing Notify to use the account function");
    }
    const result = blocknative.account(address);
    return result;
  }
  function hash2(hash3, id) {
    if (!blocknative) {
      throw new Error("A dappId needs to be passed in when intializing Notify to use the hash function");
    }
    const result = blocknative.transaction(hash3, id);
    return result;
  }
  function transaction2(options2) {
    if (!blocknative) {
      throw new Error("A dappId needs to be passed in when intializing Notify to use the transaction function");
    }
    validateTransactionOptions(options2);
    const emitter = createEmitter2();
    const result = preflightTransaction(blocknative, options2, emitter).catch((err) => {
      const { onerror: onerror2 } = get_store_value(app);
      onerror2 && onerror2(err);
      return err;
    });
    return {
      emitter,
      result
    };
  }
  function unsubscribe2(addressOrHash) {
    if (!blocknative) {
      throw new Error("A dappId needs to be passed in when intializing Notify to use the unsubscribe function");
    }
    blocknative.unsubscribe(addressOrHash);
  }
  function notification(notificationObject) {
    validateNotificationObject(notificationObject);
    let key = 0;
    const id = (0, import_v4.default)();
    const startTime = Date.now();
    const { eventCode = `customNotification${key++}` } = notificationObject;
    const dismiss = () => notifications.remove(id, eventCode);
    function update2(notificationUpdate) {
      validateNotificationObject(notificationUpdate);
      const { eventCode: eventCode2 = `customNotification${key++}` } = notificationUpdate;
      createNotification({ id, startTime, eventCode: eventCode2 }, notificationUpdate);
      return {
        dismiss,
        update: update2
      };
    }
    createNotification({ id, startTime, eventCode }, notificationObject);
    return {
      dismiss,
      update: update2
    };
  }
  function config2(options2) {
    validateConfig(options2);
    const _a2 = options2, { notifyMessages, networkId: newNetworkId, system: newSystem } = _a2, otherOptions = __objRest(_a2, ["notifyMessages", "networkId", "system"]);
    const { networkId: networkId2, system: system2, dappId: dappId2, transactionHandler: transactionHandler2, name: name2, apiUrl: apiUrl2 } = get_store_value(app);
    if (newNetworkId && newNetworkId !== networkId2 || newSystem && newSystem !== system2) {
      if (!blocknative) {
        throw new Error("A dappId needs to be passed in when intializing Notify to be able to connect to a system and network");
      }
      blocknative.destroy();
      blocknative = new esm_default({
        dappId: dappId2,
        networkId: newNetworkId || networkId2,
        transactionHandlers: transactionHandler2 ? [handleTransactionEvent, transactionHandler2] : [handleTransactionEvent],
        name: name2 || "Notify",
        apiUrl: apiUrl2,
        system: newSystem || system2
      });
    }
    app.update((store) => {
      return __spreadProps(__spreadValues(__spreadProps(__spreadValues({}, store), {
        networkId: newNetworkId || networkId2,
        system: newSystem || system2
      }), otherOptions), {
        notifyMessages: notifyMessages ? __spreadValues(__spreadValues({}, store.notifyMessages), notifyMessages) : store.notifyMessages
      });
    });
  }
}
var notify_default = init$1;

// node_modules/eth-components/chunk-GRNYWZIC.js
var callbacks = {};
var DEBUG = true;
var transactor = (settings, signer, gasPrice, etherscan, throwOnError = false) => {
  if (signer != null)
    return async (tx, callback) => {
      let { provider, providerNetwork } = await parseProviderOrSigner(signer);
      checkBlocknativeAppId(settings);
      let options, notify2;
      navigator.onLine && (options = { dappId: settings.apiKeys.BlocknativeDappId, system: "ethereum", networkId: providerNetwork == null ? void 0 : providerNetwork.chainId, transactionHandler: (txInformation) => {
        DEBUG && console.log("HANDLE TX", txInformation);
        let possibleFunction = callbacks[txInformation.transaction.hash];
        typeof possibleFunction == "function" && possibleFunction(txInformation.transaction);
      } }, notify2 = notify_default(options));
      let etherscanNetwork = "";
      (providerNetwork == null ? void 0 : providerNetwork.name) && (providerNetwork == null ? void 0 : providerNetwork.chainId) > 1 && (etherscanNetwork = providerNetwork.name + ".");
      let etherscanTxUrl = "https://" + etherscanNetwork + "etherscan.io/tx/";
      (providerNetwork == null ? void 0 : providerNetwork.chainId) === 100 && (etherscanTxUrl = "https://blockscout.com/poa/xdai/tx/");
      try {
        let result;
        if (tx instanceof Promise ? (DEBUG && console.log("AWAITING TX", tx), result = await tx) : (tx.gasPrice || (tx.gasPrice = gasPrice || ethers_exports.utils.parseUnits("4.1", "gwei")), tx.gasLimit || (tx.gasLimit = BigNumber.from(ethers_exports.utils.hexlify(12e4))), DEBUG && console.log("RUNNING TX", tx), result = await (signer == null ? void 0 : signer.sendTransaction(tx))), DEBUG && console.log("RESULT:", result), callback && result && (callbacks[result.hash] = callback), result && "wait" in result && result.wait) {
          if (providerNetwork != null && [1, 3, 4, 5, 42, 100].indexOf(providerNetwork.chainId) >= 0 && notify2 != null) {
            let { emitter } = notify2.hash(result.hash);
            emitter.on("all", (transaction2) => ({ onclick: () => {
              var _a, _b;
              window.open(`${(_a = etherscan != null ? etherscan : etherscanTxUrl) != null ? _a : ""}${(_b = transaction2.hash) != null ? _b : ""}`);
            } }));
          } else if (notification_default.info({ message: "Local Transaction Sent", description: result == null ? void 0 : result.hash, placement: "bottomRight" }), callback != null && (result == null ? void 0 : result.hash) != null) {
            let listeningInterval;
            listeningInterval = setInterval(async () => {
              if ((result == null ? void 0 : result.hash) != null) {
                console.log("CHECK IN ON THE TX", result, provider);
                let currentTransactionReceipt = await (provider == null ? void 0 : provider.getTransactionReceipt(result.hash));
                currentTransactionReceipt && currentTransactionReceipt.confirmations && (callback(__spreadValues2(__spreadValues2({}, result), currentTransactionReceipt)), listeningInterval && clearInterval(listeningInterval));
              }
            }, 500);
          }
          await result.wait();
        }
        return result;
      } catch (e) {
        if (DEBUG && console.log(e), notification_default.error({ message: "Transaction Error", description: e == null ? void 0 : e.message }), throwOnError)
          throw e;
      }
    };
};

export {
  transactor
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/** @preserve
 * Counter block mode compatible with  Dr Brian Gladman fileenc.c
 * derived from CryptoJS.mode.CTR
 * Jan Hruby jhruby.web@gmail.com
 */
/** @preserve
(c) 2012 by Cdric Mesnil. All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted
provided that the following conditions are met:

    - Redistributions of source code must retain the above copyright notice, this list of
    conditions and the following disclaimer.
    - Redistributions in binary form must reproduce the above copyright notice, this list
    of conditions and the following disclaimer in the documentation and/or other materials
    provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS
OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
//# sourceMappingURL=chunk-UH3EAQAS.js.map
