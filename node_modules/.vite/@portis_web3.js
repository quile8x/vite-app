import {
  assert_exports,
  init_assert,
  require_bn,
  require_browser,
  require_dist,
  require_dist2,
  require_elliptic,
  require_eth_sig_util,
  require_json_stable_stringify,
  require_lib,
  require_noop,
  require_semaphore
} from "./chunk-ECH3LXRM.js";
import {
  require_stream_browserify
} from "./chunk-PA7HBL7M.js";
import {
  require_eth_json_rpc_filters,
  require_immutable,
  require_polling,
  require_subscriptionManager
} from "./chunk-2D3B6PX5.js";
import {
  require_safe_buffer,
  require_util
} from "./chunk-AU42HW6U.js";
import "./chunk-5DWCCEEY.js";
import "./chunk-SSY6J6BT.js";
import "./chunk-P7B7HGVM.js";
import {
  require_isArray,
  require_isArrayLike,
  require_isObject,
  require_keys
} from "./chunk-YLZEUPJL.js";
import {
  require_inherits_browser
} from "./chunk-K6V6NNJN.js";
import {
  require_events
} from "./chunk-775XWLPQ.js";
import "./chunk-ZJS3N4JA.js";
import {
  __commonJS,
  __toModule,
  define_process_env_default,
  init_define_process_env
} from "./chunk-VNKJPIOO.js";

// node_modules/penpal/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/penpal/lib/index.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ERR_NOT_IN_IFRAME = exports.ERR_CONNECTION_TIMEOUT = exports.ERR_CONNECTION_DESTROYED = void 0;
    var HANDSHAKE = "handshake";
    var HANDSHAKE_REPLY = "handshake-reply";
    var CALL = "call";
    var REPLY = "reply";
    var FULFILLED = "fulfilled";
    var REJECTED = "rejected";
    var MESSAGE = "message";
    var DATA_CLONE_ERROR = "DataCloneError";
    var ERR_CONNECTION_DESTROYED = "ConnectionDestroyed";
    exports.ERR_CONNECTION_DESTROYED = ERR_CONNECTION_DESTROYED;
    var ERR_CONNECTION_TIMEOUT = "ConnectionTimeout";
    exports.ERR_CONNECTION_TIMEOUT = ERR_CONNECTION_TIMEOUT;
    var ERR_NOT_IN_IFRAME = "NotInIframe";
    exports.ERR_NOT_IN_IFRAME = ERR_NOT_IN_IFRAME;
    var DEFAULT_PORTS = {
      "http:": "80",
      "https:": "443"
    };
    var URL_REGEX = /^(https?:)?\/\/([^/:]+)(:(\d+))?/;
    var Penpal2 = {
      ERR_CONNECTION_DESTROYED,
      ERR_CONNECTION_TIMEOUT,
      ERR_NOT_IN_IFRAME,
      Promise: function() {
        try {
          return window ? window.Promise : null;
        } catch (e) {
          return null;
        }
      }(),
      debug: false
    };
    var generateId = function() {
      var id = 0;
      return function() {
        return ++id;
      };
    }();
    var log = function log2() {
      if (Penpal2.debug) {
        var _console;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        (_console = console).log.apply(_console, ["[Penpal]"].concat(args));
      }
    };
    var getOriginFromUrl = function getOriginFromUrl2(url) {
      var location2 = document.location;
      var regexResult = URL_REGEX.exec(url);
      var protocol;
      var hostname;
      var port;
      if (regexResult) {
        protocol = regexResult[1] ? regexResult[1] : location2.protocol;
        hostname = regexResult[2];
        port = regexResult[4];
      } else {
        protocol = location2.protocol;
        hostname = location2.hostname;
        port = location2.port;
      }
      var portSuffix = port && port !== DEFAULT_PORTS[protocol] ? ":".concat(port) : "";
      return "".concat(protocol, "//").concat(hostname).concat(portSuffix);
    };
    var DestructionPromise = function DestructionPromise2(executor) {
      var handlers = [];
      executor(function() {
        handlers.forEach(function(handler) {
          handler();
        });
      });
      return {
        then: function then(handler) {
          handlers.push(handler);
        }
      };
    };
    var serializeError = function serializeError2(_ref) {
      var name = _ref.name, message = _ref.message, stack = _ref.stack;
      return {
        name,
        message,
        stack
      };
    };
    var deserializeError = function deserializeError2(obj) {
      var deserializedError = new Error();
      Object.keys(obj).forEach(function(key) {
        return deserializedError[key] = obj[key];
      });
      return deserializedError;
    };
    var connectCallSender = function connectCallSender2(callSender, info, methodNames, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call sender"));
      var createMethodProxy = function createMethodProxy2(methodName) {
        return function() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          log("".concat(localName, ": Sending ").concat(methodName, "() call"));
          if (destroyed) {
            var error = new Error("Unable to send ".concat(methodName, "() call due ") + "to destroyed connection");
            error.code = ERR_CONNECTION_DESTROYED;
            throw error;
          }
          return new Penpal2.Promise(function(resolve, reject) {
            var id = generateId();
            var handleMessageEvent = function handleMessageEvent2(event) {
              if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === REPLY && event.data.id === id) {
                log("".concat(localName, ": Received ").concat(methodName, "() reply"));
                local.removeEventListener(MESSAGE, handleMessageEvent2);
                var returnValue = event.data.returnValue;
                if (event.data.returnValueIsError) {
                  returnValue = deserializeError(returnValue);
                }
                (event.data.resolution === FULFILLED ? resolve : reject)(returnValue);
              }
            };
            local.addEventListener(MESSAGE, handleMessageEvent);
            remote.postMessage({
              penpal: CALL,
              id,
              methodName,
              args
            }, remoteOrigin);
          });
        };
      };
      destructionPromise.then(function() {
        destroyed = true;
      });
      methodNames.reduce(function(api, methodName) {
        api[methodName] = createMethodProxy(methodName);
        return api;
      }, callSender);
    };
    var connectCallReceiver = function connectCallReceiver2(info, methods, destructionPromise) {
      var localName = info.localName, local = info.local, remote = info.remote, remoteOrigin = info.remoteOrigin;
      var destroyed = false;
      log("".concat(localName, ": Connecting call receiver"));
      var handleMessageEvent = function handleMessageEvent2(event) {
        if (event.source === remote && event.origin === remoteOrigin && event.data.penpal === CALL) {
          var _event$data = event.data, methodName = _event$data.methodName, args = _event$data.args, id = _event$data.id;
          log("".concat(localName, ": Received ").concat(methodName, "() call"));
          if (methodName in methods) {
            var createPromiseHandler = function createPromiseHandler2(resolution) {
              return function(returnValue) {
                log("".concat(localName, ": Sending ").concat(methodName, "() reply"));
                if (destroyed) {
                  log("".concat(localName, ": Unable to send ").concat(methodName, "() reply due to destroyed connection"));
                  return;
                }
                var message = {
                  penpal: REPLY,
                  id,
                  resolution,
                  returnValue
                };
                if (resolution === REJECTED && returnValue instanceof Error) {
                  message.returnValue = serializeError(returnValue);
                  message.returnValueIsError = true;
                }
                try {
                  remote.postMessage(message, remoteOrigin);
                } catch (err) {
                  if (err.name === DATA_CLONE_ERROR) {
                    remote.postMessage({
                      penpal: REPLY,
                      id,
                      resolution: REJECTED,
                      returnValue: serializeError(err),
                      returnValueIsError: true
                    }, remoteOrigin);
                  }
                  throw err;
                }
              };
            };
            new Penpal2.Promise(function(resolve) {
              return resolve(methods[methodName].apply(methods, args));
            }).then(createPromiseHandler(FULFILLED), createPromiseHandler(REJECTED));
          }
        }
      };
      local.addEventListener(MESSAGE, handleMessageEvent);
      destructionPromise.then(function() {
        destroyed = true;
        local.removeEventListener(MESSAGE, handleMessageEvent);
      });
    };
    Penpal2.connectToChild = function(_ref2) {
      var url = _ref2.url, appendTo = _ref2.appendTo, _ref2$methods = _ref2.methods, methods = _ref2$methods === void 0 ? {} : _ref2$methods, timeout = _ref2.timeout;
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var parent = window;
      var iframe = document.createElement("iframe");
      (appendTo || document.body).appendChild(iframe);
      connectionDestructionPromise.then(function() {
        if (iframe.parentNode) {
          iframe.parentNode.removeChild(iframe);
        }
      });
      var child = iframe.contentWindow || iframe.contentDocument.parentWindow;
      var childOrigin = getOriginFromUrl(url);
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error = new Error("Connection to child timed out after ".concat(timeout, "ms"));
            error.code = ERR_CONNECTION_TIMEOUT;
            reject(error);
            destroy();
          }, timeout);
        }
        var callSender = {};
        var receiverMethodNames;
        var destroyCallReceiver;
        var handleMessage = function handleMessage2(event) {
          if (event.source === child && event.origin === childOrigin && event.data.penpal === HANDSHAKE) {
            log("Parent: Received handshake, sending reply");
            event.source.postMessage({
              penpal: HANDSHAKE_REPLY,
              methodNames: Object.keys(methods)
            }, event.origin);
            var info = {
              localName: "Parent",
              local: parent,
              remote: child,
              remoteOrigin: event.origin
            };
            if (destroyCallReceiver) {
              destroyCallReceiver();
            }
            var callReceiverDestructionPromise = new DestructionPromise(function(resolveCallReceiverDestructionPromise) {
              connectionDestructionPromise.then(resolveCallReceiverDestructionPromise);
              destroyCallReceiver = resolveCallReceiverDestructionPromise;
            });
            connectCallReceiver(info, methods, callReceiverDestructionPromise);
            if (receiverMethodNames) {
              receiverMethodNames.forEach(function(receiverMethodName) {
                delete callSender[receiverMethodName];
              });
            }
            receiverMethodNames = event.data.methodNames;
            connectCallSender(callSender, info, receiverMethodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        parent.addEventListener(MESSAGE, handleMessage);
        connectionDestructionPromise.then(function() {
          parent.removeEventListener(MESSAGE, handleMessage);
          var error = new Error("Connection destroyed");
          error.code = ERR_CONNECTION_DESTROYED;
          reject(error);
        });
        log("Parent: Loading iframe");
        iframe.src = url;
      });
      return {
        promise,
        iframe,
        destroy
      };
    };
    Penpal2.connectToParent = function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$parentOrigin = _ref3.parentOrigin, parentOrigin = _ref3$parentOrigin === void 0 ? "*" : _ref3$parentOrigin, _ref3$methods = _ref3.methods, methods = _ref3$methods === void 0 ? {} : _ref3$methods, timeout = _ref3.timeout;
      if (window === window.top) {
        var error = new Error("connectToParent() must be called within an iframe");
        error.code = ERR_NOT_IN_IFRAME;
        throw error;
      }
      var destroy;
      var connectionDestructionPromise = new DestructionPromise(function(resolveConnectionDestructionPromise) {
        destroy = resolveConnectionDestructionPromise;
      });
      var child = window;
      var parent = child.parent;
      var promise = new Penpal2.Promise(function(resolveConnectionPromise, reject) {
        var connectionTimeoutId;
        if (timeout !== void 0) {
          connectionTimeoutId = setTimeout(function() {
            var error2 = new Error("Connection to parent timed out after ".concat(timeout, "ms"));
            error2.code = ERR_CONNECTION_TIMEOUT;
            reject(error2);
            destroy();
          }, timeout);
        }
        var handleMessageEvent = function handleMessageEvent2(event) {
          if ((parentOrigin === "*" || parentOrigin === event.origin) && event.source === parent && event.data.penpal === HANDSHAKE_REPLY) {
            log("Child: Received handshake reply");
            child.removeEventListener(MESSAGE, handleMessageEvent2);
            var info = {
              localName: "Child",
              local: child,
              remote: parent,
              remoteOrigin: event.origin
            };
            var callSender = {};
            connectCallReceiver(info, methods, connectionDestructionPromise);
            connectCallSender(callSender, info, event.data.methodNames, connectionDestructionPromise);
            clearTimeout(connectionTimeoutId);
            resolveConnectionPromise(callSender);
          }
        };
        child.addEventListener(MESSAGE, handleMessageEvent);
        connectionDestructionPromise.then(function() {
          child.removeEventListener(MESSAGE, handleMessageEvent);
          var error2 = new Error("Connection destroyed");
          error2.code = ERR_CONNECTION_DESTROYED;
          reject(error2);
        });
        log("Child: Sending handshake");
        parent.postMessage({
          penpal: HANDSHAKE,
          methodNames: Object.keys(methods)
        }, parentOrigin);
      });
      return {
        promise,
        destroy
      };
    };
    var _default = Penpal2;
    exports.default = _default;
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js
var require_keccak = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/keccak.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var inherits = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Keccak(rate, capacity, delimitedSuffix, hashBitLength, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._hashBitLength = hashBitLength;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits(Keccak, Transform);
      Keccak.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype._flush = function(callback) {
        var error = null;
        try {
          this.push(this.digest());
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Keccak.prototype.update = function(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Digest already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      };
      Keccak.prototype.digest = function(encoding) {
        if (this._finalized)
          throw new Error("Digest already called");
        this._finalized = true;
        if (this._delimitedSuffix)
          this._state.absorbLastFewBits(this._delimitedSuffix);
        var digest = this._state.squeeze(this._hashBitLength / 8);
        if (encoding !== void 0)
          digest = digest.toString(encoding);
        this._resetState();
        return digest;
      };
      Keccak.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Keccak.prototype._clone = function() {
        var clone = new Keccak(this._rate, this._capacity, this._delimitedSuffix, this._hashBitLength, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Keccak;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js
var require_shake = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/shake.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var Transform = require_stream_browserify().Transform;
    var inherits = require_inherits_browser();
    module.exports = function(KeccakState) {
      function Shake(rate, capacity, delimitedSuffix, options) {
        Transform.call(this, options);
        this._rate = rate;
        this._capacity = capacity;
        this._delimitedSuffix = delimitedSuffix;
        this._options = options;
        this._state = new KeccakState();
        this._state.initialize(rate, capacity);
        this._finalized = false;
      }
      inherits(Shake, Transform);
      Shake.prototype._transform = function(chunk, encoding, callback) {
        var error = null;
        try {
          this.update(chunk, encoding);
        } catch (err) {
          error = err;
        }
        callback(error);
      };
      Shake.prototype._flush = function() {
      };
      Shake.prototype._read = function(size) {
        this.push(this.squeeze(size));
      };
      Shake.prototype.update = function(data, encoding) {
        if (!Buffer2.isBuffer(data) && typeof data !== "string")
          throw new TypeError("Data must be a string or a buffer");
        if (this._finalized)
          throw new Error("Squeeze already called");
        if (!Buffer2.isBuffer(data))
          data = Buffer2.from(data, encoding);
        this._state.absorb(data);
        return this;
      };
      Shake.prototype.squeeze = function(dataByteLength, encoding) {
        if (!this._finalized) {
          this._finalized = true;
          this._state.absorbLastFewBits(this._delimitedSuffix);
        }
        var data = this._state.squeeze(dataByteLength);
        if (encoding !== void 0)
          data = data.toString(encoding);
        return data;
      };
      Shake.prototype._resetState = function() {
        this._state.initialize(this._rate, this._capacity);
        return this;
      };
      Shake.prototype._clone = function() {
        var clone = new Shake(this._rate, this._capacity, this._delimitedSuffix, this._options);
        this._state.copy(clone._state);
        clone._finalized = this._finalized;
        return clone;
      };
      return Shake;
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/api/index.js
var require_api = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/api/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var createKeccak = require_keccak();
    var createShake = require_shake();
    module.exports = function(KeccakState) {
      var Keccak = createKeccak(KeccakState);
      var Shake = createShake(KeccakState);
      return function(algorithm, options) {
        var hash = typeof algorithm === "string" ? algorithm.toLowerCase() : algorithm;
        switch (hash) {
          case "keccak224":
            return new Keccak(1152, 448, null, 224, options);
          case "keccak256":
            return new Keccak(1088, 512, null, 256, options);
          case "keccak384":
            return new Keccak(832, 768, null, 384, options);
          case "keccak512":
            return new Keccak(576, 1024, null, 512, options);
          case "sha3-224":
            return new Keccak(1152, 448, 6, 224, options);
          case "sha3-256":
            return new Keccak(1088, 512, 6, 256, options);
          case "sha3-384":
            return new Keccak(832, 768, 6, 384, options);
          case "sha3-512":
            return new Keccak(576, 1024, 6, 512, options);
          case "shake128":
            return new Shake(1344, 256, 31, options);
          case "shake256":
            return new Shake(1088, 512, 31, options);
          default:
            throw new Error("Invald algorithm: " + algorithm);
        }
      };
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js
var require_keccak_state_unroll = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak-state-unroll.js"(exports) {
    init_define_process_env();
    "use strict";
    var P1600_ROUND_CONSTANTS = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649, 0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
    exports.p1600 = function(s) {
      for (var round = 0; round < 24; ++round) {
        var lo0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        var hi0 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        var lo1 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        var hi1 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        var lo2 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        var hi2 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        var lo3 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        var hi3 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        var lo4 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        var hi4 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        var lo = lo4 ^ (lo1 << 1 | hi1 >>> 31);
        var hi = hi4 ^ (hi1 << 1 | lo1 >>> 31);
        var t1slo0 = s[0] ^ lo;
        var t1shi0 = s[1] ^ hi;
        var t1slo5 = s[10] ^ lo;
        var t1shi5 = s[11] ^ hi;
        var t1slo10 = s[20] ^ lo;
        var t1shi10 = s[21] ^ hi;
        var t1slo15 = s[30] ^ lo;
        var t1shi15 = s[31] ^ hi;
        var t1slo20 = s[40] ^ lo;
        var t1shi20 = s[41] ^ hi;
        lo = lo0 ^ (lo2 << 1 | hi2 >>> 31);
        hi = hi0 ^ (hi2 << 1 | lo2 >>> 31);
        var t1slo1 = s[2] ^ lo;
        var t1shi1 = s[3] ^ hi;
        var t1slo6 = s[12] ^ lo;
        var t1shi6 = s[13] ^ hi;
        var t1slo11 = s[22] ^ lo;
        var t1shi11 = s[23] ^ hi;
        var t1slo16 = s[32] ^ lo;
        var t1shi16 = s[33] ^ hi;
        var t1slo21 = s[42] ^ lo;
        var t1shi21 = s[43] ^ hi;
        lo = lo1 ^ (lo3 << 1 | hi3 >>> 31);
        hi = hi1 ^ (hi3 << 1 | lo3 >>> 31);
        var t1slo2 = s[4] ^ lo;
        var t1shi2 = s[5] ^ hi;
        var t1slo7 = s[14] ^ lo;
        var t1shi7 = s[15] ^ hi;
        var t1slo12 = s[24] ^ lo;
        var t1shi12 = s[25] ^ hi;
        var t1slo17 = s[34] ^ lo;
        var t1shi17 = s[35] ^ hi;
        var t1slo22 = s[44] ^ lo;
        var t1shi22 = s[45] ^ hi;
        lo = lo2 ^ (lo4 << 1 | hi4 >>> 31);
        hi = hi2 ^ (hi4 << 1 | lo4 >>> 31);
        var t1slo3 = s[6] ^ lo;
        var t1shi3 = s[7] ^ hi;
        var t1slo8 = s[16] ^ lo;
        var t1shi8 = s[17] ^ hi;
        var t1slo13 = s[26] ^ lo;
        var t1shi13 = s[27] ^ hi;
        var t1slo18 = s[36] ^ lo;
        var t1shi18 = s[37] ^ hi;
        var t1slo23 = s[46] ^ lo;
        var t1shi23 = s[47] ^ hi;
        lo = lo3 ^ (lo0 << 1 | hi0 >>> 31);
        hi = hi3 ^ (hi0 << 1 | lo0 >>> 31);
        var t1slo4 = s[8] ^ lo;
        var t1shi4 = s[9] ^ hi;
        var t1slo9 = s[18] ^ lo;
        var t1shi9 = s[19] ^ hi;
        var t1slo14 = s[28] ^ lo;
        var t1shi14 = s[29] ^ hi;
        var t1slo19 = s[38] ^ lo;
        var t1shi19 = s[39] ^ hi;
        var t1slo24 = s[48] ^ lo;
        var t1shi24 = s[49] ^ hi;
        var t2slo0 = t1slo0;
        var t2shi0 = t1shi0;
        var t2slo16 = t1shi5 << 4 | t1slo5 >>> 28;
        var t2shi16 = t1slo5 << 4 | t1shi5 >>> 28;
        var t2slo7 = t1slo10 << 3 | t1shi10 >>> 29;
        var t2shi7 = t1shi10 << 3 | t1slo10 >>> 29;
        var t2slo23 = t1shi15 << 9 | t1slo15 >>> 23;
        var t2shi23 = t1slo15 << 9 | t1shi15 >>> 23;
        var t2slo14 = t1slo20 << 18 | t1shi20 >>> 14;
        var t2shi14 = t1shi20 << 18 | t1slo20 >>> 14;
        var t2slo10 = t1slo1 << 1 | t1shi1 >>> 31;
        var t2shi10 = t1shi1 << 1 | t1slo1 >>> 31;
        var t2slo1 = t1shi6 << 12 | t1slo6 >>> 20;
        var t2shi1 = t1slo6 << 12 | t1shi6 >>> 20;
        var t2slo17 = t1slo11 << 10 | t1shi11 >>> 22;
        var t2shi17 = t1shi11 << 10 | t1slo11 >>> 22;
        var t2slo8 = t1shi16 << 13 | t1slo16 >>> 19;
        var t2shi8 = t1slo16 << 13 | t1shi16 >>> 19;
        var t2slo24 = t1slo21 << 2 | t1shi21 >>> 30;
        var t2shi24 = t1shi21 << 2 | t1slo21 >>> 30;
        var t2slo20 = t1shi2 << 30 | t1slo2 >>> 2;
        var t2shi20 = t1slo2 << 30 | t1shi2 >>> 2;
        var t2slo11 = t1slo7 << 6 | t1shi7 >>> 26;
        var t2shi11 = t1shi7 << 6 | t1slo7 >>> 26;
        var t2slo2 = t1shi12 << 11 | t1slo12 >>> 21;
        var t2shi2 = t1slo12 << 11 | t1shi12 >>> 21;
        var t2slo18 = t1slo17 << 15 | t1shi17 >>> 17;
        var t2shi18 = t1shi17 << 15 | t1slo17 >>> 17;
        var t2slo9 = t1shi22 << 29 | t1slo22 >>> 3;
        var t2shi9 = t1slo22 << 29 | t1shi22 >>> 3;
        var t2slo5 = t1slo3 << 28 | t1shi3 >>> 4;
        var t2shi5 = t1shi3 << 28 | t1slo3 >>> 4;
        var t2slo21 = t1shi8 << 23 | t1slo8 >>> 9;
        var t2shi21 = t1slo8 << 23 | t1shi8 >>> 9;
        var t2slo12 = t1slo13 << 25 | t1shi13 >>> 7;
        var t2shi12 = t1shi13 << 25 | t1slo13 >>> 7;
        var t2slo3 = t1slo18 << 21 | t1shi18 >>> 11;
        var t2shi3 = t1shi18 << 21 | t1slo18 >>> 11;
        var t2slo19 = t1shi23 << 24 | t1slo23 >>> 8;
        var t2shi19 = t1slo23 << 24 | t1shi23 >>> 8;
        var t2slo15 = t1slo4 << 27 | t1shi4 >>> 5;
        var t2shi15 = t1shi4 << 27 | t1slo4 >>> 5;
        var t2slo6 = t1slo9 << 20 | t1shi9 >>> 12;
        var t2shi6 = t1shi9 << 20 | t1slo9 >>> 12;
        var t2slo22 = t1shi14 << 7 | t1slo14 >>> 25;
        var t2shi22 = t1slo14 << 7 | t1shi14 >>> 25;
        var t2slo13 = t1slo19 << 8 | t1shi19 >>> 24;
        var t2shi13 = t1shi19 << 8 | t1slo19 >>> 24;
        var t2slo4 = t1slo24 << 14 | t1shi24 >>> 18;
        var t2shi4 = t1shi24 << 14 | t1slo24 >>> 18;
        s[0] = t2slo0 ^ ~t2slo1 & t2slo2;
        s[1] = t2shi0 ^ ~t2shi1 & t2shi2;
        s[10] = t2slo5 ^ ~t2slo6 & t2slo7;
        s[11] = t2shi5 ^ ~t2shi6 & t2shi7;
        s[20] = t2slo10 ^ ~t2slo11 & t2slo12;
        s[21] = t2shi10 ^ ~t2shi11 & t2shi12;
        s[30] = t2slo15 ^ ~t2slo16 & t2slo17;
        s[31] = t2shi15 ^ ~t2shi16 & t2shi17;
        s[40] = t2slo20 ^ ~t2slo21 & t2slo22;
        s[41] = t2shi20 ^ ~t2shi21 & t2shi22;
        s[2] = t2slo1 ^ ~t2slo2 & t2slo3;
        s[3] = t2shi1 ^ ~t2shi2 & t2shi3;
        s[12] = t2slo6 ^ ~t2slo7 & t2slo8;
        s[13] = t2shi6 ^ ~t2shi7 & t2shi8;
        s[22] = t2slo11 ^ ~t2slo12 & t2slo13;
        s[23] = t2shi11 ^ ~t2shi12 & t2shi13;
        s[32] = t2slo16 ^ ~t2slo17 & t2slo18;
        s[33] = t2shi16 ^ ~t2shi17 & t2shi18;
        s[42] = t2slo21 ^ ~t2slo22 & t2slo23;
        s[43] = t2shi21 ^ ~t2shi22 & t2shi23;
        s[4] = t2slo2 ^ ~t2slo3 & t2slo4;
        s[5] = t2shi2 ^ ~t2shi3 & t2shi4;
        s[14] = t2slo7 ^ ~t2slo8 & t2slo9;
        s[15] = t2shi7 ^ ~t2shi8 & t2shi9;
        s[24] = t2slo12 ^ ~t2slo13 & t2slo14;
        s[25] = t2shi12 ^ ~t2shi13 & t2shi14;
        s[34] = t2slo17 ^ ~t2slo18 & t2slo19;
        s[35] = t2shi17 ^ ~t2shi18 & t2shi19;
        s[44] = t2slo22 ^ ~t2slo23 & t2slo24;
        s[45] = t2shi22 ^ ~t2shi23 & t2shi24;
        s[6] = t2slo3 ^ ~t2slo4 & t2slo0;
        s[7] = t2shi3 ^ ~t2shi4 & t2shi0;
        s[16] = t2slo8 ^ ~t2slo9 & t2slo5;
        s[17] = t2shi8 ^ ~t2shi9 & t2shi5;
        s[26] = t2slo13 ^ ~t2slo14 & t2slo10;
        s[27] = t2shi13 ^ ~t2shi14 & t2shi10;
        s[36] = t2slo18 ^ ~t2slo19 & t2slo15;
        s[37] = t2shi18 ^ ~t2shi19 & t2shi15;
        s[46] = t2slo23 ^ ~t2slo24 & t2slo20;
        s[47] = t2shi23 ^ ~t2shi24 & t2shi20;
        s[8] = t2slo4 ^ ~t2slo0 & t2slo1;
        s[9] = t2shi4 ^ ~t2shi0 & t2shi1;
        s[18] = t2slo9 ^ ~t2slo5 & t2slo6;
        s[19] = t2shi9 ^ ~t2shi5 & t2shi6;
        s[28] = t2slo14 ^ ~t2slo10 & t2slo11;
        s[29] = t2shi14 ^ ~t2shi10 & t2shi11;
        s[38] = t2slo19 ^ ~t2slo15 & t2slo16;
        s[39] = t2shi19 ^ ~t2shi15 & t2shi16;
        s[48] = t2slo24 ^ ~t2slo20 & t2slo21;
        s[49] = t2shi24 ^ ~t2shi20 & t2shi21;
        s[0] ^= P1600_ROUND_CONSTANTS[round * 2];
        s[1] ^= P1600_ROUND_CONSTANTS[round * 2 + 1];
      }
    };
  }
});

// node_modules/@portis/web3/node_modules/keccak/lib/keccak.js
var require_keccak2 = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/lib/keccak.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var keccakState = require_keccak_state_unroll();
    function Keccak() {
      this.state = [
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      this.blockSize = null;
      this.count = 0;
      this.squeezing = false;
    }
    Keccak.prototype.initialize = function(rate, capacity) {
      for (var i = 0; i < 50; ++i)
        this.state[i] = 0;
      this.blockSize = rate / 8;
      this.count = 0;
      this.squeezing = false;
    };
    Keccak.prototype.absorb = function(data) {
      for (var i = 0; i < data.length; ++i) {
        this.state[~~(this.count / 4)] ^= data[i] << 8 * (this.count % 4);
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
    };
    Keccak.prototype.absorbLastFewBits = function(bits) {
      this.state[~~(this.count / 4)] ^= bits << 8 * (this.count % 4);
      if ((bits & 128) !== 0 && this.count === this.blockSize - 1)
        keccakState.p1600(this.state);
      this.state[~~((this.blockSize - 1) / 4)] ^= 128 << 8 * ((this.blockSize - 1) % 4);
      keccakState.p1600(this.state);
      this.count = 0;
      this.squeezing = true;
    };
    Keccak.prototype.squeeze = function(length) {
      if (!this.squeezing)
        this.absorbLastFewBits(1);
      var output = Buffer2.alloc(length);
      for (var i = 0; i < length; ++i) {
        output[i] = this.state[~~(this.count / 4)] >>> 8 * (this.count % 4) & 255;
        this.count += 1;
        if (this.count === this.blockSize) {
          keccakState.p1600(this.state);
          this.count = 0;
        }
      }
      return output;
    };
    Keccak.prototype.copy = function(dest) {
      for (var i = 0; i < 50; ++i)
        dest.state[i] = this.state[i];
      dest.blockSize = this.blockSize;
      dest.count = this.count;
      dest.squeezing = this.squeezing;
    };
    module.exports = Keccak;
  }
});

// node_modules/@portis/web3/node_modules/keccak/js.js
var require_js = __commonJS({
  "node_modules/@portis/web3/node_modules/keccak/js.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = require_api()(require_keccak2());
  }
});

// node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/@portis/web3/node_modules/ethereumjs-util/dist/index.js"(exports) {
    init_define_process_env();
    "use strict";
    var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
    var createKeccakHash = require_js();
    var secp256k1 = require_elliptic();
    var assert = (init_assert(), assert_exports);
    var rlp = require_dist();
    var BN2 = require_bn();
    var createHash = require_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    Object.assign(exports, require_lib());
    exports.MAX_INTEGER = new BN2("ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff", 16);
    exports.TWO_POW256 = new BN2("10000000000000000000000000000000000000000000000000000000000000000", 16);
    exports.KECCAK256_NULL_S = "c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
    exports.SHA3_NULL_S = exports.KECCAK256_NULL_S;
    exports.KECCAK256_NULL = Buffer2.from(exports.KECCAK256_NULL_S, "hex");
    exports.SHA3_NULL = exports.KECCAK256_NULL;
    exports.KECCAK256_RLP_ARRAY_S = "1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347";
    exports.SHA3_RLP_ARRAY_S = exports.KECCAK256_RLP_ARRAY_S;
    exports.KECCAK256_RLP_ARRAY = Buffer2.from(exports.KECCAK256_RLP_ARRAY_S, "hex");
    exports.SHA3_RLP_ARRAY = exports.KECCAK256_RLP_ARRAY;
    exports.KECCAK256_RLP_S = "56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421";
    exports.SHA3_RLP_S = exports.KECCAK256_RLP_S;
    exports.KECCAK256_RLP = Buffer2.from(exports.KECCAK256_RLP_S, "hex");
    exports.SHA3_RLP = exports.KECCAK256_RLP;
    exports.BN = BN2;
    exports.rlp = rlp;
    exports.secp256k1 = secp256k1;
    exports.zeros = function(bytes) {
      return Buffer2.allocUnsafe(bytes).fill(0);
    };
    exports.zeroAddress = function() {
      var addressLength = 20;
      var zeroAddress = exports.zeros(addressLength);
      return exports.bufferToHex(zeroAddress);
    };
    exports.setLengthLeft = exports.setLength = function(msg, length, right) {
      var buf = exports.zeros(length);
      msg = exports.toBuffer(msg);
      if (right) {
        if (msg.length < length) {
          msg.copy(buf);
          return buf;
        }
        return msg.slice(0, length);
      } else {
        if (msg.length < length) {
          msg.copy(buf, length - msg.length);
          return buf;
        }
        return msg.slice(-length);
      }
    };
    exports.setLengthRight = function(msg, length) {
      return exports.setLength(msg, length, true);
    };
    exports.unpad = exports.stripZeros = function(a) {
      a = exports.stripHexPrefix(a);
      var first = a[0];
      while (a.length > 0 && first.toString() === "0") {
        a = a.slice(1);
        first = a[0];
      }
      return a;
    };
    exports.toBuffer = function(v) {
      if (!Buffer2.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer2.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer2.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer2.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer2.allocUnsafe(0);
        } else if (BN2.isBN(v)) {
          v = v.toArrayLike(Buffer2);
        } else if (v.toArray) {
          v = Buffer2.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    };
    exports.bufferToInt = function(buf) {
      return new BN2(exports.toBuffer(buf)).toNumber();
    };
    exports.bufferToHex = function(buf) {
      buf = exports.toBuffer(buf);
      return "0x" + buf.toString("hex");
    };
    exports.fromSigned = function(num) {
      return new BN2(num).fromTwos(256);
    };
    exports.toUnsigned = function(num) {
      return Buffer2.from(num.toTwos(256).toArray());
    };
    exports.keccak = function(a, bits) {
      a = exports.toBuffer(a);
      if (!bits)
        bits = 256;
      return createKeccakHash("keccak" + bits).update(a).digest();
    };
    exports.keccak256 = function(a) {
      return exports.keccak(a);
    };
    exports.sha3 = exports.keccak;
    exports.sha256 = function(a) {
      a = exports.toBuffer(a);
      return createHash("sha256").update(a).digest();
    };
    exports.ripemd160 = function(a, padded) {
      a = exports.toBuffer(a);
      var hash = createHash("rmd160").update(a).digest();
      if (padded === true) {
        return exports.setLength(hash, 32);
      } else {
        return hash;
      }
    };
    exports.rlphash = function(a) {
      return exports.keccak(rlp.encode(a));
    };
    exports.isValidPrivate = function(privateKey) {
      return secp256k1.privateKeyVerify(privateKey);
    };
    exports.isValidPublic = function(publicKey, sanitize) {
      if (publicKey.length === 64) {
        return secp256k1.publicKeyVerify(Buffer2.concat([Buffer2.from([4]), publicKey]));
      }
      if (!sanitize) {
        return false;
      }
      return secp256k1.publicKeyVerify(publicKey);
    };
    exports.pubToAddress = exports.publicToAddress = function(pubKey, sanitize) {
      pubKey = exports.toBuffer(pubKey);
      if (sanitize && pubKey.length !== 64) {
        pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);
      }
      assert(pubKey.length === 64);
      return exports.keccak(pubKey).slice(-20);
    };
    var privateToPublic = exports.privateToPublic = function(privateKey) {
      privateKey = exports.toBuffer(privateKey);
      return secp256k1.publicKeyCreate(privateKey, false).slice(1);
    };
    exports.importPublic = function(publicKey) {
      publicKey = exports.toBuffer(publicKey);
      if (publicKey.length !== 64) {
        publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);
      }
      return publicKey;
    };
    exports.ecsign = function(msgHash, privateKey) {
      var sig = secp256k1.sign(msgHash, privateKey);
      var ret = {};
      ret.r = sig.signature.slice(0, 32);
      ret.s = sig.signature.slice(32, 64);
      ret.v = sig.recovery + 27;
      return ret;
    };
    exports.hashPersonalMessage = function(message) {
      var prefix = exports.toBuffer("Ethereum Signed Message:\n" + message.length.toString());
      return exports.keccak(Buffer2.concat([prefix, message]));
    };
    exports.ecrecover = function(msgHash, v, r, s) {
      var signature = Buffer2.concat([exports.setLength(r, 32), exports.setLength(s, 32)], 64);
      var recovery = v - 27;
      if (recovery !== 0 && recovery !== 1) {
        throw new Error("Invalid signature v value");
      }
      var senderPubKey = secp256k1.recover(msgHash, signature, recovery);
      return secp256k1.publicKeyConvert(senderPubKey, false).slice(1);
    };
    exports.toRpcSig = function(v, r, s) {
      if (v !== 27 && v !== 28) {
        throw new Error("Invalid recovery id");
      }
      return exports.bufferToHex(Buffer2.concat([exports.setLengthLeft(r, 32), exports.setLengthLeft(s, 32), exports.toBuffer(v - 27)]));
    };
    exports.fromRpcSig = function(sig) {
      sig = exports.toBuffer(sig);
      if (sig.length !== 65) {
        throw new Error("Invalid signature length");
      }
      var v = sig[64];
      if (v < 27) {
        v += 27;
      }
      return {
        v,
        r: sig.slice(0, 32),
        s: sig.slice(32, 64)
      };
    };
    exports.privateToAddress = function(privateKey) {
      return exports.publicToAddress(privateToPublic(privateKey));
    };
    exports.isValidAddress = function(address) {
      return /^0x[0-9a-fA-F]{40}$/.test(address);
    };
    exports.isZeroAddress = function(address) {
      var zeroAddress = exports.zeroAddress();
      return zeroAddress === exports.addHexPrefix(address);
    };
    exports.toChecksumAddress = function(address) {
      address = exports.stripHexPrefix(address).toLowerCase();
      var hash = exports.keccak(address).toString("hex");
      var ret = "0x";
      for (var i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
          ret += address[i].toUpperCase();
        } else {
          ret += address[i];
        }
      }
      return ret;
    };
    exports.isValidChecksumAddress = function(address) {
      return exports.isValidAddress(address) && exports.toChecksumAddress(address) === address;
    };
    exports.generateAddress = function(from, nonce) {
      from = exports.toBuffer(from);
      nonce = new BN2(nonce);
      if (nonce.isZero()) {
        nonce = null;
      } else {
        nonce = Buffer2.from(nonce.toArray());
      }
      return exports.rlphash([from, nonce]).slice(-20);
    };
    exports.isPrecompiled = function(address) {
      var a = exports.unpad(address);
      return a.length === 1 && a[0] >= 1 && a[0] <= 8;
    };
    exports.addHexPrefix = function(str) {
      if (typeof str !== "string") {
        return str;
      }
      return exports.isHexPrefixed(str) ? str : "0x" + str;
    };
    exports.isValidSignature = function(v, r, s, homestead) {
      var SECP256K1_N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
      var SECP256K1_N = new BN2("fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141", 16);
      if (r.length !== 32 || s.length !== 32) {
        return false;
      }
      if (v !== 27 && v !== 28) {
        return false;
      }
      r = new BN2(r);
      s = new BN2(s);
      if (r.isZero() || r.gt(SECP256K1_N) || s.isZero() || s.gt(SECP256K1_N)) {
        return false;
      }
      if (homestead === false && new BN2(s).cmp(SECP256K1_N_DIV_2) === 1) {
        return false;
      }
      return true;
    };
    exports.baToJSON = function(ba) {
      if (Buffer2.isBuffer(ba)) {
        return "0x" + ba.toString("hex");
      } else if (ba instanceof Array) {
        var array = [];
        for (var i = 0; i < ba.length; i++) {
          array.push(exports.baToJSON(ba[i]));
        }
        return array;
      }
    };
    exports.defineProperties = function(self, fields, data) {
      self.raw = [];
      self._fields = [];
      self.toJSON = function(label) {
        if (label) {
          var obj = {};
          self._fields.forEach(function(field) {
            obj[field] = "0x" + self[field].toString("hex");
          });
          return obj;
        }
        return exports.baToJSON(this.raw);
      };
      self.serialize = function serialize() {
        return rlp.encode(self.raw);
      };
      fields.forEach(function(field, i) {
        self._fields.push(field.name);
        function getter() {
          return self.raw[i];
        }
        function setter(v) {
          v = exports.toBuffer(v);
          if (v.toString("hex") === "00" && !field.allowZero) {
            v = Buffer2.allocUnsafe(0);
          }
          if (field.allowLess && field.length) {
            v = exports.stripZeros(v);
            assert(field.length >= v.length, "The field " + field.name + " must not have more " + field.length + " bytes");
          } else if (!(field.allowZero && v.length === 0) && field.length) {
            assert(field.length === v.length, "The field " + field.name + " must have byte length of " + field.length);
          }
          self.raw[i] = v;
        }
        Object.defineProperty(self, field.name, {
          enumerable: true,
          configurable: true,
          get: getter,
          set: setter
        });
        if (field.default) {
          self[field.name] = field.default;
        }
        if (field.alias) {
          Object.defineProperty(self, field.alias, {
            enumerable: false,
            configurable: true,
            set: setter,
            get: getter
          });
        }
      });
      if (data) {
        if (typeof data === "string") {
          data = Buffer2.from(exports.stripHexPrefix(data), "hex");
        }
        if (Buffer2.isBuffer(data)) {
          data = rlp.decode(data);
        }
        if (Array.isArray(data)) {
          if (data.length > self._fields.length) {
            throw new Error("wrong number of fields in data");
          }
          data.forEach(function(d, i) {
            self[self._fields[i]] = exports.toBuffer(d);
          });
        } else if ((typeof data === "undefined" ? "undefined" : _typeof(data)) === "object") {
          var keys = Object.keys(data);
          fields.forEach(function(field) {
            if (keys.indexOf(field.name) !== -1)
              self[field.name] = data[field.name];
            if (keys.indexOf(field.alias) !== -1)
              self[field.alias] = data[field.alias];
          });
        } else {
          throw new Error("invalid data");
        }
      }
    };
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = {};
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = once;
    function once(fn) {
      return function() {
        if (fn === null)
          return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll) {
      return iteratorSymbol && coll[iteratorSymbol] && coll[iteratorSymbol]();
    };
    var iteratorSymbol = typeof Symbol === "function" && Symbol.iterator;
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = iterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    var _keys = require_keys();
    var _keys2 = _interopRequireDefault(_keys);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return function next() {
        return ++i < len ? { value: coll[i], key: i } : null;
      };
    }
    function createES2015Iterator(iterator2) {
      var i = -1;
      return function next() {
        var item = iterator2.next();
        if (item.done)
          return null;
        i++;
        return { value: item.value, key: i };
      };
    }
    function createObjectIterator(obj) {
      var okeys = (0, _keys2.default)(obj);
      var i = -1;
      var len = okeys.length;
      return function next() {
        var key = okeys[++i];
        return i < len ? { value: obj[key], key } : null;
      };
    }
    function iterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator2 = (0, _getIterator2.default)(coll);
      return iterator2 ? createES2015Iterator(iterator2) : createObjectIterator(coll);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = onlyOnce;
    function onlyOnce(fn) {
      return function() {
        if (fn === null)
          throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, arguments);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _eachOfLimit;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _eachOfLimit(limit) {
      return function(obj, iteratee, callback) {
        callback = (0, _once2.default)(callback || _noop2.default);
        if (limit <= 0 || !obj) {
          return callback(null);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value) {
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (value === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        replenish();
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS({
  "node_modules/async/internal/slice.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = slice;
    function slice(arrayLike, start) {
      start = start | 0;
      var newLen = Math.max(arrayLike.length - start, 0);
      var newArr = Array(newLen);
      for (var idx = 0; idx < newLen; idx++) {
        newArr[idx] = arrayLike[start + idx];
      }
      return newArr;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(fn) {
      return function() {
        var args = (0, _slice2.default)(arguments);
        var callback = args.pop();
        fn.call(this, args, callback);
      };
    };
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.hasNextTick = exports.hasSetImmediate = void 0;
    exports.fallback = fallback;
    exports.wrap = wrap;
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var hasSetImmediate = exports.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    function wrap(defer) {
      return function(fn) {
        var args = (0, _slice2.default)(arguments, 1);
        defer(function() {
          fn.apply(null, args);
        });
      };
    }
    var _defer;
    if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports.default = wrap(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = asyncify;
    var _isObject = require_isObject();
    var _isObject2 = _interopRequireDefault(_isObject);
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function asyncify(func) {
      return (0, _initialParams2.default)(function(args, callback) {
        var result;
        try {
          result = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if ((0, _isObject2.default)(result) && typeof result.then === "function") {
          result.then(function(value) {
            invokeCallback(callback, null, value);
          }, function(err) {
            invokeCallback(callback, err.message ? err : new Error(err));
          });
        } else {
          callback(null, result);
        }
      });
    }
    function invokeCallback(callback, error, value) {
      try {
        callback(error, value);
      } catch (e) {
        (0, _setImmediate2.default)(rethrow, e);
      }
    }
    function rethrow(error) {
      throw error;
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var supportsSymbol = typeof Symbol === "function";
    function isAsync(fn) {
      return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
    }
    function wrapAsync(asyncFn) {
      return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    exports.default = wrapAsync;
    exports.isAsync = isAsync;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachOfLimit;
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doLimit.js
var require_doLimit = __commonJS({
  "node_modules/async/internal/doLimit.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doLimit;
    function doLimit(fn, limit) {
      return function(iterable, iteratee, callback) {
        return fn(iterable, limit, iteratee, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    };
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      var index = 0, completed = 0, length = coll.length;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value) {
        if (err) {
          callback(err);
        } else if (++completed === length || value === _breakLoop2.default) {
          callback(null);
        }
      }
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    var eachOfGeneric = (0, _doLimit2.default)(_eachOfLimit2.default, Infinity);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/doParallel.js
var require_doParallel = __commonJS({
  "node_modules/async/internal/doParallel.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = doParallel;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function doParallel(fn) {
      return function(obj, iteratee, callback) {
        return fn(_eachOf2.default, obj, (0, _wrapAsync2.default)(iteratee), callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/map.js
var require_map = __commonJS({
  "node_modules/async/internal/map.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _asyncMap;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _asyncMap(eachfn, arr, iteratee, callback) {
      callback = callback || _noop2.default;
      arr = arr || [];
      var results = [];
      var counter = 0;
      var _iteratee = (0, _wrapAsync2.default)(iteratee);
      eachfn(arr, function(value, _, callback2) {
        var index = counter++;
        _iteratee(value, function(err, v) {
          results[index] = v;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/map.js
var require_map2 = __commonJS({
  "node_modules/async/map.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _doParallel = require_doParallel();
    var _doParallel2 = _interopRequireDefault(_doParallel);
    var _map = require_map();
    var _map2 = _interopRequireDefault(_map);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doParallel2.default)(_map2.default);
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return function(value, index, callback) {
        return iteratee(value, callback);
      };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachLimit.js
var require_eachLimit = __commonJS({
  "node_modules/async/eachLimit.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = eachLimit;
    var _eachOfLimit = require_eachOfLimit();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function eachLimit(coll, limit, iteratee, callback) {
      (0, _eachOfLimit2.default)(limit)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/eachSeries.js
var require_eachSeries = __commonJS({
  "node_modules/async/eachSeries.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var _eachLimit = require_eachLimit();
    var _eachLimit2 = _interopRequireDefault(_eachLimit);
    var _doLimit = require_doLimit();
    var _doLimit2 = _interopRequireDefault(_doLimit);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports.default = (0, _doLimit2.default)(_eachLimit2.default, 1);
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/util/stoplight.js
var require_stoplight = __commonJS({
  "node_modules/web3-provider-engine/util/stoplight.js"(exports, module) {
    init_define_process_env();
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    module.exports = Stoplight;
    inherits(Stoplight, EventEmitter);
    function Stoplight() {
      const self = this;
      EventEmitter.call(self);
      self.isLocked = true;
    }
    Stoplight.prototype.go = function() {
      const self = this;
      self.isLocked = false;
      self.emit("unlock");
    };
    Stoplight.prototype.stop = function() {
      const self = this;
      self.isLocked = true;
      self.emit("lock");
    };
    Stoplight.prototype.await = function(fn) {
      const self = this;
      if (self.isLocked) {
        self.once("unlock", fn);
      } else {
        setTimeout(fn);
      }
    };
  }
});

// node_modules/web3-provider-engine/util/rpc-cache-utils.js
var require_rpc_cache_utils = __commonJS({
  "node_modules/web3-provider-engine/util/rpc-cache-utils.js"(exports, module) {
    init_define_process_env();
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, opts = {}) {
      if (!canCache(payload))
        return null;
      const { includeBlockRef } = opts;
      const params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/util/random-id.js
var require_random_id = __commonJS({
  "node_modules/web3-provider-engine/util/random-id.js"(exports, module) {
    init_define_process_env();
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/util/create-payload.js
var require_create_payload = __commonJS({
  "node_modules/web3-provider-engine/util/create-payload.js"(exports, module) {
    init_define_process_env();
    var getRandomId = require_random_id();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/index.js
var require_web3_provider_engine = __commonJS({
  "node_modules/web3-provider-engine/index.js"(exports, module) {
    init_define_process_env();
    var EventEmitter = require_events().EventEmitter;
    var inherits = require_util().inherits;
    var ethUtil = require_dist2();
    var EthBlockTracker = require_polling();
    var map = require_map2();
    var eachSeries = require_eachSeries();
    var Stoplight = require_stoplight();
    var cacheUtils = require_rpc_cache_utils();
    var createPayload = require_create_payload();
    var noop = function() {
    };
    module.exports = Web3ProviderEngine;
    inherits(Web3ProviderEngine, EventEmitter);
    function Web3ProviderEngine(opts) {
      const self = this;
      EventEmitter.call(self);
      self.setMaxListeners(30);
      opts = opts || {};
      const directProvider = { sendAsync: self._handleAsync.bind(self) };
      const blockTrackerProvider = opts.blockTrackerProvider || directProvider;
      self._blockTracker = opts.blockTracker || new EthBlockTracker({
        provider: blockTrackerProvider,
        pollingInterval: opts.pollingInterval || 4e3,
        setSkipCacheFlag: true
      });
      self._ready = new Stoplight();
      self.currentBlock = null;
      self._providers = [];
    }
    Web3ProviderEngine.prototype.start = function(cb = noop) {
      const self = this;
      self._ready.go();
      self._blockTracker.on("latest", (blockNumber) => {
        self._getBlockByNumberWithRetry(blockNumber, (err, block) => {
          if (err) {
            this.emit("error", err);
            return;
          }
          if (!block) {
            console.log(block);
            this.emit("error", new Error("Could not find block"));
            return;
          }
          const bufferBlock = toBufferBlock(block);
          self._setCurrentBlock(bufferBlock);
          self.emit("rawBlock", block);
          self.emit("latest", block);
        });
      });
      self._blockTracker.on("sync", self.emit.bind(self, "sync"));
      self._blockTracker.on("error", self.emit.bind(self, "error"));
      self._running = true;
      self.emit("start");
    };
    Web3ProviderEngine.prototype.stop = function() {
      const self = this;
      self._blockTracker.removeAllListeners();
      self._running = false;
      self.emit("stop");
    };
    Web3ProviderEngine.prototype.isRunning = function() {
      const self = this;
      return self._running;
    };
    Web3ProviderEngine.prototype.addProvider = function(source, index) {
      const self = this;
      if (typeof index === "number") {
        self._providers.splice(index, 0, source);
      } else {
        self._providers.push(source);
      }
      source.setEngine(this);
    };
    Web3ProviderEngine.prototype.removeProvider = function(source) {
      const self = this;
      const index = self._providers.indexOf(source);
      if (index < 0)
        throw new Error("Provider not found.");
      self._providers.splice(index, 1);
    };
    Web3ProviderEngine.prototype.send = function(payload) {
      throw new Error("Web3ProviderEngine does not support synchronous requests.");
    };
    Web3ProviderEngine.prototype.sendAsync = function(payload, cb) {
      const self = this;
      self._ready.await(function() {
        if (Array.isArray(payload)) {
          map(payload, self._handleAsync.bind(self), cb);
        } else {
          self._handleAsync(payload, cb);
        }
      });
    };
    Web3ProviderEngine.prototype._getBlockByNumberWithRetry = function(blockNumber, cb) {
      const self = this;
      let retriesRemaining = 5;
      attemptRequest();
      return;
      function attemptRequest() {
        self._getBlockByNumber(blockNumber, afterRequest);
      }
      function afterRequest(err, block) {
        if (err)
          return cb(err);
        if (!block) {
          if (retriesRemaining > 0) {
            retriesRemaining--;
            setTimeout(function() {
              attemptRequest();
            }, 1e3);
            return;
          } else {
            cb(null, null);
            return;
          }
        }
        cb(null, block);
        return;
      }
    };
    Web3ProviderEngine.prototype._getBlockByNumber = function(blockNumber, cb) {
      const req = createPayload({ method: "eth_getBlockByNumber", params: [blockNumber, false], skipCache: true });
      this._handleAsync(req, (err, res) => {
        if (err)
          return cb(err);
        return cb(null, res.result);
      });
    };
    Web3ProviderEngine.prototype._handleAsync = function(payload, finished) {
      var self = this;
      var currentProvider = -1;
      var result = null;
      var error = null;
      var stack = [];
      next();
      function next(after) {
        currentProvider += 1;
        stack.unshift(after);
        if (currentProvider >= self._providers.length) {
          end(new Error('Request for method "' + payload.method + '" not handled by any subprovider. Please check your subprovider configuration to ensure this method is handled.'));
        } else {
          try {
            var provider = self._providers[currentProvider];
            provider.handleRequest(payload, next, end);
          } catch (e) {
            end(e);
          }
        }
      }
      function end(_error, _result) {
        error = _error;
        result = _result;
        eachSeries(stack, function(fn, callback) {
          if (fn) {
            fn(error, result, callback);
          } else {
            callback();
          }
        }, function() {
          var resultObj = {
            id: payload.id,
            jsonrpc: payload.jsonrpc,
            result
          };
          if (error != null) {
            resultObj.error = {
              message: error.stack || error.message || error,
              code: -32e3
            };
            finished(error, resultObj);
          } else {
            finished(null, resultObj);
          }
        });
      }
    };
    Web3ProviderEngine.prototype._setCurrentBlock = function(block) {
      const self = this;
      self.currentBlock = block;
      self.emit("block", block);
    };
    function toBufferBlock(jsonBlock) {
      return {
        number: ethUtil.toBuffer(jsonBlock.number),
        hash: ethUtil.toBuffer(jsonBlock.hash),
        parentHash: ethUtil.toBuffer(jsonBlock.parentHash),
        nonce: ethUtil.toBuffer(jsonBlock.nonce),
        mixHash: ethUtil.toBuffer(jsonBlock.mixHash),
        sha3Uncles: ethUtil.toBuffer(jsonBlock.sha3Uncles),
        logsBloom: ethUtil.toBuffer(jsonBlock.logsBloom),
        transactionsRoot: ethUtil.toBuffer(jsonBlock.transactionsRoot),
        stateRoot: ethUtil.toBuffer(jsonBlock.stateRoot),
        receiptsRoot: ethUtil.toBuffer(jsonBlock.receiptRoot || jsonBlock.receiptsRoot),
        miner: ethUtil.toBuffer(jsonBlock.miner),
        difficulty: ethUtil.toBuffer(jsonBlock.difficulty),
        totalDifficulty: ethUtil.toBuffer(jsonBlock.totalDifficulty),
        size: ethUtil.toBuffer(jsonBlock.size),
        extraData: ethUtil.toBuffer(jsonBlock.extraData),
        gasLimit: ethUtil.toBuffer(jsonBlock.gasLimit),
        gasUsed: ethUtil.toBuffer(jsonBlock.gasUsed),
        timestamp: ethUtil.toBuffer(jsonBlock.timestamp),
        transactions: jsonBlock.transactions
      };
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/random-id.js
var require_random_id2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/random-id.js"(exports, module) {
    init_define_process_env();
    "use strict";
    module.exports = createRandomId;
    function createRandomId() {
      return Math.floor(Number.MAX_SAFE_INTEGER * Math.random());
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/util/create-payload.js
var require_create_payload2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/create-payload.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var getRandomId = require_random_id2();
    var extend = require_immutable();
    module.exports = createPayload;
    function createPayload(data) {
      return extend({
        id: getRandomId(),
        jsonrpc: "2.0",
        params: []
      }, data);
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js
var require_subprovider = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subprovider.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var createPayload = require_create_payload2();
    module.exports = SubProvider;
    function SubProvider() {
    }
    SubProvider.prototype.setEngine = function(engine) {
      var self = this;
      if (self.engine)
        return;
      self.engine = engine;
      engine.on("block", function(block) {
        self.currentBlock = block;
      });
      engine.on("start", function() {
        self.start();
      });
      engine.on("stop", function() {
        self.stop();
      });
    };
    SubProvider.prototype.handleRequest = function(payload, next, end) {
      throw new Error("Subproviders should override `handleRequest`.");
    };
    SubProvider.prototype.emitPayload = function(payload, cb) {
      var self = this;
      self.engine.sendAsync(createPayload(payload), cb);
    };
    SubProvider.prototype.stop = function() {
    };
    SubProvider.prototype.start = function() {
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js
var require_json_rpc_engine_middleware = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/json-rpc-engine-middleware.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var Subprovider = require_subprovider();
    var JsonRpcEngineMiddlewareSubprovider = function(_Subprovider) {
      _inherits(JsonRpcEngineMiddlewareSubprovider2, _Subprovider);
      var _super = _createSuper(JsonRpcEngineMiddlewareSubprovider2);
      function JsonRpcEngineMiddlewareSubprovider2(constructorFn) {
        var _this;
        _classCallCheck(this, JsonRpcEngineMiddlewareSubprovider2);
        _this = _super.call(this);
        if (!constructorFn)
          throw new Error("JsonRpcEngineMiddlewareSubprovider - no constructorFn specified");
        _this._constructorFn = constructorFn;
        return _this;
      }
      _createClass(JsonRpcEngineMiddlewareSubprovider2, [{
        key: "setEngine",
        value: function setEngine(engine) {
          if (this.middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - subprovider added to engine twice");
          var blockTracker = engine._blockTracker;
          var middleware = this._constructorFn({
            engine,
            provider: engine,
            blockTracker
          });
          if (!middleware)
            throw new Error("JsonRpcEngineMiddlewareSubprovider - _constructorFn did not return middleware");
          if (typeof middleware !== "function")
            throw new Error("JsonRpcEngineMiddlewareSubprovider - specified middleware is not a function");
          this.middleware = middleware;
        }
      }, {
        key: "handleRequest",
        value: function handleRequest(req, provEngNext, provEngEnd) {
          var res = {
            id: req.id
          };
          this.middleware(req, res, middlewareNext, middlewareEnd);
          function middlewareNext(handler) {
            provEngNext(function(err, result, cb) {
              if (err) {
                delete res.result;
                res.error = {
                  message: err.message || err
                };
              } else {
                res.result = result;
              }
              if (handler) {
                handler(cb);
              } else {
                cb();
              }
            });
          }
          function middlewareEnd(err) {
            if (err)
              return provEngEnd(err);
            provEngEnd(null, res.result);
          }
        }
      }]);
      return JsonRpcEngineMiddlewareSubprovider2;
    }(Subprovider);
    module.exports = JsonRpcEngineMiddlewareSubprovider;
  }
});

// node_modules/eth-json-rpc-middleware/cache-utils.js
var require_cache_utils = __commonJS({
  "node_modules/eth-json-rpc-middleware/cache-utils.js"(exports, module) {
    init_define_process_env();
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload, skipBlockRef) {
      const simpleParams = skipBlockRef ? paramsWithoutBlockTag(payload) : payload.params;
      if (canCache(payload)) {
        return payload.method + ":" + stringify(simpleParams);
      } else {
        return null;
      }
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      let index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      const index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
        case "test_permaCache":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
        case "test_forkCache":
          return "fork";
        case "eth_gasPrice":
        case "eth_blockNumber":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "test_blockCache":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
        case "test_neverCache":
          return "never";
      }
    }
  }
});

// node_modules/json-rpc-engine/src/createAsyncMiddleware.js
var require_createAsyncMiddleware = __commonJS({
  "node_modules/json-rpc-engine/src/createAsyncMiddleware.js"(exports, module) {
    init_define_process_env();
    module.exports = function createAsyncMiddleware(asyncMiddleware) {
      return (req, res, next, end) => {
        let resolveNextPromise;
        const nextPromise = new Promise((resolve) => {
          resolveNextPromise = resolve;
        });
        let returnHandlerCallback, nextWasCalled;
        const asyncNext = async () => {
          nextWasCalled = true;
          next((callback) => {
            returnHandlerCallback = callback;
            resolveNextPromise();
          });
          await nextPromise;
        };
        asyncMiddleware(req, res, asyncNext).then(async () => {
          if (nextWasCalled) {
            await nextPromise;
            returnHandlerCallback(null);
          } else {
            end(null);
          }
        }).catch((error) => {
          if (returnHandlerCallback) {
            returnHandlerCallback(error);
          } else {
            end(error);
          }
        });
      };
    };
  }
});

// node_modules/eth-json-rpc-middleware/block-cache.js
var require_block_cache = __commonJS({
  "node_modules/eth-json-rpc-middleware/block-cache.js"(exports, module) {
    init_define_process_env();
    var cacheUtils = require_cache_utils();
    var createAsyncMiddleware = require_createAsyncMiddleware();
    var emptyValues = [void 0, null, "<nil>"];
    module.exports = createBlockCacheMiddleware;
    function createBlockCacheMiddleware(opts = {}) {
      const { blockTracker } = opts;
      if (!blockTracker)
        throw new Error("createBlockCacheMiddleware - No BlockTracker specified");
      const blockCache = new BlockCacheStrategy();
      const strategies = {
        perma: blockCache,
        block: blockCache,
        fork: blockCache
      };
      return createAsyncMiddleware(async (req, res, next) => {
        if (req.skipCache) {
          return next();
        }
        const type = cacheUtils.cacheTypeForPayload(req);
        const strategy = strategies[type];
        if (!strategy) {
          return next();
        }
        if (!strategy.canCacheRequest(req)) {
          return next();
        }
        let blockTag = cacheUtils.blockTagForPayload(req);
        if (!blockTag)
          blockTag = "latest";
        let requestedBlockNumber;
        if (blockTag === "earliest") {
          requestedBlockNumber = "0x00";
        } else if (blockTag === "latest") {
          const latestBlockNumber = await blockTracker.getLatestBlock();
          blockCache.clearBefore(latestBlockNumber);
          requestedBlockNumber = latestBlockNumber;
        } else {
          requestedBlockNumber = blockTag;
        }
        const cacheResult = await strategy.get(req, requestedBlockNumber);
        if (cacheResult === void 0) {
          await next();
          await strategy.set(req, requestedBlockNumber, res.result);
        } else {
          res.result = cacheResult;
        }
      });
    }
    var BlockCacheStrategy = class {
      constructor() {
        this.cache = {};
      }
      getBlockCacheForPayload(payload, blockNumberHex) {
        const blockNumber = Number.parseInt(blockNumberHex, 16);
        let blockCache = this.cache[blockNumber];
        if (!blockCache) {
          const newCache = {};
          this.cache[blockNumber] = newCache;
          blockCache = newCache;
        }
        return blockCache;
      }
      async get(payload, requestedBlockNumber) {
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        if (!blockCache)
          return;
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        const cached = blockCache[identifier];
        return cached;
      }
      async set(payload, requestedBlockNumber, result) {
        const canCache = this.canCacheResult(payload, result);
        if (!canCache)
          return;
        const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);
        const identifier = cacheUtils.cacheIdentifierForPayload(payload, true);
        blockCache[identifier] = result;
      }
      canCacheRequest(payload) {
        if (!cacheUtils.canCache(payload)) {
          return false;
        }
        const blockTag = cacheUtils.blockTagForPayload(payload);
        if (blockTag === "pending") {
          return false;
        }
        return true;
      }
      canCacheResult(payload, result) {
        if (emptyValues.includes(result))
          return;
        if (["eth_getTransactionByHash", "eth_getTransactionReceipt"].includes(payload.method)) {
          if (!result || !result.blockHash || result.blockHash === "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return false;
          }
        }
        return true;
      }
      clearBefore(oldBlockHex) {
        const self = this;
        const oldBlockNumber = Number.parseInt(oldBlockHex, 16);
        Object.keys(self.cache).map(Number).filter((num) => num < oldBlockNumber).forEach((num) => delete self.cache[num]);
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/cache.js
var require_cache = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/cache.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createBlockCacheMiddleware = require_block_cache();
    var BlockCacheSubprovider = function(_ProviderSubprovider) {
      _inherits(BlockCacheSubprovider2, _ProviderSubprovider);
      var _super = _createSuper(BlockCacheSubprovider2);
      function BlockCacheSubprovider2(opts) {
        _classCallCheck(this, BlockCacheSubprovider2);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker;
          return createBlockCacheMiddleware(Object.assign({
            blockTracker
          }, opts));
        });
      }
      return BlockCacheSubprovider2;
    }(ProviderSubprovider);
    module.exports = BlockCacheSubprovider;
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js
var require_fixture = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/fixture.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var inherits = require_util().inherits;
    var Subprovider = require_subprovider();
    module.exports = FixtureProvider;
    inherits(FixtureProvider, Subprovider);
    function FixtureProvider(staticResponses) {
      var self = this;
      staticResponses = staticResponses || {};
      self.staticResponses = staticResponses;
    }
    FixtureProvider.prototype.handleRequest = function(payload, next, end) {
      var self = this;
      var staticResponse = self.staticResponses[payload.method];
      if (typeof staticResponse === "function") {
        staticResponse(payload, next, end);
      } else if (staticResponse !== void 0) {
        setTimeout(function() {
          return end(null, staticResponse);
        });
      } else {
        next();
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/filters.js
var require_filters = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/filters.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createFilterMiddleware = require_eth_json_rpc_filters();
    var SubscriptionsSubprovider2 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider3, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider3);
      function SubscriptionsSubprovider3() {
        _classCallCheck(this, SubscriptionsSubprovider3);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          return createFilterMiddleware({
            blockTracker,
            provider
          });
        });
      }
      return SubscriptionsSubprovider3;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider2;
  }
});

// node_modules/async/waterfall.js
var require_waterfall = __commonJS({
  "node_modules/async/waterfall.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = function(tasks, callback) {
      callback = (0, _once2.default)(callback || _noop2.default);
      if (!(0, _isArray2.default)(tasks))
        return callback(new Error("First argument to waterfall must be an array of functions"));
      if (!tasks.length)
        return callback();
      var taskIndex = 0;
      function nextTask(args) {
        var task = (0, _wrapAsync2.default)(tasks[taskIndex++]);
        args.push((0, _onlyOnce2.default)(next));
        task.apply(null, args);
      }
      function next(err) {
        if (err || taskIndex === tasks.length) {
          return callback.apply(null, arguments);
        }
        nextTask((0, _slice2.default)(arguments, 1));
      }
      nextTask([]);
    };
    var _isArray = require_isArray();
    var _isArray2 = _interopRequireDefault(_isArray);
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = _parallel;
    var _noop = require_noop();
    var _noop2 = _interopRequireDefault(_noop);
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _slice = require_slice();
    var _slice2 = _interopRequireDefault(_slice);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _parallel(eachfn, tasks, callback) {
      callback = callback || _noop2.default;
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, function(task, key, callback2) {
        (0, _wrapAsync2.default)(task)(function(err, result) {
          if (arguments.length > 2) {
            result = (0, _slice2.default)(arguments, 1);
          }
          results[key] = result;
          callback2(err);
        });
      }, function(err) {
        callback(err, results);
      });
    }
    module.exports = exports["default"];
  }
});

// node_modules/async/parallel.js
var require_parallel2 = __commonJS({
  "node_modules/async/parallel.js"(exports, module) {
    init_define_process_env();
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = parallelLimit;
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _parallel = require_parallel();
    var _parallel2 = _interopRequireDefault(_parallel);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parallelLimit(tasks, callback) {
      (0, _parallel2.default)(_eachOf2.default, tasks, callback);
    }
    module.exports = exports["default"];
  }
});

// node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js
var require_estimate_gas = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/estimate-gas.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var createPayload = require_create_payload2();
    module.exports = estimateGas;
    function estimateGas(provider, txParams, cb) {
      provider.sendAsync(createPayload({
        method: "eth_estimateGas",
        params: [txParams]
      }), function(err, res) {
        if (err) {
          if (err.message === "no contract code at given address") {
            return cb(null, "0xcf08");
          } else {
            return cb(err);
          }
        }
        cb(null, res.result);
      });
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js
var require_hooked_wallet = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/hooked-wallet.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var waterfall = require_waterfall();
    var parallel = require_parallel2();
    var inherits = require_util().inherits;
    var ethUtil = require_dist2();
    var sigUtil = require_eth_sig_util();
    var extend = require_immutable();
    var Semaphore = require_semaphore();
    var Subprovider = require_subprovider();
    var estimateGas = require_estimate_gas();
    var hexRegex = /^[0-9A-Fa-f]+$/g;
    module.exports = HookedWalletSubprovider2;
    inherits(HookedWalletSubprovider2, Subprovider);
    function HookedWalletSubprovider2(opts) {
      var self = this;
      self.nonceLock = Semaphore(1);
      if (opts.getAccounts)
        self.getAccounts = opts.getAccounts;
      if (opts.processTransaction)
        self.processTransaction = opts.processTransaction;
      if (opts.processMessage)
        self.processMessage = opts.processMessage;
      if (opts.processPersonalMessage)
        self.processPersonalMessage = opts.processPersonalMessage;
      if (opts.processTypedMessage)
        self.processTypedMessage = opts.processTypedMessage;
      self.approveTransaction = opts.approveTransaction || self.autoApprove;
      self.approveMessage = opts.approveMessage || self.autoApprove;
      self.approvePersonalMessage = opts.approvePersonalMessage || self.autoApprove;
      self.approveDecryptMessage = opts.approveDecryptMessage || self.autoApprove;
      self.approveEncryptionPublicKey = opts.approveEncryptionPublicKey || self.autoApprove;
      self.approveTypedMessage = opts.approveTypedMessage || self.autoApprove;
      if (opts.signTransaction)
        self.signTransaction = opts.signTransaction || mustProvideInConstructor("signTransaction");
      if (opts.signMessage)
        self.signMessage = opts.signMessage || mustProvideInConstructor("signMessage");
      if (opts.signPersonalMessage)
        self.signPersonalMessage = opts.signPersonalMessage || mustProvideInConstructor("signPersonalMessage");
      if (opts.decryptMessage)
        self.decryptMessage = opts.decryptMessage || mustProvideInConstructor("decryptMessage");
      if (opts.encryptionPublicKey)
        self.encryptionPublicKey = opts.encryptionPublicKey || mustProvideInConstructor("encryptionPublicKey");
      if (opts.signTypedMessage)
        self.signTypedMessage = opts.signTypedMessage || mustProvideInConstructor("signTypedMessage");
      if (opts.recoverPersonalSignature)
        self.recoverPersonalSignature = opts.recoverPersonalSignature;
      if (opts.publishTransaction)
        self.publishTransaction = opts.publishTransaction;
      self.estimateGas = opts.estimateGas || self.estimateGas;
      self.getGasPrice = opts.getGasPrice || self.getGasPrice;
    }
    HookedWalletSubprovider2.prototype.handleRequest = function(payload, next, end) {
      var self = this;
      self._parityRequests = {};
      self._parityRequestCount = 0;
      var txParams, msgParams, extraParams;
      var message, address;
      switch (payload.method) {
        case "eth_coinbase":
          self.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var result = accounts[0] || null;
            end(null, result);
          });
          return;
        case "eth_accounts":
          self.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            end(null, accounts);
          });
          return;
        case "eth_sendTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self.validateTransaction(txParams, cb);
          }, function(cb) {
            return self.processTransaction(txParams, cb);
          }], end);
          return;
        case "eth_signTransaction":
          txParams = payload.params[0];
          waterfall([function(cb) {
            return self.validateTransaction(txParams, cb);
          }, function(cb) {
            return self.processSignTransaction(txParams, cb);
          }], end);
          return;
        case "eth_sign":
          address = payload.params[0];
          message = payload.params[1];
          extraParams = payload.params[2] || {};
          msgParams = extend(extraParams, {
            from: address,
            data: message
          });
          waterfall([function(cb) {
            return self.validateMessage(msgParams, cb);
          }, function(cb) {
            return self.processMessage(msgParams, cb);
          }], end);
          return;
        case "personal_sign":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              var warning = "The eth_personalSign method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self.validatePersonalMessage(msgParams, cb);
            }, function(cb) {
              return self.processPersonalMessage(msgParams, cb);
            }], end);
          }();
        case "eth_decryptMessage":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesData(second) && resemblesAddress(first)) {
              var warning = "The eth_decryptMessage method requires params ordered ";
              warning += "[message, address]. This was previously handled incorrectly, ";
              warning += "and has been corrected automatically. ";
              warning += "Please switch this param order for smooth behavior in the future.";
              console.warn(warning);
              address = payload.params[0];
              message = payload.params[1];
            } else {
              message = payload.params[0];
              address = payload.params[1];
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self.validateDecryptMessage(msgParams, cb);
            }, function(cb) {
              return self.processDecryptMessage(msgParams, cb);
            }], end);
          }();
        case "encryption_public_key":
          return function() {
            var address2 = payload.params[0];
            waterfall([function(cb) {
              return self.validateEncryptionPublicKey(address2, cb);
            }, function(cb) {
              return self.processEncryptionPublicKey(address2, cb);
            }], end);
          }();
        case "personal_ecRecover":
          return function() {
            message = payload.params[0];
            var signature = payload.params[1];
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              sig: signature,
              data: message
            });
            self.recoverPersonalSignature(msgParams, end);
          }();
        case "eth_signTypedData":
        case "eth_signTypedData_v3":
        case "eth_signTypedData_v4":
          return function() {
            var first = payload.params[0];
            var second = payload.params[1];
            if (resemblesAddress(first)) {
              address = first;
              message = second;
            } else {
              message = first;
              address = second;
            }
            extraParams = payload.params[2] || {};
            msgParams = extend(extraParams, {
              from: address,
              data: message
            });
            waterfall([function(cb) {
              return self.validateTypedMessage(msgParams, cb);
            }, function(cb) {
              return self.processTypedMessage(msgParams, cb);
            }], end);
          }();
        case "parity_postTransaction":
          txParams = payload.params[0];
          self.parityPostTransaction(txParams, end);
          return;
        case "parity_postSign":
          address = payload.params[0];
          message = payload.params[1];
          self.parityPostSign(address, message, end);
          return;
        case "parity_checkRequest":
          return function() {
            var requestId = payload.params[0];
            self.parityCheckRequest(requestId, end);
          }();
        case "parity_defaultAccount":
          self.getAccounts(function(err, accounts) {
            if (err)
              return end(err);
            var account = accounts[0] || null;
            end(null, account);
          });
          return;
        default:
          next();
          return;
      }
    };
    HookedWalletSubprovider2.prototype.getAccounts = function(cb) {
      cb(null, []);
    };
    HookedWalletSubprovider2.prototype.processTransaction = function(txParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self.finalizeAndSubmitTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processSignTransaction = function(txParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveTransaction(txParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("transaction", didApprove, cb2);
      }, function(cb2) {
        return self.finalizeTx(txParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processMessage = function(msgParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self.signMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processPersonalMessage = function(msgParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approvePersonalMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self.signPersonalMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processDecryptMessage = function(msgParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveDecryptMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("decryptMessage", didApprove, cb2);
      }, function(cb2) {
        return self.decryptMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processEncryptionPublicKey = function(msgParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveEncryptionPublicKey(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("encryptionPublicKey", didApprove, cb2);
      }, function(cb2) {
        return self.encryptionPublicKey(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.processTypedMessage = function(msgParams, cb) {
      var self = this;
      waterfall([function(cb2) {
        return self.approveTypedMessage(msgParams, cb2);
      }, function(didApprove, cb2) {
        return self.checkApproval("message", didApprove, cb2);
      }, function(cb2) {
        return self.signTypedMessage(msgParams, cb2);
      }], cb);
    };
    HookedWalletSubprovider2.prototype.autoApprove = function(txParams, cb) {
      cb(null, true);
    };
    HookedWalletSubprovider2.prototype.checkApproval = function(type, didApprove, cb) {
      cb(didApprove ? null : new Error("User denied " + type + " signature."));
    };
    HookedWalletSubprovider2.prototype.parityPostTransaction = function(txParams, cb) {
      var self = this;
      var count = self._parityRequestCount;
      var reqId = "0x".concat(count.toString(16));
      self._parityRequestCount++;
      self.emitPayload({
        method: "eth_sendTransaction",
        params: [txParams]
      }, function(error, res) {
        if (error) {
          self._parityRequests[reqId] = {
            error
          };
          return;
        }
        var txHash = res.result;
        self._parityRequests[reqId] = txHash;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityPostSign = function(address, message, cb) {
      var self = this;
      var count = self._parityRequestCount;
      var reqId = "0x".concat(count.toString(16));
      self._parityRequestCount++;
      self.emitPayload({
        method: "eth_sign",
        params: [address, message]
      }, function(error, res) {
        if (error) {
          self._parityRequests[reqId] = {
            error
          };
          return;
        }
        var result = res.result;
        self._parityRequests[reqId] = result;
      });
      cb(null, reqId);
    };
    HookedWalletSubprovider2.prototype.parityCheckRequest = function(reqId, cb) {
      var self = this;
      var result = self._parityRequests[reqId] || null;
      if (!result)
        return cb(null, null);
      if (result.error)
        return cb(result.error);
      cb(null, result);
    };
    HookedWalletSubprovider2.prototype.recoverPersonalSignature = function(msgParams, cb) {
      var senderHex;
      try {
        senderHex = sigUtil.recoverPersonalSignature(msgParams);
      } catch (err) {
        return cb(err);
      }
      cb(null, senderHex);
    };
    HookedWalletSubprovider2.prototype.validateTransaction = function(txParams, cb) {
      var self = this;
      if (txParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign transaction."));
      self.validateSender(txParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign transaction for this address: "'.concat(txParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateMessage = function(msgParams, cb) {
      var self = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign message."));
      self.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validatePersonalMessage = function(msgParams, cb) {
      var self = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign personal message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to sign personal message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateMessage - message was not encoded as hex."));
      self.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateDecryptMessage = function(msgParams, cb) {
      var self = this;
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to decrypt message."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined message - message required to decrypt message."));
      if (!isValidHex(msgParams.data))
        return cb(new Error("HookedWalletSubprovider - validateDecryptMessage - message was not encoded as hex."));
      self.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to decrypt message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateEncryptionPublicKey = function(address, cb) {
      var self = this;
      self.validateSender(address, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to obtain encryption public key for this address: "'.concat(address, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateTypedMessage = function(msgParams, cb) {
      if (msgParams.from === void 0)
        return cb(new Error("Undefined address - from address required to sign typed data."));
      if (msgParams.data === void 0)
        return cb(new Error("Undefined data - message required to sign typed data."));
      this.validateSender(msgParams.from, function(err, senderIsValid) {
        if (err)
          return cb(err);
        if (!senderIsValid)
          return cb(new Error('Unknown address - unable to sign message for this address: "'.concat(msgParams.from, '"')));
        cb();
      });
    };
    HookedWalletSubprovider2.prototype.validateSender = function(senderAddress, cb) {
      var self = this;
      if (!senderAddress)
        return cb(null, false);
      self.getAccounts(function(err, accounts) {
        if (err)
          return cb(err);
        var senderIsValid = accounts.map(toLowerCase).indexOf(senderAddress.toLowerCase()) !== -1;
        cb(null, senderIsValid);
      });
    };
    HookedWalletSubprovider2.prototype.finalizeAndSubmitTx = function(txParams, cb) {
      var self = this;
      self.nonceLock.take(function() {
        waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self), self.publishTransaction.bind(self)], function(err, txHash) {
          self.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, txHash);
        });
      });
    };
    HookedWalletSubprovider2.prototype.finalizeTx = function(txParams, cb) {
      var self = this;
      self.nonceLock.take(function() {
        waterfall([self.fillInTxExtras.bind(self, txParams), self.signTransaction.bind(self)], function(err, signedTx) {
          self.nonceLock.leave();
          if (err)
            return cb(err);
          cb(null, {
            raw: signedTx,
            tx: txParams
          });
        });
      });
    };
    HookedWalletSubprovider2.prototype.publishTransaction = function(rawTx, cb) {
      var self = this;
      self.emitPayload({
        method: "eth_sendRawTransaction",
        params: [rawTx]
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.estimateGas = function(txParams, cb) {
      var self = this;
      estimateGas(self.engine, txParams, cb);
    };
    HookedWalletSubprovider2.prototype.getGasPrice = function(cb) {
      var self = this;
      self.emitPayload({
        method: "eth_gasPrice",
        params: []
      }, function(err, res) {
        if (err)
          return cb(err);
        cb(null, res.result);
      });
    };
    HookedWalletSubprovider2.prototype.fillInTxExtras = function(txParams, cb) {
      var self = this;
      var address = txParams.from;
      var tasks = {};
      if (txParams.gasPrice === void 0) {
        tasks.gasPrice = self.getGasPrice.bind(self);
      }
      if (txParams.nonce === void 0) {
        tasks.nonce = self.emitPayload.bind(self, {
          method: "eth_getTransactionCount",
          params: [address, "pending"]
        });
      }
      if (txParams.gas === void 0) {
        tasks.gas = self.estimateGas.bind(self, cloneTxParams(txParams));
      }
      parallel(tasks, function(err, taskResults) {
        if (err)
          return cb(err);
        var result = {};
        if (taskResults.gasPrice)
          result.gasPrice = taskResults.gasPrice;
        if (taskResults.nonce)
          result.nonce = taskResults.nonce.result;
        if (taskResults.gas)
          result.gas = taskResults.gas;
        cb(null, extend(txParams, result));
      });
    };
    function cloneTxParams(txParams) {
      return {
        from: txParams.from,
        to: txParams.to,
        value: txParams.value,
        data: txParams.data,
        gas: txParams.gas,
        gasPrice: txParams.gasPrice,
        nonce: txParams.nonce
      };
    }
    function toLowerCase(string) {
      return string.toLowerCase();
    }
    function resemblesAddress(string) {
      var fixed = ethUtil.addHexPrefix(string);
      var isValid = ethUtil.isValidAddress(fixed);
      return isValid;
    }
    function resemblesData(string) {
      var fixed = ethUtil.addHexPrefix(string);
      var isValidAddress = ethUtil.isValidAddress(fixed);
      return !isValidAddress && isValidHex(string);
    }
    function isValidHex(data) {
      var isString = typeof data === "string";
      if (!isString)
        return false;
      var isHexPrefixed = data.slice(0, 2) === "0x";
      if (!isHexPrefixed)
        return false;
      var nonPrefixed = data.slice(2);
      var isValid = nonPrefixed.match(hexRegex);
      return isValid;
    }
    function mustProvideInConstructor(methodName) {
      return function(params, cb) {
        cb(new Error('ProviderEngine - HookedWalletSubprovider - Must provide "' + methodName + '" fn in constructor options'));
      };
    }
  }
});

// node_modules/ethereum-common/params.json
var require_params = __commonJS({
  "node_modules/ethereum-common/params.json"(exports, module) {
    module.exports = {
      genesisGasLimit: {
        v: 5e3,
        d: "Gas limit of the Genesis block."
      },
      genesisDifficulty: {
        v: 17179869184,
        d: "Difficulty of the Genesis block."
      },
      genesisNonce: {
        v: "0x0000000000000042",
        d: "the geneis nonce"
      },
      genesisExtraData: {
        v: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa",
        d: "extra data "
      },
      genesisHash: {
        v: "0xd4e56740f876aef8c010b86a40d5f56745a118d0906a34e69aec8c0db1cb8fa3",
        d: "genesis hash"
      },
      genesisStateRoot: {
        v: "0xd7f8974fb5ac78d9ac099b9ad5018bedc2ce0a72dad1827a1709da30580f0544",
        d: "the genesis state root"
      },
      minGasLimit: {
        v: 5e3,
        d: "Minimum the gas limit may ever be."
      },
      gasLimitBoundDivisor: {
        v: 1024,
        d: "The bound divisor of the gas limit, used in update calculations."
      },
      minimumDifficulty: {
        v: 131072,
        d: "The minimum that the difficulty may ever be."
      },
      difficultyBoundDivisor: {
        v: 2048,
        d: "The bound divisor of the difficulty, used in the update calculations."
      },
      durationLimit: {
        v: 13,
        d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not."
      },
      maximumExtraDataSize: {
        v: 32,
        d: "Maximum size extra data may be after Genesis."
      },
      epochDuration: {
        v: 3e4,
        d: "Duration between proof-of-work epochs."
      },
      stackLimit: {
        v: 1024,
        d: "Maximum size of VM stack allowed."
      },
      callCreateDepth: {
        v: 1024,
        d: "Maximum depth of call/create stack."
      },
      tierStepGas: {
        v: [0, 2, 3, 5, 8, 10, 20],
        d: "Once per operation, for a selection of them."
      },
      expGas: {
        v: 10,
        d: "Once per EXP instuction."
      },
      expByteGas: {
        v: 10,
        d: "Times ceil(log256(exponent)) for the EXP instruction."
      },
      sha3Gas: {
        v: 30,
        d: "Once per SHA3 operation."
      },
      sha3WordGas: {
        v: 6,
        d: "Once per word of the SHA3 operation's data."
      },
      sloadGas: {
        v: 50,
        d: "Once per SLOAD operation."
      },
      sstoreSetGas: {
        v: 2e4,
        d: "Once per SSTORE operation if the zeroness changes from zero."
      },
      sstoreResetGas: {
        v: 5e3,
        d: "Once per SSTORE operation if the zeroness does not change from zero."
      },
      sstoreRefundGas: {
        v: 15e3,
        d: "Once per SSTORE operation if the zeroness changes to zero."
      },
      jumpdestGas: {
        v: 1,
        d: "Refunded gas, once per SSTORE operation if the zeroness changes to zero."
      },
      logGas: {
        v: 375,
        d: "Per LOG* operation."
      },
      logDataGas: {
        v: 8,
        d: "Per byte in a LOG* operation's data."
      },
      logTopicGas: {
        v: 375,
        d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas."
      },
      createGas: {
        v: 32e3,
        d: "Once per CREATE operation & contract-creation transaction."
      },
      callGas: {
        v: 40,
        d: "Once per CALL operation & message call transaction."
      },
      callStipend: {
        v: 2300,
        d: "Free gas given at beginning of call."
      },
      callValueTransferGas: {
        v: 9e3,
        d: "Paid for CALL when the value transfor is non-zero."
      },
      callNewAccountGas: {
        v: 25e3,
        d: "Paid for CALL when the destination address didn't exist prior."
      },
      suicideRefundGas: {
        v: 24e3,
        d: "Refunded following a suicide operation."
      },
      memoryGas: {
        v: 3,
        d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL."
      },
      quadCoeffDiv: {
        v: 512,
        d: "Divisor for the quadratic particle of the memory cost equation."
      },
      createDataGas: {
        v: 200,
        d: ""
      },
      txGas: {
        v: 21e3,
        d: "Per transaction. NOTE: Not payable on data of calls between transactions."
      },
      txCreation: {
        v: 32e3,
        d: "the cost of creating a contract via tx"
      },
      txDataZeroGas: {
        v: 4,
        d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions."
      },
      txDataNonZeroGas: {
        v: 68,
        d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions."
      },
      copyGas: {
        v: 3,
        d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added."
      },
      ecrecoverGas: {
        v: 3e3,
        d: ""
      },
      sha256Gas: {
        v: 60,
        d: ""
      },
      sha256WordGas: {
        v: 12,
        d: ""
      },
      ripemd160Gas: {
        v: 600,
        d: ""
      },
      ripemd160WordGas: {
        v: 120,
        d: ""
      },
      identityGas: {
        v: 15,
        d: ""
      },
      identityWordGas: {
        v: 3,
        d: ""
      },
      minerReward: {
        v: "5000000000000000000",
        d: "the amount a miner get rewarded for mining a block"
      },
      ommerReward: {
        v: "625000000000000000",
        d: "The amount of wei a miner of an uncle block gets for being inculded in the blockchain"
      },
      niblingReward: {
        v: "156250000000000000",
        d: "the amount a miner gets for inculding a uncle"
      },
      homeSteadForkNumber: {
        v: 115e4,
        d: "the block that the Homestead fork started at"
      },
      homesteadRepriceForkNumber: {
        v: 2463e3,
        d: "the block that the Homestead Reprice (EIP150) fork started at"
      },
      timebombPeriod: {
        v: 1e5,
        d: "Exponential difficulty timebomb period"
      },
      freeBlockPeriod: {
        v: 2
      }
    };
  }
});

// node_modules/ethereumjs-tx/es5/index.js
var require_es5 = __commonJS({
  "node_modules/ethereumjs-tx/es5/index.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var ethUtil = require_dist2();
    var fees = require_params();
    var BN2 = ethUtil.BN;
    var N_DIV_2 = new BN2("7fffffffffffffffffffffffffffffff5d576e7357a4501ddfe92f46681b20a0", 16);
    var Transaction = function() {
      function Transaction2(data) {
        _classCallCheck(this, Transaction2);
        data = data || {};
        var fields = [{
          name: "nonce",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasPrice",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "gasLimit",
          alias: "gas",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "to",
          allowZero: true,
          length: 20,
          default: new Buffer([])
        }, {
          name: "value",
          length: 32,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "data",
          alias: "input",
          allowZero: true,
          default: new Buffer([])
        }, {
          name: "v",
          allowZero: true,
          default: new Buffer([28])
        }, {
          name: "r",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }, {
          name: "s",
          length: 32,
          allowZero: true,
          allowLess: true,
          default: new Buffer([])
        }];
        ethUtil.defineProperties(this, fields, data);
        Object.defineProperty(this, "from", {
          enumerable: true,
          configurable: true,
          get: this.getSenderAddress.bind(this)
        });
        var sigV = ethUtil.bufferToInt(this.v);
        var chainId = Math.floor((sigV - 35) / 2);
        if (chainId < 0)
          chainId = 0;
        this._chainId = chainId || data.chainId || 0;
        this._homestead = true;
      }
      Transaction2.prototype.toCreationAddress = function toCreationAddress() {
        return this.to.toString("hex") === "";
      };
      Transaction2.prototype.hash = function hash(includeSignature) {
        if (includeSignature === void 0)
          includeSignature = true;
        var items = void 0;
        if (includeSignature) {
          items = this.raw;
        } else {
          if (this._chainId > 0) {
            var raw = this.raw.slice();
            this.v = this._chainId;
            this.r = 0;
            this.s = 0;
            items = this.raw;
            this.raw = raw;
          } else {
            items = this.raw.slice(0, 6);
          }
        }
        return ethUtil.rlphash(items);
      };
      Transaction2.prototype.getChainId = function getChainId() {
        return this._chainId;
      };
      Transaction2.prototype.getSenderAddress = function getSenderAddress() {
        if (this._from) {
          return this._from;
        }
        var pubkey = this.getSenderPublicKey();
        this._from = ethUtil.publicToAddress(pubkey);
        return this._from;
      };
      Transaction2.prototype.getSenderPublicKey = function getSenderPublicKey() {
        if (!this._senderPubKey || !this._senderPubKey.length) {
          if (!this.verifySignature())
            throw new Error("Invalid Signature");
        }
        return this._senderPubKey;
      };
      Transaction2.prototype.verifySignature = function verifySignature() {
        var msgHash = this.hash(false);
        if (this._homestead && new BN2(this.s).cmp(N_DIV_2) === 1) {
          return false;
        }
        try {
          var v = ethUtil.bufferToInt(this.v);
          if (this._chainId > 0) {
            v -= this._chainId * 2 + 8;
          }
          this._senderPubKey = ethUtil.ecrecover(msgHash, v, this.r, this.s);
        } catch (e) {
          return false;
        }
        return !!this._senderPubKey;
      };
      Transaction2.prototype.sign = function sign(privateKey) {
        var msgHash = this.hash(false);
        var sig = ethUtil.ecsign(msgHash, privateKey);
        if (this._chainId > 0) {
          sig.v += this._chainId * 2 + 8;
        }
        Object.assign(this, sig);
      };
      Transaction2.prototype.getDataFee = function getDataFee() {
        var data = this.raw[5];
        var cost = new BN2(0);
        for (var i = 0; i < data.length; i++) {
          data[i] === 0 ? cost.iaddn(fees.txDataZeroGas.v) : cost.iaddn(fees.txDataNonZeroGas.v);
        }
        return cost;
      };
      Transaction2.prototype.getBaseFee = function getBaseFee() {
        var fee = this.getDataFee().iaddn(fees.txGas.v);
        if (this._homestead && this.toCreationAddress()) {
          fee.iaddn(fees.txCreation.v);
        }
        return fee;
      };
      Transaction2.prototype.getUpfrontCost = function getUpfrontCost() {
        return new BN2(this.gasLimit).imul(new BN2(this.gasPrice)).iadd(new BN2(this.value));
      };
      Transaction2.prototype.validate = function validate(stringError) {
        var errors = [];
        if (!this.verifySignature()) {
          errors.push("Invalid Signature");
        }
        if (this.getBaseFee().cmp(new BN2(this.gasLimit)) > 0) {
          errors.push(["gas limit is too low. Need at least " + this.getBaseFee()]);
        }
        if (stringError === void 0 || stringError === false) {
          return errors.length === 0;
        } else {
          return errors.join(" ");
        }
      };
      return Transaction2;
    }();
    module.exports = Transaction;
  }
});

// node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js
var require_rpc_cache_utils2 = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/util/rpc-cache-utils.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var stringify = require_json_stable_stringify();
    module.exports = {
      cacheIdentifierForPayload,
      canCache,
      blockTagForPayload,
      paramsWithoutBlockTag,
      blockTagParamIndex,
      cacheTypeForPayload
    };
    function cacheIdentifierForPayload(payload) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!canCache(payload))
        return null;
      var includeBlockRef = opts.includeBlockRef;
      var params = includeBlockRef ? payload.params : paramsWithoutBlockTag(payload);
      return payload.method + ":" + stringify(params);
    }
    function canCache(payload) {
      return cacheTypeForPayload(payload) !== "never";
    }
    function blockTagForPayload(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return null;
      }
      return payload.params[index];
    }
    function paramsWithoutBlockTag(payload) {
      var index = blockTagParamIndex(payload);
      if (index >= payload.params.length) {
        return payload.params;
      }
      if (payload.method === "eth_getBlockByNumber") {
        return payload.params.slice(1);
      }
      return payload.params.slice(0, index);
    }
    function blockTagParamIndex(payload) {
      switch (payload.method) {
        case "eth_getStorageAt":
          return 2;
        case "eth_getBalance":
        case "eth_getCode":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
          return 1;
        case "eth_getBlockByNumber":
          return 0;
        default:
          return void 0;
      }
    }
    function cacheTypeForPayload(payload) {
      switch (payload.method) {
        case "web3_clientVersion":
        case "web3_sha3":
        case "eth_protocolVersion":
        case "eth_getBlockTransactionCountByHash":
        case "eth_getUncleCountByBlockHash":
        case "eth_getCode":
        case "eth_getBlockByHash":
        case "eth_getTransactionByHash":
        case "eth_getTransactionByBlockHashAndIndex":
        case "eth_getTransactionReceipt":
        case "eth_getUncleByBlockHashAndIndex":
        case "eth_getCompilers":
        case "eth_compileLLL":
        case "eth_compileSolidity":
        case "eth_compileSerpent":
        case "shh_version":
          return "perma";
        case "eth_getBlockByNumber":
        case "eth_getBlockTransactionCountByNumber":
        case "eth_getUncleCountByBlockNumber":
        case "eth_getTransactionByBlockNumberAndIndex":
        case "eth_getUncleByBlockNumberAndIndex":
          return "fork";
        case "eth_gasPrice":
        case "eth_getBalance":
        case "eth_getStorageAt":
        case "eth_getTransactionCount":
        case "eth_call":
        case "eth_estimateGas":
        case "eth_getFilterLogs":
        case "eth_getLogs":
        case "eth_blockNumber":
          return "block";
        case "net_version":
        case "net_peerCount":
        case "net_listening":
        case "eth_syncing":
        case "eth_sign":
        case "eth_coinbase":
        case "eth_mining":
        case "eth_hashrate":
        case "eth_accounts":
        case "eth_sendTransaction":
        case "eth_sendRawTransaction":
        case "eth_newFilter":
        case "eth_newBlockFilter":
        case "eth_newPendingTransactionFilter":
        case "eth_uninstallFilter":
        case "eth_getFilterChanges":
        case "eth_getWork":
        case "eth_submitWork":
        case "eth_submitHashrate":
        case "db_putString":
        case "db_getString":
        case "db_putHex":
        case "db_getHex":
        case "shh_post":
        case "shh_newIdentity":
        case "shh_hasIdentity":
        case "shh_newGroup":
        case "shh_addToGroup":
        case "shh_newFilter":
        case "shh_uninstallFilter":
        case "shh_getFilterChanges":
        case "shh_getMessages":
          return "never";
      }
    }
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js
var require_nonce_tracker = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/nonce-tracker.js"(exports, module) {
    init_define_process_env();
    "use strict";
    var inherits = require_util().inherits;
    var Transaction = require_es5();
    var ethUtil = require_dist2();
    var Subprovider = require_subprovider();
    var blockTagForPayload = require_rpc_cache_utils2().blockTagForPayload;
    module.exports = NonceTrackerSubprovider;
    inherits(NonceTrackerSubprovider, Subprovider);
    function NonceTrackerSubprovider(opts) {
      var self = this;
      self.nonceCache = {};
    }
    NonceTrackerSubprovider.prototype.handleRequest = function(payload, next, end) {
      var self = this;
      switch (payload.method) {
        case "eth_getTransactionCount":
          var blockTag = blockTagForPayload(payload);
          var address = payload.params[0].toLowerCase();
          var cachedResult = self.nonceCache[address];
          if (blockTag === "pending") {
            if (cachedResult) {
              end(null, cachedResult);
            } else {
              next(function(err, result, cb) {
                if (err)
                  return cb();
                if (self.nonceCache[address] === void 0) {
                  self.nonceCache[address] = result;
                }
                cb();
              });
            }
          } else {
            next();
          }
          return;
        case "eth_sendRawTransaction":
          next(function(err, result, cb) {
            if (err)
              return cb();
            var rawTx = payload.params[0];
            var stripped = ethUtil.stripHexPrefix(rawTx);
            var rawData = Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex");
            var tx = new Transaction(Buffer.from(ethUtil.stripHexPrefix(rawTx), "hex"));
            var address2 = "0x" + tx.getSenderAddress().toString("hex").toLowerCase();
            var nonce = ethUtil.bufferToInt(tx.nonce);
            nonce++;
            var hexNonce = nonce.toString(16);
            if (hexNonce.length % 2)
              hexNonce = "0" + hexNonce;
            hexNonce = "0x" + hexNonce;
            self.nonceCache[address2] = hexNonce;
            cb();
          });
          return;
        case "evm_revert":
          self.nonceCache = {};
          next();
          return;
        default:
          next();
          return;
      }
    };
  }
});

// node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js
var require_subscriptions = __commonJS({
  "node_modules/web3-provider-engine/dist/es5/subproviders/subscriptions.js"(exports, module) {
    init_define_process_env();
    "use strict";
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof2(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof = function _typeof2(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _createSuper(Derived) {
      return function() {
        var Super = _getPrototypeOf(Derived), result;
        if (_isNativeReflectConstruct()) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _possibleConstructorReturn(self, call) {
      if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized(self);
    }
    function _assertThisInitialized(self) {
      if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self;
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    var ProviderSubprovider = require_json_rpc_engine_middleware();
    var createSubscriptionManager = require_subscriptionManager();
    var SubscriptionsSubprovider2 = function(_ProviderSubprovider) {
      _inherits(SubscriptionsSubprovider3, _ProviderSubprovider);
      var _super = _createSuper(SubscriptionsSubprovider3);
      function SubscriptionsSubprovider3() {
        _classCallCheck(this, SubscriptionsSubprovider3);
        return _super.call(this, function(_ref) {
          var blockTracker = _ref.blockTracker, provider = _ref.provider, engine = _ref.engine;
          var _createSubscriptionMa = createSubscriptionManager({
            blockTracker,
            provider
          }), events = _createSubscriptionMa.events, middleware = _createSubscriptionMa.middleware;
          events.on("notification", function(data) {
            return engine.emit("data", null, data);
          });
          return middleware;
        });
      }
      return SubscriptionsSubprovider3;
    }(ProviderSubprovider);
    module.exports = SubscriptionsSubprovider2;
  }
});

// dep:@portis_web3
init_define_process_env();

// node_modules/@portis/web3/es/index.js
init_define_process_env();

// node_modules/@portis/web3/es/networks.js
init_define_process_env();
function networkAdapter(network, gasRelay) {
  var networkObj = typeof network === "string" ? Object.assign({}, networks[network]) : network;
  if (typeof networkObj !== "object") {
    throw new Error("[Portis] illegal 'network' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (!networkObj.nodeUrl) {
    throw new Error("[Portis] 'nodeUrl' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
  }
  if (gasRelay && !networkObj.gasRelayHubAddress) {
    throw new Error("[Portis] can't find default gas relay hub for " + network);
  }
  if (typeof network === "string" && !gasRelay) {
    delete networkObj.gasRelayHubAddress;
  }
  return networkObj;
}
var networks = {
  mainnet: {
    nodeUrl: "https://mainnet.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "1",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  ropsten: {
    nodeUrl: "https://ropsten.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "3",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  rinkeby: {
    nodeUrl: "https://rinkeby.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "4",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  goerli: {
    nodeUrl: "https://goerli.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "5"
  },
  ubiq: {
    nodeUrl: "https://rpc1.ubiqscan.io",
    chainId: "8"
  },
  thundercoreTestnet: {
    nodeUrl: "https://testnet-rpc.thundercore.com:8544",
    chainId: "18"
  },
  orchid: {
    nodeUrl: "https://public-node.rsk.co",
    chainId: "30"
  },
  orchidTestnet: {
    nodeUrl: "https://public-node.testnet.rsk.co",
    chainId: "31"
  },
  kovan: {
    nodeUrl: "https://kovan.infura.io/v3/faa4639b090f46499f29d894da0551a0",
    chainId: "42",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  classic: {
    nodeUrl: "https://ethereumclassic.network",
    chainId: "61"
  },
  sokol: {
    nodeUrl: "https://sokol.poa.network",
    chainId: "77"
  },
  core: {
    nodeUrl: "https://core.poa.network",
    chainId: "99"
  },
  xdai: {
    nodeUrl: "https://dai.poa.network",
    chainId: "100",
    gasRelayHubAddress: "0xD216153c06E857cD7f72665E0aF1d7D82172F494"
  },
  thundercore: {
    nodeUrl: "https://mainnet-rpc.thundercore.com",
    chainId: "108"
  },
  fuse: {
    nodeUrl: "https://rpc.fusenet.io",
    chainId: "122"
  },
  lightstreams: {
    nodeUrl: "https://node.mainnet.lightstreams.io",
    chainId: "163"
  },
  matic: {
    nodeUrl: "https://rpc-mainnet.matic.network",
    chainId: "137"
  },
  maticMumbai: {
    nodeUrl: "https://rpc-mumbai.matic.today",
    chainId: "80001"
  },
  maticAlpha: {
    nodeUrl: "https://alpha.ethereum.matic.network",
    chainId: "4626"
  },
  maticTestnet: {
    nodeUrl: "https://testnet2.matic.network",
    chainId: "8995"
  }
};

// node_modules/@portis/web3/es/utils/onWindowLoad.js
init_define_process_env();

// node_modules/@portis/web3/es/utils/isClientSide.js
init_define_process_env();
var isClientSide = function() {
  return !!(typeof window !== "undefined" && window.document);
};

// node_modules/@portis/web3/es/utils/onWindowLoad.js
var loaded = false;
function onWindowLoad() {
  return new Promise(function(resolve, reject) {
    if (!isClientSide()) {
      reject();
    } else if (loaded) {
      resolve();
    } else if (["loaded", "interactive", "complete"].indexOf(document.readyState) > -1) {
      loaded = true;
      resolve();
    } else {
      window.addEventListener("load", function() {
        loaded = true;
        resolve();
      }, false);
    }
  });
}

// node_modules/@portis/web3/es/utils/secureOrigin.js
init_define_process_env();
function validateSecureOrigin() {
  var isLocalhost = location.hostname === "localhost" || location.hostname === "127.0.0.1";
  var isSecureOrigin = location.protocol === "https:";
  var isSecure = isLocalhost || isSecureOrigin;
  if (!isSecure) {
    throw "[Portis] Access to the WebCrypto API is restricted to secure origins.\nIf this is a development environment please use http://localhost:" + location.port + " instead.\nOtherwise, please use an SSL certificate.";
  }
}

// node_modules/@portis/web3/es/widget/widgetManager.js
init_define_process_env();
var import_penpal = __toModule(require_lib2());

// node_modules/@portis/web3/es/styles.js
init_define_process_env();
var styles = "\n.por_portis-container {\n  position: fixed;\n  width: 0px;\n  height: 0px;\n  top: 0px;\n  right: 0px;\n  z-index: 2147483647;\n}\n\n@media (max-width: 576px) {\n  .por_portis-container {\n    bottom: 0;\n    top: auto;\n  }\n}\n\n.por_portis-widget-frame {\n  position: fixed;\n  width: 375px;\n  height: 0;\n  top: 20px;\n  right: 20px;\n  box-shadow: 0 5px 40px rgba(0,0,0,.16);\n  border-radius: 8px;\n  overflow: hidden;\n  z-index: 2147483000;\n}\n\n@media (max-width: 576px) {\n  .por_portis-widget-frame {\n    bottom: 0;\n    top: auto;\n    width: 100%;\n    right: 0;\n    left: 0;\n    border-bottom-left-radius: 0;\n    border-bottom-right-radius: 0;\n  }\n}\n";

// node_modules/@portis/web3/es/widget/widgetManager.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var WIDGET_URL = define_process_env_default.PORTIS_WIDGET_URL || "https://widget.portis.io";
var STAGING_WIDGET_URL = "https://widget-staging.portis.io";
var PORTIS_IFRAME_CLASS = "por_portis-widget-frame";
var PORTIS_CONTAINER_CLASS = "por_portis-container";
function windowLoadHandler() {
  if (document.getElementsByClassName(PORTIS_IFRAME_CLASS).length) {
    console.warn("Portis script was already loaded. This might cause unexpected behavior. If loading with a <script> tag, please make sure that you only load it once.");
  }
}
var WidgetManager = function() {
  function WidgetManager2(_widgetConfig, _clearProviderSession) {
    this._widgetConfig = _widgetConfig;
    this._clearProviderSession = _clearProviderSession;
    this._widgetUrl = WIDGET_URL;
    this._onLoginCallback = function() {
    };
    this._onLogoutCallback = function() {
    };
    this._onActiveWalletChangedCallback = function() {
    };
    this._onErrorCallback = function() {
    };
    validateSecureOrigin();
    if (_widgetConfig.staging) {
      console.warn("Please note: you are using the Portis STAGING environment.");
      this._widgetUrl = STAGING_WIDGET_URL;
    }
    WidgetManager2._checkIfWidgetAlreadyInitialized();
  }
  WidgetManager2.prototype.getWidget = function() {
    return __awaiter(this, void 0, void 0, function() {
      var _a2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            if (!!this.widgetInstance)
              return [3, 2];
            if (!this.widgetPromise) {
              this.widgetPromise = this._initWidget();
            }
            _a2 = this;
            return [4, this.widgetPromise];
          case 1:
            _a2.widgetInstance = _b.sent();
            _b.label = 2;
          case 2:
            return [2, this.widgetInstance];
        }
      });
    });
  };
  WidgetManager2.prototype.setDefaultEmail = function(email) {
    this._widgetConfig.defaultEmail = email;
  };
  WidgetManager2.prototype.setOnLoginCallback = function(callback) {
    this._onLoginCallback = callback;
  };
  WidgetManager2.prototype.setOnLogoutCallback = function(callback) {
    this._onLogoutCallback = callback;
  };
  WidgetManager2.prototype.setOnActiveWalletChangedCallback = function(callback) {
    this._onActiveWalletChangedCallback = callback;
  };
  WidgetManager2.prototype.setOnErrorCallback = function(callback) {
    this._onErrorCallback = callback;
  };
  WidgetManager2.prototype.showPortis = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showPortis(this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getCampaignInfo(campaignId)];
        }
      });
    });
  };
  WidgetManager2.prototype.claimVoucher = function(voucherId) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.claimVoucher(voucherId, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.logout = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.logout()];
        }
      });
    });
  };
  WidgetManager2.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.getExtendedPublicKey(path, coin, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.importWallet(mnemonicOrPrivateKey, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.isLoggedIn = function() {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.isLoggedIn()];
        }
      });
    });
  };
  WidgetManager2.prototype.signBitcoinTransaction = function(params) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.signBitcoinTransaction(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.showBitcoinWallet(path, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2.prototype.purchaseERC20 = function(params) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetCommunication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetCommunication = _a2.sent().communication;
            return [2, widgetCommunication.purchaseERC20(params, this._widgetConfig)];
        }
      });
    });
  };
  WidgetManager2._checkIfWidgetAlreadyInitialized = function() {
    if (document.getElementsByClassName(PORTIS_CONTAINER_CLASS).length) {
      console.warn("An instance of Portis was already initialized. This is probably a mistake. Make sure that you use the same Portis instance throughout your app.");
    }
  };
  WidgetManager2.prototype._initWidget = function() {
    return __awaiter(this, void 0, void 0, function() {
      var style, container, widgetFrame, connection, communication;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, onWindowLoad()];
          case 1:
            _a2.sent();
            style = document.createElement("style");
            style.innerHTML = styles;
            container = document.createElement("div");
            container.className = PORTIS_CONTAINER_CLASS;
            widgetFrame = document.createElement("div");
            widgetFrame.id = "portis-container-" + Date.now();
            widgetFrame.className = PORTIS_IFRAME_CLASS;
            container.appendChild(widgetFrame);
            document.body.appendChild(container);
            document.head.appendChild(style);
            connection = import_penpal.default.connectToChild({
              url: this._widgetUrl,
              appendTo: document.getElementById(widgetFrame.id),
              methods: {
                setHeight: this._setHeight.bind(this),
                getWindowSize: WidgetManager2._getWindowSize.bind(this),
                onLogin: this._onLogin.bind(this),
                onLogout: this._onLogout.bind(this),
                onActiveWalletChanged: this._onActiveWalletChanged.bind(this),
                onError: this._onError.bind(this)
              }
            });
            return [4, connection.promise];
          case 2:
            communication = _a2.sent();
            communication.setSdkConfig(this._widgetConfig);
            connection.iframe.style.position = "absolute";
            connection.iframe.style.height = "100%";
            connection.iframe.style.width = "100%";
            connection.iframe.style.border = "0 transparent";
            return [2, { communication, widgetFrame }];
        }
      });
    });
  };
  WidgetManager2.prototype._setHeight = function(height) {
    return __awaiter(this, void 0, void 0, function() {
      var widgetFrame;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this.getWidget()];
          case 1:
            widgetFrame = _a2.sent().widgetFrame;
            widgetFrame.style.height = height + "px";
            return [2];
        }
      });
    });
  };
  WidgetManager2._getWindowSize = function() {
    var body = document.getElementsByTagName("body")[0];
    var width = window.innerWidth || document.documentElement.clientWidth || body.clientWidth;
    var height = window.innerHeight || document.documentElement.clientHeight || body.clientHeight;
    return { width, height };
  };
  WidgetManager2.prototype._onLogin = function(walletAddress, email, reputation) {
    if (this._onLoginCallback) {
      this._onLoginCallback(walletAddress, email, reputation);
    }
  };
  WidgetManager2.prototype._onLogout = function() {
    this._clearProviderSession();
    if (this._onLogoutCallback) {
      this._onLogoutCallback();
    }
  };
  WidgetManager2.prototype._onActiveWalletChanged = function(walletAddress) {
    if (this._onActiveWalletChangedCallback) {
      this._onActiveWalletChangedCallback(walletAddress);
    }
  };
  WidgetManager2.prototype._onError = function(error) {
    if (this._onErrorCallback) {
      this._onErrorCallback(error);
    }
  };
  return WidgetManager2;
}();
var widgetManager_default = WidgetManager;

// node_modules/@portis/web3/es/web3/web3Manager.js
init_define_process_env();

// node_modules/@portis/web3/es/utils/getTxGas.js
init_define_process_env();
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator2 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var _a = require_dist3();
var addHexPrefix = _a.addHexPrefix;
var stripHexPrefix = _a.stripHexPrefix;
var BN = _a.BN;
var SIMPLE_GAS_COST = "0x5208";
function getTxGas(query, txParams) {
  return __awaiter2(this, void 0, void 0, function() {
    var block, _a2, safeGas, simpleSend, gasLimitSpecified, gas, error_1;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, query.getBlockByNumber("latest", false)];
        case 1:
          block = _b.sent();
          return [4, safeTxGas(query, txParams, block.gasLimit)];
        case 2:
          _a2 = _b.sent(), safeGas = _a2.safeGas, simpleSend = _a2.simpleSend, gasLimitSpecified = _a2.gasLimitSpecified;
          if (simpleSend || gasLimitSpecified) {
            return [2, safeGas];
          }
          _b.label = 3;
        case 3:
          _b.trys.push([3, 5, , 6]);
          return [4, estimateTxGas(query, txParams, block.gasLimit, safeGas)];
        case 4:
          gas = _b.sent();
          return [2, gas];
        case 5:
          error_1 = _b.sent();
          return [2, safeGas];
        case 6:
          return [2];
      }
    });
  });
}
function safeTxGas(query, txParams, blockGasLimitHex) {
  return __awaiter2(this, void 0, void 0, function() {
    var gasLimitSpecified, recipient, hasRecipient, code, codeIsEmpty, err, blockGasLimitBN, saferGasLimitBN;
    return __generator2(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          gasLimitSpecified = Boolean(txParams.gas);
          if (gasLimitSpecified) {
            return [2, { safeGas: txParams.gas, simpleSend: false, gasLimitSpecified: true }];
          }
          recipient = txParams.to;
          hasRecipient = Boolean(recipient);
          if (!hasRecipient)
            return [3, 2];
          return [4, query.getCode(recipient)];
        case 1:
          code = _a2.sent();
          codeIsEmpty = !code || code === "0x" || code === "0x0";
          if (codeIsEmpty) {
            if (txParams.data) {
              err = new Error("Trying to call a function on a non-contract address");
              throw err;
            }
            return [2, { safeGas: SIMPLE_GAS_COST, simpleSend: true, gasLimitSpecified: false }];
          }
          _a2.label = 2;
        case 2:
          blockGasLimitBN = hexToBn(blockGasLimitHex);
          saferGasLimitBN = BnMultiplyByFraction(blockGasLimitBN, 19, 20);
          return [2, { safeGas: bnToHex(saferGasLimitBN), simpleSend: false, gasLimitSpecified: false }];
      }
    });
  });
}
function estimateTxGas(query, txParams, blockGasLimitHex, safeGas) {
  return __awaiter2(this, void 0, void 0, function() {
    var estimatedGas, _a2;
    return __generator2(this, function(_b) {
      switch (_b.label) {
        case 0:
          txParams.gas = safeGas;
          _a2 = addHexPrefix;
          return [4, query.estimateGas(txParams)];
        case 1:
          estimatedGas = _a2.apply(void 0, [_b.sent()]);
          return [2, addGasBuffer(estimatedGas, blockGasLimitHex)];
      }
    });
  });
}
function addGasBuffer(initialGasLimitHex, blockGasLimitHex) {
  var initialGasLimitBn = hexToBn(initialGasLimitHex);
  var blockGasLimitBn = hexToBn(blockGasLimitHex);
  var upperGasLimitBn = blockGasLimitBn.muln(0.9);
  var bufferedGasLimitBn = initialGasLimitBn.muln(1.5);
  if (initialGasLimitBn.gt(upperGasLimitBn))
    return bnToHex(initialGasLimitBn);
  if (bufferedGasLimitBn.lt(upperGasLimitBn))
    return bnToHex(bufferedGasLimitBn);
  return bnToHex(upperGasLimitBn);
}
function hexToBn(inputHex) {
  return new BN(stripHexPrefix(inputHex), 16);
}
function bnToHex(inputBn) {
  return addHexPrefix(inputBn.toString(16));
}
function BnMultiplyByFraction(targetBN, numerator, denominator) {
  var numBN = new BN(numerator);
  var denomBN = new BN(denominator);
  return targetBN.mul(numBN).div(denomBN);
}

// node_modules/@portis/web3/es/utils/query.js
init_define_process_env();
var Query = function() {
  function Query2(provider) {
    this.provider = provider;
  }
  Query2.prototype.getBlockByNumber = function(blockNumber, fullTransaction) {
    return this.sendAsync("eth_getBlockByNumber", blockNumber, fullTransaction);
  };
  Query2.prototype.getCode = function(address, blockNumber) {
    if (blockNumber === void 0) {
      blockNumber = "latest";
    }
    return this.sendAsync("eth_getCode", address, blockNumber);
  };
  Query2.prototype.estimateGas = function(txParams) {
    return this.sendAsync("eth_estimateGas", txParams);
  };
  Query2.prototype.sendAsync = function(methodName) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    return new Promise(function(resolve, reject) {
      _this.provider.sendAsync({
        id: 42,
        jsonrpc: "2.0",
        method: methodName,
        params: args
      }, function(error, response) {
        if (error) {
          reject(error);
        } else {
          resolve(response.result);
        }
      });
    });
  };
  return Query2;
}();

// node_modules/@portis/web3/es/web3/web3Manager.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator3 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var ProviderEngine = require_web3_provider_engine();
var CacheSubprovider = require_cache();
var FixtureSubprovider = require_fixture();
var FilterSubprovider = require_filters();
var HookedWalletSubprovider = require_hooked_wallet();
var NonceSubprovider = require_nonce_tracker();
var SubscriptionsSubprovider = require_subscriptions();
var Web3Manager = function() {
  function Web3Manager2(config, _getWidgetCommunication) {
    this.config = config;
    this._getWidgetCommunication = _getWidgetCommunication;
    this.provider = this._initProvider();
  }
  Web3Manager2.prototype.setSelectedAddress = function(selectedAddress) {
    this._selectedAddress = selectedAddress;
  };
  Web3Manager2.prototype.changeNetwork = function(network, gasRelay) {
    var newNetwork = networkAdapter(network, gasRelay);
    this.clearSubprovider(NonceSubprovider);
    this.clearSubprovider(CacheSubprovider);
    this.config.network = newNetwork;
  };
  Web3Manager2.prototype._initProvider = function() {
    var _this = this;
    if (this.engine) {
      return this.engine;
    }
    this.engine = new ProviderEngine();
    var query = new Query(this.engine);
    this.engine.send = function(payload, callback) {
      if (typeof payload === "string") {
        return new Promise(function(resolve, reject) {
          _this.engine.sendAsync({
            jsonrpc: "2.0",
            id: 42,
            method: payload,
            params: callback || []
          }, function(error, response) {
            if (error) {
              reject(error);
            } else {
              resolve(response.result);
            }
          });
        });
      }
      if (callback) {
        _this.engine.sendAsync(payload, callback);
        return;
      }
      var result = null;
      switch (payload.method) {
        case "eth_accounts":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "eth_coinbase":
          result = _this._selectedAddress ? [_this._selectedAddress] : [];
          break;
        case "net_version":
          result = _this._network;
          break;
        case "eth_uninstallFilter":
          _this.engine.sendAsync(payload, function(_) {
            return _;
          });
          result = true;
          break;
        default:
          var message = "The Portis Web3 object does not support synchronous methods like " + payload.method + " without a callback parameter.";
          throw new Error(message);
      }
      return {
        id: payload.id,
        jsonrpc: payload.jsonrpc,
        result
      };
    };
    this.engine.addProvider(new FixtureSubprovider({
      web3_clientVersion: "Portis/v" + this.config.version + "/javascript",
      net_listening: true,
      eth_hashrate: "0x00",
      eth_mining: false,
      eth_syncing: true
    }));
    this.engine.addProvider(new CacheSubprovider());
    this.engine.addProvider(new SubscriptionsSubprovider());
    this.engine.addProvider(new FilterSubprovider());
    this.engine.addProvider(new NonceSubprovider());
    this.engine.addProvider({
      setEngine: function(_) {
        return _;
      },
      handleRequest: function(payload, next) {
        return __awaiter3(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            if (!payload.id) {
              payload.id = 42;
            }
            next();
            return [2];
          });
        });
      }
    });
    this.engine.addProvider(new HookedWalletSubprovider({
      getAccounts: function(cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.getAccounts(this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (!error && result) {
                  this._selectedAddress = result[0];
                }
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTransaction: function(txParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.signTransaction(txParams, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signPersonalMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signPersonalMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessage: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessage" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      signTypedMessageV3: function(msgParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, params, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                params = __assign({}, msgParams, { messageStandard: "signTypedMessageV3" });
                return [4, widgetCommunication.signMessage(params, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                cb(error, result);
                return [2];
            }
          });
        });
      },
      estimateGas: function(txParams, cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          var gas;
          return __generator3(this, function(_a2) {
            switch (_a2.label) {
              case 0:
                return [4, getTxGas(query, txParams)];
              case 1:
                gas = _a2.sent();
                cb(null, gas);
                return [2];
            }
          });
        });
      },
      getGasPrice: function(cb) {
        return __awaiter3(_this, void 0, void 0, function() {
          return __generator3(this, function(_a2) {
            cb(null, "");
            return [2];
          });
        });
      }
    }));
    this.engine.addProvider({
      setEngine: function(_) {
        return _;
      },
      handleRequest: function(payload, next, end) {
        return __awaiter3(_this, void 0, void 0, function() {
          var widgetCommunication, _a2, error, result;
          return __generator3(this, function(_b) {
            switch (_b.label) {
              case 0:
                return [4, this._getWidgetCommunication()];
              case 1:
                widgetCommunication = _b.sent();
                return [4, widgetCommunication.relay(payload, this.config)];
              case 2:
                _a2 = _b.sent(), error = _a2.error, result = _a2.result;
                if (payload.method === "net_version") {
                  this._network = result;
                  this.engine.networkVersion = this._network;
                }
                end(error, result);
                return [2];
            }
          });
        });
      }
    });
    this.engine.enable = function() {
      return new Promise(function(resolve, reject) {
        _this.engine.sendAsync({ method: "eth_accounts" }, function(error, response) {
          if (error) {
            reject(error);
          } else {
            resolve(response.result);
          }
        });
      });
    };
    this.engine.isConnected = function() {
      return true;
    };
    this.engine.isPortis = true;
    this.engine.on("error", function(error) {
      if (error && error.message && error.message.includes("PollingBlockTracker")) {
        console.warn("If you see this warning constantly, there might be an error with your RPC node.");
      } else {
        console.error(error);
      }
    });
    this.engine.start();
    return this.engine;
  };
  Web3Manager2.prototype.clearSubprovider = function(subproviderType) {
    var subprovider = this.provider._providers.find(function(subprovider2) {
      return subprovider2 instanceof subproviderType;
    });
    this.provider.removeProvider(subprovider);
    this.provider.addProvider(new subproviderType());
  };
  return Web3Manager2;
}();
var web3Manager_default = Web3Manager;

// node_modules/@portis/web3/es/utils/mockify.js
init_define_process_env();
var mockify = function(obj) {
  return new Proxy(obj, {
    get: function(target, prop) {
      if (target[prop] instanceof Function) {
        return function() {
        };
      } else {
        return void 0;
      }
    }
  });
};

// node_modules/@portis/web3/es/index.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : new P(function(resolve2) {
        resolve2(result.value);
      }).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __generator4 = function(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
};
var VERSION = "4.1.0";
var SUPPORTED_SCOPES = ["email", "reputation"];
onWindowLoad().then(windowLoadHandler).catch(function() {
});
var Portis = function() {
  function Portis2(dappId, network, options) {
    if (options === void 0) {
      options = {};
    }
    if (!isClientSide()) {
      return mockify(this);
    }
    validateSecureOrigin();
    this._validateParams(dappId, network, options);
    this._config = {
      dappId,
      network: networkAdapter(network, options.gasRelay),
      version: VERSION,
      scope: options.scope,
      registerPageByDefault: options.registerPageByDefault,
      staging: options.staging
    };
    this._getWidgetCommunication = this._getWidgetCommunication.bind(this);
    this._widgetManagerInstance = new widgetManager_default(this.config, this._clearProviderSession);
    this._web3ManagerInstance = new web3Manager_default(this.config, this._getWidgetCommunication);
    this.setDefaultEmail = this.setDefaultEmail.bind(this);
    this.changeNetwork = this.changeNetwork.bind(this);
    this.getWidget = this.getWidget.bind(this);
    this.onLogin = this.onLogin.bind(this);
    this.onLogout = this.onLogout.bind(this);
    this.onActiveWalletChanged = this.onActiveWalletChanged.bind(this);
    this.onError = this.onError.bind(this);
    this.showPortis = this.showPortis.bind(this);
    this.getCampaignInfo = this.getCampaignInfo.bind(this);
    this.claimVoucher = this.claimVoucher.bind(this);
    this.getExtendedPublicKey = this.getExtendedPublicKey.bind(this);
    this.importWallet = this.importWallet.bind(this);
    this.isLoggedIn = this.isLoggedIn.bind(this);
    this.signBitcoinTransaction = this.signBitcoinTransaction.bind(this);
    this.showBitcoinWallet = this.showBitcoinWallet.bind(this);
    this.purchaseERC20 = this.purchaseERC20.bind(this);
  }
  Object.defineProperty(Portis2.prototype, "_widgetManager", {
    get: function() {
      return this._widgetManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "_web3Manager", {
    get: function() {
      return this._web3ManagerInstance;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "config", {
    get: function() {
      return this._config;
    },
    enumerable: true,
    configurable: true
  });
  Portis2.prototype._clearProviderSession = function() {
    this._web3Manager.setSelectedAddress("");
  };
  Portis2.prototype._getWidgetCommunication = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            return [4, this._widgetManager.getWidget()];
          case 1:
            return [2, _a2.sent().communication];
        }
      });
    });
  };
  Object.defineProperty(Portis2.prototype, "web3Provider", {
    get: function() {
      return this._web3Manager.provider;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(Portis2.prototype, "provider", {
    get: function() {
      return this.web3Provider;
    },
    enumerable: true,
    configurable: true
  });
  Portis2.prototype.changeNetwork = function(network, gasRelay) {
    this._web3Manager.changeNetwork(network, gasRelay);
  };
  Portis2.prototype.setDefaultEmail = function(email) {
    this._widgetManager.setDefaultEmail(email);
  };
  Portis2.prototype.getWidget = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getWidget()];
      });
    });
  };
  Portis2.prototype.onLogin = function(callback) {
    this._widgetManager.setOnLoginCallback(callback);
  };
  Portis2.prototype.onLogout = function(callback) {
    this._widgetManager.setOnLogoutCallback(callback);
  };
  Portis2.prototype.onActiveWalletChanged = function(callback) {
    this._widgetManager.setOnActiveWalletChangedCallback(callback);
  };
  Portis2.prototype.onError = function(callback) {
    this._widgetManager.setOnErrorCallback(callback);
  };
  Portis2.prototype.showPortis = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showPortis()];
      });
    });
  };
  Portis2.prototype.getCampaignInfo = function(campaignId) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getCampaignInfo(campaignId)];
      });
    });
  };
  Portis2.prototype.claimVoucher = function(voucherId) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.claimVoucher(voucherId)];
      });
    });
  };
  Portis2.prototype.logout = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.logout()];
      });
    });
  };
  Portis2.prototype.getExtendedPublicKey = function(path, coin) {
    if (path === void 0) {
      path = "m/44'/60'/0'/0/0";
    }
    if (coin === void 0) {
      coin = "Ethereum";
    }
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.getExtendedPublicKey(path, coin)];
      });
    });
  };
  Portis2.prototype.importWallet = function(mnemonicOrPrivateKey) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.importWallet(mnemonicOrPrivateKey)];
      });
    });
  };
  Portis2.prototype.isLoggedIn = function() {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.isLoggedIn()];
      });
    });
  };
  Portis2.prototype.signBitcoinTransaction = function(params) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.signBitcoinTransaction(params)];
      });
    });
  };
  Portis2.prototype.showBitcoinWallet = function(path) {
    if (path === void 0) {
      path = "m/49'/0'/0'/0/0";
    }
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.showBitcoinWallet(path)];
      });
    });
  };
  Portis2.prototype.purchaseERC20 = function(tokenAddress, amount, tokenSymbol, logoURL) {
    return __awaiter4(this, void 0, void 0, function() {
      return __generator4(this, function(_a2) {
        return [2, this._widgetManager.purchaseERC20({ tokenAddress, amount, tokenSymbol, logoURL })];
      });
    });
  };
  Portis2.prototype._validateParams = function(dappId, network, options) {
    if (!dappId) {
      throw new Error("[Portis] 'dappId' is required. Get your dappId here: https://dashboard.portis.io");
    }
    if (!network) {
      throw new Error("[Portis] 'network' is required. Read more about it here: https://docs.portis.io/#/configuration?id=network");
    }
    if (options.scope) {
      if (!Array.isArray(options.scope)) {
        throw new Error("[Portis] 'scope' must be an array. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
      var unknownScope = options.scope.filter(function(item) {
        return SUPPORTED_SCOPES.indexOf(item) < 0;
      });
      if (unknownScope.length > 0) {
        throw new Error("[Portis] invalid 'scope' parameter. Read more about it here: https://docs.portis.io/#/configuration?id=scope");
      }
    }
    if (options.registerPageByDefault !== void 0 && typeof options.registerPageByDefault !== "boolean") {
      throw new Error("[Portis] invalid 'registerPageByDefault' parameter, must be a boolean. Read more about it here: https://docs.portis.io/#/configuration?id=registerPageByDefault");
    }
  };
  return Portis2;
}();
var es_default = Portis;

// dep:@portis_web3
var portis_web3_default = es_default;
export {
  portis_web3_default as default
};
//# sourceMappingURL=@portis_web3.js.map
