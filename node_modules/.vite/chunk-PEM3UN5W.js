import {
  isEthersProvider
} from "./chunk-GRADH3LD.js";
import {
  utils_exports
} from "./chunk-B5PQFD23.js";
import {
  StaticJsonRpcProvider,
  Web3Provider,
  keccak256
} from "./chunk-LSYLA56E.js";
import {
  BigNumber,
  arrayify
} from "./chunk-SVV6QRWF.js";
import {
  require_dist
} from "./chunk-QHVLCMC5.js";
import {
  tiny_invariant_esm_default,
  tiny_warning_esm_default
} from "./chunk-53OEHZQQ.js";
import {
  require_events
} from "./chunk-2RX4YWIV.js";
import {
  React,
  __objRest,
  __spreadProps,
  __spreadValues
} from "./chunk-TCPLS2ND.js";
import {
  require_react
} from "./chunk-VTKEAFCW.js";
import {
  __toModule
} from "./chunk-MDAI7X5T.js";

// node_modules/eth-hooks/chunk-SZO3HXET.js
var import_react25 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useBoolean/useBoolean.js
var import_react = __toModule(require_react());

// node_modules/usehooks-ts/esm/useCopyToClipboard/useCopyToClipboard.js
var import_react2 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useCounter/useCounter.js
var import_react3 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useDarkMode/useDarkMode.js
var import_react5 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useLocalStorage/useLocalStorage.js
var import_react4 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useDebounce/useDebounce.js
var import_react6 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useElementSize/useElementSize.js
var import_react8 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useEventListener/useEventListener.js
var import_react7 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useFetch/useFetch.js
var import_react9 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useHover/useHover.js
var import_react10 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useImageOnLoad/useImageOnLoad.js
var import_react11 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useIntersectionObserver/useIntersectionObserver.js
var import_react12 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useInterval/useInterval.js
var import_react13 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useIsClient/useIsClient.js
var import_react14 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useIsMounted/useIsMounted.js
var import_react15 = __toModule(require_react());
function useIsMounted() {
  var isMounted = (0, import_react15.useRef)(false);
  (0, import_react15.useEffect)(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  return (0, import_react15.useCallback)(function() {
    return isMounted.current;
  }, []);
}
var useIsMounted_default = useIsMounted;

// node_modules/usehooks-ts/esm/useLockedBody/useLockedBody.js
var import_react16 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useMap/useMap.js
var import_react17 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useOnClickOutside/useOnClickOutside.js
var import_react18 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useReadLocalStorage/useReadLocalStorage.js
var import_react19 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useScreen/useScreen.js
var import_react20 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useScript/useScript.js
var import_react21 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useTimeout/useTimeout.js
var import_react22 = __toModule(require_react());

// node_modules/usehooks-ts/esm/useWindowSize/useWindowSize.js
var import_react23 = __toModule(require_react());

// node_modules/@web3-react/abstract-connector/dist/abstract-connector.esm.js
var import_events = __toModule(require_events());

// node_modules/@web3-react/types/dist/types.esm.js
var ConnectorEvent;
(function(ConnectorEvent2) {
  ConnectorEvent2["Update"] = "Web3ReactUpdate";
  ConnectorEvent2["Error"] = "Web3ReactError";
  ConnectorEvent2["Deactivate"] = "Web3ReactDeactivate";
})(ConnectorEvent || (ConnectorEvent = {}));

// node_modules/@web3-react/abstract-connector/dist/abstract-connector.esm.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
var AbstractConnector = function(_EventEmitter) {
  _inheritsLoose(AbstractConnector2, _EventEmitter);
  function AbstractConnector2(_temp) {
    var _this;
    var _ref = _temp === void 0 ? {} : _temp, supportedChainIds = _ref.supportedChainIds;
    _this = _EventEmitter.call(this) || this;
    _this.supportedChainIds = supportedChainIds;
    return _this;
  }
  var _proto = AbstractConnector2.prototype;
  _proto.emitUpdate = function emitUpdate(update) {
    if (true) {
      console.log("Emitting '" + ConnectorEvent.Update + "' with payload", update);
    }
    this.emit(ConnectorEvent.Update, update);
  };
  _proto.emitError = function emitError(error) {
    if (true) {
      console.log("Emitting '" + ConnectorEvent.Error + "' with payload", error);
    }
    this.emit(ConnectorEvent.Error, error);
  };
  _proto.emitDeactivate = function emitDeactivate() {
    if (true) {
      console.log("Emitting '" + ConnectorEvent.Deactivate + "'");
    }
    this.emit(ConnectorEvent.Deactivate);
  };
  return AbstractConnector2;
}(import_events.EventEmitter);

// node_modules/eth-hooks/node_modules/@web3-react/core/dist/core.esm.js
var import_react24 = __toModule(require_react());
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
var _iteratorSymbol = typeof Symbol !== "undefined" ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";
var _asyncIteratorSymbol = typeof Symbol !== "undefined" ? Symbol.asyncIterator || (Symbol.asyncIterator = Symbol("Symbol.asyncIterator")) : "@@asyncIterator";
function _catch(body, recover) {
  try {
    var result = body();
  } catch (e) {
    return recover(e);
  }
  if (result && result.then) {
    return result.then(void 0, recover);
  }
  return result;
}
function normalizeChainId(chainId) {
  if (typeof chainId === "string") {
    chainId = chainId.replace(/^Ox/, "0x");
    var parsedChainId = Number.parseInt(chainId, chainId.trim().substring(0, 2) === "0x" ? 16 : 10);
    !!Number.isNaN(parsedChainId) ? true ? tiny_invariant_esm_default(false, "chainId " + chainId + " is not an integer") : tiny_invariant_esm_default(false) : void 0;
    return parsedChainId;
  } else {
    !Number.isInteger(chainId) ? true ? tiny_invariant_esm_default(false, "chainId " + chainId + " is not an integer") : tiny_invariant_esm_default(false) : void 0;
    return chainId;
  }
}
function normalizeAccount(_address) {
  !(typeof _address === "string" && _address.match(/^(0x)?[0-9a-fA-F]{40}$/)) ? true ? tiny_invariant_esm_default(false, "Invalid address " + _address) : tiny_invariant_esm_default(false) : void 0;
  var address = _address.substring(0, 2) === "0x" ? _address : "0x" + _address;
  var chars = address.toLowerCase().substring(2).split("");
  var charsArray = new Uint8Array(40);
  for (var i = 0; i < 40; i++) {
    charsArray[i] = chars[i].charCodeAt(0);
  }
  var hashed = arrayify(keccak256(charsArray));
  for (var _i = 0; _i < 40; _i += 2) {
    if (hashed[_i >> 1] >> 4 >= 8) {
      chars[_i] = chars[_i].toUpperCase();
    }
    if ((hashed[_i >> 1] & 15) >= 8) {
      chars[_i + 1] = chars[_i + 1].toUpperCase();
    }
  }
  var addressChecksum = "0x" + chars.join("");
  !!(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && address !== addressChecksum) ? true ? tiny_invariant_esm_default(false, "Bad address checksum " + address + " " + addressChecksum) : tiny_invariant_esm_default(false) : void 0;
  return addressChecksum;
}
var augmentConnectorUpdate = function augmentConnectorUpdate2(connector, update) {
  try {
    var _temp3 = function _temp32(provider) {
      return Promise.resolve(Promise.all([update.chainId === void 0 ? connector.getChainId() : update.chainId, update.account === void 0 ? connector.getAccount() : update.account])).then(function(_ref2) {
        var _chainId = _ref2[0], _account = _ref2[1];
        var chainId = normalizeChainId(_chainId);
        if (!!connector.supportedChainIds && !connector.supportedChainIds.includes(chainId)) {
          throw new UnsupportedChainIdError(chainId, connector.supportedChainIds);
        }
        var account = _account === null ? _account : normalizeAccount(_account);
        return {
          provider,
          chainId,
          account
        };
      });
    };
    var _temp4 = update.provider === void 0;
    return Promise.resolve(_temp4 ? Promise.resolve(connector.getProvider()).then(_temp3) : _temp3(update.provider));
  } catch (e) {
    return Promise.reject(e);
  }
};
var StaleConnectorError = function(_Error) {
  _inheritsLoose2(StaleConnectorError2, _Error);
  function StaleConnectorError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.name = _this.constructor.name;
    return _this;
  }
  return StaleConnectorError2;
}(_wrapNativeSuper(Error));
var UnsupportedChainIdError = function(_Error2) {
  _inheritsLoose2(UnsupportedChainIdError2, _Error2);
  function UnsupportedChainIdError2(unsupportedChainId, supportedChainIds) {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.name = _this2.constructor.name;
    _this2.message = "Unsupported chain id: " + unsupportedChainId + ". Supported chain ids are: " + supportedChainIds + ".";
    return _this2;
  }
  return UnsupportedChainIdError2;
}(_wrapNativeSuper(Error));
var ActionType;
(function(ActionType2) {
  ActionType2[ActionType2["ACTIVATE_CONNECTOR"] = 0] = "ACTIVATE_CONNECTOR";
  ActionType2[ActionType2["UPDATE"] = 1] = "UPDATE";
  ActionType2[ActionType2["UPDATE_FROM_ERROR"] = 2] = "UPDATE_FROM_ERROR";
  ActionType2[ActionType2["ERROR"] = 3] = "ERROR";
  ActionType2[ActionType2["ERROR_FROM_ACTIVATION"] = 4] = "ERROR_FROM_ACTIVATION";
  ActionType2[ActionType2["DEACTIVATE_CONNECTOR"] = 5] = "DEACTIVATE_CONNECTOR";
})(ActionType || (ActionType = {}));
function reducer(state, _ref) {
  var type = _ref.type, payload = _ref.payload;
  switch (type) {
    case ActionType.ACTIVATE_CONNECTOR: {
      var connector = payload.connector, provider = payload.provider, chainId = payload.chainId, account = payload.account, onError = payload.onError;
      return {
        connector,
        provider,
        chainId,
        account,
        onError
      };
    }
    case ActionType.UPDATE: {
      var _provider = payload.provider, _chainId2 = payload.chainId, _account2 = payload.account;
      return _extends({}, state, _provider === void 0 ? {} : {
        provider: _provider
      }, _chainId2 === void 0 ? {} : {
        chainId: _chainId2
      }, _account2 === void 0 ? {} : {
        account: _account2
      });
    }
    case ActionType.UPDATE_FROM_ERROR: {
      var _provider2 = payload.provider, _chainId3 = payload.chainId, _account3 = payload.account;
      return _extends({}, state, _provider2 === void 0 ? {} : {
        provider: _provider2
      }, _chainId3 === void 0 ? {} : {
        chainId: _chainId3
      }, _account3 === void 0 ? {} : {
        account: _account3
      }, {
        error: void 0
      });
    }
    case ActionType.ERROR: {
      var error = payload.error;
      var _connector = state.connector, _onError = state.onError;
      return {
        connector: _connector,
        error,
        onError: _onError
      };
    }
    case ActionType.ERROR_FROM_ACTIVATION: {
      var _connector2 = payload.connector, _error = payload.error;
      return {
        connector: _connector2,
        error: _error
      };
    }
    case ActionType.DEACTIVATE_CONNECTOR: {
      return {};
    }
  }
}
function useWeb3ReactManager() {
  var _useReducer = (0, import_react24.useReducer)(reducer, {}), state = _useReducer[0], dispatch = _useReducer[1];
  var connector = state.connector, provider = state.provider, chainId = state.chainId, account = state.account, onError = state.onError, error = state.error;
  var updateBusterRef = (0, import_react24.useRef)(-1);
  updateBusterRef.current += 1;
  var activate = (0, import_react24.useCallback)(function(connector2, onError2, throwErrors) {
    if (throwErrors === void 0) {
      throwErrors = false;
    }
    try {
      var updateBusterInitial = updateBusterRef.current;
      var activated = false;
      return Promise.resolve(_catch(function() {
        return Promise.resolve(connector2.activate().then(function(update) {
          activated = true;
          return update;
        })).then(function(update) {
          return Promise.resolve(augmentConnectorUpdate(connector2, update)).then(function(augmentedUpdate) {
            if (updateBusterRef.current > updateBusterInitial) {
              throw new StaleConnectorError();
            }
            dispatch({
              type: ActionType.ACTIVATE_CONNECTOR,
              payload: _extends({
                connector: connector2
              }, augmentedUpdate, {
                onError: onError2
              })
            });
          });
        });
      }, function(error2) {
        if (error2 instanceof StaleConnectorError) {
          activated && connector2.deactivate();
          true ? tiny_warning_esm_default(false, "Suppressed stale connector activation " + connector2) : void 0;
        } else if (throwErrors) {
          activated && connector2.deactivate();
          throw error2;
        } else if (onError2) {
          activated && connector2.deactivate();
          onError2(error2);
        } else {
          dispatch({
            type: ActionType.ERROR_FROM_ACTIVATION,
            payload: {
              connector: connector2,
              error: error2
            }
          });
        }
      }));
    } catch (e) {
      return Promise.reject(e);
    }
  }, []);
  var setError = (0, import_react24.useCallback)(function(error2) {
    dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, []);
  var deactivate = (0, import_react24.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  var handleUpdate = (0, import_react24.useCallback)(function(update) {
    try {
      if (!connector) {
        throw Error("This should never happen, it's just so Typescript stops complaining");
      }
      var updateBusterInitial = updateBusterRef.current;
      return Promise.resolve(function() {
        if (!error) {
          var _chainId4 = update.chainId === void 0 ? void 0 : normalizeChainId(update.chainId);
          if (_chainId4 !== void 0 && !!connector.supportedChainIds && !connector.supportedChainIds.includes(_chainId4)) {
            var _error2 = new UnsupportedChainIdError(_chainId4, connector.supportedChainIds);
            onError ? onError(_error2) : dispatch({
              type: ActionType.ERROR,
              payload: {
                error: _error2
              }
            });
          } else {
            var _account4 = typeof update.account === "string" ? normalizeAccount(update.account) : update.account;
            dispatch({
              type: ActionType.UPDATE,
              payload: {
                provider: update.provider,
                chainId: _chainId4,
                account: _account4
              }
            });
          }
        } else {
          return _catch(function() {
            return Promise.resolve(augmentConnectorUpdate(connector, update)).then(function(augmentedUpdate) {
              if (updateBusterRef.current > updateBusterInitial) {
                throw new StaleConnectorError();
              }
              dispatch({
                type: ActionType.UPDATE_FROM_ERROR,
                payload: augmentedUpdate
              });
            });
          }, function(error2) {
            if (error2 instanceof StaleConnectorError) {
              true ? tiny_warning_esm_default(false, "Suppressed stale connector update from error state " + connector + " " + update) : void 0;
            } else {
              onError ? onError(error2) : dispatch({
                type: ActionType.ERROR,
                payload: {
                  error: error2
                }
              });
            }
          });
        }
      }());
    } catch (e) {
      return Promise.reject(e);
    }
  }, [connector, error, onError]);
  var handleError = (0, import_react24.useCallback)(function(error2) {
    onError ? onError(error2) : dispatch({
      type: ActionType.ERROR,
      payload: {
        error: error2
      }
    });
  }, [onError]);
  var handleDeactivate = (0, import_react24.useCallback)(function() {
    dispatch({
      type: ActionType.DEACTIVATE_CONNECTOR
    });
  }, []);
  (0, import_react24.useEffect)(function() {
    return function() {
      if (connector) {
        connector.deactivate();
      }
    };
  }, [connector]);
  (0, import_react24.useEffect)(function() {
    if (connector) {
      connector.on(ConnectorEvent.Update, handleUpdate).on(ConnectorEvent.Error, handleError).on(ConnectorEvent.Deactivate, handleDeactivate);
    }
    return function() {
      if (connector) {
        connector.off(ConnectorEvent.Update, handleUpdate).off(ConnectorEvent.Error, handleError).off(ConnectorEvent.Deactivate, handleDeactivate);
      }
    };
  }, [connector, handleUpdate, handleError, handleDeactivate]);
  return {
    connector,
    provider,
    chainId,
    account,
    activate,
    setError,
    deactivate,
    error
  };
}
var PRIMARY_KEY = "primary";
var CONTEXTS = {};
function createWeb3ReactRoot(key) {
  !!CONTEXTS[key] ? true ? tiny_invariant_esm_default(false, "A root already exists for provided key " + key) : tiny_invariant_esm_default(false) : void 0;
  CONTEXTS[key] = (0, import_react24.createContext)({
    activate: function() {
      try {
        true ? true ? tiny_invariant_esm_default(false, "No <Web3ReactProvider ... /> found.") : tiny_invariant_esm_default(false) : void 0;
        return Promise.resolve();
      } catch (e) {
        return Promise.reject(e);
      }
    },
    setError: function setError() {
      true ? tiny_invariant_esm_default(false, "No <Web3ReactProvider ... /> found.") : tiny_invariant_esm_default(false);
    },
    deactivate: function deactivate() {
      true ? tiny_invariant_esm_default(false, "No <Web3ReactProvider ... /> found.") : tiny_invariant_esm_default(false);
    },
    active: false
  });
  CONTEXTS[key].displayName = "Web3ReactContext - " + key;
  var Provider = CONTEXTS[key].Provider;
  return function Web3ReactProvider2(_ref) {
    var getLibrary = _ref.getLibrary, children = _ref.children;
    var _useWeb3ReactManager = useWeb3ReactManager(), connector = _useWeb3ReactManager.connector, provider = _useWeb3ReactManager.provider, chainId = _useWeb3ReactManager.chainId, account = _useWeb3ReactManager.account, activate = _useWeb3ReactManager.activate, setError = _useWeb3ReactManager.setError, deactivate = _useWeb3ReactManager.deactivate, error = _useWeb3ReactManager.error;
    var active = connector !== void 0 && chainId !== void 0 && account !== void 0 && !!!error;
    var library = (0, import_react24.useMemo)(function() {
      return active && chainId !== void 0 && Number.isInteger(chainId) && !!connector ? getLibrary(provider, connector) : void 0;
    }, [active, getLibrary, provider, connector, chainId]);
    var web3ReactContext = {
      connector,
      library,
      chainId,
      account,
      activate,
      setError,
      deactivate,
      active,
      error
    };
    return import_react24.default.createElement(Provider, {
      value: web3ReactContext
    }, children);
  };
}
var Web3ReactProvider = createWeb3ReactRoot(PRIMARY_KEY);
function getWeb3ReactContext(key) {
  if (key === void 0) {
    key = PRIMARY_KEY;
  }
  !Object.keys(CONTEXTS).includes(key) ? true ? tiny_invariant_esm_default(false, "Invalid key " + key) : tiny_invariant_esm_default(false) : void 0;
  return CONTEXTS[key];
}
function useWeb3React(key) {
  return (0, import_react24.useContext)(getWeb3ReactContext(key));
}

// node_modules/eth-hooks/chunk-SZO3HXET.js
var import_react26 = __toModule(require_react());
var import_web3modal = __toModule(require_dist());
var BlockNumberReactContext = (0, import_react25.createContext)(void 0);
var reducer2 = (state = {}, payload) => {
  let current = state[payload.chainId];
  return !current || payload.blockNumber > current ? __spreadProps(__spreadValues({}, state), { [payload.chainId]: payload.blockNumber }) : state;
};
var useBlockNumberContext = () => {
  let blockNumber = (0, import_react25.useContext)(BlockNumberReactContext);
  return blockNumber == null && console.log("blockNumber context is null"), blockNumber != null ? blockNumber : 0;
};
var BlockNumberContext = (props) => {
  let { ethersProvider, chainId } = useEthersContext(props.providerKey), isMounted = useIsMounted_default(), [state, dispatch] = (0, import_react25.useReducer)(reducer2, {}), blockNumber = chainId && (state == null ? void 0 : state[chainId]) ? state == null ? void 0 : state[chainId] : 0;
  return (0, import_react25.useEffect)(() => {
    var _a;
    if (chainId && ethersProvider) {
      let update = (blockNumber2) => {
        isMounted() && dispatch({ chainId, blockNumber: blockNumber2 });
      };
      return (_a = ethersProvider == null ? void 0 : ethersProvider.addListener) == null || _a.call(ethersProvider, "block", update), (state == null ? void 0 : state[chainId]) == null && (ethersProvider == null || ethersProvider.getBlockNumber().then((val) => {
        isMounted() && dispatch({ chainId, blockNumber: val });
      })), () => {
        var _a2;
        (_a2 = ethersProvider == null ? void 0 : ethersProvider.removeListener) == null || _a2.call(ethersProvider, "block", update);
      };
    }
  }, [chainId, ethersProvider, isMounted]), React.createElement(BlockNumberReactContext.Provider, { value: blockNumber }, props.children, " ");
};
var UserClosedModalError = class extends Error {
  constructor() {
    super();
    this.name = this.constructor.name, this.message = "EthersModalConnector: The user closed the modal with selecting a provider.";
  }
};
var CouldNotActivateError = class extends Error {
  constructor(error) {
    super();
    this.name = this.constructor.name, this.message = `EthersModalConnector: Could not activate provider.  ${error != null ? error : ""}`;
  }
};
var NoEthereumProviderFoundError = class extends Error {
  constructor() {
    super();
    this.name = this.constructor.name, this.message = "EthersModalConnector: No ethereum provider Found.";
  }
};
var const_web3DialogClosedByUser = "Modal closed by user";
var EthersModalConnector = class extends AbstractConnector {
  constructor(web3modalOptions, config = { reloadOnNetworkChange: false, immutableProvider: false }, id, debug = false) {
    super();
    this._debug = false;
    var _a;
    this._options = web3modalOptions, this._id = id, this._debug = debug, this._config = config, this._theme = (_a = web3modalOptions.theme) != null ? _a : "light", this.handleChainChanged = this.handleChainChanged.bind(this), this.handleAccountsChanged = this.handleAccountsChanged.bind(this), this.handleDisconnect = this.handleDisconnect.bind(this), this.handleClose = this.handleClose.bind(this);
  }
  get config() {
    return this._config;
  }
  log(...args) {
    this._debug && console.log("\u{1F50C} ", args);
  }
  maybeReload() {
    window && this._config.reloadOnNetworkChange && window.location.reload();
  }
  setEthersProvider() {
    this.isEthersProvider() ? this._ethersProvider = this._providerBase : this._ethersProvider = new Web3Provider(this._providerBase, this._config.immutableProvider ? "any" : void 0);
  }
  handleChainChanged(chainId) {
    var _a;
    this.log(`Handling chain changed to ${chainId}! updating providers`), (_a = this.emitUpdate) == null || _a.call(this, { chainId, provider: this._providerBase }), this.setEthersProvider(), this.maybeReload();
  }
  handleAccountsChanged(accounts) {
    var _a, _b;
    this.log("Handling accounts changed", accounts), accounts.length === 0 ? (_a = this.emitDeactivate) == null || _a.call(this) : (_b = this.emitUpdate) == null || _b.call(this, { account: accounts[0] });
  }
  handleDisconnect(code, reason) {
    this.log("Handling disconnected event", code, reason), this.deactivate();
  }
  handleClose(code, reason) {
    this.log("Handling 'close' event", code, reason), this.deactivate();
  }
  load() {
    this._web3Modal || (this._web3Modal = new import_web3modal.default(__spreadProps(__spreadValues({}, this._options), { theme: this._theme })));
  }
  async activate() {
    var _a, _b, _c, _d, _e, _f;
    try {
      this.load(), this._web3Modal && (this._options.cacheProvider === false && this.resetModal(), console.log("Open provider modal"), await this._web3Modal.updateTheme(this._theme), this._id ? this._providerBase = await this._web3Modal.connectTo(this._id) : this._providerBase = await this._web3Modal.connect(), this._providerBase.on("chainChanged", this.handleChainChanged), this._providerBase.on("accountsChanged", this.handleAccountsChanged), this._providerBase.on("disconnect", this.handleDisconnect), this._providerBase.on("close", this.handleClose), this.setEthersProvider());
      let account = (_b = (_a = this._providerBase) == null ? void 0 : _a.selectedAddress) != null ? _b : await this.getAccount(), chainId = (_f = (_c = this._providerBase) == null ? void 0 : _c.networkVersion) != null ? _f : BigNumber.from((_e = (_d = this._providerBase) == null ? void 0 : _d.chainId) != null ? _e : 0).toNumber();
      return chainId === 0 && (chainId = await this.getChainId()), this.setSignerFromAccount(account), { provider: this._providerBase, account, chainId };
    } catch (error) {
      throw this.resetModal(), (error == null ? void 0 : error.includes(const_web3DialogClosedByUser)) ? (console.log(error), this.deactivate(), new UserClosedModalError()) : (console.error("EthersModalConnector: Could not activate provider", error, this._providerBase), new CouldNotActivateError(error));
    }
  }
  isEthersProvider() {
    return isEthersProvider(this._providerBase);
  }
  deactivate() {
    var _a, _b, _c, _d, _e, _f, _g;
    (_a = this.emitDeactivate) == null || _a.call(this), (_b = this._providerBase) == null || _b.removeListener("disconnect", this.handleDisconnect), (_c = this._providerBase) == null || _c.removeListener("chainChanged", this.handleChainChanged), (_d = this._providerBase) == null || _d.removeListener("accountsChanged", this.handleAccountsChanged), (_e = this._providerBase) == null || _e.removeListener("close", this.handleClose);
    let provider = this._providerBase;
    (_f = provider == null ? void 0 : provider.disconnect) == null || _f.call(provider), (_g = provider == null ? void 0 : provider.close) == null || _g.call(provider), this.maybeReload();
  }
  getProvider() {
    return Promise.resolve(this._ethersProvider);
  }
  async getChainId() {
    var _a, _b, _c;
    return Promise.resolve((_c = (_b = (_a = this._ethersProvider) == null ? void 0 : _a.network) == null ? void 0 : _b.chainId) != null ? _c : 0);
  }
  async setSignerFromAccount(account) {
    var _a, _b;
    account && utils_exports.isAddress(account) && await ((_a = this._signer) == null ? void 0 : _a.getAddress()) !== account && (this._signer = (_b = this._ethersProvider) == null ? void 0 : _b.getSigner(account));
  }
  async getAccount() {
    var _a, _b, _c;
    if (this._signer) {
      let account2 = await this._signer.getAddress();
      if (utils_exports.isAddress(account2))
        return account2;
    }
    let accounts = await ((_a = this._ethersProvider) == null ? void 0 : _a.listAccounts()), account = (_b = accounts == null ? void 0 : accounts[0]) != null ? _b : null;
    return await this.setSignerFromAccount(account), Promise.resolve((_c = accounts == null ? void 0 : accounts[0]) != null ? _c : null);
  }
  getSigner() {
    return this._signer;
  }
  async changeSigner(signer) {
    var _a, _b, _c;
    let account = await signer.getAddress();
    utils_exports.isAddress(account) && this.validState() && (this._signer = signer, this.handleAccountsChanged([account]), console.log(`changeSigner: provider chainId ${await this.getChainId()}`), console.log(`new signer chainId ${(_c = (_b = await ((_a = signer.provider) == null ? void 0 : _a.getNetwork())) == null ? void 0 : _b.chainId) != null ? _c : ""}`));
  }
  validState() {
    return this._providerBase != null && this._ethersProvider != null && this._web3Modal != null;
  }
  resetModal() {
    var _a;
    this._web3Modal && (this._web3Modal.clearCachedProvider(), this._providerBase = void 0, this._ethersProvider = void 0, this._signer = void 0, (_a = this.emitUpdate) == null || _a.call(this, { account: void 0, provider: void 0, chainId: void 0 }));
  }
  setModalTheme(theme) {
    this._theme = theme;
  }
};
var useEthersContext = (providerKey) => {
  let _a = useWeb3React(providerKey), { connector, activate, library, account, deactivate, chainId } = _a, context = __objRest(_a, ["connector", "activate", "library", "account", "deactivate", "chainId"]);
  if (!(connector instanceof EthersModalConnector || connector instanceof AbstractConnector) && connector != null)
    throw "Connector is not a EthersModalConnector";
  let ethersConnector = connector, openWeb3Modal = (0, import_react26.useCallback)((ethersModalConnector) => {
    if (context.active && deactivate(), ethersModalConnector == null && console.error("A valid ethersModalConnector was not provided"), ethersModalConnector != null) {
      let onError = (error) => {
        var _a2;
        try {
          (_a2 = connector == null ? void 0 : connector.deactivate) == null || _a2.call(connector), console.warn(error);
        } catch {
        }
      };
      activate(ethersModalConnector, onError).catch(onError);
    }
  }, [context.active, deactivate, activate, connector]), disconnectModal = (0, import_react26.useCallback)(() => {
    ethersConnector.resetModal(), deactivate();
  }, [deactivate, ethersConnector]);
  return __spreadValues({ connector: ethersConnector, ethersProvider: library, activate, deactivate, library, account: account != null ? account : void 0, signer: ethersConnector == null ? void 0 : ethersConnector.getSigner(), chainId, changeSigner: ethersConnector == null ? void 0 : ethersConnector.changeSigner.bind(ethersConnector), openModal: openWeb3Modal, disconnectModal, setModalTheme: ethersConnector == null ? void 0 : ethersConnector.setModalTheme.bind(ethersConnector) }, context);
};
var getEthersAppProviderLibrary = (provider, connector) => {
  if (provider == null)
    throw new NoEthereumProviderFoundError();
  let anyNetwork;
  return connector instanceof EthersModalConnector && (anyNetwork = connector.config.immutableProvider ? "any" : void 0), isEthersProvider(provider) ? provider : new Web3Provider(provider, anyNetwork);
};
var EthersAppContext = (props) => React.createElement(Web3ReactProvider, { getLibrary: getEthersAppProviderLibrary }, React.createElement(BlockNumberContext, null, props.children));
var ConnectToStaticJsonRpcProvider = async (_package, opts) => {
  let url = opts.rpc[opts.currentChainId];
  try {
    let provider = new StaticJsonRpcProvider(url, opts.currentChainId);
    return await provider.getNetwork(), await provider.getBlockNumber(), (provider == null ? void 0 : provider.anyNetwork) || console.warn(`ConnectToStaticJsonRpcProvider: could not connect to chain: ${opts.currentChainId} url: ${url}`), provider;
  } catch {
    throw new Error("No StaticJsonRpcProvider found");
  }
};

export {
  useIsMounted_default,
  useBlockNumberContext,
  BlockNumberContext,
  UserClosedModalError,
  CouldNotActivateError,
  NoEthereumProviderFoundError,
  const_web3DialogClosedByUser,
  EthersModalConnector,
  useEthersContext,
  getEthersAppProviderLibrary,
  EthersAppContext,
  ConnectToStaticJsonRpcProvider
};
//# sourceMappingURL=chunk-PEM3UN5W.js.map
