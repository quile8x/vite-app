import {
  const_web3DialogClosedByUser,
  require_dist,
  useBlockNumberContext,
  useEthersContext,
  useIsMounted_default
} from "./chunk-VSQTF2MU.js";
import {
  require_axios
} from "./chunk-A4NTWOE2.js";
import {
  asyncSome,
  parseProviderOrSigner
} from "./chunk-5J4SWUYL.js";
import {
  signerHasNetwork
} from "./chunk-PC2NGECW.js";
import {
  BaseContract,
  Wallet,
  ethers_exports,
  utils_exports
} from "./chunk-3ESVQUN7.js";
import {
  Web3Provider
} from "./chunk-GZY3RKWX.js";
import {
  __spreadValues
} from "./chunk-BPBPYPFP.js";
import {
  BigNumber
} from "./chunk-C2WXXGWQ.js";
import {
  useDebounce
} from "./chunk-6K5IOUKO.js";
import {
  require_react
} from "./chunk-I3QJNPE6.js";
import {
  __toModule,
  init_define_process_env
} from "./chunk-VNKJPIOO.js";

// node_modules/eth-hooks/chunk-PNTNPJDE.js
init_define_process_env();
var import_react = __toModule(require_react());
var import_react2 = __toModule(require_react());
var import_react3 = __toModule(require_react());
var import_react4 = __toModule(require_react());
var import_react5 = __toModule(require_react());
var import_react6 = __toModule(require_react());
var import_react7 = __toModule(require_react());
var import_axios = __toModule(require_axios());
var import_react8 = __toModule(require_react());
var import_react9 = __toModule(require_react());
var import_react10 = __toModule(require_react());
var import_react11 = __toModule(require_react());
var import_react12 = __toModule(require_react());
var import_react13 = __toModule(require_react());
var import_react14 = __toModule(require_react());
var import_react15 = __toModule(require_react());
var import_web3modal = __toModule(require_dist());
var zero = BigNumber.from(0);
var useBalance = (address) => {
  let isMounted = useIsMounted_default(), { ethersProvider } = useEthersContext(), blockNumber = useBlockNumberContext(), [balance, setBalance] = (0, import_react.useState)(zero), callFunc = (0, import_react.useCallback)(async () => {
    if (ethersProvider && address) {
      let newBalance = await ethersProvider.getBalance(address);
      isMounted() && setBalance((value) => value.toHexString() !== (newBalance == null ? void 0 : newBalance.toHexString()) ? newBalance : value);
    }
  }, [address, ethersProvider, isMounted]);
  return (0, import_react.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), balance;
};
var isValidPk = (pk) => (pk == null ? void 0 : pk.length) === 64 || (pk == null ? void 0 : pk.length) === 66;
var saveBurnerKeyToStorage = (incomingPK) => {
  if (isValidPk(incomingPK)) {
    let rawPK = incomingPK;
    window.history.pushState({}, "", "/");
    let currentPrivateKey = window.localStorage.getItem("metaPrivateKey");
    currentPrivateKey && currentPrivateKey !== rawPK && (window.localStorage.setItem(`metaPrivateKey_backup${Date.now()}`, currentPrivateKey), console.log("\u{1F511} ...Saved Private Key")), window.localStorage.setItem("metaPrivateKey", rawPK.toString());
  }
};
var loadBurnerKeyFromStorage = () => window.localStorage.getItem("metaPrivateKey");
var useBurnerSigner = (localProvider) => {
  var _a;
  let key = "scaffold-eth-burner-privateKey", [privateKeyValue, setPrivateKey] = (0, import_react3.useState)(), walletRef = (0, import_react3.useRef)(), creatingBurnerRef = (0, import_react3.useRef)(false), [signer] = useDebounce(walletRef.current, 200, { trailing: true }), [account] = useDebounce((_a = walletRef.current) == null ? void 0 : _a.address, 200, { trailing: true }), setValue = (value) => {
    try {
      setPrivateKey(value), window.localStorage.setItem(key, value);
    } catch (error) {
      console.log(error);
    }
  };
  (0, import_react3.useEffect)(() => {
    let storedKey = window.localStorage.getItem(key);
    if (storedKey)
      setValue(storedKey);
    else {
      console.log("generating a new key");
      let newKey = ethers_exports.Wallet.createRandom().privateKey;
      setValue(newKey);
    }
  }, []), (0, import_react3.useEffect)(() => {
    if (privateKeyValue && localProvider) {
      let newSigner = new ethers_exports.Wallet(privateKeyValue).connect(localProvider);
      walletRef.current = newSigner;
    }
  }, [privateKeyValue, localProvider]);
  let saveToStorage = (0, import_react3.useCallback)(() => {
    console.log("\u{1F511} Incoming Private Key..."), privateKeyValue != null && saveBurnerKeyToStorage(privateKeyValue);
  }, [privateKeyValue]), generateBurnerSigner = (0, import_react3.useCallback)(() => {
    if (localProvider && !creatingBurnerRef.current) {
      creatingBurnerRef.current = true, console.log("\u{1F511} Create new burner wallet...");
      let wallet = Wallet.createRandom();
      setPrivateKey((_v) => (console.log("\u{1F4DD} ...Set key"), creatingBurnerRef.current = false, wallet.privateKey));
    } else
      console.log("\u26A0 Could not create burner wallet");
  }, [localProvider]), loadOrGenerateBurner = (0, import_react3.useCallback)(() => {
    if (setPrivateKey != null) {
      let pk = loadBurnerKeyFromStorage();
      pk && isValidPk(pk) ? (console.log("\u{1F511} ...Loaded Private Key"), setPrivateKey(pk)) : generateBurnerSigner();
    }
  }, [generateBurnerSigner]);
  return { signer, account, saveBurner: saveToStorage, loadOrGenerateBurner, generateBurnerSigner, getBurnerPrivateKey: () => privateKeyValue };
};
var useContractExistsAtAddress = (contract) => {
  let isMounted = useIsMounted_default(), [contractIsDeployed, setContractIsDeployed] = (0, import_react4.useState)(false), blockNumber = useBlockNumberContext(), callFunc = (0, import_react4.useCallback)(async () => {
    if (!(contract == null ? void 0 : contract.provider) || !utils_exports.isAddress(contract.address)) {
      isMounted() && setContractIsDeployed(false);
      return;
    }
    let bytecode = await contract.provider.getCode(contract.address);
    isMounted() && setContractIsDeployed(bytecode !== "0x");
  }, [contract, isMounted]);
  return (0, import_react4.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), contractIsDeployed;
};
var parseContractsInJson = (contractList, chainId) => {
  var _a, _b;
  let combinedContracts = {};
  if ((contractList == null ? void 0 : contractList[chainId]) != null) {
    for (let network in contractList[chainId])
      if (Object.prototype.hasOwnProperty.call(contractList[chainId], network)) {
        let chainContracts = (_b = (_a = contractList == null ? void 0 : contractList[chainId]) == null ? void 0 : _a[network]) == null ? void 0 : _b.contracts;
        chainContracts != null && (combinedContracts = __spreadValues(__spreadValues({}, combinedContracts), chainContracts));
      }
  }
  return combinedContracts;
};
var useContractLoader = (config = {}, providerOrSigner, configChainId) => {
  let isMounted = useIsMounted_default(), { ethersProvider, chainId: contextChainId } = useEthersContext(), chainId = configChainId != null ? configChainId : contextChainId, [contracts, setContracts] = (0, import_react5.useState)({}), configDep = (0, import_react5.useMemo)(() => `${JSON.stringify(config != null ? config : {})}, ${JSON.stringify({ chainId })}`, [chainId, config]), callFunc = (0, import_react5.useCallback)(() => {
    var _a, _b;
    if (ethersProvider && chainId && chainId > 0)
      try {
        let contractList = __spreadValues({}, (_a = config.deployedContractsJson) != null ? _a : {}), externalContractList = __spreadValues({}, (_b = config.externalContracts) != null ? _b : {}), combinedContracts = parseContractsInJson(contractList, chainId);
        (externalContractList == null ? void 0 : externalContractList[chainId]) != null && (combinedContracts = __spreadValues(__spreadValues({}, combinedContracts), externalContractList[chainId].contracts));
        let newContracts = Object.keys(combinedContracts).reduce((accumulator, contractName) => {
          let address = config.customAddresses && Object.keys(config.customAddresses).includes(contractName) ? config.customAddresses[contractName] : combinedContracts[contractName].address, provider = providerOrSigner != null ? providerOrSigner : chainId === contextChainId ? ethersProvider : void 0;
          return accumulator[contractName] = new BaseContract(address, combinedContracts[contractName].abi, provider), accumulator;
        }, {});
        isMounted() && setContracts((currValue) => currValue !== newContracts && (Object.keys(currValue).length > 0 || Object.keys(newContracts).length > 0) ? (console.log("\u{1F300} loading contracts.."), newContracts) : currValue);
      } catch (e) {
        console.log("\u26A0 useContractLoader, ERROR LOADING CONTRACTS!!", e, config);
      }
  }, [ethersProvider, configDep, providerOrSigner]);
  return (0, import_react5.useEffect)(() => {
    callFunc();
  }, [callFunc, chainId]), contracts;
};
var useContractReader = (contract, contractFunctionInfo, formatter, onChange) => {
  let isMounted = useIsMounted_default(), [value, setValue] = (0, import_react6.useState)(), blockNumber = useBlockNumberContext(), ethersContext = useEthersContext(), callContractFunction = (0, import_react6.useCallback)(async () => {
    var _a;
    let contractFunction = (_a = contract.functions) == null ? void 0 : _a[contractFunctionInfo.functionName], result;
    try {
      contractFunctionInfo.functionArgs && contractFunctionInfo.functionArgs.length > 0 ? result = await (contractFunction == null ? void 0 : contractFunction(...contractFunctionInfo.functionArgs)) : result = await (contractFunction == null ? void 0 : contractFunction());
    } catch {
      console.warn("Could not read from contract function", contractFunctionInfo);
    }
    return result;
  }, [contract, contractFunctionInfo.functionArgs, contractFunctionInfo.functionName]), contractProvider = contract == null ? void 0 : contract.provider, callFunc = (0, import_react6.useCallback)(async () => {
    var _a;
    let contractChainId = (_a = await (contractProvider == null ? void 0 : contractProvider.getNetwork())) == null ? void 0 : _a.chainId;
    if (callContractFunction != null && contractChainId === ethersContext.chainId && contractProvider != null && (ethersContext == null ? void 0 : ethersContext.chainId))
      try {
        let newResult = await callContractFunction();
        formatter != null && (newResult = formatter(newResult)), isMounted() && (setValue((value2) => !Object.is(value2, newResult) && JSON.stringify(value2) !== JSON.stringify(newResult) ? newResult : value2), onChange == null || onChange(newResult));
      } catch (error) {
        console.warn(error);
      }
  }, [contractProvider, callContractFunction, ethersContext == null ? void 0 : ethersContext.chainId, formatter, isMounted, onChange]);
  return (0, import_react6.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), value;
};
var getEventKey = (m) => `${m.transactionHash}_${m.logIndex}`;
var useEventListener = (contract, eventName, startBlock) => {
  let isMounted = useIsMounted_default(), [eventMap, setEventMap] = (0, import_react7.useState)([]), queryEvents = (0, import_react7.useCallback)((_listenerArgs) => {
    (async () => {
      let result = await (contract == null ? void 0 : contract.queryFilter(eventName, startBlock));
      isMounted() && result && setEventMap((value) => JSON.stringify(value.map(getEventKey)) !== JSON.stringify(result.map(getEventKey)) ? result : value);
    })();
  }, [contract, eventName, isMounted, startBlock]);
  return (0, import_react7.useEffect)(() => {
    (contract == null ? void 0 : contract.queryFilter) != null && setEventMap && (eventMap == null || (eventMap == null ? void 0 : eventMap.length) === 0) && queryEvents && queryEvents([]);
  }, [contract == null ? void 0 : contract.queryFilter]), (0, import_react7.useEffect)(() => {
    try {
      return contract == null || contract.on(eventName, queryEvents), () => {
        contract == null || contract.off(eventName, queryEvents);
      };
    } catch (e) {
      console.log(e);
    }
  }, [queryEvents, contract, eventName]), eventMap;
};
var useGasPrice = (chainId, speed, currentNetworkInfo) => {
  let { ethersProvider } = useEthersContext(), blockNumber = useBlockNumberContext(), [currentChainId, setCurrentChainId] = (0, import_react8.useState)(), [gasPrice, setGasPrice] = (0, import_react8.useState)(), [gasPriceDebounced] = useDebounce(gasPrice, 250, { trailing: true }), callFunc = (0, import_react8.useCallback)(() => {
    if (currentChainId !== chainId && (setCurrentChainId(chainId), setGasPrice(void 0)), !chainId)
      setGasPrice(void 0);
    else if (chainId === 1) {
      if (navigator.onLine) {
        let gweiFactor = 10;
        import_axios.default.get("https://ethgasstation.info/json/ethgasAPI.json").then((response) => {
          var _a;
          let result = (_a = response.data) != null ? _a : {}, newGasPrice = result[speed] / gweiFactor;
          newGasPrice || (newGasPrice = result.fast / gweiFactor), setGasPrice(newGasPrice);
        }).catch((error) => {
          console.log("\u26A0 Could not get gas Price!", error), setGasPrice(void 0);
        });
      }
    } else
      ethersProvider ? ethersProvider.getFeeData().then((fee) => {
        var _a, _b;
        let price = (_a = fee.gasPrice) != null ? _a : fee.maxFeePerGas;
        if (price && (price == null ? void 0 : price.toBigInt()) > 0) {
          let result = (_b = parseInt(utils_exports.formatUnits(price, "gwei"))) != null ? _b : 0;
          setGasPrice(result);
        } else
          (currentNetworkInfo == null ? void 0 : currentNetworkInfo.gasPrice) ? setGasPrice(currentNetworkInfo.gasPrice) : setGasPrice(void 0);
      }).catch((_error) => {
        console.log("\u26A0 Could not estimate gas!"), (currentNetworkInfo == null ? void 0 : currentNetworkInfo.gasPrice) ? setGasPrice(currentNetworkInfo.gasPrice) : setGasPrice(void 0);
      }) : (currentNetworkInfo == null ? void 0 : currentNetworkInfo.gasPrice) ? setGasPrice(currentNetworkInfo.gasPrice) : setGasPrice(void 0);
  }, [currentChainId, chainId, ethersProvider, currentNetworkInfo == null ? void 0 : currentNetworkInfo.gasPrice, speed]);
  return (0, import_react8.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), gasPriceDebounced;
};
var useGetUserFromProviders = (currentProvider, ...moreProviders) => {
  let [signer, setSigner] = (0, import_react9.useState)(), [provider, setProvider] = (0, import_react9.useState)(), [providerNetwork, setProviderNetwork] = (0, import_react9.useState)(), [address, setAddress] = (0, import_react9.useState)(), allProviders = [currentProvider, ...moreProviders].filter((f) => f != null), providerDeps = allProviders.map((m) => {
    var _a, _b;
    return `${(_a = m == null ? void 0 : m.network) == null ? void 0 : _a.name}_${(_b = m == null ? void 0 : m.network) == null ? void 0 : _b.chainId}_${m == null ? void 0 : m.connection.url}`;
  }).reduce((acc, value) => acc ? acc + value : value != null ? value : "", ""), callFunc = (0, import_react9.useCallback)(async () => {
    !await asyncSome(allProviders, async (provider2) => {
      let result = await parseProviderOrSigner(provider2);
      if (result.provider && result.providerNetwork && result.signer) {
        setSigner(result.signer), setProvider(result.provider), setProviderNetwork(result.providerNetwork);
        let address2 = await result.signer.getAddress();
        return setAddress(address2), true;
      }
      return false;
    }) && currentProvider != null && (setProvider(currentProvider), setSigner(void 0), setProviderNetwork(void 0), setAddress(void 0));
  }, [providerDeps]);
  return (0, import_react9.useEffect)(() => {
    callFunc();
  }, [callFunc]), { signer, provider, providerNetwork, address };
};
var useGetUserFromSigners = (signer) => {
  let [resolvedSigner, setResolvedSigner] = (0, import_react10.useState)(), [provider, setProvider] = (0, import_react10.useState)(), [providerNetwork, setProviderNetwork] = (0, import_react10.useState)(), [address, setAddress] = (0, import_react10.useState)(), callFunc = (0, import_react10.useCallback)(async () => {
    let result = await parseProviderOrSigner(signer);
    if (result.provider && result.providerNetwork && result.signer) {
      setResolvedSigner(result.signer), setProvider(result.provider), setProviderNetwork(result.providerNetwork);
      let address2 = await result.signer.getAddress();
      setAddress(address2);
    } else
      setProvider(void 0), setResolvedSigner(signer), setProviderNetwork(void 0), setAddress(void 0);
  }, [signer]);
  return (0, import_react10.useEffect)(() => {
    callFunc();
  }, [callFunc]), { signer: resolvedSigner, provider, providerNetwork, address };
};
var useNonce = (address) => {
  let isMounted = useIsMounted_default(), { ethersProvider } = useEthersContext(), blockNumber = useBlockNumberContext(), [nonce, setNonce] = (0, import_react11.useState)(0), callFunc = (0, import_react11.useCallback)(async () => {
    var _a;
    let nextNonce = 0;
    try {
      nextNonce = (_a = await (ethersProvider == null ? void 0 : ethersProvider.getTransactionCount(address))) != null ? _a : 0;
    } catch {
    }
    isMounted() && setNonce((value) => nextNonce && value !== nextNonce && value < nextNonce ? nextNonce : value);
  }, [address, ethersProvider, isMounted]);
  return (0, import_react11.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), nonce;
};
var DEBUG = false;
var useOnRepetition = (callback, options, ...args) => {
  var _a, _b;
  let isPolling = (options == null ? void 0 : options.pollTime) != null && options.pollTime > 0, readyForEvents = (options == null ? void 0 : options.provider) && !isPolling && ((_b = (_a = options == null ? void 0 : options.provider) == null ? void 0 : _a.network) == null ? void 0 : _b.chainId) > 0, readyForLeadTrigger = (readyForEvents || isPolling) && (options == null ? void 0 : options.leadingTrigger), isFirstCall = (0, import_react12.useRef)(true), argDeps = JSON.stringify(args != null ? args : []), callFunctionWithArgs = (0, import_react12.useCallback)(() => {
    DEBUG && console.log("create callback"), callback && (args && args.length > 0 ? callback(...args) : callback());
  }, [callback, argDeps]), listener = (0, import_react12.useCallback)((_blockNumber) => {
    readyForEvents && callFunctionWithArgs();
  }, [callFunctionWithArgs, readyForEvents]);
  (0, import_react12.useEffect)(() => {
    var _a2, _b2;
    return readyForEvents && ((_b2 = (_a2 = options == null ? void 0 : options.provider) == null ? void 0 : _a2.addListener) == null || _b2.call(_a2, "block", listener)), () => {
      var _a3, _b3;
      (_b3 = (_a3 = options == null ? void 0 : options.provider) == null ? void 0 : _a3.removeListener) == null || _b3.call(_a3, "block", listener);
    };
  }, [options.provider, readyForEvents, listener]), (0, import_react12.useEffect)(() => {
    var _a2;
    let tick = () => {
      DEBUG && console.log("polling: call function"), callFunctionWithArgs();
    };
    if (isPolling) {
      let safePollTime = ((_a2 = options == null ? void 0 : options.pollTime) != null ? _a2 : 0) > 1e4 ? options.pollTime : 1e4, id = setInterval(tick, safePollTime);
      return () => {
        clearInterval(id);
      };
    }
  }, [options.pollTime, isPolling, callFunctionWithArgs]), (0, import_react12.useEffect)(() => {
    isFirstCall.current || (isFirstCall.current = true);
  }, [argDeps]), (0, import_react12.useEffect)(() => {
    readyForLeadTrigger && callFunctionWithArgs != null && (isFirstCall == null ? void 0 : isFirstCall.current) === true && (isFirstCall.current = false, callFunctionWithArgs());
  }, [callFunctionWithArgs, readyForLeadTrigger]);
};
var useTimestamp = () => {
  let isMounted = useIsMounted_default(), { ethersProvider } = useEthersContext(), blockNumber = useBlockNumberContext(), [timestamp, setTimestamp] = (0, import_react13.useState)(0), callFunc = (0, import_react13.useCallback)(async () => {
    if (blockNumber != null) {
      let block = await (ethersProvider == null ? void 0 : ethersProvider.getBlock(blockNumber));
      if ((block == null ? void 0 : block.timestamp) != null) {
        let nextTimestamp = block.timestamp;
        isMounted() && setTimestamp(nextTimestamp);
      }
    }
  }, [blockNumber, ethersProvider, isMounted]);
  return (0, import_react13.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), timestamp;
};
var useUserAddress = (signer) => {
  let isMounted = useIsMounted_default(), [userAddress, setUserAddress] = (0, import_react14.useState)(), blockNumber = useBlockNumberContext(), callFunc = (0, import_react14.useCallback)(async () => {
    if (signerHasNetwork(signer)) {
      let address = await (signer == null ? void 0 : signer.getAddress());
      isMounted() && setUserAddress(address);
    }
  }, [isMounted, signer]);
  return (0, import_react14.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), userAddress;
};
var useWeb3Modal = (web3ModalConfig, setCurrentEthersProvider) => {
  var _a;
  let web3ModalProviderRef = (0, import_react15.useRef)(), initalizingRef = (0, import_react15.useRef)();
  (0, import_react15.useEffect)(() => {
    if (!import_web3modal.default)
      throw "Web3Modal is a peer dependancy to use this hook";
    web3ModalProviderRef.current = new import_web3modal.default(web3ModalConfig != null ? web3ModalConfig : {}), initalizingRef.current = true, setCurrentEthersProvider(void 0);
  }, [web3ModalConfig]);
  let reloadPage = (0, import_react15.useCallback)(() => (_param) => {
    var _a2;
    ((_a2 = web3ModalProviderRef.current) == null ? void 0 : _a2.cachedProvider) && setTimeout(() => {
      window.location.reload();
    }, 1);
  }, []), logoutOfWeb3ModalCallback = (0, import_react15.useCallback)((reload = true) => {
    initalizingRef.current = false, setCurrentEthersProvider(void 0), reload && reloadPage();
  }, [setCurrentEthersProvider]), loadWeb3Modal = (0, import_react15.useCallback)(async () => {
    var _a2;
    try {
      initalizingRef.current = true;
      let provider = await ((_a2 = web3ModalProviderRef.current) == null ? void 0 : _a2.connect());
      setCurrentEthersProvider(new Web3Provider(provider, "any")), (provider == null ? void 0 : provider.on) && (provider.on("chainChanged", (chainId) => {
        console.log(`chain changed to ${chainId}! updating providers`), setCurrentEthersProvider(new Web3Provider(provider, "any"));
      }), provider.on("accountsChanged", () => {
        console.log("account changed!"), setCurrentEthersProvider(new Web3Provider(provider, "any"));
      }), provider.on("disconnect", (code, reason) => {
        console.log(code, reason), logoutOfWeb3ModalCallback(), setCurrentEthersProvider(void 0);
      }));
    } catch (e) {
      if (e.includes(const_web3DialogClosedByUser))
        console.log(e);
      else
        throw e;
    } finally {
      initalizingRef.current = false;
    }
  }, [setCurrentEthersProvider]);
  (0, import_react15.useEffect)(() => {
    var _a2;
    ((_a2 = web3ModalProviderRef.current) == null ? void 0 : _a2.cachedProvider) && loadWeb3Modal();
  }, [loadWeb3Modal]);
  let openWeb3ModalCallback = (0, import_react15.useCallback)(() => {
    var _a2;
    setCurrentEthersProvider(void 0), (_a2 = web3ModalProviderRef.current) == null || _a2.clearCachedProvider(), loadWeb3Modal();
  }, [loadWeb3Modal]), updateWeb3ModalThemeCallback = (0, import_react15.useCallback)((theme) => {
    var _a2;
    (_a2 = web3ModalProviderRef.current) == null || _a2.updateTheme(theme);
  }, []);
  return { initializing: (_a = initalizingRef.current) != null ? _a : false, openWeb3ModalCallback, logoutOfWeb3ModalCallback, updateWeb3ModalThemeCallback };
};
var useBlockNumber = (provider, pollTime = 0) => {
  let [blockNumber, setBlockNumber] = (0, import_react2.useState)(0), isMounted = useIsMounted_default(), getBlockNumber = (0, import_react2.useCallback)(async () => {
    let nextBlockNumber = await (provider == null ? void 0 : provider.getBlockNumber());
    isMounted() && provider != null && setBlockNumber((value) => value !== nextBlockNumber ? nextBlockNumber != null ? nextBlockNumber : 0 : value);
  }, [provider, isMounted]);
  return useOnRepetition(getBlockNumber, { provider, pollTime }), blockNumber;
};

export {
  useBalance,
  useBurnerSigner,
  useContractExistsAtAddress,
  parseContractsInJson,
  useContractLoader,
  useContractReader,
  useEventListener,
  useGasPrice,
  useGetUserFromProviders,
  useGetUserFromSigners,
  useNonce,
  useOnRepetition,
  useTimestamp,
  useUserAddress,
  useWeb3Modal,
  useBlockNumber
};
//# sourceMappingURL=chunk-YOPUKV55.js.map
