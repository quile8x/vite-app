import {
  useOnRepetition
} from "./chunk-UYDLMLNN.js";
import {
  useBlockNumberContext
} from "./chunk-QHKKUULM.js";
import {
  Contract,
  keccak256,
  pack,
  utils_exports
} from "./chunk-DNYYJHAB.js";
import {
  getAddress,
  getCreate2Address,
  getDefaultProvider,
  lib_exports2 as lib_exports
} from "./chunk-GJKYZXTF.js";
import {
  getNetwork
} from "./chunk-43S5UDMX.js";
import {
  tiny_invariant_esm_default,
  tiny_warning_esm_default
} from "./chunk-4MNLZCPJ.js";
import {
  require_axios
} from "./chunk-DFMUFUDT.js";
import {
  require_react
} from "./chunk-IQ6JHC5C.js";
import {
  __commonJS,
  __toModule,
  init_define_process_env
} from "./chunk-OF4YZRDE.js";

// node_modules/toformat/toFormat.js
var require_toFormat = __commonJS({
  "node_modules/toformat/toFormat.js"(exports, module) {
    init_define_process_env();
    function toFormat2(Ctor) {
      "use strict";
      Ctor.prototype.toFormat = function toFormat3(dp, rm, fmt) {
        if (!this.e && this.e !== 0)
          return this.toString();
        var arr, g1, g2, i, u, nd, intd, intp, fracp, dsep, gsep, gsize, sgsize, fgsep, fgsize, tfmt = this.format || {}, cfmt = this.constructor.format || {};
        if (dp != u) {
          if (typeof dp == "object") {
            fmt = dp;
            dp = u;
          } else if (rm != u) {
            if (typeof rm == "object") {
              fmt = rm;
              rm = u;
            } else if (typeof fmt != "object") {
              fmt = {};
            }
          } else {
            fmt = {};
          }
        } else {
          fmt = {};
        }
        arr = this.toFixed(dp, rm).split(".");
        intp = arr[0];
        fracp = arr[1];
        intd = this.s < 0 ? intp.slice(1) : intp;
        nd = intd.length;
        dsep = fmt.decimalSeparator;
        if (dsep == u) {
          dsep = tfmt.decimalSeparator;
          if (dsep == u) {
            dsep = cfmt.decimalSeparator;
            if (dsep == u)
              dsep = ".";
          }
        }
        gsep = fmt.groupSeparator;
        if (gsep == u) {
          gsep = tfmt.groupSeparator;
          if (gsep == u)
            gsep = cfmt.groupSeparator;
        }
        if (gsep) {
          gsize = fmt.groupSize;
          if (gsize == u) {
            gsize = tfmt.groupSize;
            if (gsize == u) {
              gsize = cfmt.groupSize;
              if (gsize == u)
                gsize = 0;
            }
          }
          sgsize = fmt.secondaryGroupSize;
          if (sgsize == u) {
            sgsize = tfmt.secondaryGroupSize;
            if (sgsize == u) {
              sgsize = cfmt.secondaryGroupSize;
              if (sgsize == u)
                sgsize = 0;
            }
          }
          if (sgsize) {
            g1 = +sgsize;
            g2 = +gsize;
            nd -= g2;
          } else {
            g1 = +gsize;
            g2 = +sgsize;
          }
          if (g1 > 0 && nd > 0) {
            i = nd % g1 || g1;
            intp = intd.substr(0, i);
            for (; i < nd; i += g1)
              intp += gsep + intd.substr(i, g1);
            if (g2 > 0)
              intp += gsep + intd.slice(i);
            if (this.s < 0)
              intp = "-" + intp;
          }
        }
        if (fracp) {
          fgsep = fmt.fractionGroupSeparator;
          if (fgsep == u) {
            fgsep = tfmt.fractionGroupSeparator;
            if (fgsep == u)
              fgsep = cfmt.fractionGroupSeparator;
          }
          if (fgsep) {
            fgsize = fmt.fractionGroupSize;
            if (fgsize == u) {
              fgsize = tfmt.fractionGroupSize;
              if (fgsize == u) {
                fgsize = cfmt.fractionGroupSize;
                if (fgsize == u)
                  fgsize = 0;
              }
            }
            fgsize = +fgsize;
            if (fgsize) {
              fracp = fracp.replace(new RegExp("\\d{" + fgsize + "}\\B", "g"), "$&" + fgsep);
            }
          }
          return intp + dsep + fracp;
        } else {
          return intp;
        }
      };
      Ctor.format = {
        decimalSeparator: ".",
        groupSeparator: ",",
        groupSize: 3,
        secondaryGroupSize: 0,
        fractionGroupSeparator: "",
        fractionGroupSize: 0
      };
      return Ctor;
    }
    if (typeof module !== "undefined" && module.exports)
      module.exports = toFormat2;
  }
});

// node_modules/eth-hooks/dapps.js
init_define_process_env();

// node_modules/@uniswap/sdk/dist/sdk.esm.js
init_define_process_env();

// node_modules/jsbi/dist/jsbi.mjs
init_define_process_env();
var JSBI = class extends Array {
  constructor(i, _) {
    if (super(i), this.sign = _, i > JSBI.__kMaxLength)
      throw new RangeError("Maximum BigInt size exceeded");
  }
  static BigInt(i) {
    var _ = Math.floor, t = Number.isFinite;
    if (typeof i == "number") {
      if (i === 0)
        return JSBI.__zero();
      if (JSBI.__isOneDigitInt(i))
        return 0 > i ? JSBI.__oneDigit(-i, true) : JSBI.__oneDigit(i, false);
      if (!t(i) || _(i) !== i)
        throw new RangeError("The number " + i + " cannot be converted to BigInt because it is not an integer");
      return JSBI.__fromDouble(i);
    }
    if (typeof i == "string") {
      const _2 = JSBI.__fromString(i);
      if (_2 === null)
        throw new SyntaxError("Cannot convert " + i + " to a BigInt");
      return _2;
    }
    if (typeof i == "boolean")
      return i === true ? JSBI.__oneDigit(1, false) : JSBI.__zero();
    if (typeof i == "object") {
      if (i.constructor === JSBI)
        return i;
      const _2 = JSBI.__toPrimitive(i);
      return JSBI.BigInt(_2);
    }
    throw new TypeError("Cannot convert " + i + " to a BigInt");
  }
  toDebugString() {
    const i = ["BigInt["];
    for (const _ of this)
      i.push((_ ? (_ >>> 0).toString(16) : _) + ", ");
    return i.push("]"), i.join("");
  }
  toString(i = 10) {
    if (2 > i || 36 < i)
      throw new RangeError("toString() radix argument must be between 2 and 36");
    return this.length === 0 ? "0" : (i & i - 1) == 0 ? JSBI.__toStringBasePowerOfTwo(this, i) : JSBI.__toStringGeneric(this, i, false);
  }
  static toNumber(i) {
    const _ = i.length;
    if (_ === 0)
      return 0;
    if (_ === 1) {
      const _2 = i.__unsignedDigit(0);
      return i.sign ? -_2 : _2;
    }
    const t = i.__digit(_ - 1), e = JSBI.__clz30(t), n = 30 * _ - e;
    if (1024 < n)
      return i.sign ? -Infinity : 1 / 0;
    let g = n - 1, o = t, s = _ - 1;
    const l = e + 3;
    let r = l === 32 ? 0 : o << l;
    r >>>= 12;
    const a = l - 12;
    let u = 12 <= l ? 0 : o << 20 + l, d = 20 + l;
    for (0 < a && 0 < s && (s--, o = i.__digit(s), r |= o >>> 30 - a, u = o << a + 2, d = a + 2); 0 < d && 0 < s; )
      s--, o = i.__digit(s), u |= 30 <= d ? o << d - 30 : o >>> 30 - d, d -= 30;
    const h = JSBI.__decideRounding(i, d, s, o);
    if ((h === 1 || h === 0 && (1 & u) == 1) && (u = u + 1 >>> 0, u === 0 && (r++, r >>> 20 != 0 && (r = 0, g++, 1023 < g))))
      return i.sign ? -Infinity : 1 / 0;
    const m = i.sign ? -2147483648 : 0;
    return g = g + 1023 << 20, JSBI.__kBitConversionInts[1] = m | g | r, JSBI.__kBitConversionInts[0] = u, JSBI.__kBitConversionDouble[0];
  }
  static unaryMinus(i) {
    if (i.length === 0)
      return i;
    const _ = i.__copy();
    return _.sign = !i.sign, _;
  }
  static bitwiseNot(i) {
    return i.sign ? JSBI.__absoluteSubOne(i).__trim() : JSBI.__absoluteAddOne(i, true);
  }
  static exponentiate(i, _) {
    if (_.sign)
      throw new RangeError("Exponent must be positive");
    if (_.length === 0)
      return JSBI.__oneDigit(1, false);
    if (i.length === 0)
      return i;
    if (i.length === 1 && i.__digit(0) === 1)
      return i.sign && (1 & _.__digit(0)) == 0 ? JSBI.unaryMinus(i) : i;
    if (1 < _.length)
      throw new RangeError("BigInt too big");
    let t = _.__unsignedDigit(0);
    if (t === 1)
      return i;
    if (t >= JSBI.__kMaxLengthBits)
      throw new RangeError("BigInt too big");
    if (i.length === 1 && i.__digit(0) === 2) {
      const _2 = 1 + (0 | t / 30), e2 = i.sign && (1 & t) != 0, n2 = new JSBI(_2, e2);
      n2.__initializeDigits();
      const g = 1 << t % 30;
      return n2.__setDigit(_2 - 1, g), n2;
    }
    let e = null, n = i;
    for ((1 & t) != 0 && (e = i), t >>= 1; t !== 0; t >>= 1)
      n = JSBI.multiply(n, n), (1 & t) != 0 && (e === null ? e = n : e = JSBI.multiply(e, n));
    return e;
  }
  static multiply(_, t) {
    if (_.length === 0)
      return _;
    if (t.length === 0)
      return t;
    let i = _.length + t.length;
    30 <= _.__clzmsd() + t.__clzmsd() && i--;
    const e = new JSBI(i, _.sign !== t.sign);
    e.__initializeDigits();
    for (let n = 0; n < _.length; n++)
      JSBI.__multiplyAccumulate(t, _.__digit(n), e, n);
    return e.__trim();
  }
  static divide(i, _) {
    if (_.length === 0)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i, _))
      return JSBI.__zero();
    const t = i.sign !== _.sign, e = _.__unsignedDigit(0);
    let n;
    if (_.length === 1 && 32767 >= e) {
      if (e === 1)
        return t === i.sign ? i : JSBI.unaryMinus(i);
      n = JSBI.__absoluteDivSmall(i, e, null);
    } else
      n = JSBI.__absoluteDivLarge(i, _, true, false);
    return n.sign = t, n.__trim();
  }
  static remainder(i, _) {
    if (_.length === 0)
      throw new RangeError("Division by zero");
    if (0 > JSBI.__absoluteCompare(i, _))
      return i;
    const t = _.__unsignedDigit(0);
    if (_.length === 1 && 32767 >= t) {
      if (t === 1)
        return JSBI.__zero();
      const _2 = JSBI.__absoluteModSmall(i, t);
      return _2 === 0 ? JSBI.__zero() : JSBI.__oneDigit(_2, i.sign);
    }
    const e = JSBI.__absoluteDivLarge(i, _, false, true);
    return e.sign = i.sign, e.__trim();
  }
  static add(i, _) {
    const t = i.sign;
    return t === _.sign ? JSBI.__absoluteAdd(i, _, t) : 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t);
  }
  static subtract(i, _) {
    const t = i.sign;
    return t === _.sign ? 0 <= JSBI.__absoluteCompare(i, _) ? JSBI.__absoluteSub(i, _, t) : JSBI.__absoluteSub(_, i, !t) : JSBI.__absoluteAdd(i, _, t);
  }
  static leftShift(i, _) {
    return _.length === 0 || i.length === 0 ? i : _.sign ? JSBI.__rightShiftByAbsolute(i, _) : JSBI.__leftShiftByAbsolute(i, _);
  }
  static signedRightShift(i, _) {
    return _.length === 0 || i.length === 0 ? i : _.sign ? JSBI.__leftShiftByAbsolute(i, _) : JSBI.__rightShiftByAbsolute(i, _);
  }
  static unsignedRightShift() {
    throw new TypeError("BigInts have no unsigned right shift; use >> instead");
  }
  static lessThan(i, _) {
    return 0 > JSBI.__compareToBigInt(i, _);
  }
  static lessThanOrEqual(i, _) {
    return 0 >= JSBI.__compareToBigInt(i, _);
  }
  static greaterThan(i, _) {
    return 0 < JSBI.__compareToBigInt(i, _);
  }
  static greaterThanOrEqual(i, _) {
    return 0 <= JSBI.__compareToBigInt(i, _);
  }
  static equal(_, t) {
    if (_.sign !== t.sign)
      return false;
    if (_.length !== t.length)
      return false;
    for (let e = 0; e < _.length; e++)
      if (_.__digit(e) !== t.__digit(e))
        return false;
    return true;
  }
  static notEqual(i, _) {
    return !JSBI.equal(i, _);
  }
  static bitwiseAnd(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return JSBI.__absoluteAnd(i, _).__trim();
    if (i.sign && _.sign) {
      const e = t(i.length, _.length) + 1;
      let n = JSBI.__absoluteSubOne(i, e);
      const g = JSBI.__absoluteSubOne(_);
      return n = JSBI.__absoluteOr(n, g, n), JSBI.__absoluteAddOne(n, true, n).__trim();
    }
    return i.sign && ([i, _] = [_, i]), JSBI.__absoluteAndNot(i, JSBI.__absoluteSubOne(_)).__trim();
  }
  static bitwiseXor(i, _) {
    var t = Math.max;
    if (!i.sign && !_.sign)
      return JSBI.__absoluteXor(i, _).__trim();
    if (i.sign && _.sign) {
      const e2 = t(i.length, _.length), n2 = JSBI.__absoluteSubOne(i, e2), g = JSBI.__absoluteSubOne(_);
      return JSBI.__absoluteXor(n2, g, n2).__trim();
    }
    const e = t(i.length, _.length) + 1;
    i.sign && ([i, _] = [_, i]);
    let n = JSBI.__absoluteSubOne(_, e);
    return n = JSBI.__absoluteXor(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static bitwiseOr(i, _) {
    var t = Math.max;
    const e = t(i.length, _.length);
    if (!i.sign && !_.sign)
      return JSBI.__absoluteOr(i, _).__trim();
    if (i.sign && _.sign) {
      let t2 = JSBI.__absoluteSubOne(i, e);
      const n2 = JSBI.__absoluteSubOne(_);
      return t2 = JSBI.__absoluteAnd(t2, n2, t2), JSBI.__absoluteAddOne(t2, true, t2).__trim();
    }
    i.sign && ([i, _] = [_, i]);
    let n = JSBI.__absoluteSubOne(_, e);
    return n = JSBI.__absoluteAndNot(n, i, n), JSBI.__absoluteAddOne(n, true, n).__trim();
  }
  static asIntN(_, t) {
    var i = Math.floor;
    if (t.length === 0)
      return t;
    if (_ = i(_), 0 > _)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (_ === 0)
      return JSBI.__zero();
    if (_ >= JSBI.__kMaxLengthBits)
      return t;
    const e = 0 | (_ + 29) / 30;
    if (t.length < e)
      return t;
    const g = t.__unsignedDigit(e - 1), o = 1 << (_ - 1) % 30;
    if (t.length === e && g < o)
      return t;
    if (!((g & o) === o))
      return JSBI.__truncateToNBits(_, t);
    if (!t.sign)
      return JSBI.__truncateAndSubFromPowerOfTwo(_, t, true);
    if ((g & o - 1) == 0) {
      for (let n = e - 2; 0 <= n; n--)
        if (t.__digit(n) !== 0)
          return JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
      return t.length === e && g === o ? t : JSBI.__truncateToNBits(_, t);
    }
    return JSBI.__truncateAndSubFromPowerOfTwo(_, t, false);
  }
  static asUintN(i, _) {
    var t = Math.floor;
    if (_.length === 0)
      return _;
    if (i = t(i), 0 > i)
      throw new RangeError("Invalid value: not (convertible to) a safe integer");
    if (i === 0)
      return JSBI.__zero();
    if (_.sign) {
      if (i > JSBI.__kMaxLengthBits)
        throw new RangeError("BigInt too big");
      return JSBI.__truncateAndSubFromPowerOfTwo(i, _, false);
    }
    if (i >= JSBI.__kMaxLengthBits)
      return _;
    const e = 0 | (i + 29) / 30;
    if (_.length < e)
      return _;
    const g = i % 30;
    if (_.length == e) {
      if (g === 0)
        return _;
      const i2 = _.__digit(e - 1);
      if (i2 >>> g == 0)
        return _;
    }
    return JSBI.__truncateToNBits(i, _);
  }
  static ADD(i, _) {
    if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), typeof i == "string")
      return typeof _ != "string" && (_ = _.toString()), i + _;
    if (typeof _ == "string")
      return i.toString() + _;
    if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i) && JSBI.__isBigInt(_))
      return JSBI.add(i, _);
    if (typeof i == "number" && typeof _ == "number")
      return i + _;
    throw new TypeError("Cannot mix BigInt and other types, use explicit conversions");
  }
  static LT(i, _) {
    return JSBI.__compare(i, _, 0);
  }
  static LE(i, _) {
    return JSBI.__compare(i, _, 1);
  }
  static GT(i, _) {
    return JSBI.__compare(i, _, 2);
  }
  static GE(i, _) {
    return JSBI.__compare(i, _, 3);
  }
  static EQ(i, _) {
    for (; ; ) {
      if (JSBI.__isBigInt(i))
        return JSBI.__isBigInt(_) ? JSBI.equal(i, _) : JSBI.EQ(_, i);
      if (typeof i == "number") {
        if (JSBI.__isBigInt(_))
          return JSBI.__equalToNumber(_, i);
        if (typeof _ != "object")
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if (typeof i == "string") {
        if (JSBI.__isBigInt(_))
          return i = JSBI.__fromString(i), i !== null && JSBI.equal(i, _);
        if (typeof _ != "object")
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if (typeof i == "boolean") {
        if (JSBI.__isBigInt(_))
          return JSBI.__equalToNumber(_, +i);
        if (typeof _ != "object")
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if (typeof i == "symbol") {
        if (JSBI.__isBigInt(_))
          return false;
        if (typeof _ != "object")
          return i == _;
        _ = JSBI.__toPrimitive(_);
      } else if (typeof i == "object") {
        if (typeof _ == "object" && _.constructor !== JSBI)
          return i == _;
        i = JSBI.__toPrimitive(i);
      } else
        return i == _;
    }
  }
  static NE(i, _) {
    return !JSBI.EQ(i, _);
  }
  static __zero() {
    return new JSBI(0, false);
  }
  static __oneDigit(i, _) {
    const t = new JSBI(1, _);
    return t.__setDigit(0, i), t;
  }
  __copy() {
    const _ = new JSBI(this.length, this.sign);
    for (let t = 0; t < this.length; t++)
      _[t] = this[t];
    return _;
  }
  __trim() {
    let i = this.length, _ = this[i - 1];
    for (; _ === 0; )
      i--, _ = this[i - 1], this.pop();
    return i === 0 && (this.sign = false), this;
  }
  __initializeDigits() {
    for (let _ = 0; _ < this.length; _++)
      this[_] = 0;
  }
  static __decideRounding(i, _, t, e) {
    if (0 < _)
      return -1;
    let n;
    if (0 > _)
      n = -_ - 1;
    else {
      if (t === 0)
        return -1;
      t--, e = i.__digit(t), n = 29;
    }
    let g = 1 << n;
    if ((e & g) == 0)
      return -1;
    if (g -= 1, (e & g) != 0)
      return 1;
    for (; 0 < t; )
      if (t--, i.__digit(t) !== 0)
        return 1;
    return 0;
  }
  static __fromDouble(i) {
    JSBI.__kBitConversionDouble[0] = i;
    const _ = 2047 & JSBI.__kBitConversionInts[1] >>> 20, t = _ - 1023, e = (0 | t / 30) + 1, n = new JSBI(e, 0 > i);
    let g = 1048575 & JSBI.__kBitConversionInts[1] | 1048576, o = JSBI.__kBitConversionInts[0];
    const s = 20, l = t % 30;
    let r, a = 0;
    if (l < 20) {
      const i2 = s - l;
      a = i2 + 32, r = g >>> i2, g = g << 32 - i2 | o >>> i2, o <<= 32 - i2;
    } else if (l === 20)
      a = 32, r = g, g = o, o = 0;
    else {
      const i2 = l - s;
      a = 32 - i2, r = g << i2 | o >>> 32 - i2, g = o << i2, o = 0;
    }
    n.__setDigit(e - 1, r);
    for (let _2 = e - 2; 0 <= _2; _2--)
      0 < a ? (a -= 30, r = g >>> 2, g = g << 30 | o >>> 2, o <<= 30) : r = 0, n.__setDigit(_2, r);
    return n.__trim();
  }
  static __isWhitespace(i) {
    return !!(13 >= i && 9 <= i) || (159 >= i ? i == 32 : 131071 >= i ? i == 160 || i == 5760 : 196607 >= i ? (i &= 131071, 10 >= i || i == 40 || i == 41 || i == 47 || i == 95 || i == 4096) : i == 65279);
  }
  static __fromString(i, _ = 0) {
    let t = 0;
    const e = i.length;
    let n = 0;
    if (n === e)
      return JSBI.__zero();
    let g = i.charCodeAt(n);
    for (; JSBI.__isWhitespace(g); ) {
      if (++n === e)
        return JSBI.__zero();
      g = i.charCodeAt(n);
    }
    if (g === 43) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = 1;
    } else if (g === 45) {
      if (++n === e)
        return null;
      g = i.charCodeAt(n), t = -1;
    }
    if (_ === 0) {
      if (_ = 10, g === 48) {
        if (++n === e)
          return JSBI.__zero();
        if (g = i.charCodeAt(n), g === 88 || g === 120) {
          if (_ = 16, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (g === 79 || g === 111) {
          if (_ = 8, ++n === e)
            return null;
          g = i.charCodeAt(n);
        } else if (g === 66 || g === 98) {
          if (_ = 2, ++n === e)
            return null;
          g = i.charCodeAt(n);
        }
      }
    } else if (_ === 16 && g === 48) {
      if (++n === e)
        return JSBI.__zero();
      if (g = i.charCodeAt(n), g === 88 || g === 120) {
        if (++n === e)
          return null;
        g = i.charCodeAt(n);
      }
    }
    if (t != 0 && _ !== 10)
      return null;
    for (; g === 48; ) {
      if (++n === e)
        return JSBI.__zero();
      g = i.charCodeAt(n);
    }
    const o = e - n;
    let s = JSBI.__kMaxBitsPerChar[_], l = JSBI.__kBitsPerCharTableMultiplier - 1;
    if (o > 1073741824 / s)
      return null;
    const r = s * o + l >>> JSBI.__kBitsPerCharTableShift, a = new JSBI(0 | (r + 29) / 30, false), u = 10 > _ ? _ : 10, h = 10 < _ ? _ - 10 : 0;
    if ((_ & _ - 1) == 0) {
      s >>= JSBI.__kBitsPerCharTableShift;
      const _2 = [], t2 = [];
      let o2 = false;
      do {
        let l2 = 0, r2 = 0;
        for (; ; ) {
          let _3;
          if (g - 48 >>> 0 < u)
            _3 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            _3 = (32 | g) - 87;
          else {
            o2 = true;
            break;
          }
          if (r2 += s, l2 = l2 << s | _3, ++n === e) {
            o2 = true;
            break;
          }
          if (g = i.charCodeAt(n), 30 < r2 + s)
            break;
        }
        _2.push(l2), t2.push(r2);
      } while (!o2);
      JSBI.__fillFromParts(a, _2, t2);
    } else {
      a.__initializeDigits();
      let t2 = false, o2 = 0;
      do {
        let r2 = 0, b = 1;
        for (; ; ) {
          let s2;
          if (g - 48 >>> 0 < u)
            s2 = g - 48;
          else if ((32 | g) - 97 >>> 0 < h)
            s2 = (32 | g) - 87;
          else {
            t2 = true;
            break;
          }
          const l2 = b * _;
          if (1073741823 < l2)
            break;
          if (b = l2, r2 = r2 * _ + s2, o2++, ++n === e) {
            t2 = true;
            break;
          }
          g = i.charCodeAt(n);
        }
        l = 30 * JSBI.__kBitsPerCharTableMultiplier - 1;
        const D = 0 | (s * o2 + l >>> JSBI.__kBitsPerCharTableShift) / 30;
        a.__inplaceMultiplyAdd(b, r2, D);
      } while (!t2);
    }
    if (n !== e) {
      if (!JSBI.__isWhitespace(g))
        return null;
      for (n++; n < e; n++)
        if (g = i.charCodeAt(n), !JSBI.__isWhitespace(g))
          return null;
    }
    return a.sign = t == -1, a.__trim();
  }
  static __fillFromParts(_, t, e) {
    let n = 0, g = 0, o = 0;
    for (let s = t.length - 1; 0 <= s; s--) {
      const i = t[s], l = e[s];
      g |= i << o, o += l, o === 30 ? (_.__setDigit(n++, g), o = 0, g = 0) : 30 < o && (_.__setDigit(n++, 1073741823 & g), o -= 30, g = i >>> l - o);
    }
    if (g !== 0) {
      if (n >= _.length)
        throw new Error("implementation bug");
      _.__setDigit(n++, g);
    }
    for (; n < _.length; n++)
      _.__setDigit(n, 0);
  }
  static __toStringBasePowerOfTwo(_, i) {
    const t = _.length;
    let e = i - 1;
    e = (85 & e >>> 1) + (85 & e), e = (51 & e >>> 2) + (51 & e), e = (15 & e >>> 4) + (15 & e);
    const n = e, g = i - 1, o = _.__digit(t - 1), s = JSBI.__clz30(o);
    let l = 0 | (30 * t - s + n - 1) / n;
    if (_.sign && l++, 268435456 < l)
      throw new Error("string too long");
    const r = Array(l);
    let a = l - 1, u = 0, d = 0;
    for (let e2 = 0; e2 < t - 1; e2++) {
      const i2 = _.__digit(e2), t2 = (u | i2 << d) & g;
      r[a--] = JSBI.__kConversionChars[t2];
      const o2 = n - d;
      for (u = i2 >>> o2, d = 30 - o2; d >= n; )
        r[a--] = JSBI.__kConversionChars[u & g], u >>>= n, d -= n;
    }
    const h = (u | o << d) & g;
    for (r[a--] = JSBI.__kConversionChars[h], u = o >>> n - d; u !== 0; )
      r[a--] = JSBI.__kConversionChars[u & g], u >>>= n;
    if (_.sign && (r[a--] = "-"), a != -1)
      throw new Error("implementation bug");
    return r.join("");
  }
  static __toStringGeneric(_, i, t) {
    const e = _.length;
    if (e === 0)
      return "";
    if (e === 1) {
      let e2 = _.__unsignedDigit(0).toString(i);
      return t === false && _.sign && (e2 = "-" + e2), e2;
    }
    const n = 30 * e - JSBI.__clz30(_.__digit(e - 1)), g = JSBI.__kMaxBitsPerChar[i], o = g - 1;
    let s = n * JSBI.__kBitsPerCharTableMultiplier;
    s += o - 1, s = 0 | s / o;
    const l = s + 1 >> 1, r = JSBI.exponentiate(JSBI.__oneDigit(i, false), JSBI.__oneDigit(l, false));
    let a, u;
    const d = r.__unsignedDigit(0);
    if (r.length === 1 && 32767 >= d) {
      a = new JSBI(_.length, false), a.__initializeDigits();
      let t2 = 0;
      for (let e2 = 2 * _.length - 1; 0 <= e2; e2--) {
        const i2 = t2 << 15 | _.__halfDigit(e2);
        a.__setHalfDigit(e2, 0 | i2 / d), t2 = 0 | i2 % d;
      }
      u = t2.toString(i);
    } else {
      const t2 = JSBI.__absoluteDivLarge(_, r, true, true);
      a = t2.quotient;
      const e2 = t2.remainder.__trim();
      u = JSBI.__toStringGeneric(e2, i, true);
    }
    a.__trim();
    let h = JSBI.__toStringGeneric(a, i, true);
    for (; u.length < l; )
      u = "0" + u;
    return t === false && _.sign && (h = "-" + h), h + u;
  }
  static __unequalSign(i) {
    return i ? -1 : 1;
  }
  static __absoluteGreater(i) {
    return i ? -1 : 1;
  }
  static __absoluteLess(i) {
    return i ? 1 : -1;
  }
  static __compareToBigInt(i, _) {
    const t = i.sign;
    if (t !== _.sign)
      return JSBI.__unequalSign(t);
    const e = JSBI.__absoluteCompare(i, _);
    return 0 < e ? JSBI.__absoluteGreater(t) : 0 > e ? JSBI.__absoluteLess(t) : 0;
  }
  static __compareToNumber(i, _) {
    if (JSBI.__isOneDigitInt(_)) {
      const t = i.sign, e = 0 > _;
      if (t !== e)
        return JSBI.__unequalSign(t);
      if (i.length === 0) {
        if (e)
          throw new Error("implementation bug");
        return _ === 0 ? 0 : -1;
      }
      if (1 < i.length)
        return JSBI.__absoluteGreater(t);
      const n = Math.abs(_), g = i.__unsignedDigit(0);
      return g > n ? JSBI.__absoluteGreater(t) : g < n ? JSBI.__absoluteLess(t) : 0;
    }
    return JSBI.__compareToDouble(i, _);
  }
  static __compareToDouble(i, _) {
    if (_ !== _)
      return _;
    if (_ === 1 / 0)
      return -1;
    if (_ === -Infinity)
      return 1;
    const t = i.sign;
    if (t !== 0 > _)
      return JSBI.__unequalSign(t);
    if (_ === 0)
      throw new Error("implementation bug: should be handled elsewhere");
    if (i.length === 0)
      return -1;
    JSBI.__kBitConversionDouble[0] = _;
    const e = 2047 & JSBI.__kBitConversionInts[1] >>> 20;
    if (e == 2047)
      throw new Error("implementation bug: handled elsewhere");
    const n = e - 1023;
    if (0 > n)
      return JSBI.__absoluteGreater(t);
    const g = i.length;
    let o = i.__digit(g - 1);
    const s = JSBI.__clz30(o), l = 30 * g - s, r = n + 1;
    if (l < r)
      return JSBI.__absoluteLess(t);
    if (l > r)
      return JSBI.__absoluteGreater(t);
    let a = 1048576 | 1048575 & JSBI.__kBitConversionInts[1], u = JSBI.__kBitConversionInts[0];
    const d = 20, h = 29 - s;
    if (h !== (0 | (l - 1) % 30))
      throw new Error("implementation bug");
    let m, b = 0;
    if (20 > h) {
      const i2 = d - h;
      b = i2 + 32, m = a >>> i2, a = a << 32 - i2 | u >>> i2, u <<= 32 - i2;
    } else if (h === 20)
      b = 32, m = a, a = u, u = 0;
    else {
      const i2 = h - d;
      b = 32 - i2, m = a << i2 | u >>> 32 - i2, a = u << i2, u = 0;
    }
    if (o >>>= 0, m >>>= 0, o > m)
      return JSBI.__absoluteGreater(t);
    if (o < m)
      return JSBI.__absoluteLess(t);
    for (let e2 = g - 2; 0 <= e2; e2--) {
      0 < b ? (b -= 30, m = a >>> 2, a = a << 30 | u >>> 2, u <<= 30) : m = 0;
      const _2 = i.__unsignedDigit(e2);
      if (_2 > m)
        return JSBI.__absoluteGreater(t);
      if (_2 < m)
        return JSBI.__absoluteLess(t);
    }
    if (a !== 0 || u !== 0) {
      if (b === 0)
        throw new Error("implementation bug");
      return JSBI.__absoluteLess(t);
    }
    return 0;
  }
  static __equalToNumber(i, _) {
    var t = Math.abs;
    return JSBI.__isOneDigitInt(_) ? _ === 0 ? i.length === 0 : i.length === 1 && i.sign === 0 > _ && i.__unsignedDigit(0) === t(_) : JSBI.__compareToDouble(i, _) === 0;
  }
  static __comparisonResultToBool(i, _) {
    return _ === 0 ? 0 > i : _ === 1 ? 0 >= i : _ === 2 ? 0 < i : _ === 3 ? 0 <= i : void 0;
  }
  static __compare(i, _, t) {
    if (i = JSBI.__toPrimitive(i), _ = JSBI.__toPrimitive(_), typeof i == "string" && typeof _ == "string")
      switch (t) {
        case 0:
          return i < _;
        case 1:
          return i <= _;
        case 2:
          return i > _;
        case 3:
          return i >= _;
      }
    if (JSBI.__isBigInt(i) && typeof _ == "string")
      return _ = JSBI.__fromString(_), _ !== null && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
    if (typeof i == "string" && JSBI.__isBigInt(_))
      return i = JSBI.__fromString(i), i !== null && JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
    if (i = JSBI.__toNumeric(i), _ = JSBI.__toNumeric(_), JSBI.__isBigInt(i)) {
      if (JSBI.__isBigInt(_))
        return JSBI.__comparisonResultToBool(JSBI.__compareToBigInt(i, _), t);
      if (typeof _ != "number")
        throw new Error("implementation bug");
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(i, _), t);
    }
    if (typeof i != "number")
      throw new Error("implementation bug");
    if (JSBI.__isBigInt(_))
      return JSBI.__comparisonResultToBool(JSBI.__compareToNumber(_, i), 2 ^ t);
    if (typeof _ != "number")
      throw new Error("implementation bug");
    return t === 0 ? i < _ : t === 1 ? i <= _ : t === 2 ? i > _ : t === 3 ? i >= _ : void 0;
  }
  __clzmsd() {
    return JSBI.__clz30(this.__digit(this.length - 1));
  }
  static __absoluteAdd(_, t, e) {
    if (_.length < t.length)
      return JSBI.__absoluteAdd(t, _, e);
    if (_.length === 0)
      return _;
    if (t.length === 0)
      return _.sign === e ? _ : JSBI.unaryMinus(_);
    let n = _.length;
    (_.__clzmsd() === 0 || t.length === _.length && t.__clzmsd() === 0) && n++;
    const g = new JSBI(n, e);
    let o = 0, s = 0;
    for (; s < t.length; s++) {
      const i = _.__digit(s) + t.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    for (; s < _.length; s++) {
      const i = _.__digit(s) + o;
      o = i >>> 30, g.__setDigit(s, 1073741823 & i);
    }
    return s < g.length && g.__setDigit(s, o), g.__trim();
  }
  static __absoluteSub(_, t, e) {
    if (_.length === 0)
      return _;
    if (t.length === 0)
      return _.sign === e ? _ : JSBI.unaryMinus(_);
    const n = new JSBI(_.length, e);
    let g = 0, o = 0;
    for (; o < t.length; o++) {
      const i = _.__digit(o) - t.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    for (; o < _.length; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    return n.__trim();
  }
  static __absoluteAddOne(_, i, t = null) {
    const e = _.length;
    t === null ? t = new JSBI(e, i) : t.sign = i;
    let n = 1;
    for (let g = 0; g < e; g++) {
      const i2 = _.__digit(g) + n;
      n = i2 >>> 30, t.__setDigit(g, 1073741823 & i2);
    }
    return n != 0 && t.__setDigitGrow(e, 1), t;
  }
  static __absoluteSubOne(_, t) {
    const e = _.length;
    t = t || e;
    const n = new JSBI(t, false);
    let g = 1;
    for (let o = 0; o < e; o++) {
      const i = _.__digit(o) - g;
      g = 1 & i >>> 30, n.__setDigit(o, 1073741823 & i);
    }
    if (g != 0)
      throw new Error("implementation bug");
    for (let g2 = e; g2 < t; g2++)
      n.__setDigit(g2, 0);
    return n;
  }
  static __absoluteAnd(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = o;
    e === null ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & t.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteAndNot(_, t, e = null) {
    const n = _.length, g = t.length;
    let o = g;
    n < g && (o = n);
    let s = n;
    e === null ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) & ~t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteOr(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    e === null ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) | t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteXor(_, t, e = null) {
    let n = _.length, g = t.length, o = g;
    if (n < g) {
      o = n;
      const i = _, e2 = n;
      _ = t, n = g, t = i, g = e2;
    }
    let s = n;
    e === null ? e = new JSBI(s, false) : s = e.length;
    let l = 0;
    for (; l < o; l++)
      e.__setDigit(l, _.__digit(l) ^ t.__digit(l));
    for (; l < n; l++)
      e.__setDigit(l, _.__digit(l));
    for (; l < s; l++)
      e.__setDigit(l, 0);
    return e;
  }
  static __absoluteCompare(_, t) {
    const e = _.length - t.length;
    if (e != 0)
      return e;
    let n = _.length - 1;
    for (; 0 <= n && _.__digit(n) === t.__digit(n); )
      n--;
    return 0 > n ? 0 : _.__unsignedDigit(n) > t.__unsignedDigit(n) ? 1 : -1;
  }
  static __multiplyAccumulate(_, t, e, n) {
    if (t === 0)
      return;
    const g = 32767 & t, o = t >>> 15;
    let s = 0, l = 0;
    for (let r, a = 0; a < _.length; a++, n++) {
      r = e.__digit(n);
      const i = _.__digit(a), t2 = 32767 & i, u = i >>> 15, d = JSBI.__imul(t2, g), h = JSBI.__imul(t2, o), m = JSBI.__imul(u, g), b = JSBI.__imul(u, o);
      r += l + d + s, s = r >>> 30, r &= 1073741823, r += ((32767 & h) << 15) + ((32767 & m) << 15), s += r >>> 30, l = b + (h >>> 15) + (m >>> 15), e.__setDigit(n, 1073741823 & r);
    }
    for (; s != 0 || l !== 0; n++) {
      let i = e.__digit(n);
      i += s + l, l = 0, s = i >>> 30, e.__setDigit(n, 1073741823 & i);
    }
  }
  static __internalMultiplyAdd(_, t, e, g, o) {
    let s = e, l = 0;
    for (let n = 0; n < g; n++) {
      const i = _.__digit(n), e2 = JSBI.__imul(32767 & i, t), g2 = JSBI.__imul(i >>> 15, t), a = e2 + ((32767 & g2) << 15) + l + s;
      s = a >>> 30, l = g2 >>> 15, o.__setDigit(n, 1073741823 & a);
    }
    if (o.length > g)
      for (o.__setDigit(g++, s + l); g < o.length; )
        o.__setDigit(g++, 0);
    else if (s + l !== 0)
      throw new Error("implementation bug");
  }
  __inplaceMultiplyAdd(i, _, t) {
    t > this.length && (t = this.length);
    const e = 32767 & i, n = i >>> 15;
    let g = 0, o = _;
    for (let s = 0; s < t; s++) {
      const i2 = this.__digit(s), _2 = 32767 & i2, t2 = i2 >>> 15, l = JSBI.__imul(_2, e), r = JSBI.__imul(_2, n), a = JSBI.__imul(t2, e), u = JSBI.__imul(t2, n);
      let d = o + l + g;
      g = d >>> 30, d &= 1073741823, d += ((32767 & r) << 15) + ((32767 & a) << 15), g += d >>> 30, o = u + (r >>> 15) + (a >>> 15), this.__setDigit(s, 1073741823 & d);
    }
    if (g != 0 || o !== 0)
      throw new Error("implementation bug");
  }
  static __absoluteDivSmall(_, t, e = null) {
    e === null && (e = new JSBI(_.length, false));
    let n = 0;
    for (let g, o = 2 * _.length - 1; 0 <= o; o -= 2) {
      g = (n << 15 | _.__halfDigit(o)) >>> 0;
      const i = 0 | g / t;
      n = 0 | g % t, g = (n << 15 | _.__halfDigit(o - 1)) >>> 0;
      const s = 0 | g / t;
      n = 0 | g % t, e.__setDigit(o >>> 1, i << 15 | s);
    }
    return e;
  }
  static __absoluteModSmall(_, t) {
    let e = 0;
    for (let n = 2 * _.length - 1; 0 <= n; n--) {
      const i = (e << 15 | _.__halfDigit(n)) >>> 0;
      e = 0 | i % t;
    }
    return e;
  }
  static __absoluteDivLarge(i, _, t, e) {
    const g = _.__halfDigitLength(), n = _.length, o = i.__halfDigitLength() - g;
    let s = null;
    t && (s = new JSBI(o + 2 >>> 1, false), s.__initializeDigits());
    const l = new JSBI(g + 2 >>> 1, false);
    l.__initializeDigits();
    const r = JSBI.__clz15(_.__halfDigit(g - 1));
    0 < r && (_ = JSBI.__specialLeftShift(_, r, 0));
    const a = JSBI.__specialLeftShift(i, r, 1), u = _.__halfDigit(g - 1);
    let d = 0;
    for (let r2, h = o; 0 <= h; h--) {
      r2 = 32767;
      const i2 = a.__halfDigit(h + g);
      if (i2 !== u) {
        const t2 = (i2 << 15 | a.__halfDigit(h + g - 1)) >>> 0;
        r2 = 0 | t2 / u;
        let e3 = 0 | t2 % u;
        const n2 = _.__halfDigit(g - 2), o2 = a.__halfDigit(h + g - 2);
        for (; JSBI.__imul(r2, n2) >>> 0 > (e3 << 16 | o2) >>> 0 && (r2--, e3 += u, !(32767 < e3)); )
          ;
      }
      JSBI.__internalMultiplyAdd(_, r2, 0, n, l);
      let e2 = a.__inplaceSub(l, h, g + 1);
      e2 !== 0 && (e2 = a.__inplaceAdd(_, h, g), a.__setHalfDigit(h + g, 32767 & a.__halfDigit(h + g) + e2), r2--), t && (1 & h ? d = r2 << 15 : s.__setDigit(h >>> 1, d | r2));
    }
    if (e)
      return a.__inplaceRightShift(r), t ? { quotient: s, remainder: a } : a;
    if (t)
      return s;
    throw new Error("unreachable");
  }
  static __clz15(i) {
    return JSBI.__clz30(i) - 15;
  }
  __inplaceAdd(_, t, e) {
    let n = 0;
    for (let g = 0; g < e; g++) {
      const i = this.__halfDigit(t + g) + _.__halfDigit(g) + n;
      n = i >>> 15, this.__setHalfDigit(t + g, 32767 & i);
    }
    return n;
  }
  __inplaceSub(_, t, e) {
    let n = 0;
    if (1 & t) {
      t >>= 1;
      let g = this.__digit(t), o = 32767 & g, s = 0;
      for (; s < e - 1 >>> 1; s++) {
        const i2 = _.__digit(s), e2 = (g >>> 15) - (32767 & i2) - n;
        n = 1 & e2 >>> 15, this.__setDigit(t + s, (32767 & e2) << 15 | 32767 & o), g = this.__digit(t + s + 1), o = (32767 & g) - (i2 >>> 15) - n, n = 1 & o >>> 15;
      }
      const i = _.__digit(s), l = (g >>> 15) - (32767 & i) - n;
      n = 1 & l >>> 15, this.__setDigit(t + s, (32767 & l) << 15 | 32767 & o);
      if (t + s + 1 >= this.length)
        throw new RangeError("out of bounds");
      (1 & e) == 0 && (g = this.__digit(t + s + 1), o = (32767 & g) - (i >>> 15) - n, n = 1 & o >>> 15, this.__setDigit(t + _.length, 1073709056 & g | 32767 & o));
    } else {
      t >>= 1;
      let g = 0;
      for (; g < _.length - 1; g++) {
        const i2 = this.__digit(t + g), e2 = _.__digit(g), o2 = (32767 & i2) - (32767 & e2) - n;
        n = 1 & o2 >>> 15;
        const s2 = (i2 >>> 15) - (e2 >>> 15) - n;
        n = 1 & s2 >>> 15, this.__setDigit(t + g, (32767 & s2) << 15 | 32767 & o2);
      }
      const i = this.__digit(t + g), o = _.__digit(g), s = (32767 & i) - (32767 & o) - n;
      n = 1 & s >>> 15;
      let l = 0;
      (1 & e) == 0 && (l = (i >>> 15) - (o >>> 15) - n, n = 1 & l >>> 15), this.__setDigit(t + g, (32767 & l) << 15 | 32767 & s);
    }
    return n;
  }
  __inplaceRightShift(_) {
    if (_ === 0)
      return;
    let t = this.__digit(0) >>> _;
    const e = this.length - 1;
    for (let n = 0; n < e; n++) {
      const i = this.__digit(n + 1);
      this.__setDigit(n, 1073741823 & i << 30 - _ | t), t = i >>> _;
    }
    this.__setDigit(e, t);
  }
  static __specialLeftShift(_, t, e) {
    const g = _.length, n = new JSBI(g + e, false);
    if (t === 0) {
      for (let t2 = 0; t2 < g; t2++)
        n.__setDigit(t2, _.__digit(t2));
      return 0 < e && n.__setDigit(g, 0), n;
    }
    let o = 0;
    for (let s = 0; s < g; s++) {
      const i = _.__digit(s);
      n.__setDigit(s, 1073741823 & i << t | o), o = i >>> 30 - t;
    }
    return 0 < e && n.__setDigit(g, o), n;
  }
  static __leftShiftByAbsolute(_, i) {
    const t = JSBI.__toShiftAmount(i);
    if (0 > t)
      throw new RangeError("BigInt too big");
    const e = 0 | t / 30, n = t % 30, g = _.length, o = n !== 0 && _.__digit(g - 1) >>> 30 - n != 0, s = g + e + (o ? 1 : 0), l = new JSBI(s, _.sign);
    if (n === 0) {
      let t2 = 0;
      for (; t2 < e; t2++)
        l.__setDigit(t2, 0);
      for (; t2 < s; t2++)
        l.__setDigit(t2, _.__digit(t2 - e));
    } else {
      let t2 = 0;
      for (let _2 = 0; _2 < e; _2++)
        l.__setDigit(_2, 0);
      for (let o2 = 0; o2 < g; o2++) {
        const i2 = _.__digit(o2);
        l.__setDigit(o2 + e, 1073741823 & i2 << n | t2), t2 = i2 >>> 30 - n;
      }
      if (o)
        l.__setDigit(g + e, t2);
      else if (t2 !== 0)
        throw new Error("implementation bug");
    }
    return l.__trim();
  }
  static __rightShiftByAbsolute(_, i) {
    const t = _.length, e = _.sign, n = JSBI.__toShiftAmount(i);
    if (0 > n)
      return JSBI.__rightShiftByMaximum(e);
    const g = 0 | n / 30, o = n % 30;
    let s = t - g;
    if (0 >= s)
      return JSBI.__rightShiftByMaximum(e);
    let l = false;
    if (e) {
      if ((_.__digit(g) & (1 << o) - 1) != 0)
        l = true;
      else
        for (let t2 = 0; t2 < g; t2++)
          if (_.__digit(t2) !== 0) {
            l = true;
            break;
          }
    }
    if (l && o === 0) {
      const i2 = _.__digit(t - 1);
      ~i2 == 0 && s++;
    }
    let r = new JSBI(s, e);
    if (o === 0) {
      r.__setDigit(s - 1, 0);
      for (let e2 = g; e2 < t; e2++)
        r.__setDigit(e2 - g, _.__digit(e2));
    } else {
      let e2 = _.__digit(g) >>> o;
      const n2 = t - g - 1;
      for (let t2 = 0; t2 < n2; t2++) {
        const i2 = _.__digit(t2 + g + 1);
        r.__setDigit(t2, 1073741823 & i2 << 30 - o | e2), e2 = i2 >>> o;
      }
      r.__setDigit(n2, e2);
    }
    return l && (r = JSBI.__absoluteAddOne(r, true, r)), r.__trim();
  }
  static __rightShiftByMaximum(i) {
    return i ? JSBI.__oneDigit(1, true) : JSBI.__zero();
  }
  static __toShiftAmount(i) {
    if (1 < i.length)
      return -1;
    const _ = i.__unsignedDigit(0);
    return _ > JSBI.__kMaxLengthBits ? -1 : _;
  }
  static __toPrimitive(i, _ = "default") {
    if (typeof i != "object")
      return i;
    if (i.constructor === JSBI)
      return i;
    if (typeof Symbol != "undefined" && typeof Symbol.toPrimitive == "symbol") {
      const t2 = i[Symbol.toPrimitive];
      if (t2) {
        const i2 = t2(_);
        if (typeof i2 != "object")
          return i2;
        throw new TypeError("Cannot convert object to primitive value");
      }
    }
    const t = i.valueOf;
    if (t) {
      const _2 = t.call(i);
      if (typeof _2 != "object")
        return _2;
    }
    const e = i.toString;
    if (e) {
      const _2 = e.call(i);
      if (typeof _2 != "object")
        return _2;
    }
    throw new TypeError("Cannot convert object to primitive value");
  }
  static __toNumeric(i) {
    return JSBI.__isBigInt(i) ? i : +i;
  }
  static __isBigInt(i) {
    return typeof i == "object" && i !== null && i.constructor === JSBI;
  }
  static __truncateToNBits(i, _) {
    const t = 0 | (i + 29) / 30, e = new JSBI(t, _.sign), n = t - 1;
    for (let t2 = 0; t2 < n; t2++)
      e.__setDigit(t2, _.__digit(t2));
    let g = _.__digit(n);
    if (i % 30 != 0) {
      const _2 = 32 - i % 30;
      g = g << _2 >>> _2;
    }
    return e.__setDigit(n, g), e.__trim();
  }
  static __truncateAndSubFromPowerOfTwo(_, t, e) {
    var n = Math.min;
    const g = 0 | (_ + 29) / 30, o = new JSBI(g, e);
    let s = 0;
    const l = g - 1;
    let a = 0;
    for (const i = n(l, t.length); s < i; s++) {
      const i2 = 0 - t.__digit(s) - a;
      a = 1 & i2 >>> 30, o.__setDigit(s, 1073741823 & i2);
    }
    for (; s < l; s++)
      o.__setDigit(s, 0 | 1073741823 & -a);
    let u = l < t.length ? t.__digit(l) : 0;
    const d = _ % 30;
    let h;
    if (d == 0)
      h = 0 - u - a, h &= 1073741823;
    else {
      const i = 32 - d;
      u = u << i >>> i;
      const _2 = 1 << 32 - i;
      h = _2 - u - a, h &= _2 - 1;
    }
    return o.__setDigit(l, h), o.__trim();
  }
  __digit(_) {
    return this[_];
  }
  __unsignedDigit(_) {
    return this[_] >>> 0;
  }
  __setDigit(_, i) {
    this[_] = 0 | i;
  }
  __setDigitGrow(_, i) {
    this[_] = 0 | i;
  }
  __halfDigitLength() {
    const i = this.length;
    return 32767 >= this.__unsignedDigit(i - 1) ? 2 * i - 1 : 2 * i;
  }
  __halfDigit(_) {
    return 32767 & this[_ >>> 1] >>> 15 * (1 & _);
  }
  __setHalfDigit(_, i) {
    const t = _ >>> 1, e = this.__digit(t), n = 1 & _ ? 32767 & e | i << 15 : 1073709056 & e | 32767 & i;
    this.__setDigit(t, n);
  }
  static __digitPow(i, _) {
    let t = 1;
    for (; 0 < _; )
      1 & _ && (t *= i), _ >>>= 1, i *= i;
    return t;
  }
  static __isOneDigitInt(i) {
    return (1073741823 & i) === i;
  }
};
JSBI.__kMaxLength = 33554432, JSBI.__kMaxLengthBits = JSBI.__kMaxLength << 5, JSBI.__kMaxBitsPerChar = [0, 0, 32, 51, 64, 75, 83, 90, 96, 102, 107, 111, 115, 119, 122, 126, 128, 131, 134, 136, 139, 141, 143, 145, 147, 149, 151, 153, 154, 156, 158, 159, 160, 162, 163, 165, 166], JSBI.__kBitsPerCharTableShift = 5, JSBI.__kBitsPerCharTableMultiplier = 1 << JSBI.__kBitsPerCharTableShift, JSBI.__kConversionChars = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"], JSBI.__kBitConversionBuffer = new ArrayBuffer(8), JSBI.__kBitConversionDouble = new Float64Array(JSBI.__kBitConversionBuffer), JSBI.__kBitConversionInts = new Int32Array(JSBI.__kBitConversionBuffer), JSBI.__clz30 = Math.clz32 ? function(i) {
  return Math.clz32(i) - 2;
} : function(i) {
  return i === 0 ? 30 : 0 | 29 - (0 | Math.log(i >>> 0) / Math.LN2);
}, JSBI.__imul = Math.imul || function(i, _) {
  return 0 | i * _;
};
var jsbi_default = JSBI;

// node_modules/big.js/big.mjs
init_define_process_env();
var DP = 20;
var RM = 1;
var MAX_DP = 1e6;
var MAX_POWER = 1e6;
var NE = -7;
var PE = 21;
var NAME = "[big.js] ";
var INVALID = NAME + "Invalid ";
var INVALID_DP = INVALID + "decimal places";
var INVALID_RM = INVALID + "rounding mode";
var DIV_BY_ZERO = NAME + "Division by zero";
var P = {};
var UNDEFINED = void 0;
var NUMERIC = /^-?(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
function _Big_() {
  function Big3(n) {
    var x = this;
    if (!(x instanceof Big3))
      return n === UNDEFINED ? _Big_() : new Big3(n);
    if (n instanceof Big3) {
      x.s = n.s;
      x.e = n.e;
      x.c = n.c.slice();
    } else {
      parse(x, n);
    }
    x.constructor = Big3;
  }
  Big3.prototype = P;
  Big3.DP = DP;
  Big3.RM = RM;
  Big3.NE = NE;
  Big3.PE = PE;
  Big3.version = "5.2.2";
  return Big3;
}
function parse(x, n) {
  var e, i, nl;
  if (n === 0 && 1 / n < 0)
    n = "-0";
  else if (!NUMERIC.test(n += ""))
    throw Error(INVALID + "number");
  x.s = n.charAt(0) == "-" ? (n = n.slice(1), -1) : 1;
  if ((e = n.indexOf(".")) > -1)
    n = n.replace(".", "");
  if ((i = n.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +n.slice(i + 1);
    n = n.substring(0, i);
  } else if (e < 0) {
    e = n.length;
  }
  nl = n.length;
  for (i = 0; i < nl && n.charAt(i) == "0"; )
    ++i;
  if (i == nl) {
    x.c = [x.e = 0];
  } else {
    for (; nl > 0 && n.charAt(--nl) == "0"; )
      ;
    x.e = e - i - 1;
    x.c = [];
    for (e = 0; i <= nl; )
      x.c[e++] = +n.charAt(i++);
  }
  return x;
}
function round(x, dp, rm, more) {
  var xc = x.c, i = x.e + dp + 1;
  if (i < xc.length) {
    if (rm === 1) {
      more = xc[i] >= 5;
    } else if (rm === 2) {
      more = xc[i] > 5 || xc[i] == 5 && (more || i < 0 || xc[i + 1] !== UNDEFINED || xc[i - 1] & 1);
    } else if (rm === 3) {
      more = more || !!xc[0];
    } else {
      more = false;
      if (rm !== 0)
        throw Error(INVALID_RM);
    }
    if (i < 1) {
      xc.length = 1;
      if (more) {
        x.e = -dp;
        xc[0] = 1;
      } else {
        xc[0] = x.e = 0;
      }
    } else {
      xc.length = i--;
      if (more) {
        for (; ++xc[i] > 9; ) {
          xc[i] = 0;
          if (!i--) {
            ++x.e;
            xc.unshift(1);
          }
        }
      }
      for (i = xc.length; !xc[--i]; )
        xc.pop();
    }
  } else if (rm < 0 || rm > 3 || rm !== ~~rm) {
    throw Error(INVALID_RM);
  }
  return x;
}
function stringify(x, id, n, k) {
  var e, s, Big3 = x.constructor, z = !x.c[0];
  if (n !== UNDEFINED) {
    if (n !== ~~n || n < (id == 3) || n > MAX_DP) {
      throw Error(id == 3 ? INVALID + "precision" : INVALID_DP);
    }
    x = new Big3(x);
    n = k - x.e;
    if (x.c.length > ++k)
      round(x, n, Big3.RM);
    if (id == 2)
      k = x.e + n + 1;
    for (; x.c.length < k; )
      x.c.push(0);
  }
  e = x.e;
  s = x.c.join("");
  n = s.length;
  if (id != 2 && (id == 1 || id == 3 && k <= e || e <= Big3.NE || e >= Big3.PE)) {
    s = s.charAt(0) + (n > 1 ? "." + s.slice(1) : "") + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    for (; ++e; )
      s = "0" + s;
    s = "0." + s;
  } else if (e > 0) {
    if (++e > n)
      for (e -= n; e--; )
        s += "0";
    else if (e < n)
      s = s.slice(0, e) + "." + s.slice(e);
  } else if (n > 1) {
    s = s.charAt(0) + "." + s.slice(1);
  }
  return x.s < 0 && (!z || id == 4) ? "-" + s : s;
}
P.abs = function() {
  var x = new this.constructor(this);
  x.s = 1;
  return x;
};
P.cmp = function(y) {
  var isneg, x = this, xc = x.c, yc = (y = new x.constructor(y)).c, i = x.s, j = y.s, k = x.e, l = y.e;
  if (!xc[0] || !yc[0])
    return !xc[0] ? !yc[0] ? 0 : -j : i;
  if (i != j)
    return i;
  isneg = i < 0;
  if (k != l)
    return k > l ^ isneg ? 1 : -1;
  j = (k = xc.length) < (l = yc.length) ? k : l;
  for (i = -1; ++i < j; ) {
    if (xc[i] != yc[i])
      return xc[i] > yc[i] ^ isneg ? 1 : -1;
  }
  return k == l ? 0 : k > l ^ isneg ? 1 : -1;
};
P.div = function(y) {
  var x = this, Big3 = x.constructor, a = x.c, b = (y = new Big3(y)).c, k = x.s == y.s ? 1 : -1, dp = Big3.DP;
  if (dp !== ~~dp || dp < 0 || dp > MAX_DP)
    throw Error(INVALID_DP);
  if (!b[0])
    throw Error(DIV_BY_ZERO);
  if (!a[0])
    return new Big3(k * 0);
  var bl, bt, n, cmp, ri, bz = b.slice(), ai = bl = b.length, al = a.length, r = a.slice(0, bl), rl = r.length, q = y, qc = q.c = [], qi = 0, d = dp + (q.e = x.e - y.e) + 1;
  q.s = k;
  k = d < 0 ? 0 : d;
  bz.unshift(0);
  for (; rl++ < bl; )
    r.push(0);
  do {
    for (n = 0; n < 10; n++) {
      if (bl != (rl = r.length)) {
        cmp = bl > rl ? 1 : -1;
      } else {
        for (ri = -1, cmp = 0; ++ri < bl; ) {
          if (b[ri] != r[ri]) {
            cmp = b[ri] > r[ri] ? 1 : -1;
            break;
          }
        }
      }
      if (cmp < 0) {
        for (bt = rl == bl ? b : bz; rl; ) {
          if (r[--rl] < bt[rl]) {
            ri = rl;
            for (; ri && !r[--ri]; )
              r[ri] = 9;
            --r[ri];
            r[rl] += 10;
          }
          r[rl] -= bt[rl];
        }
        for (; !r[0]; )
          r.shift();
      } else {
        break;
      }
    }
    qc[qi++] = cmp ? n : ++n;
    if (r[0] && cmp)
      r[rl] = a[ai] || 0;
    else
      r = [a[ai]];
  } while ((ai++ < al || r[0] !== UNDEFINED) && k--);
  if (!qc[0] && qi != 1) {
    qc.shift();
    q.e--;
  }
  if (qi > d)
    round(q, dp, Big3.RM, r[0] !== UNDEFINED);
  return q;
};
P.eq = function(y) {
  return !this.cmp(y);
};
P.gt = function(y) {
  return this.cmp(y) > 0;
};
P.gte = function(y) {
  return this.cmp(y) > -1;
};
P.lt = function(y) {
  return this.cmp(y) < 0;
};
P.lte = function(y) {
  return this.cmp(y) < 1;
};
P.minus = P.sub = function(y) {
  var i, j, t, xlty, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (a != b) {
    y.s = -b;
    return x.plus(y);
  }
  var xc = x.c.slice(), xe = x.e, yc = y.c, ye = y.e;
  if (!xc[0] || !yc[0]) {
    return yc[0] ? (y.s = -b, y) : new Big3(xc[0] ? x : 0);
  }
  if (a = xe - ye) {
    if (xlty = a < 0) {
      a = -a;
      t = xc;
    } else {
      ye = xe;
      t = yc;
    }
    t.reverse();
    for (b = a; b--; )
      t.push(0);
    t.reverse();
  } else {
    j = ((xlty = xc.length < yc.length) ? xc : yc).length;
    for (a = b = 0; b < j; b++) {
      if (xc[b] != yc[b]) {
        xlty = xc[b] < yc[b];
        break;
      }
    }
  }
  if (xlty) {
    t = xc;
    xc = yc;
    yc = t;
    y.s = -y.s;
  }
  if ((b = (j = yc.length) - (i = xc.length)) > 0)
    for (; b--; )
      xc[i++] = 0;
  for (b = i; j > a; ) {
    if (xc[--j] < yc[j]) {
      for (i = j; i && !xc[--i]; )
        xc[i] = 9;
      --xc[i];
      xc[j] += 10;
    }
    xc[j] -= yc[j];
  }
  for (; xc[--b] === 0; )
    xc.pop();
  for (; xc[0] === 0; ) {
    xc.shift();
    --ye;
  }
  if (!xc[0]) {
    y.s = 1;
    xc = [ye = 0];
  }
  y.c = xc;
  y.e = ye;
  return y;
};
P.mod = function(y) {
  var ygtx, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (!y.c[0])
    throw Error(DIV_BY_ZERO);
  x.s = y.s = 1;
  ygtx = y.cmp(x) == 1;
  x.s = a;
  y.s = b;
  if (ygtx)
    return new Big3(x);
  a = Big3.DP;
  b = Big3.RM;
  Big3.DP = Big3.RM = 0;
  x = x.div(y);
  Big3.DP = a;
  Big3.RM = b;
  return this.minus(x.times(y));
};
P.plus = P.add = function(y) {
  var t, x = this, Big3 = x.constructor, a = x.s, b = (y = new Big3(y)).s;
  if (a != b) {
    y.s = -b;
    return x.minus(y);
  }
  var xe = x.e, xc = x.c, ye = y.e, yc = y.c;
  if (!xc[0] || !yc[0])
    return yc[0] ? y : new Big3(xc[0] ? x : a * 0);
  xc = xc.slice();
  if (a = xe - ye) {
    if (a > 0) {
      ye = xe;
      t = yc;
    } else {
      a = -a;
      t = xc;
    }
    t.reverse();
    for (; a--; )
      t.push(0);
    t.reverse();
  }
  if (xc.length - yc.length < 0) {
    t = yc;
    yc = xc;
    xc = t;
  }
  a = yc.length;
  for (b = 0; a; xc[a] %= 10)
    b = (xc[--a] = xc[a] + yc[a] + b) / 10 | 0;
  if (b) {
    xc.unshift(b);
    ++ye;
  }
  for (a = xc.length; xc[--a] === 0; )
    xc.pop();
  y.c = xc;
  y.e = ye;
  return y;
};
P.pow = function(n) {
  var x = this, one = new x.constructor(1), y = one, isneg = n < 0;
  if (n !== ~~n || n < -MAX_POWER || n > MAX_POWER)
    throw Error(INVALID + "exponent");
  if (isneg)
    n = -n;
  for (; ; ) {
    if (n & 1)
      y = y.times(x);
    n >>= 1;
    if (!n)
      break;
    x = x.times(x);
  }
  return isneg ? one.div(y) : y;
};
P.round = function(dp, rm) {
  var Big3 = this.constructor;
  if (dp === UNDEFINED)
    dp = 0;
  else if (dp !== ~~dp || dp < -MAX_DP || dp > MAX_DP)
    throw Error(INVALID_DP);
  return round(new Big3(this), dp, rm === UNDEFINED ? Big3.RM : rm);
};
P.sqrt = function() {
  var r, c, t, x = this, Big3 = x.constructor, s = x.s, e = x.e, half = new Big3(0.5);
  if (!x.c[0])
    return new Big3(x);
  if (s < 0)
    throw Error(NAME + "No square root");
  s = Math.sqrt(x + "");
  if (s === 0 || s === 1 / 0) {
    c = x.c.join("");
    if (!(c.length + e & 1))
      c += "0";
    s = Math.sqrt(c);
    e = ((e + 1) / 2 | 0) - (e < 0 || e & 1);
    r = new Big3((s == 1 / 0 ? "1e" : (s = s.toExponential()).slice(0, s.indexOf("e") + 1)) + e);
  } else {
    r = new Big3(s);
  }
  e = r.e + (Big3.DP += 4);
  do {
    t = r;
    r = half.times(t.plus(x.div(t)));
  } while (t.c.slice(0, e).join("") !== r.c.slice(0, e).join(""));
  return round(r, Big3.DP -= 4, Big3.RM);
};
P.times = P.mul = function(y) {
  var c, x = this, Big3 = x.constructor, xc = x.c, yc = (y = new Big3(y)).c, a = xc.length, b = yc.length, i = x.e, j = y.e;
  y.s = x.s == y.s ? 1 : -1;
  if (!xc[0] || !yc[0])
    return new Big3(y.s * 0);
  y.e = i + j;
  if (a < b) {
    c = xc;
    xc = yc;
    yc = c;
    j = a;
    a = b;
    b = j;
  }
  for (c = new Array(j = a + b); j--; )
    c[j] = 0;
  for (i = b; i--; ) {
    b = 0;
    for (j = a + i; j > i; ) {
      b = c[j] + yc[i] * xc[j - i - 1] + b;
      c[j--] = b % 10;
      b = b / 10 | 0;
    }
    c[j] = (c[j] + b) % 10;
  }
  if (b)
    ++y.e;
  else
    c.shift();
  for (i = c.length; !c[--i]; )
    c.pop();
  y.c = c;
  return y;
};
P.toExponential = function(dp) {
  return stringify(this, 1, dp, dp);
};
P.toFixed = function(dp) {
  return stringify(this, 2, dp, this.e + dp);
};
P.toPrecision = function(sd) {
  return stringify(this, 3, sd, sd - 1);
};
P.toString = function() {
  return stringify(this);
};
P.valueOf = P.toJSON = function() {
  return stringify(this, 4);
};
var Big = _Big_();
var big_default = Big;

// node_modules/@uniswap/sdk/dist/sdk.esm.js
var import_toformat = __toModule(require_toFormat());

// node_modules/decimal.js-light/decimal.mjs
init_define_process_env();
var MAX_DIGITS = 1e9;
var defaults = {
  precision: 20,
  rounding: 4,
  toExpNeg: -7,
  toExpPos: 21,
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
};
var Decimal;
var external = true;
var decimalError = "[DecimalError] ";
var invalidArgument = decimalError + "Invalid argument: ";
var exponentOutOfRange = decimalError + "Exponent out of range: ";
var mathfloor = Math.floor;
var mathpow = Math.pow;
var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
var ONE;
var BASE = 1e7;
var LOG_BASE = 7;
var MAX_SAFE_INTEGER = 9007199254740991;
var MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE);
var P2 = {};
P2.absoluteValue = P2.abs = function() {
  var x = new this.constructor(this);
  if (x.s)
    x.s = 1;
  return x;
};
P2.comparedTo = P2.cmp = function(y) {
  var i, j, xdL, ydL, x = this;
  y = new x.constructor(y);
  if (x.s !== y.s)
    return x.s || -y.s;
  if (x.e !== y.e)
    return x.e > y.e ^ x.s < 0 ? 1 : -1;
  xdL = x.d.length;
  ydL = y.d.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x.d[i] !== y.d[i])
      return x.d[i] > y.d[i] ^ x.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x.s < 0 ? 1 : -1;
};
P2.decimalPlaces = P2.dp = function() {
  var x = this, w = x.d.length - 1, dp = (w - x.e) * LOG_BASE;
  w = x.d[w];
  if (w)
    for (; w % 10 == 0; w /= 10)
      dp--;
  return dp < 0 ? 0 : dp;
};
P2.dividedBy = P2.div = function(y) {
  return divide(this, new this.constructor(y));
};
P2.dividedToIntegerBy = P2.idiv = function(y) {
  var x = this, Ctor = x.constructor;
  return round2(divide(x, new Ctor(y), 0, 1), Ctor.precision);
};
P2.equals = P2.eq = function(y) {
  return !this.cmp(y);
};
P2.exponent = function() {
  return getBase10Exponent(this);
};
P2.greaterThan = P2.gt = function(y) {
  return this.cmp(y) > 0;
};
P2.greaterThanOrEqualTo = P2.gte = function(y) {
  return this.cmp(y) >= 0;
};
P2.isInteger = P2.isint = function() {
  return this.e > this.d.length - 2;
};
P2.isNegative = P2.isneg = function() {
  return this.s < 0;
};
P2.isPositive = P2.ispos = function() {
  return this.s > 0;
};
P2.isZero = function() {
  return this.s === 0;
};
P2.lessThan = P2.lt = function(y) {
  return this.cmp(y) < 0;
};
P2.lessThanOrEqualTo = P2.lte = function(y) {
  return this.cmp(y) < 1;
};
P2.logarithm = P2.log = function(base) {
  var r, x = this, Ctor = x.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE))
      throw Error(decimalError + "NaN");
  }
  if (x.s < 1)
    throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE))
    return new Ctor(0);
  external = false;
  r = divide(ln(x, wpr), ln(base, wpr), wpr);
  external = true;
  return round2(r, pr);
};
P2.minus = P2.sub = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? subtract(x, y) : add(x, (y.s = -y.s, y));
};
P2.modulo = P2.mod = function(y) {
  var q, x = this, Ctor = x.constructor, pr = Ctor.precision;
  y = new Ctor(y);
  if (!y.s)
    throw Error(decimalError + "NaN");
  if (!x.s)
    return round2(new Ctor(x), pr);
  external = false;
  q = divide(x, y, 0, 1).times(y);
  external = true;
  return x.minus(q);
};
P2.naturalExponential = P2.exp = function() {
  return exp(this);
};
P2.naturalLogarithm = P2.ln = function() {
  return ln(this);
};
P2.negated = P2.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s || 0;
  return x;
};
P2.plus = P2.add = function(y) {
  var x = this;
  y = new x.constructor(y);
  return x.s == y.s ? add(x, y) : subtract(x, (y.s = -y.s, y));
};
P2.precision = P2.sd = function(z) {
  var e, sd, w, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  e = getBase10Exponent(x) + 1;
  w = x.d.length - 1;
  sd = w * LOG_BASE + 1;
  w = x.d[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      sd--;
    for (w = x.d[0]; w >= 10; w /= 10)
      sd++;
  }
  return z && e > sd ? e : sd;
};
P2.squareRoot = P2.sqrt = function() {
  var e, n, pr, r, s, t, wpr, x = this, Ctor = x.constructor;
  if (x.s < 1) {
    if (!x.s)
      return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e = getBase10Exponent(x);
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(x.d);
    if ((n.length + e) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
    if (s == 1 / 0) {
      n = "5e" + e;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  pr = Ctor.precision;
  s = wpr = pr + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide(x, t, wpr + 2)).times(0.5);
    if (digitsToString(t.d).slice(0, wpr) === (n = digitsToString(r.d)).slice(0, wpr)) {
      n = n.slice(wpr - 3, wpr + 1);
      if (s == wpr && n == "4999") {
        round2(t, pr + 1, 0);
        if (t.times(t).eq(x)) {
          r = t;
          break;
        }
      } else if (n != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round2(r, pr);
};
P2.times = P2.mul = function(y) {
  var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  if (!x.s || !y.s)
    return new Ctor(0);
  y.s *= x.s;
  e = x.e + y.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k = xdL + i; k > i; ) {
      t = r[k] + yd[i] * xd[k - i - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e;
  else
    r.shift();
  y.d = r;
  y.e = e;
  return external ? round2(y, Ctor.precision) : y;
};
P2.toDecimalPlaces = P2.todp = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return round2(x, dp + getBase10Exponent(x) + 1, rm);
};
P2.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = toString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = round2(new Ctor(x), dp + 1, rm);
    str = toString(x, true, dp + 1);
  }
  return str;
};
P2.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0)
    return toString(x);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  y = round2(new Ctor(x), dp + getBase10Exponent(x) + 1, rm);
  str = toString(y.abs(), false, dp + getBase10Exponent(y) + 1);
  return x.isneg() && !x.isZero() ? "-" + str : str;
};
P2.toInteger = P2.toint = function() {
  var x = this, Ctor = x.constructor;
  return round2(new Ctor(x), getBase10Exponent(x) + 1, Ctor.rounding);
};
P2.toNumber = function() {
  return +this;
};
P2.toPower = P2.pow = function(y) {
  var e, k, pr, r, sign, yIsInt, x = this, Ctor = x.constructor, guard = 12, yn = +(y = new Ctor(y));
  if (!y.s)
    return new Ctor(ONE);
  x = new Ctor(x);
  if (!x.s) {
    if (y.s < 1)
      throw Error(decimalError + "Infinity");
    return x;
  }
  if (x.eq(ONE))
    return x;
  pr = Ctor.precision;
  if (y.eq(ONE))
    return round2(x, pr);
  e = y.e;
  k = y.d.length - 1;
  yIsInt = e >= k;
  sign = x.s;
  if (!yIsInt) {
    if (sign < 0)
      throw Error(decimalError + "NaN");
  } else if ((k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = new Ctor(ONE);
    e = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k % 2) {
        r = r.times(x);
        truncate(r.d, e);
      }
      k = mathfloor(k / 2);
      if (k === 0)
        break;
      x = x.times(x);
      truncate(x.d, e);
    }
    external = true;
    return y.s < 0 ? new Ctor(ONE).div(r) : round2(r, pr);
  }
  sign = sign < 0 && y.d[Math.max(e, k)] & 1 ? -1 : 1;
  x.s = 1;
  external = false;
  r = y.times(ln(x, pr + guard));
  external = true;
  r = exp(r);
  r.s = sign;
  return r;
};
P2.toPrecision = function(sd, rm) {
  var e, str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    e = getBase10Exponent(x);
    str = toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = round2(new Ctor(x), sd, rm);
    e = getBase10Exponent(x);
    str = toString(x, sd <= e || e <= Ctor.toExpNeg, sd);
  }
  return str;
};
P2.toSignificantDigits = P2.tosd = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return round2(new Ctor(x), sd, rm);
};
P2.toString = P2.valueOf = P2.val = P2.toJSON = P2[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x = this, e = getBase10Exponent(x), Ctor = x.constructor;
  return toString(x, e <= Ctor.toExpNeg || e >= Ctor.toExpPos);
};
function add(x, y) {
  var carry, d, e, i, k, len, xd, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (!y.s)
      y = new Ctor(x);
    return external ? round2(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  k = x.e;
  e = y.e;
  xd = xd.slice();
  i = k - e;
  if (i) {
    if (i < 0) {
      d = xd;
      i = -i;
      len = yd.length;
    } else {
      d = yd;
      e = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i > len) {
      i = len;
      d.length = 1;
    }
    d.reverse();
    for (; i--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = e;
  return external ? round2(y, pr) : y;
}
function checkInt32(i, min, max) {
  if (i !== ~~i || i < min || i > max) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d) {
  var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d[i] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
var divide = function() {
  function multiplyInteger(x, k) {
    var temp, carry = 0, i = x.length;
    for (x = x.slice(); i--; ) {
      temp = x[i] * k + carry;
      x[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare(a, b, aL, bL) {
    var i, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i = r = 0; i < aL; i++) {
        if (a[i] != b[i]) {
          r = a[i] > b[i] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL) {
    var i = 0;
    for (; aL--; ) {
      a[aL] -= i;
      i = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i * BASE + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, dp) {
    var cmp, e, i, k, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!x.s)
      return new Ctor(x);
    if (!y.s)
      throw Error(decimalError + "Division by zero");
    e = x.e - y.e;
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign);
    qd = q.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); )
      ++i;
    if (yd[i] > (xd[i] || 0))
      --e;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x) - getBase10Exponent(y)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0)
      return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k = 0;
      yd = yd[0];
      sd++;
      for (; (i < xL || k) && sd--; i++) {
        t = k * BASE + (xd[i] || 0);
        qd[i] = t / yd | 0;
        k = t % yd | 0;
      }
    } else {
      k = BASE / (yd[0] + 1) | 0;
      if (k > 1) {
        yd = multiplyInteger(yd, k);
        xd = multiplyInteger(xd, k);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; )
        rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2)
        ++yd0;
      do {
        k = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL)
            rem0 = rem0 * BASE + (rem[1] || 0);
          k = rem0 / yd0 | 0;
          if (k > 1) {
            if (k >= BASE)
              k = BASE - 1;
            prod = multiplyInteger(yd, k);
            prodL = prod.length;
            remL = rem.length;
            cmp = compare(prod, rem, prodL, remL);
            if (cmp == 1) {
              k--;
              subtract2(prod, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k == 0)
              cmp = k = 1;
            prod = yd.slice();
          }
          prodL = prod.length;
          if (prodL < remL)
            prod.unshift(0);
          subtract2(rem, prod, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k++;
          rem = [0];
        }
        qd[i++] = k;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0])
      qd.shift();
    q.e = e;
    return round2(q, dp ? pr + getBase10Exponent(q) + 1 : pr);
  };
}();
function exp(x, sd) {
  var denominator, guard, pow, sum, t, wpr, i = 0, k = 0, Ctor = x.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x) > 16)
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  if (!x.s)
    return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.abs().gte(0.1)) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow = sum = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow = round2(pow.times(x), wpr);
    denominator = denominator.times(++i);
    t = sum.plus(divide(pow, denominator, wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      while (k--)
        sum = round2(sum.times(sum), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum, pr)) : sum;
    }
    sum = t;
  }
}
function getBase10Exponent(x) {
  var e = x.e * LOG_BASE, w = x.d[0];
  for (; w >= 10; w /= 10)
    e++;
  return e;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round2(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function ln(y, sd) {
  var c, c0, denominator, e, numerator, sum, t, wpr, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, pr = Ctor.precision;
  if (x.s < 1)
    throw Error(decimalError + (x.s ? "NaN" : "-Infinity"));
  if (x.eq(ONE))
    return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x.eq(10)) {
    if (sd == null)
      external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  e = getBase10Exponent(x);
  if (Math.abs(e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e = getBase10Exponent(x);
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e + "");
    x = ln(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? (external = true, round2(x, pr)) : x;
  }
  sum = numerator = x = divide(x.minus(ONE), x.plus(ONE), wpr);
  x2 = round2(x.times(x), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round2(numerator.times(x2), wpr);
    t = sum.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {
      sum = sum.times(2);
      if (e !== 0)
        sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
      sum = divide(sum, new Ctor(n), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round2(sum, pr)) : sum;
    }
    sum = t;
    denominator += 2;
  }
}
function parseDecimal(x, str) {
  var e, i, len;
  if ((e = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e < 0)
      e = i;
    e += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e < 0) {
    e = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; )
    ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; )
    --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e = e - i - 1;
    x.e = mathfloor(e / LOG_BASE);
    x.d = [];
    i = (e + 1) % LOG_BASE;
    if (e < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x.d.push(+str);
    if (external && (x.e > MAX_E || x.e < -MAX_E))
      throw Error(exponentOutOfRange + e);
  } else {
    x.s = 0;
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function round2(x, sd, rm) {
  var i, j, k, n, rd, doRound, w, xdi, xd = x.d;
  for (n = 1, k = xd[0]; k >= 10; k /= 10)
    n++;
  i = sd - n;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k = xd.length;
    if (xdi >= k)
      return x;
    w = k = xd[xdi];
    for (n = 1; k >= 10; k /= 10)
      n++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n;
  }
  if (rm !== void 0) {
    k = mathpow(10, n - j - 1);
    rd = w / k % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w % k;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, n - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k = getBase10Exponent(x);
      xd.length = 1;
      sd = sd - k - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x.e = x.s = 0;
    }
    return x;
  }
  if (i == 0) {
    xd.length = xdi;
    k = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w / mathpow(10, n - j) % mathpow(10, j) | 0) * k : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k) == BASE) {
          xd[0] = 1;
          ++x.e;
        }
        break;
      } else {
        xd[xdi] += k;
        if (xd[xdi] != BASE)
          break;
        xd[xdi--] = 0;
        k = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; )
    xd.pop();
  if (external && (x.e > MAX_E || x.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x));
  }
  return x;
}
function subtract(x, y) {
  var d, e, i, j, k, len, xd, xe, xLTy, yd, Ctor = x.constructor, pr = Ctor.precision;
  if (!x.s || !y.s) {
    if (y.s)
      y.s = -y.s;
    else
      y = new Ctor(x);
    return external ? round2(y, pr) : y;
  }
  xd = x.d;
  yd = y.d;
  e = y.e;
  xe = x.e;
  xd = xd.slice();
  k = xe - e;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i) {
      k = i;
      d.length = 1;
    }
    d.reverse();
    for (i = k; i--; )
      d.push(0);
    d.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e;
  if (!xd[0])
    return new Ctor(0);
  y.d = xd;
  y.e = e;
  return external ? round2(y, pr) : y;
}
function toString(x, isExp, sd) {
  var k, e = getBase10Exponent(x), str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e < 0 ? "e" : "e+") + e;
  } else if (e < 0) {
    str = "0." + getZeroString(-e - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e >= len) {
    str += getZeroString(e + 1 - len);
    if (sd && (k = sd - e - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i, p, ps;
  function Decimal3(value) {
    var x = this;
    if (!(x instanceof Decimal3))
      return new Decimal3(value);
    x.constructor = Decimal3;
    if (value instanceof Decimal3) {
      x.s = value.s;
      x.e = value.e;
      x.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x.s = 1;
      } else if (value < 0) {
        value = -value;
        x.s = -1;
      } else {
        x.s = 0;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x.e = 0;
        x.d = [value];
        return;
      }
      return parseDecimal(x, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x.s = -1;
    } else {
      x.s = 1;
    }
    if (isDecimal.test(value))
      parseDecimal(x, value);
    else
      throw Error(invalidArgument + value);
  }
  Decimal3.prototype = P2;
  Decimal3.ROUND_UP = 0;
  Decimal3.ROUND_DOWN = 1;
  Decimal3.ROUND_CEIL = 2;
  Decimal3.ROUND_FLOOR = 3;
  Decimal3.ROUND_HALF_UP = 4;
  Decimal3.ROUND_HALF_DOWN = 5;
  Decimal3.ROUND_HALF_EVEN = 6;
  Decimal3.ROUND_HALF_CEIL = 7;
  Decimal3.ROUND_HALF_FLOOR = 8;
  Decimal3.clone = clone;
  Decimal3.config = Decimal3.set = config;
  if (obj === void 0)
    obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; )
      if (!obj.hasOwnProperty(p = ps[i++]))
        obj[p] = this[p];
  }
  Decimal3.config(obj);
  return Decimal3;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p, v, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v = obj[p = ps[i]]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if ((v = obj[p = "LN10"]) !== void 0) {
    if (v == Math.LN10)
      this[p] = new this(v);
    else
      throw Error(invalidArgument + p + ": " + v);
  }
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
var decimal_default = Decimal;

// node_modules/@uniswap/v2-core/build/IUniswapV2Pair.json
var abi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Swap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      }
    ],
    name: "Sync",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "MINIMUM_LIQUIDITY",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "burn",
    outputs: [
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getReserves",
    outputs: [
      {
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "blockTimestampLast",
        type: "uint32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "kLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "liquidity",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "price0CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "price1CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "skim",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "swap",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "sync",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token0",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token1",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
var evm = {
  bytecode: {
    linkReferences: {},
    object: "",
    opcodes: "",
    sourceMap: ""
  },
  deployedBytecode: {
    linkReferences: {},
    object: "",
    opcodes: "",
    sourceMap: ""
  }
};
var metadata = '{"compiler":{"version":"0.5.16+commit.9c3226ce"},"language":"Solidity","output":{"abi":[{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"owner","type":"address"},{"indexed":true,"internalType":"address","name":"spender","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Approval","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"},{"indexed":true,"internalType":"address","name":"to","type":"address"}],"name":"Burn","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1","type":"uint256"}],"name":"Mint","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"sender","type":"address"},{"indexed":false,"internalType":"uint256","name":"amount0In","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1In","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount0Out","type":"uint256"},{"indexed":false,"internalType":"uint256","name":"amount1Out","type":"uint256"},{"indexed":true,"internalType":"address","name":"to","type":"address"}],"name":"Swap","type":"event"},{"anonymous":false,"inputs":[{"indexed":false,"internalType":"uint112","name":"reserve0","type":"uint112"},{"indexed":false,"internalType":"uint112","name":"reserve1","type":"uint112"}],"name":"Sync","type":"event"},{"anonymous":false,"inputs":[{"indexed":true,"internalType":"address","name":"from","type":"address"},{"indexed":true,"internalType":"address","name":"to","type":"address"},{"indexed":false,"internalType":"uint256","name":"value","type":"uint256"}],"name":"Transfer","type":"event"},{"constant":true,"inputs":[],"name":"DOMAIN_SEPARATOR","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"MINIMUM_LIQUIDITY","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[],"name":"PERMIT_TYPEHASH","outputs":[{"internalType":"bytes32","name":"","type":"bytes32"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"}],"name":"allowance","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"approve","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"balanceOf","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"burn","outputs":[{"internalType":"uint256","name":"amount0","type":"uint256"},{"internalType":"uint256","name":"amount1","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"decimals","outputs":[{"internalType":"uint8","name":"","type":"uint8"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[],"name":"factory","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"getReserves","outputs":[{"internalType":"uint112","name":"reserve0","type":"uint112"},{"internalType":"uint112","name":"reserve1","type":"uint112"},{"internalType":"uint32","name":"blockTimestampLast","type":"uint32"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"","type":"address"},{"internalType":"address","name":"","type":"address"}],"name":"initialize","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"kLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"mint","outputs":[{"internalType":"uint256","name":"liquidity","type":"uint256"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"name","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":true,"inputs":[{"internalType":"address","name":"owner","type":"address"}],"name":"nonces","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"owner","type":"address"},{"internalType":"address","name":"spender","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"},{"internalType":"uint256","name":"deadline","type":"uint256"},{"internalType":"uint8","name":"v","type":"uint8"},{"internalType":"bytes32","name":"r","type":"bytes32"},{"internalType":"bytes32","name":"s","type":"bytes32"}],"name":"permit","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"price0CumulativeLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"price1CumulativeLast","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"}],"name":"skim","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"uint256","name":"amount0Out","type":"uint256"},{"internalType":"uint256","name":"amount1Out","type":"uint256"},{"internalType":"address","name":"to","type":"address"},{"internalType":"bytes","name":"data","type":"bytes"}],"name":"swap","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"symbol","outputs":[{"internalType":"string","name":"","type":"string"}],"payable":false,"stateMutability":"pure","type":"function"},{"constant":false,"inputs":[],"name":"sync","outputs":[],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":true,"inputs":[],"name":"token0","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"token1","outputs":[{"internalType":"address","name":"","type":"address"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":true,"inputs":[],"name":"totalSupply","outputs":[{"internalType":"uint256","name":"","type":"uint256"}],"payable":false,"stateMutability":"view","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transfer","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"},{"constant":false,"inputs":[{"internalType":"address","name":"from","type":"address"},{"internalType":"address","name":"to","type":"address"},{"internalType":"uint256","name":"value","type":"uint256"}],"name":"transferFrom","outputs":[{"internalType":"bool","name":"","type":"bool"}],"payable":false,"stateMutability":"nonpayable","type":"function"}],"devdoc":{"methods":{}},"userdoc":{"methods":{}}},"settings":{"compilationTarget":{"contracts/interfaces/IUniswapV2Pair.sol":"IUniswapV2Pair"},"evmVersion":"istanbul","libraries":{},"optimizer":{"enabled":true,"runs":999999},"remappings":[]},"sources":{"contracts/interfaces/IUniswapV2Pair.sol":{"keccak256":"0x7c9bc70e5996c763e02ff38905282bc24fb242b0ef2519a003b36824fc524a4b","urls":["bzz-raw://85d5ad2dd23ee127f40907a12865a1e8cb5828814f6f2480285e1827dd72dedf","dweb:/ipfs/QmayKQWJgWmr46DqWseADyUanmqxh662hPNdAkdHRjiQQH"]}},"version":1}';
var interface2 = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "sender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1In",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "Swap",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        indexed: false,
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      }
    ],
    name: "Sync",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    constant: true,
    inputs: [],
    name: "DOMAIN_SEPARATOR",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "MINIMUM_LIQUIDITY",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "PERMIT_TYPEHASH",
    outputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      }
    ],
    name: "allowance",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "approve",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "burn",
    outputs: [
      {
        internalType: "uint256",
        name: "amount0",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        internalType: "uint8",
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "factory",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "getReserves",
    outputs: [
      {
        internalType: "uint112",
        name: "reserve0",
        type: "uint112"
      },
      {
        internalType: "uint112",
        name: "reserve1",
        type: "uint112"
      },
      {
        internalType: "uint32",
        name: "blockTimestampLast",
        type: "uint32"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      },
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    name: "initialize",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "kLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "mint",
    outputs: [
      {
        internalType: "uint256",
        name: "liquidity",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "nonces",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "deadline",
        type: "uint256"
      },
      {
        internalType: "uint8",
        name: "v",
        type: "uint8"
      },
      {
        internalType: "bytes32",
        name: "r",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "s",
        type: "bytes32"
      }
    ],
    name: "permit",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "price0CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "price1CumulativeLast",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "skim",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "uint256",
        name: "amount0Out",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount1Out",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "swap",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "symbol",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    payable: false,
    stateMutability: "pure",
    type: "function"
  },
  {
    constant: false,
    inputs: [],
    name: "sync",
    outputs: [],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token0",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "token1",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [],
    name: "totalSupply",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transfer",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    constant: false,
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "transferFrom",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    payable: false,
    stateMutability: "nonpayable",
    type: "function"
  }
];
var bytecode = "";
var IUniswapV2Pair_default = {
  abi,
  evm,
  metadata,
  interface: interface2,
  bytecode
};

// node_modules/@uniswap/sdk/dist/sdk.esm.js
var _SOLIDITY_TYPE_MAXIMA;
var ChainId;
(function(ChainId2) {
  ChainId2[ChainId2["MAINNET"] = 1] = "MAINNET";
  ChainId2[ChainId2["ROPSTEN"] = 3] = "ROPSTEN";
  ChainId2[ChainId2["RINKEBY"] = 4] = "RINKEBY";
  ChainId2[ChainId2["G\xD6RLI"] = 5] = "G\xD6RLI";
  ChainId2[ChainId2["KOVAN"] = 42] = "KOVAN";
})(ChainId || (ChainId = {}));
var TradeType;
(function(TradeType2) {
  TradeType2[TradeType2["EXACT_INPUT"] = 0] = "EXACT_INPUT";
  TradeType2[TradeType2["EXACT_OUTPUT"] = 1] = "EXACT_OUTPUT";
})(TradeType || (TradeType = {}));
var Rounding;
(function(Rounding2) {
  Rounding2[Rounding2["ROUND_DOWN"] = 0] = "ROUND_DOWN";
  Rounding2[Rounding2["ROUND_HALF_UP"] = 1] = "ROUND_HALF_UP";
  Rounding2[Rounding2["ROUND_UP"] = 2] = "ROUND_UP";
})(Rounding || (Rounding = {}));
var FACTORY_ADDRESS = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f";
var INIT_CODE_HASH = "0x96e8ac4277198ff8b6f785478aa9a39f403cb768dd02cbee326c3e7da348845f";
var MINIMUM_LIQUIDITY = jsbi_default.BigInt(1e3);
var ZERO = jsbi_default.BigInt(0);
var ONE2 = jsbi_default.BigInt(1);
var TWO = jsbi_default.BigInt(2);
var THREE = jsbi_default.BigInt(3);
var FIVE = jsbi_default.BigInt(5);
var TEN = jsbi_default.BigInt(10);
var _100 = jsbi_default.BigInt(100);
var _997 = jsbi_default.BigInt(997);
var _1000 = jsbi_default.BigInt(1e3);
var SolidityType;
(function(SolidityType2) {
  SolidityType2["uint8"] = "uint8";
  SolidityType2["uint256"] = "uint256";
})(SolidityType || (SolidityType = {}));
var SOLIDITY_TYPE_MAXIMA = (_SOLIDITY_TYPE_MAXIMA = {}, _SOLIDITY_TYPE_MAXIMA[SolidityType.uint8] = jsbi_default.BigInt("0xff"), _SOLIDITY_TYPE_MAXIMA[SolidityType.uint256] = jsbi_default.BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"), _SOLIDITY_TYPE_MAXIMA);
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct2(Parent2, args2, Class2) {
      var a = [null];
      a.push.apply(a, args2);
      var Constructor = Function.bind.apply(Parent2, a);
      var instance = new Constructor();
      if (Class2)
        _setPrototypeOf(instance, Class2.prototype);
      return instance;
    };
  }
  return _construct.apply(null, arguments);
}
function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : void 0;
  _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
    if (Class2 === null || !_isNativeFunction(Class2))
      return Class2;
    if (typeof Class2 !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }
    if (typeof _cache !== "undefined") {
      if (_cache.has(Class2))
        return _cache.get(Class2);
      _cache.set(Class2, Wrapper);
    }
    function Wrapper() {
      return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
    }
    Wrapper.prototype = Object.create(Class2.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class2);
  };
  return _wrapNativeSuper(Class);
}
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _createForOfIteratorHelperLoose(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it = o[Symbol.iterator]();
  return it.next.bind(it);
}
var CAN_SET_PROTOTYPE = "setPrototypeOf" in Object;
var InsufficientReservesError = function(_Error) {
  _inheritsLoose(InsufficientReservesError2, _Error);
  function InsufficientReservesError2() {
    var _this;
    _this = _Error.call(this) || this;
    _this.isInsufficientReservesError = true;
    _this.name = _this.constructor.name;
    if (CAN_SET_PROTOTYPE)
      Object.setPrototypeOf(_assertThisInitialized(_this), (this instanceof InsufficientReservesError2 ? this.constructor : void 0).prototype);
    return _this;
  }
  return InsufficientReservesError2;
}(_wrapNativeSuper(Error));
var InsufficientInputAmountError = function(_Error2) {
  _inheritsLoose(InsufficientInputAmountError2, _Error2);
  function InsufficientInputAmountError2() {
    var _this2;
    _this2 = _Error2.call(this) || this;
    _this2.isInsufficientInputAmountError = true;
    _this2.name = _this2.constructor.name;
    if (CAN_SET_PROTOTYPE)
      Object.setPrototypeOf(_assertThisInitialized(_this2), (this instanceof InsufficientInputAmountError2 ? this.constructor : void 0).prototype);
    return _this2;
  }
  return InsufficientInputAmountError2;
}(_wrapNativeSuper(Error));
function validateSolidityTypeInstance(value, solidityType) {
  !jsbi_default.greaterThanOrEqual(value, ZERO) ? true ? tiny_invariant_esm_default(false, value + " is not a " + solidityType + ".") : tiny_invariant_esm_default(false) : void 0;
  !jsbi_default.lessThanOrEqual(value, SOLIDITY_TYPE_MAXIMA[solidityType]) ? true ? tiny_invariant_esm_default(false, value + " is not a " + solidityType + ".") : tiny_invariant_esm_default(false) : void 0;
}
function validateAndParseAddress(address) {
  try {
    var checksummedAddress = getAddress(address);
    true ? tiny_warning_esm_default(address === checksummedAddress, address + " is not checksummed.") : void 0;
    return checksummedAddress;
  } catch (error) {
    true ? tiny_invariant_esm_default(false, address + " is not a valid address.") : tiny_invariant_esm_default(false);
  }
}
function parseBigintIsh(bigintIsh) {
  return bigintIsh instanceof jsbi_default ? bigintIsh : typeof bigintIsh === "bigint" ? jsbi_default.BigInt(bigintIsh.toString()) : jsbi_default.BigInt(bigintIsh);
}
function sqrt(y) {
  validateSolidityTypeInstance(y, SolidityType.uint256);
  var z = ZERO;
  var x;
  if (jsbi_default.greaterThan(y, THREE)) {
    z = y;
    x = jsbi_default.add(jsbi_default.divide(y, TWO), ONE2);
    while (jsbi_default.lessThan(x, z)) {
      z = x;
      x = jsbi_default.divide(jsbi_default.add(jsbi_default.divide(y, x), x), TWO);
    }
  } else if (jsbi_default.notEqual(y, ZERO)) {
    z = ONE2;
  }
  return z;
}
function sortedInsert(items, add2, maxSize, comparator) {
  !(maxSize > 0) ? true ? tiny_invariant_esm_default(false, "MAX_SIZE_ZERO") : tiny_invariant_esm_default(false) : void 0;
  !(items.length <= maxSize) ? true ? tiny_invariant_esm_default(false, "ITEMS_SIZE") : tiny_invariant_esm_default(false) : void 0;
  if (items.length === 0) {
    items.push(add2);
    return null;
  } else {
    var isFull = items.length === maxSize;
    if (isFull && comparator(items[items.length - 1], add2) <= 0) {
      return add2;
    }
    var lo = 0, hi = items.length;
    while (lo < hi) {
      var mid = lo + hi >>> 1;
      if (comparator(items[mid], add2) <= 0) {
        lo = mid + 1;
      } else {
        hi = mid;
      }
    }
    items.splice(lo, 0, add2);
    return isFull ? items.pop() : null;
  }
}
var Currency = function Currency2(decimals, symbol, name) {
  validateSolidityTypeInstance(jsbi_default.BigInt(decimals), SolidityType.uint8);
  this.decimals = decimals;
  this.symbol = symbol;
  this.name = name;
};
Currency.ETHER = new Currency(18, "ETH", "Ether");
var ETHER = Currency.ETHER;
var _WETH;
var Token = function(_Currency) {
  _inheritsLoose(Token2, _Currency);
  function Token2(chainId, address, decimals, symbol, name) {
    var _this;
    _this = _Currency.call(this, decimals, symbol, name) || this;
    _this.chainId = chainId;
    _this.address = validateAndParseAddress(address);
    return _this;
  }
  var _proto = Token2.prototype;
  _proto.equals = function equals(other) {
    if (this === other) {
      return true;
    }
    return this.chainId === other.chainId && this.address === other.address;
  };
  _proto.sortsBefore = function sortsBefore(other) {
    !(this.chainId === other.chainId) ? true ? tiny_invariant_esm_default(false, "CHAIN_IDS") : tiny_invariant_esm_default(false) : void 0;
    !(this.address !== other.address) ? true ? tiny_invariant_esm_default(false, "ADDRESSES") : tiny_invariant_esm_default(false) : void 0;
    return this.address.toLowerCase() < other.address.toLowerCase();
  };
  return Token2;
}(Currency);
function currencyEquals(currencyA, currencyB) {
  if (currencyA instanceof Token && currencyB instanceof Token) {
    return currencyA.equals(currencyB);
  } else if (currencyA instanceof Token) {
    return false;
  } else if (currencyB instanceof Token) {
    return false;
  } else {
    return currencyA === currencyB;
  }
}
var WETH = (_WETH = {}, _WETH[ChainId.MAINNET] = new Token(ChainId.MAINNET, "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2", 18, "WETH", "Wrapped Ether"), _WETH[ChainId.ROPSTEN] = new Token(ChainId.ROPSTEN, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[ChainId.RINKEBY] = new Token(ChainId.RINKEBY, "0xc778417E063141139Fce010982780140Aa0cD5Ab", 18, "WETH", "Wrapped Ether"), _WETH[ChainId.G\u00D6RLI] = new Token(ChainId.G\u00D6RLI, "0xB4FBF271143F4FBf7B91A5ded31805e42b2208d6", 18, "WETH", "Wrapped Ether"), _WETH[ChainId.KOVAN] = new Token(ChainId.KOVAN, "0xd0A1E359811322d97991E03f863a0C30C2cF029C", 18, "WETH", "Wrapped Ether"), _WETH);
var _toSignificantRoundin;
var _toFixedRounding;
var Decimal2 = (0, import_toformat.default)(decimal_default);
var Big2 = (0, import_toformat.default)(big_default);
var toSignificantRounding = (_toSignificantRoundin = {}, _toSignificantRoundin[Rounding.ROUND_DOWN] = Decimal2.ROUND_DOWN, _toSignificantRoundin[Rounding.ROUND_HALF_UP] = Decimal2.ROUND_HALF_UP, _toSignificantRoundin[Rounding.ROUND_UP] = Decimal2.ROUND_UP, _toSignificantRoundin);
var toFixedRounding = (_toFixedRounding = {}, _toFixedRounding[Rounding.ROUND_DOWN] = 0, _toFixedRounding[Rounding.ROUND_HALF_UP] = 1, _toFixedRounding[Rounding.ROUND_UP] = 3, _toFixedRounding);
var Fraction = function() {
  function Fraction2(numerator, denominator) {
    if (denominator === void 0) {
      denominator = ONE2;
    }
    this.numerator = parseBigintIsh(numerator);
    this.denominator = parseBigintIsh(denominator);
  }
  var _proto = Fraction2.prototype;
  _proto.invert = function invert() {
    return new Fraction2(this.denominator, this.numerator);
  };
  _proto.add = function add2(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(jsbi_default.add(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(jsbi_default.add(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.subtract = function subtract2(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    if (jsbi_default.equal(this.denominator, otherParsed.denominator)) {
      return new Fraction2(jsbi_default.subtract(this.numerator, otherParsed.numerator), this.denominator);
    }
    return new Fraction2(jsbi_default.subtract(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator)), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.lessThan = function lessThan(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    return jsbi_default.lessThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.equalTo = function equalTo(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    return jsbi_default.equal(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.greaterThan = function greaterThan(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    return jsbi_default.greaterThan(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(otherParsed.numerator, this.denominator));
  };
  _proto.multiply = function multiply(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.numerator), jsbi_default.multiply(this.denominator, otherParsed.denominator));
  };
  _proto.divide = function divide2(other) {
    var otherParsed = other instanceof Fraction2 ? other : new Fraction2(parseBigintIsh(other));
    return new Fraction2(jsbi_default.multiply(this.numerator, otherParsed.denominator), jsbi_default.multiply(this.denominator, otherParsed.numerator));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(significantDigits) ? true ? tiny_invariant_esm_default(false, significantDigits + " is not an integer.") : tiny_invariant_esm_default(false) : void 0;
    !(significantDigits > 0) ? true ? tiny_invariant_esm_default(false, significantDigits + " is not positive.") : tiny_invariant_esm_default(false) : void 0;
    Decimal2.set({
      precision: significantDigits + 1,
      rounding: toSignificantRounding[rounding]
    });
    var quotient = new Decimal2(this.numerator.toString()).div(this.denominator.toString()).toSignificantDigits(significantDigits);
    return quotient.toFormat(quotient.decimalPlaces(), format);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_HALF_UP;
    }
    !Number.isInteger(decimalPlaces) ? true ? tiny_invariant_esm_default(false, decimalPlaces + " is not an integer.") : tiny_invariant_esm_default(false) : void 0;
    !(decimalPlaces >= 0) ? true ? tiny_invariant_esm_default(false, decimalPlaces + " is negative.") : tiny_invariant_esm_default(false) : void 0;
    Big2.DP = decimalPlaces;
    Big2.RM = toFixedRounding[rounding];
    return new Big2(this.numerator.toString()).div(this.denominator.toString()).toFormat(decimalPlaces, format);
  };
  _createClass(Fraction2, [{
    key: "quotient",
    get: function get() {
      return jsbi_default.divide(this.numerator, this.denominator);
    }
  }, {
    key: "remainder",
    get: function get() {
      return new Fraction2(jsbi_default.remainder(this.numerator, this.denominator), this.denominator);
    }
  }]);
  return Fraction2;
}();
var Big$1 = (0, import_toformat.default)(big_default);
var CurrencyAmount = function(_Fraction) {
  _inheritsLoose(CurrencyAmount2, _Fraction);
  function CurrencyAmount2(currency, amount) {
    var _this;
    var parsedAmount = parseBigintIsh(amount);
    validateSolidityTypeInstance(parsedAmount, SolidityType.uint256);
    _this = _Fraction.call(this, parsedAmount, jsbi_default.exponentiate(TEN, jsbi_default.BigInt(currency.decimals))) || this;
    _this.currency = currency;
    return _this;
  }
  CurrencyAmount2.ether = function ether(amount) {
    return new CurrencyAmount2(ETHER, amount);
  };
  var _proto = CurrencyAmount2.prototype;
  _proto.add = function add2(other) {
    !currencyEquals(this.currency, other.currency) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return new CurrencyAmount2(this.currency, jsbi_default.add(this.raw, other.raw));
  };
  _proto.subtract = function subtract2(other) {
    !currencyEquals(this.currency, other.currency) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return new CurrencyAmount2(this.currency, jsbi_default.subtract(this.raw, other.raw));
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    return _Fraction.prototype.toSignificant.call(this, significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = this.currency.decimals;
    }
    if (rounding === void 0) {
      rounding = Rounding.ROUND_DOWN;
    }
    !(decimalPlaces <= this.currency.decimals) ? true ? tiny_invariant_esm_default(false, "DECIMALS") : tiny_invariant_esm_default(false) : void 0;
    return _Fraction.prototype.toFixed.call(this, decimalPlaces, format, rounding);
  };
  _proto.toExact = function toExact(format) {
    if (format === void 0) {
      format = {
        groupSeparator: ""
      };
    }
    Big$1.DP = this.currency.decimals;
    return new Big$1(this.numerator.toString()).div(this.denominator.toString()).toFormat(format);
  };
  _createClass(CurrencyAmount2, [{
    key: "raw",
    get: function get() {
      return this.numerator;
    }
  }]);
  return CurrencyAmount2;
}(Fraction);
var TokenAmount = function(_CurrencyAmount) {
  _inheritsLoose(TokenAmount2, _CurrencyAmount);
  function TokenAmount2(token, amount) {
    var _this;
    _this = _CurrencyAmount.call(this, token, amount) || this;
    _this.token = token;
    return _this;
  }
  var _proto = TokenAmount2.prototype;
  _proto.add = function add2(other) {
    !this.token.equals(other.token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return new TokenAmount2(this.token, jsbi_default.add(this.raw, other.raw));
  };
  _proto.subtract = function subtract2(other) {
    !this.token.equals(other.token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return new TokenAmount2(this.token, jsbi_default.subtract(this.raw, other.raw));
  };
  return TokenAmount2;
}(CurrencyAmount);
var Price = function(_Fraction) {
  _inheritsLoose(Price2, _Fraction);
  function Price2(baseCurrency, quoteCurrency, denominator, numerator) {
    var _this;
    _this = _Fraction.call(this, numerator, denominator) || this;
    _this.baseCurrency = baseCurrency;
    _this.quoteCurrency = quoteCurrency;
    _this.scalar = new Fraction(jsbi_default.exponentiate(TEN, jsbi_default.BigInt(baseCurrency.decimals)), jsbi_default.exponentiate(TEN, jsbi_default.BigInt(quoteCurrency.decimals)));
    return _this;
  }
  Price2.fromRoute = function fromRoute(route) {
    var prices = [];
    for (var _iterator = _createForOfIteratorHelperLoose(route.pairs.entries()), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, i = _step$value[0], pair = _step$value[1];
      prices.push(route.path[i].equals(pair.token0) ? new Price2(pair.reserve0.currency, pair.reserve1.currency, pair.reserve0.raw, pair.reserve1.raw) : new Price2(pair.reserve1.currency, pair.reserve0.currency, pair.reserve1.raw, pair.reserve0.raw));
    }
    return prices.slice(1).reduce(function(accumulator, currentValue) {
      return accumulator.multiply(currentValue);
    }, prices[0]);
  };
  var _proto = Price2.prototype;
  _proto.invert = function invert() {
    return new Price2(this.quoteCurrency, this.baseCurrency, this.numerator, this.denominator);
  };
  _proto.multiply = function multiply(other) {
    !currencyEquals(this.quoteCurrency, other.baseCurrency) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    var fraction = _Fraction.prototype.multiply.call(this, other);
    return new Price2(this.baseCurrency, other.quoteCurrency, fraction.denominator, fraction.numerator);
  };
  _proto.quote = function quote(currencyAmount) {
    !currencyEquals(currencyAmount.currency, this.baseCurrency) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    if (this.quoteCurrency instanceof Token) {
      return new TokenAmount(this.quoteCurrency, _Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);
    }
    return CurrencyAmount.ether(_Fraction.prototype.multiply.call(this, currencyAmount.raw).quotient);
  };
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 6;
    }
    return this.adjusted.toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 4;
    }
    return this.adjusted.toFixed(decimalPlaces, format, rounding);
  };
  _createClass(Price2, [{
    key: "raw",
    get: function get() {
      return new Fraction(this.numerator, this.denominator);
    }
  }, {
    key: "adjusted",
    get: function get() {
      return _Fraction.prototype.multiply.call(this, this.scalar);
    }
  }]);
  return Price2;
}(Fraction);
var PAIR_ADDRESS_CACHE = {};
var Pair = function() {
  function Pair2(tokenAmountA, tokenAmountB) {
    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
    this.liquidityToken = new Token(tokenAmounts[0].token.chainId, Pair2.getAddress(tokenAmounts[0].token, tokenAmounts[1].token), 18, "UNI-V2", "Uniswap V2");
    this.tokenAmounts = tokenAmounts;
  }
  Pair2.getAddress = function getAddress2(tokenA, tokenB) {
    var _PAIR_ADDRESS_CACHE, _PAIR_ADDRESS_CACHE$t;
    var tokens = tokenA.sortsBefore(tokenB) ? [tokenA, tokenB] : [tokenB, tokenA];
    if (((_PAIR_ADDRESS_CACHE = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE === void 0 ? void 0 : (_PAIR_ADDRESS_CACHE$t = _PAIR_ADDRESS_CACHE[tokens[0].address]) === null || _PAIR_ADDRESS_CACHE$t === void 0 ? void 0 : _PAIR_ADDRESS_CACHE$t[tokens[1].address]) === void 0) {
      var _PAIR_ADDRESS_CACHE2, _extends2, _extends3;
      PAIR_ADDRESS_CACHE = _extends({}, PAIR_ADDRESS_CACHE, (_extends3 = {}, _extends3[tokens[0].address] = _extends({}, (_PAIR_ADDRESS_CACHE2 = PAIR_ADDRESS_CACHE) === null || _PAIR_ADDRESS_CACHE2 === void 0 ? void 0 : _PAIR_ADDRESS_CACHE2[tokens[0].address], (_extends2 = {}, _extends2[tokens[1].address] = getCreate2Address(FACTORY_ADDRESS, keccak256(["bytes"], [pack(["address", "address"], [tokens[0].address, tokens[1].address])]), INIT_CODE_HASH), _extends2)), _extends3));
    }
    return PAIR_ADDRESS_CACHE[tokens[0].address][tokens[1].address];
  };
  var _proto = Pair2.prototype;
  _proto.involvesToken = function involvesToken(token) {
    return token.equals(this.token0) || token.equals(this.token1);
  };
  _proto.priceOf = function priceOf(token) {
    !this.involvesToken(token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return token.equals(this.token0) ? this.token0Price : this.token1Price;
  };
  _proto.reserveOf = function reserveOf(token) {
    !this.involvesToken(token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    return token.equals(this.token0) ? this.reserve0 : this.reserve1;
  };
  _proto.getOutputAmount = function getOutputAmount(inputAmount) {
    !this.involvesToken(inputAmount.token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    if (jsbi_default.equal(this.reserve0.raw, ZERO) || jsbi_default.equal(this.reserve1.raw, ZERO)) {
      throw new InsufficientReservesError();
    }
    var inputReserve = this.reserveOf(inputAmount.token);
    var outputReserve = this.reserveOf(inputAmount.token.equals(this.token0) ? this.token1 : this.token0);
    var inputAmountWithFee = jsbi_default.multiply(inputAmount.raw, _997);
    var numerator = jsbi_default.multiply(inputAmountWithFee, outputReserve.raw);
    var denominator = jsbi_default.add(jsbi_default.multiply(inputReserve.raw, _1000), inputAmountWithFee);
    var outputAmount = new TokenAmount(inputAmount.token.equals(this.token0) ? this.token1 : this.token0, jsbi_default.divide(numerator, denominator));
    if (jsbi_default.equal(outputAmount.raw, ZERO)) {
      throw new InsufficientInputAmountError();
    }
    return [outputAmount, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  };
  _proto.getInputAmount = function getInputAmount(outputAmount) {
    !this.involvesToken(outputAmount.token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    if (jsbi_default.equal(this.reserve0.raw, ZERO) || jsbi_default.equal(this.reserve1.raw, ZERO) || jsbi_default.greaterThanOrEqual(outputAmount.raw, this.reserveOf(outputAmount.token).raw)) {
      throw new InsufficientReservesError();
    }
    var outputReserve = this.reserveOf(outputAmount.token);
    var inputReserve = this.reserveOf(outputAmount.token.equals(this.token0) ? this.token1 : this.token0);
    var numerator = jsbi_default.multiply(jsbi_default.multiply(inputReserve.raw, outputAmount.raw), _1000);
    var denominator = jsbi_default.multiply(jsbi_default.subtract(outputReserve.raw, outputAmount.raw), _997);
    var inputAmount = new TokenAmount(outputAmount.token.equals(this.token0) ? this.token1 : this.token0, jsbi_default.add(jsbi_default.divide(numerator, denominator), ONE2));
    return [inputAmount, new Pair2(inputReserve.add(inputAmount), outputReserve.subtract(outputAmount))];
  };
  _proto.getLiquidityMinted = function getLiquidityMinted(totalSupply, tokenAmountA, tokenAmountB) {
    !totalSupply.token.equals(this.liquidityToken) ? true ? tiny_invariant_esm_default(false, "LIQUIDITY") : tiny_invariant_esm_default(false) : void 0;
    var tokenAmounts = tokenAmountA.token.sortsBefore(tokenAmountB.token) ? [tokenAmountA, tokenAmountB] : [tokenAmountB, tokenAmountA];
    !(tokenAmounts[0].token.equals(this.token0) && tokenAmounts[1].token.equals(this.token1)) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    var liquidity;
    if (jsbi_default.equal(totalSupply.raw, ZERO)) {
      liquidity = jsbi_default.subtract(sqrt(jsbi_default.multiply(tokenAmounts[0].raw, tokenAmounts[1].raw)), MINIMUM_LIQUIDITY);
    } else {
      var amount0 = jsbi_default.divide(jsbi_default.multiply(tokenAmounts[0].raw, totalSupply.raw), this.reserve0.raw);
      var amount1 = jsbi_default.divide(jsbi_default.multiply(tokenAmounts[1].raw, totalSupply.raw), this.reserve1.raw);
      liquidity = jsbi_default.lessThanOrEqual(amount0, amount1) ? amount0 : amount1;
    }
    if (!jsbi_default.greaterThan(liquidity, ZERO)) {
      throw new InsufficientInputAmountError();
    }
    return new TokenAmount(this.liquidityToken, liquidity);
  };
  _proto.getLiquidityValue = function getLiquidityValue(token, totalSupply, liquidity, feeOn, kLast) {
    if (feeOn === void 0) {
      feeOn = false;
    }
    !this.involvesToken(token) ? true ? tiny_invariant_esm_default(false, "TOKEN") : tiny_invariant_esm_default(false) : void 0;
    !totalSupply.token.equals(this.liquidityToken) ? true ? tiny_invariant_esm_default(false, "TOTAL_SUPPLY") : tiny_invariant_esm_default(false) : void 0;
    !liquidity.token.equals(this.liquidityToken) ? true ? tiny_invariant_esm_default(false, "LIQUIDITY") : tiny_invariant_esm_default(false) : void 0;
    !jsbi_default.lessThanOrEqual(liquidity.raw, totalSupply.raw) ? true ? tiny_invariant_esm_default(false, "LIQUIDITY") : tiny_invariant_esm_default(false) : void 0;
    var totalSupplyAdjusted;
    if (!feeOn) {
      totalSupplyAdjusted = totalSupply;
    } else {
      !!!kLast ? true ? tiny_invariant_esm_default(false, "K_LAST") : tiny_invariant_esm_default(false) : void 0;
      var kLastParsed = parseBigintIsh(kLast);
      if (!jsbi_default.equal(kLastParsed, ZERO)) {
        var rootK = sqrt(jsbi_default.multiply(this.reserve0.raw, this.reserve1.raw));
        var rootKLast = sqrt(kLastParsed);
        if (jsbi_default.greaterThan(rootK, rootKLast)) {
          var numerator = jsbi_default.multiply(totalSupply.raw, jsbi_default.subtract(rootK, rootKLast));
          var denominator = jsbi_default.add(jsbi_default.multiply(rootK, FIVE), rootKLast);
          var feeLiquidity = jsbi_default.divide(numerator, denominator);
          totalSupplyAdjusted = totalSupply.add(new TokenAmount(this.liquidityToken, feeLiquidity));
        } else {
          totalSupplyAdjusted = totalSupply;
        }
      } else {
        totalSupplyAdjusted = totalSupply;
      }
    }
    return new TokenAmount(token, jsbi_default.divide(jsbi_default.multiply(liquidity.raw, this.reserveOf(token).raw), totalSupplyAdjusted.raw));
  };
  _createClass(Pair2, [{
    key: "token0Price",
    get: function get() {
      return new Price(this.token0, this.token1, this.tokenAmounts[0].raw, this.tokenAmounts[1].raw);
    }
  }, {
    key: "token1Price",
    get: function get() {
      return new Price(this.token1, this.token0, this.tokenAmounts[1].raw, this.tokenAmounts[0].raw);
    }
  }, {
    key: "chainId",
    get: function get() {
      return this.token0.chainId;
    }
  }, {
    key: "token0",
    get: function get() {
      return this.tokenAmounts[0].token;
    }
  }, {
    key: "token1",
    get: function get() {
      return this.tokenAmounts[1].token;
    }
  }, {
    key: "reserve0",
    get: function get() {
      return this.tokenAmounts[0];
    }
  }, {
    key: "reserve1",
    get: function get() {
      return this.tokenAmounts[1];
    }
  }]);
  return Pair2;
}();
var Route = function() {
  function Route2(pairs, input, output) {
    !(pairs.length > 0) ? true ? tiny_invariant_esm_default(false, "PAIRS") : tiny_invariant_esm_default(false) : void 0;
    !pairs.every(function(pair2) {
      return pair2.chainId === pairs[0].chainId;
    }) ? true ? tiny_invariant_esm_default(false, "CHAIN_IDS") : tiny_invariant_esm_default(false) : void 0;
    !(input instanceof Token && pairs[0].involvesToken(input) || input === ETHER && pairs[0].involvesToken(WETH[pairs[0].chainId])) ? true ? tiny_invariant_esm_default(false, "INPUT") : tiny_invariant_esm_default(false) : void 0;
    !(typeof output === "undefined" || output instanceof Token && pairs[pairs.length - 1].involvesToken(output) || output === ETHER && pairs[pairs.length - 1].involvesToken(WETH[pairs[0].chainId])) ? true ? tiny_invariant_esm_default(false, "OUTPUT") : tiny_invariant_esm_default(false) : void 0;
    var path = [input instanceof Token ? input : WETH[pairs[0].chainId]];
    for (var _iterator = _createForOfIteratorHelperLoose(pairs.entries()), _step; !(_step = _iterator()).done; ) {
      var _step$value = _step.value, i = _step$value[0], pair = _step$value[1];
      var currentInput = path[i];
      !(currentInput.equals(pair.token0) || currentInput.equals(pair.token1)) ? true ? tiny_invariant_esm_default(false, "PATH") : tiny_invariant_esm_default(false) : void 0;
      var _output = currentInput.equals(pair.token0) ? pair.token1 : pair.token0;
      path.push(_output);
    }
    this.pairs = pairs;
    this.path = path;
    this.midPrice = Price.fromRoute(this);
    this.input = input;
    this.output = output !== null && output !== void 0 ? output : path[path.length - 1];
  }
  _createClass(Route2, [{
    key: "chainId",
    get: function get() {
      return this.pairs[0].chainId;
    }
  }]);
  return Route2;
}();
var _100_PERCENT = new Fraction(_100);
var Percent = function(_Fraction) {
  _inheritsLoose(Percent2, _Fraction);
  function Percent2() {
    return _Fraction.apply(this, arguments) || this;
  }
  var _proto = Percent2.prototype;
  _proto.toSignificant = function toSignificant(significantDigits, format, rounding) {
    if (significantDigits === void 0) {
      significantDigits = 5;
    }
    return this.multiply(_100_PERCENT).toSignificant(significantDigits, format, rounding);
  };
  _proto.toFixed = function toFixed(decimalPlaces, format, rounding) {
    if (decimalPlaces === void 0) {
      decimalPlaces = 2;
    }
    return this.multiply(_100_PERCENT).toFixed(decimalPlaces, format, rounding);
  };
  return Percent2;
}(Fraction);
function computePriceImpact(midPrice, inputAmount, outputAmount) {
  var exactQuote = midPrice.raw.multiply(inputAmount.raw);
  var slippage = exactQuote.subtract(outputAmount.raw).divide(exactQuote);
  return new Percent(slippage.numerator, slippage.denominator);
}
function inputOutputComparator(a, b) {
  !currencyEquals(a.inputAmount.currency, b.inputAmount.currency) ? true ? tiny_invariant_esm_default(false, "INPUT_CURRENCY") : tiny_invariant_esm_default(false) : void 0;
  !currencyEquals(a.outputAmount.currency, b.outputAmount.currency) ? true ? tiny_invariant_esm_default(false, "OUTPUT_CURRENCY") : tiny_invariant_esm_default(false) : void 0;
  if (a.outputAmount.equalTo(b.outputAmount)) {
    if (a.inputAmount.equalTo(b.inputAmount)) {
      return 0;
    }
    if (a.inputAmount.lessThan(b.inputAmount)) {
      return -1;
    } else {
      return 1;
    }
  } else {
    if (a.outputAmount.lessThan(b.outputAmount)) {
      return 1;
    } else {
      return -1;
    }
  }
}
function tradeComparator(a, b) {
  var ioComp = inputOutputComparator(a, b);
  if (ioComp !== 0) {
    return ioComp;
  }
  if (a.priceImpact.lessThan(b.priceImpact)) {
    return -1;
  } else if (a.priceImpact.greaterThan(b.priceImpact)) {
    return 1;
  }
  return a.route.path.length - b.route.path.length;
}
function wrappedAmount(currencyAmount, chainId) {
  if (currencyAmount instanceof TokenAmount)
    return currencyAmount;
  if (currencyAmount.currency === ETHER)
    return new TokenAmount(WETH[chainId], currencyAmount.raw);
  true ? tiny_invariant_esm_default(false, "CURRENCY") : tiny_invariant_esm_default(false);
}
function wrappedCurrency(currency, chainId) {
  if (currency instanceof Token)
    return currency;
  if (currency === ETHER)
    return WETH[chainId];
  true ? tiny_invariant_esm_default(false, "CURRENCY") : tiny_invariant_esm_default(false);
}
var Trade = function() {
  function Trade2(route, amount, tradeType) {
    var amounts = new Array(route.path.length);
    var nextPairs = new Array(route.pairs.length);
    if (tradeType === TradeType.EXACT_INPUT) {
      !currencyEquals(amount.currency, route.input) ? true ? tiny_invariant_esm_default(false, "INPUT") : tiny_invariant_esm_default(false) : void 0;
      amounts[0] = wrappedAmount(amount, route.chainId);
      for (var i = 0; i < route.path.length - 1; i++) {
        var pair = route.pairs[i];
        var _pair$getOutputAmount = pair.getOutputAmount(amounts[i]), outputAmount = _pair$getOutputAmount[0], nextPair = _pair$getOutputAmount[1];
        amounts[i + 1] = outputAmount;
        nextPairs[i] = nextPair;
      }
    } else {
      !currencyEquals(amount.currency, route.output) ? true ? tiny_invariant_esm_default(false, "OUTPUT") : tiny_invariant_esm_default(false) : void 0;
      amounts[amounts.length - 1] = wrappedAmount(amount, route.chainId);
      for (var _i = route.path.length - 1; _i > 0; _i--) {
        var _pair = route.pairs[_i - 1];
        var _pair$getInputAmount = _pair.getInputAmount(amounts[_i]), inputAmount = _pair$getInputAmount[0], _nextPair = _pair$getInputAmount[1];
        amounts[_i - 1] = inputAmount;
        nextPairs[_i - 1] = _nextPair;
      }
    }
    this.route = route;
    this.tradeType = tradeType;
    this.inputAmount = tradeType === TradeType.EXACT_INPUT ? amount : route.input === ETHER ? CurrencyAmount.ether(amounts[0].raw) : amounts[0];
    this.outputAmount = tradeType === TradeType.EXACT_OUTPUT ? amount : route.output === ETHER ? CurrencyAmount.ether(amounts[amounts.length - 1].raw) : amounts[amounts.length - 1];
    this.executionPrice = new Price(this.inputAmount.currency, this.outputAmount.currency, this.inputAmount.raw, this.outputAmount.raw);
    this.nextMidPrice = Price.fromRoute(new Route(nextPairs, route.input));
    this.priceImpact = computePriceImpact(route.midPrice, this.inputAmount, this.outputAmount);
  }
  Trade2.exactIn = function exactIn(route, amountIn) {
    return new Trade2(route, amountIn, TradeType.EXACT_INPUT);
  };
  Trade2.exactOut = function exactOut(route, amountOut) {
    return new Trade2(route, amountOut, TradeType.EXACT_OUTPUT);
  };
  var _proto = Trade2.prototype;
  _proto.minimumAmountOut = function minimumAmountOut(slippageTolerance) {
    !!slippageTolerance.lessThan(ZERO) ? true ? tiny_invariant_esm_default(false, "SLIPPAGE_TOLERANCE") : tiny_invariant_esm_default(false) : void 0;
    if (this.tradeType === TradeType.EXACT_OUTPUT) {
      return this.outputAmount;
    } else {
      var slippageAdjustedAmountOut = new Fraction(ONE2).add(slippageTolerance).invert().multiply(this.outputAmount.raw).quotient;
      return this.outputAmount instanceof TokenAmount ? new TokenAmount(this.outputAmount.token, slippageAdjustedAmountOut) : CurrencyAmount.ether(slippageAdjustedAmountOut);
    }
  };
  _proto.maximumAmountIn = function maximumAmountIn(slippageTolerance) {
    !!slippageTolerance.lessThan(ZERO) ? true ? tiny_invariant_esm_default(false, "SLIPPAGE_TOLERANCE") : tiny_invariant_esm_default(false) : void 0;
    if (this.tradeType === TradeType.EXACT_INPUT) {
      return this.inputAmount;
    } else {
      var slippageAdjustedAmountIn = new Fraction(ONE2).add(slippageTolerance).multiply(this.inputAmount.raw).quotient;
      return this.inputAmount instanceof TokenAmount ? new TokenAmount(this.inputAmount.token, slippageAdjustedAmountIn) : CurrencyAmount.ether(slippageAdjustedAmountIn);
    }
  };
  Trade2.bestTradeExactIn = function bestTradeExactIn(pairs, currencyAmountIn, currencyOut, _temp, currentPairs, originalAmountIn, bestTrades) {
    var _ref = _temp === void 0 ? {} : _temp, _ref$maxNumResults = _ref.maxNumResults, maxNumResults = _ref$maxNumResults === void 0 ? 3 : _ref$maxNumResults, _ref$maxHops = _ref.maxHops, maxHops = _ref$maxHops === void 0 ? 3 : _ref$maxHops;
    if (currentPairs === void 0) {
      currentPairs = [];
    }
    if (originalAmountIn === void 0) {
      originalAmountIn = currencyAmountIn;
    }
    if (bestTrades === void 0) {
      bestTrades = [];
    }
    !(pairs.length > 0) ? true ? tiny_invariant_esm_default(false, "PAIRS") : tiny_invariant_esm_default(false) : void 0;
    !(maxHops > 0) ? true ? tiny_invariant_esm_default(false, "MAX_HOPS") : tiny_invariant_esm_default(false) : void 0;
    !(originalAmountIn === currencyAmountIn || currentPairs.length > 0) ? true ? tiny_invariant_esm_default(false, "INVALID_RECURSION") : tiny_invariant_esm_default(false) : void 0;
    var chainId = currencyAmountIn instanceof TokenAmount ? currencyAmountIn.token.chainId : currencyOut instanceof Token ? currencyOut.chainId : void 0;
    !(chainId !== void 0) ? true ? tiny_invariant_esm_default(false, "CHAIN_ID") : tiny_invariant_esm_default(false) : void 0;
    var amountIn = wrappedAmount(currencyAmountIn, chainId);
    var tokenOut = wrappedCurrency(currencyOut, chainId);
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      if (!pair.token0.equals(amountIn.token) && !pair.token1.equals(amountIn.token))
        continue;
      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))
        continue;
      var amountOut = void 0;
      try {
        ;
        var _pair$getOutputAmount2 = pair.getOutputAmount(amountIn);
        amountOut = _pair$getOutputAmount2[0];
      } catch (error) {
        if (error.isInsufficientInputAmountError) {
          continue;
        }
        throw error;
      }
      if (amountOut.token.equals(tokenOut)) {
        sortedInsert(bestTrades, new Trade2(new Route([].concat(currentPairs, [pair]), originalAmountIn.currency, currencyOut), originalAmountIn, TradeType.EXACT_INPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
        Trade2.bestTradeExactIn(pairsExcludingThisPair, amountOut, currencyOut, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [].concat(currentPairs, [pair]), originalAmountIn, bestTrades);
      }
    }
    return bestTrades;
  };
  Trade2.bestTradeExactOut = function bestTradeExactOut(pairs, currencyIn, currencyAmountOut, _temp2, currentPairs, originalAmountOut, bestTrades) {
    var _ref2 = _temp2 === void 0 ? {} : _temp2, _ref2$maxNumResults = _ref2.maxNumResults, maxNumResults = _ref2$maxNumResults === void 0 ? 3 : _ref2$maxNumResults, _ref2$maxHops = _ref2.maxHops, maxHops = _ref2$maxHops === void 0 ? 3 : _ref2$maxHops;
    if (currentPairs === void 0) {
      currentPairs = [];
    }
    if (originalAmountOut === void 0) {
      originalAmountOut = currencyAmountOut;
    }
    if (bestTrades === void 0) {
      bestTrades = [];
    }
    !(pairs.length > 0) ? true ? tiny_invariant_esm_default(false, "PAIRS") : tiny_invariant_esm_default(false) : void 0;
    !(maxHops > 0) ? true ? tiny_invariant_esm_default(false, "MAX_HOPS") : tiny_invariant_esm_default(false) : void 0;
    !(originalAmountOut === currencyAmountOut || currentPairs.length > 0) ? true ? tiny_invariant_esm_default(false, "INVALID_RECURSION") : tiny_invariant_esm_default(false) : void 0;
    var chainId = currencyAmountOut instanceof TokenAmount ? currencyAmountOut.token.chainId : currencyIn instanceof Token ? currencyIn.chainId : void 0;
    !(chainId !== void 0) ? true ? tiny_invariant_esm_default(false, "CHAIN_ID") : tiny_invariant_esm_default(false) : void 0;
    var amountOut = wrappedAmount(currencyAmountOut, chainId);
    var tokenIn = wrappedCurrency(currencyIn, chainId);
    for (var i = 0; i < pairs.length; i++) {
      var pair = pairs[i];
      if (!pair.token0.equals(amountOut.token) && !pair.token1.equals(amountOut.token))
        continue;
      if (pair.reserve0.equalTo(ZERO) || pair.reserve1.equalTo(ZERO))
        continue;
      var amountIn = void 0;
      try {
        ;
        var _pair$getInputAmount2 = pair.getInputAmount(amountOut);
        amountIn = _pair$getInputAmount2[0];
      } catch (error) {
        if (error.isInsufficientReservesError) {
          continue;
        }
        throw error;
      }
      if (amountIn.token.equals(tokenIn)) {
        sortedInsert(bestTrades, new Trade2(new Route([pair].concat(currentPairs), currencyIn, originalAmountOut.currency), originalAmountOut, TradeType.EXACT_OUTPUT), maxNumResults, tradeComparator);
      } else if (maxHops > 1 && pairs.length > 1) {
        var pairsExcludingThisPair = pairs.slice(0, i).concat(pairs.slice(i + 1, pairs.length));
        Trade2.bestTradeExactOut(pairsExcludingThisPair, currencyIn, amountIn, {
          maxNumResults,
          maxHops: maxHops - 1
        }, [pair].concat(currentPairs), originalAmountOut, bestTrades);
      }
    }
    return bestTrades;
  };
  return Trade2;
}();
function toHex(currencyAmount) {
  return "0x" + currencyAmount.raw.toString(16);
}
var ZERO_HEX = "0x0";
var Router = function() {
  function Router2() {
  }
  Router2.swapCallParameters = function swapCallParameters(trade, options) {
    var etherIn = trade.inputAmount.currency === ETHER;
    var etherOut = trade.outputAmount.currency === ETHER;
    !!(etherIn && etherOut) ? true ? tiny_invariant_esm_default(false, "ETHER_IN_OUT") : tiny_invariant_esm_default(false) : void 0;
    !(!("ttl" in options) || options.ttl > 0) ? true ? tiny_invariant_esm_default(false, "TTL") : tiny_invariant_esm_default(false) : void 0;
    var to = validateAndParseAddress(options.recipient);
    var amountIn = toHex(trade.maximumAmountIn(options.allowedSlippage));
    var amountOut = toHex(trade.minimumAmountOut(options.allowedSlippage));
    var path = trade.route.path.map(function(token) {
      return token.address;
    });
    var deadline = "ttl" in options ? "0x" + (Math.floor(new Date().getTime() / 1e3) + options.ttl).toString(16) : "0x" + options.deadline.toString(16);
    var useFeeOnTransfer = Boolean(options.feeOnTransfer);
    var methodName;
    var args;
    var value;
    switch (trade.tradeType) {
      case TradeType.EXACT_INPUT:
        if (etherIn) {
          methodName = useFeeOnTransfer ? "swapExactETHForTokensSupportingFeeOnTransferTokens" : "swapExactETHForTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = useFeeOnTransfer ? "swapExactTokensForETHSupportingFeeOnTransferTokens" : "swapExactTokensForETH";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = useFeeOnTransfer ? "swapExactTokensForTokensSupportingFeeOnTransferTokens" : "swapExactTokensForTokens";
          args = [amountIn, amountOut, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
      case TradeType.EXACT_OUTPUT:
        !!useFeeOnTransfer ? true ? tiny_invariant_esm_default(false, "EXACT_OUT_FOT") : tiny_invariant_esm_default(false) : void 0;
        if (etherIn) {
          methodName = "swapETHForExactTokens";
          args = [amountOut, path, to, deadline];
          value = amountIn;
        } else if (etherOut) {
          methodName = "swapTokensForExactETH";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        } else {
          methodName = "swapTokensForExactTokens";
          args = [amountOut, amountIn, path, to, deadline];
          value = ZERO_HEX;
        }
        break;
    }
    return {
      methodName,
      args,
      value
    };
  };
  return Router2;
}();
var ERC20 = [
  {
    constant: true,
    inputs: [],
    name: "decimals",
    outputs: [
      {
        name: "",
        type: "uint8"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  },
  {
    constant: true,
    inputs: [
      {
        name: "",
        type: "address"
      }
    ],
    name: "balanceOf",
    outputs: [
      {
        name: "",
        type: "uint256"
      }
    ],
    payable: false,
    stateMutability: "view",
    type: "function"
  }
];
var _TOKEN_DECIMALS_CACHE;
var TOKEN_DECIMALS_CACHE = (_TOKEN_DECIMALS_CACHE = {}, _TOKEN_DECIMALS_CACHE[ChainId.MAINNET] = {
  "0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A": 9
}, _TOKEN_DECIMALS_CACHE);
var Fetcher = function() {
  function Fetcher2() {
  }
  Fetcher2.fetchTokenData = function fetchTokenData(chainId, address, provider, symbol, name) {
    try {
      var _TOKEN_DECIMALS_CACHE2, _TOKEN_DECIMALS_CACHE3;
      var _temp3 = function _temp32(parsedDecimals) {
        return new Token(chainId, address, parsedDecimals, symbol, name);
      };
      if (provider === void 0)
        provider = getDefaultProvider(getNetwork(chainId));
      var _temp4 = typeof ((_TOKEN_DECIMALS_CACHE2 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE2 === void 0 ? void 0 : (_TOKEN_DECIMALS_CACHE3 = _TOKEN_DECIMALS_CACHE2[chainId]) === null || _TOKEN_DECIMALS_CACHE3 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE3[address]) === "number";
      return Promise.resolve(_temp4 ? _temp3(TOKEN_DECIMALS_CACHE[chainId][address]) : Promise.resolve(new Contract(address, ERC20, provider).decimals().then(function(decimals) {
        var _TOKEN_DECIMALS_CACHE4, _extends2, _extends3;
        TOKEN_DECIMALS_CACHE = _extends({}, TOKEN_DECIMALS_CACHE, (_extends3 = {}, _extends3[chainId] = _extends({}, (_TOKEN_DECIMALS_CACHE4 = TOKEN_DECIMALS_CACHE) === null || _TOKEN_DECIMALS_CACHE4 === void 0 ? void 0 : _TOKEN_DECIMALS_CACHE4[chainId], (_extends2 = {}, _extends2[address] = decimals, _extends2)), _extends3));
        return decimals;
      })).then(_temp3));
    } catch (e) {
      return Promise.reject(e);
    }
  };
  Fetcher2.fetchPairData = function fetchPairData(tokenA, tokenB, provider) {
    try {
      if (provider === void 0)
        provider = getDefaultProvider(getNetwork(tokenA.chainId));
      !(tokenA.chainId === tokenB.chainId) ? true ? tiny_invariant_esm_default(false, "CHAIN_ID") : tiny_invariant_esm_default(false) : void 0;
      var address = Pair.getAddress(tokenA, tokenB);
      return Promise.resolve(new Contract(address, IUniswapV2Pair_default.abi, provider).getReserves()).then(function(_ref) {
        var reserves0 = _ref[0], reserves1 = _ref[1];
        var balances = tokenA.sortsBefore(tokenB) ? [reserves0, reserves1] : [reserves1, reserves0];
        return new Pair(new TokenAmount(tokenA, balances[0]), new TokenAmount(tokenB, balances[1]));
      });
    } catch (e) {
      return Promise.reject(e);
    }
  };
  return Fetcher2;
}();

// node_modules/eth-hooks/dapps.js
var import_react = __toModule(require_react());
var import_axios = __toModule(require_axios());
var import_react2 = __toModule(require_react());
var import_react3 = __toModule(require_react());
var import_react4 = __toModule(require_react());
var useDexEthPrice = (mainnetProvider, targetNetworkInfo, pollTime = 0) => {
  let [price, setPrice] = (0, import_react.useState)(0), callFunc = (0, import_react.useCallback)(() => {
    (async () => {
      if (targetNetworkInfo == null ? void 0 : targetNetworkInfo.price)
        setPrice(targetNetworkInfo.price);
      else if (mainnetProvider) {
        let network = await mainnetProvider.getNetwork(), DAI = new Token(network ? network.chainId : 1, "0x6B175474E89094C44Da98b954EedeAC495271d0F", 18), pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId], mainnetProvider), route = new Route([pair], WETH[DAI.chainId]);
        setPrice(parseFloat(route.midPrice.toSignificant(6)));
      } else
        setPrice(-1), console.warn("useDexEthPrice: mainnetProvider or targetNetwork not given");
    })();
  }, [targetNetworkInfo == null ? void 0 : targetNetworkInfo.price, mainnetProvider]);
  return useOnRepetition(callFunc, { pollTime, provider: mainnetProvider }), price;
};
var useDexTokenList = (tokenListUri = "https://gateway.ipfs.io/ipns/tokens.uniswap.org", chainId) => {
  let [tokenList, setTokenList] = (0, import_react2.useState)([]), blockNumber = useBlockNumberContext(), callFunc = (0, import_react2.useCallback)(async () => {
    try {
      let tokenListResp = (await (0, import_axios.default)(tokenListUri)).data;
      if (tokenListResp != null) {
        let tokenInfo = [];
        chainId ? tokenInfo = tokenListResp.tokens.filter((t) => t.chainId === chainId) : tokenInfo = tokenListResp.tokens, setTokenList(tokenInfo);
      }
    } catch (e) {
      console.log(e);
    }
  }, [chainId, tokenListUri]);
  return (0, import_react2.useEffect)(() => {
    callFunc();
  }, [blockNumber, callFunc]), tokenList;
};
var lookupAddress = async (provider, address) => {
  if (utils_exports.isAddress(address))
    try {
      let reportedName = await provider.lookupAddress(address), resolvedAddress = await provider.resolveName(reportedName);
      return address && utils_exports.getAddress(address) === utils_exports.getAddress(resolvedAddress) ? reportedName : utils_exports.getAddress(address);
    } catch {
      return utils_exports.getAddress(address);
    }
  return "";
};
var useResolveEnsName = (mainnetProvider, address) => {
  let [ensName, setEnsName] = (0, import_react3.useState)(address);
  return (0, import_react3.useEffect)(() => {
    let storedData = window.localStorage.getItem("ensCache_" + address), cache = JSON.parse(storedData != null ? storedData : "{}");
    cache && (cache == null ? void 0 : cache.name) && (cache == null ? void 0 : cache.timestamp) > Date.now() ? setEnsName(cache == null ? void 0 : cache.name) : mainnetProvider && lookupAddress(mainnetProvider, address).then((name) => {
      name && (setEnsName(name), window.localStorage.setItem("ensCache_" + address, JSON.stringify({ timestamp: Date.now() + 36e4, name })));
    });
  }, [address, mainnetProvider]), ensName;
};
var useResolveEnsAddress = (mainnetProvider, ensName) => {
  let [address, setAddress] = (0, import_react4.useState)(lib_exports.AddressZero);
  return (0, import_react4.useEffect)(() => {
    mainnetProvider && mainnetProvider.resolveName(ensName).then((resolvedAddress) => setAddress(resolvedAddress));
  }, [mainnetProvider, ensName]), address;
};

export {
  useDexEthPrice,
  useDexTokenList,
  useResolveEnsName,
  useResolveEnsAddress
};
//# sourceMappingURL=chunk-CKBXXWKU.js.map
