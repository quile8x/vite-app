{
  "version": 3,
  "sources": ["../src/context/BlockNumberContext.tsx", "../src/context/EthersAppContext.tsx", "../src/context/connectors/EthersModalConnector.ts", "../src/context/connectors/connectorErrors.ts", "../src/models/constants/common.ts", "../src/context/connectors/StaticJsonRpcProviderConnector.ts", "../usehooks-ts/src/useBoolean/useBoolean.ts", "../usehooks-ts/src/useCopyToClipboard/useCopyToClipboard.ts", "../usehooks-ts/src/useCounter/useCounter.ts", "../usehooks-ts/src/useDarkMode/useDarkMode.ts", "../usehooks-ts/src/useLocalStorage/useLocalStorage.ts", "../usehooks-ts/src/useDebounce/useDebounce.ts", "../usehooks-ts/src/useElementSize/useElementSize.ts", "../usehooks-ts/src/useEventListener/useEventListener.ts", "../usehooks-ts/src/useFetch/useFetch.ts", "../usehooks-ts/src/useHover/useHover.ts", "../usehooks-ts/src/useImageOnLoad/useImageOnLoad.ts", "../usehooks-ts/src/useIntersectionObserver/useIntersectionObserver.ts", "../usehooks-ts/src/useInterval/useInterval.ts", "../usehooks-ts/src/useIsClient/useIsClient.ts", "../usehooks-ts/src/useIsMounted/useIsMounted.ts", "../usehooks-ts/src/useLockedBody/useLockedBody.ts", "../usehooks-ts/src/useMap/useMap.ts", "../usehooks-ts/src/useOnClickOutside/useOnClickOutside.ts", "../usehooks-ts/src/useReadLocalStorage/useReadLocalStorage.ts", "../usehooks-ts/src/useScreen/useScreen.ts", "../usehooks-ts/src/useScript/useScript.ts", "../usehooks-ts/src/useTimeout/useTimeout.ts", "../usehooks-ts/src/useWindowSize/useWindowSize.ts", "../@web3-react/types/src/index.ts", "../@web3-react/abstract-connector/src/index.ts", "../eth-hooks/node_modules/node_modules/babel-plugin-transform-async-to-promises/helpers.js", "../eth-hooks/node_modules/@web3-react/core/src/normalizers.ts", "../eth-hooks/node_modules/@web3-react/core/src/manager.ts", "../eth-hooks/node_modules/@web3-react/core/src/provider.tsx"],
  "sourcesContent": ["import { createContext, FC, useContext, useEffect, useReducer } from 'react';\r\nimport { useIsMounted } from 'usehooks-ts';\r\n\r\nimport { useEthersContext } from '~~/context';\r\n\r\nconst BlockNumberReactContext = createContext<number | undefined>(undefined);\r\n\r\n/** *\r\n * @internal\r\n */\r\ninterface State {\r\n  [chainId: number]: number | undefined;\r\n}\r\n\r\n/**\r\n *\r\n * @internal\r\n *\r\n */\r\ninterface Payload {\r\n  chainId: number;\r\n  blockNumber: number;\r\n}\r\n\r\n/**\r\n *\r\n * @internal\r\n *\r\n * @param state\r\n * @param payload\r\n * @returns\r\n */\r\nconst reducer = (state: State = {}, payload: Payload): State => {\r\n  const current = state[payload.chainId];\r\n  if (!current || payload.blockNumber > current) {\r\n    return {\r\n      ...state,\r\n      [payload.chainId]: payload.blockNumber,\r\n    };\r\n  }\r\n  return state;\r\n};\r\n\r\n/**\r\n * #### Summary\r\n * A hook that gets you the current blocknumber via react context\r\n * - can be shared by your whole app.\r\n *\r\n * #### Use\r\n * Make sure to wrap your main app with the {@link EthersAppContext}.\r\n * - See [scaffold-eth-typescript example](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/0225179a2a8bb7b3a255d6eff4802b47d72809dd/packages/vite-app-ts/src/components/routes/App.tsx#L38)\r\n *\r\n *\r\n * #### Notes\r\n * - this extensively used by eth-hooks to trigger hooks when a new block arrives\r\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\r\n *\r\n * @category EthersContext\r\n *\r\n * @returns current block number\r\n */\r\nexport const useBlockNumberContext = (): number => {\r\n  const blockNumber = useContext(BlockNumberReactContext);\r\n  if (blockNumber == null) {\r\n    console.log('blockNumber context is null');\r\n  }\r\n  // invariant(blockNumber != null, 'useBlockNumberContext needs to be used under BlockNumberContext');\r\n  return blockNumber ?? 0;\r\n};\r\n\r\ninterface IProps {\r\n  providerKey?: string;\r\n}\r\n\r\n/**\r\n * #### Summary\r\n * A context that works with {@link useBlockNumberContext} to give access to the current provider's block number in any place in your app\r\n *\r\n * @category EthersContext\r\n *\r\n * @param props\r\n * @returns\r\n */\r\nexport const BlockNumberContext: FC<IProps> = (props) => {\r\n  const { ethersProvider, chainId } = useEthersContext(props.providerKey);\r\n\r\n  const isMounted = useIsMounted();\r\n  const [state, dispatch] = useReducer(reducer, {});\r\n  undefined;\r\n  const blockNumber: number | undefined = chainId && state?.[chainId] ? state?.[chainId] : 0;\r\n\r\n  useEffect(() => {\r\n    if (chainId && ethersProvider) {\r\n      const update = (blockNumber: number): void => {\r\n        if (isMounted()) dispatch({ chainId, blockNumber });\r\n      };\r\n      ethersProvider?.addListener?.('block', update);\r\n\r\n      // if the current value is undefined, do an initial fetch\r\n      if (state?.[chainId] == null) {\r\n        ethersProvider?.getBlockNumber().then((val) => {\r\n          if (isMounted()) dispatch({ chainId, blockNumber: val });\r\n        });\r\n      }\r\n\r\n      return (): void => {\r\n        ethersProvider?.removeListener?.('block', update);\r\n      };\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [chainId, ethersProvider, isMounted]);\r\n\r\n  return <BlockNumberReactContext.Provider value={blockNumber}>{props.children} </BlockNumberReactContext.Provider>;\r\n};\r\n", "import { Web3Provider } from '@ethersproject/providers';\r\nimport { AbstractConnector } from '@web3-react/abstract-connector';\r\nimport { useWeb3React, Web3ReactProvider } from '@web3-react/core';\r\nimport { Web3ReactContextInterface } from '@web3-react/core/dist/types';\r\nimport { Signer } from 'ethers';\r\nimport { FC, useCallback } from 'react';\r\n\r\nimport { NoEthereumProviderFoundError } from '~~/context';\r\nimport { BlockNumberContext } from '~~/context/BlockNumberContext';\r\nimport { EthersModalConnector, TEthersModalConnector } from '~~/context/connectors/EthersModalConnector';\r\nimport { isEthersProvider } from '~~/functions/ethersHelpers';\r\nimport { TEthersProvider } from '~~/models';\r\n\r\n/**\r\n * #### Summary\r\n * A callback type that returns a EthersModalConnector\r\n *\r\n * #### Notes\r\n * - can be used by components that need to give a connector to {@link IEthersContext.openModal}\r\n *\r\n * @category EthersContext\r\n */\r\nexport type CreateEthersModalConnector = () => TEthersModalConnector | undefined;\r\n\r\n/**\r\n * #### Summary\r\n * The return type of {@link EthersModalConnector}\r\n * - ethers compatable provider {@link TEthersProvider}\r\n * - a callback to change the current signer\r\n * - the current account, chainId and signer\r\n * - callbacks to open the web3Modal, logout or change theme\r\n *\r\n * @category EthersContext\r\n */\r\nexport interface IEthersContext extends Web3ReactContextInterface<TEthersProvider> {\r\n  connector: TEthersModalConnector | undefined;\r\n  ethersProvider: TEthersProvider | undefined;\r\n  active: boolean;\r\n  signer: Signer | undefined;\r\n  account: string | undefined;\r\n  chainId: number | undefined;\r\n  changeSigner: ((signer: Signer) => Promise<void>) | undefined;\r\n  openModal: (ethersModalConnector: TEthersModalConnector) => void;\r\n  disconnectModal: () => void;\r\n  setModalTheme: ((theme: 'light' | 'dark') => void) | undefined;\r\n}\r\n\r\n/**\r\n * A wrapper around useWeb3React that provides functionality for web3modal\r\n * and eth-hooks compatability\r\n * @param providerKey (string) :: (optional) :: used if you want a secondary provider context, for example to mainnet\r\n * @returns (IEthersWeb3Context)\r\n */\r\n\r\n/**\r\n * #### Summary\r\n * This Hook provides you with access to the current Ethers Provider Context.\r\n * This provider would be the one selected by using {@link EthersModalConnect} and Web3Modal\r\n *\r\n * #### Features\r\n * Gives you access to consistent interface to get the current provider information {@link EthersModalConnector}\r\n * - ethers compatable provider {@link TEthersProvider}\r\n * - a callback to change the current account (signer)\r\n * - the current account, chainId and signer\r\n * - callbacks to open the web3Modal, logout or change theme\r\n *\r\n * #### Notes\r\n * - currently providerKey isnt being used\r\n *\r\n * @category EthersContext\r\n *\r\n * @param providerKey\r\n * @returns\r\n */\r\nexport const useEthersContext = (providerKey?: string): IEthersContext => {\r\n  const { connector, activate, library, account, deactivate, chainId, ...context } =\r\n    useWeb3React<TEthersProvider>(providerKey);\r\n  if (!(connector instanceof EthersModalConnector || connector instanceof AbstractConnector) && connector != null) {\r\n    throw 'Connector is not a EthersModalConnector';\r\n  }\r\n  const ethersConnector = connector as EthersModalConnector;\r\n\r\n  const openWeb3Modal = useCallback(\r\n    (ethersModalConnector: TEthersModalConnector | undefined) => {\r\n      if (context.active) {\r\n        deactivate();\r\n      }\r\n\r\n      if (ethersModalConnector == null) {\r\n        console.error('A valid ethersModalConnector was not provided');\r\n      }\r\n      if (ethersModalConnector != null) {\r\n        const onError = (error: Error): void => {\r\n          try {\r\n            connector?.deactivate?.();\r\n            console.warn(error);\r\n          } catch {}\r\n        };\r\n        void activate(ethersModalConnector, onError).catch(onError);\r\n      }\r\n    },\r\n    [context.active, deactivate, activate, connector]\r\n  );\r\n\r\n  const disconnectModal = useCallback(() => {\r\n    ethersConnector.resetModal();\r\n    deactivate();\r\n  }, [deactivate, ethersConnector]);\r\n\r\n  const result: IEthersContext = {\r\n    connector: ethersConnector,\r\n    ethersProvider: library,\r\n    activate,\r\n    deactivate,\r\n    library,\r\n    account: account ?? undefined,\r\n    signer: ethersConnector?.getSigner(),\r\n    chainId,\r\n    changeSigner: ethersConnector?.changeSigner.bind(ethersConnector),\r\n    openModal: openWeb3Modal,\r\n    disconnectModal: disconnectModal,\r\n    setModalTheme: ethersConnector?.setModalTheme.bind(ethersConnector),\r\n    ...context,\r\n  };\r\n\r\n  return result;\r\n};\r\n\r\n/**\r\n * Convert the provider obtained from web3Modal into a ethers.web3provider\r\n *\r\n * @internal\r\n *\r\n * @param provider\r\n * @param _connector\r\n * @returns\r\n */\r\nexport const getEthersAppProviderLibrary = (\r\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\r\n  provider: any,\r\n  connector: AbstractConnector | undefined\r\n): TEthersProvider => {\r\n  if (provider == null) {\r\n    throw new NoEthereumProviderFoundError();\r\n  }\r\n\r\n  let anyNetwork: string | undefined = undefined;\r\n  if (connector instanceof EthersModalConnector) {\r\n    anyNetwork = connector.config.immutableProvider ? 'any' : undefined;\r\n  }\r\n\r\n  if (isEthersProvider(provider)) {\r\n    return provider as TEthersProvider;\r\n  } else {\r\n    return new Web3Provider(provider, anyNetwork);\r\n  }\r\n};\r\n/**\r\n * #### Summary\r\n * Ethers App Context for your react app to be used with {@link useEthersContext}.\r\n * This is a wrapper around Web3ReactProvider that provides additional functionality such as a {@link BlockNumberContext} and access to {@link IEthersContext}\r\n *\r\n * @category EthersContext\r\n *\r\n * @param props\r\n * @returns\r\n */\r\nexport const EthersAppContext: FC = (props) => {\r\n  return (\r\n    <Web3ReactProvider getLibrary={getEthersAppProviderLibrary}>\r\n      <BlockNumberContext>{props.children}</BlockNumberContext>\r\n    </Web3ReactProvider>\r\n  );\r\n};\r\n", "import { Web3Provider } from '@ethersproject/providers';\r\nimport { AbstractConnector } from '@web3-react/abstract-connector';\r\nimport { ConnectorUpdate } from '@web3-react/types';\r\nimport { BigNumber, Signer, utils } from 'ethers';\r\nimport Core, { ICoreOptions, ThemeColors } from 'web3modal';\r\n\r\nimport { isEthersProvider } from '../../functions/ethersHelpers';\r\n\r\nimport { UserClosedModalError, CouldNotActivateError } from './connectorErrors';\r\n\r\nimport { TEthersProvider } from '~~/models';\r\nimport { const_web3DialogClosedByUser } from '~~/models/constants/common';\r\n\r\ntype TEthersModalConfig = {\r\n  /**\r\n   * when network (chain) or provider changes reload the page\r\n   */\r\n  reloadOnNetworkChange: boolean;\r\n  /**\r\n   * ### Summary\r\n   * ethers.io recomments an immutable provider, and by default doesn't allow\r\n   * network changes (i.e.) metamask changing chains.\r\n   * - if immutableProvider is true, it will follow the default behaviour\r\n   * - if immutableProvider is false, it will allow network changes\r\n   *\r\n   * ### Notes\r\n   * see https://github.com/ethers-io/ethers.js/discussions/1480\r\n   */\r\n  immutableProvider: boolean;\r\n};\r\n\r\ntype TWeb3ModalTheme = 'light' | 'dark';\r\n\r\n/**\r\n * #### Summary\r\n * An interface implemented by {@link EthersModalConnector} in addition to AbstractConnector\r\n */\r\nexport interface ICommonModalConnector {\r\n  getSigner(): Signer | undefined;\r\n  setModalTheme(theme: TWeb3ModalTheme | ThemeColors): void;\r\n  resetModal(): void;\r\n  changeSigner(signer: Signer): Promise<void>;\r\n}\r\n\r\nexport type TEthersModalConnector = ICommonModalConnector & AbstractConnector;\r\n\r\n/**\r\n * #### Summary\r\n * This is a connector for (web3-react)[https://github.com/NoahZinsmeister/web3-react] that allows it to interface with [web3Modal](https://github.com/Web3Modal/web3modal).\r\n * The provider selected by user via web3modal is interfaced to the web3-react context.\r\n *\r\n * #### Features\r\n * - This connector used with {@link useEthersContext} allows the app and all the hooks to effortlessly access the current network, provider, signer, address information {@link IEthersContext}\r\n * - The connector centralizes and takes care of management of the web3 interaction and provides a consistent exprience for your app.\r\n *\r\n * #### Notes\r\n * - inherits from web3-react class AbstractConnector\r\n *\r\n * @category EthersContext\r\n */\r\nexport class EthersModalConnector extends AbstractConnector implements ICommonModalConnector {\r\n  protected _options: Partial<ICoreOptions>;\r\n  protected _providerBase?: any;\r\n  protected _ethersProvider?: TEthersProvider;\r\n  protected _web3Modal?: Core;\r\n  protected _id: string | undefined;\r\n  protected _debug: boolean = false;\r\n  protected _config: TEthersModalConfig;\r\n  protected _signer: Signer | undefined;\r\n  protected _theme: TWeb3ModalTheme | ThemeColors;\r\n\r\n  get config(): TEthersModalConfig {\r\n    return this._config;\r\n  }\r\n\r\n  /**\r\n   * @param web3modalOptions see [web3modal docs](https://github.com/Web3Modal/web3modal#provider-options) for details.  You can also check the [scaffold-eth-typescript web3config](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/main/packages/vite-app-ts/src/config/web3ModalConfig.ts) for an example.\r\n   * @param config Configuration for EthersModalConnector\r\n   * @param id allows you to connect directly to a specific provider.  [See docs](https://github.com/Web3Modal/web3modal#connect-to-specific-provider)\r\n   * @param debug turn on debug logging\r\n   */\r\n  constructor(\r\n    web3modalOptions: Partial<ICoreOptions>,\r\n    config: TEthersModalConfig = { reloadOnNetworkChange: false, immutableProvider: false },\r\n    id?: string,\r\n    debug: boolean = false\r\n  ) {\r\n    super();\r\n\r\n    this._options = web3modalOptions;\r\n    this._id = id;\r\n    this._debug = debug;\r\n    this._config = config;\r\n    this._theme = (web3modalOptions.theme as TWeb3ModalTheme | ThemeColors) ?? 'light';\r\n\r\n    this.handleChainChanged = this.handleChainChanged.bind(this);\r\n    this.handleAccountsChanged = this.handleAccountsChanged.bind(this);\r\n    this.handleDisconnect = this.handleDisconnect.bind(this);\r\n    this.handleClose = this.handleClose.bind(this);\r\n  }\r\n\r\n  protected log(...args: any[]): void {\r\n    if (this._debug) {\r\n      console.log('\uD83D\uDD0C ', args);\r\n    }\r\n  }\r\n\r\n  private maybeReload(): void {\r\n    if (window && this._config.reloadOnNetworkChange) {\r\n      window.location.reload();\r\n    }\r\n  }\r\n\r\n  private setEthersProvider(): void {\r\n    if (this.isEthersProvider()) {\r\n      this._ethersProvider = this._providerBase as TEthersProvider;\r\n    } else {\r\n      this._ethersProvider = new Web3Provider(this._providerBase, this._config.immutableProvider ? 'any' : undefined);\r\n    }\r\n  }\r\n\r\n  private handleChainChanged(chainId: number | string): void {\r\n    this.log(`Handling chain changed to ${chainId}! updating providers`);\r\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\r\n    this.emitUpdate?.({ chainId, provider: this._providerBase });\r\n    this.setEthersProvider();\r\n    this.maybeReload();\r\n  }\r\n\r\n  private handleAccountsChanged(accounts: string[]): void {\r\n    this.log(`Handling accounts changed`, accounts);\r\n    if (accounts.length === 0) {\r\n      this.emitDeactivate?.();\r\n    } else {\r\n      this.emitUpdate?.({ account: accounts[0] });\r\n    }\r\n  }\r\n\r\n  private handleDisconnect(code: any, reason: any): void {\r\n    this.log(`Handling disconnected event`, code, reason);\r\n    this.deactivate();\r\n  }\r\n\r\n  private handleClose(code: number, reason: string): void {\r\n    this.log(\"Handling 'close' event\", code, reason);\r\n    this.deactivate();\r\n  }\r\n\r\n  private load(): void {\r\n    if (!this._web3Modal) {\r\n      this._web3Modal = new Core({ ...this._options, theme: this._theme });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * #### Summary\r\n   * Inherits from AbstractConnector.  This activates web3Modal and opens the modal.\r\n   *\r\n   * #### Notes\r\n   * Once the user selects a provider\r\n   * - this will activate the provider and attach the appropriate event listeners.\r\n   * - get the account and signer\r\n   * - gets the ethers compatable provider\r\n   *\r\n   * #### Errors\r\n   * - {@link UserClosedModalError}\r\n   * - {@link CouldNotActivateError}\r\n   * @returns\r\n   */\r\n  public async activate(): Promise<ConnectorUpdate> {\r\n    try {\r\n      this.load();\r\n\r\n      if (this._web3Modal) {\r\n        if (this._options.cacheProvider === false) this.resetModal();\r\n        console.log('Open provider modal');\r\n        await this._web3Modal.updateTheme(this._theme);\r\n        /* eslint-disable @typescript-eslint/no-unsafe-assignment*/\r\n        if (this._id) {\r\n          this._providerBase = await this._web3Modal.connectTo(this._id);\r\n        } else {\r\n          this._providerBase = await this._web3Modal.connect();\r\n        }\r\n        /* eslint-enable */\r\n\r\n        /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call*/\r\n        this._providerBase.on('chainChanged', this.handleChainChanged);\r\n        this._providerBase.on('accountsChanged', this.handleAccountsChanged);\r\n        this._providerBase.on('disconnect', this.handleDisconnect as any);\r\n        this._providerBase.on('close', this.handleClose as any);\r\n        /* eslint-enable */\r\n\r\n        this.setEthersProvider();\r\n      }\r\n\r\n      /* eslint-disable */\r\n      const account: string = this._providerBase?.selectedAddress ?? (await this.getAccount());\r\n      let chainId: number =\r\n        this._providerBase?.networkVersion ?? BigNumber.from(this._providerBase?.chainId ?? 0).toNumber();\r\n      if (chainId === 0) {\r\n        chainId = (await this.getChainId()) as number;\r\n      }\r\n      this.setSignerFromAccount(account);\r\n\r\n      return { provider: this._providerBase, account, chainId };\r\n      /* eslint-enable */\r\n    } catch (error) {\r\n      this.resetModal();\r\n      if ((error as string)?.includes(const_web3DialogClosedByUser)) {\r\n        console.log(error);\r\n        this.deactivate();\r\n        throw new UserClosedModalError();\r\n      } else {\r\n        console.error('EthersModalConnector: Could not activate provider', error, this._providerBase);\r\n        throw new CouldNotActivateError(error);\r\n      }\r\n    }\r\n  }\r\n\r\n  private isEthersProvider(): boolean {\r\n    return isEthersProvider(this._providerBase);\r\n  }\r\n\r\n  /**\r\n   * #### Summary\r\n   * Safely deactivates the current provider and removes all event listeners\r\n   */\r\n  public deactivate(): void {\r\n    /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call  */\r\n    this.emitDeactivate?.();\r\n\r\n    this._providerBase?.removeListener('disconnect', this.handleDisconnect);\r\n    this._providerBase?.removeListener('chainChanged', this.handleChainChanged);\r\n    this._providerBase?.removeListener('accountsChanged', this.handleAccountsChanged);\r\n    this._providerBase?.removeListener('close', this.handleClose);\r\n\r\n    const provider = this._providerBase;\r\n\r\n    // use disconnect function if exists\r\n    provider?.disconnect?.();\r\n    // use close function if exists\r\n    provider?.close?.();\r\n\r\n    this.maybeReload();\r\n    /* eslint-enable  */\r\n  }\r\n\r\n  public getProvider(): Promise<TEthersProvider | undefined> {\r\n    return Promise.resolve(this._ethersProvider) as Promise<TEthersProvider | undefined>;\r\n  }\r\n\r\n  public async getChainId(): Promise<number | string> {\r\n    return Promise.resolve(this._ethersProvider?.network?.chainId ?? 0) as Promise<number | string>;\r\n  }\r\n\r\n  private async setSignerFromAccount(account: string | null): Promise<void> {\r\n    if (account && utils.isAddress(account) && (await this._signer?.getAddress()) !== account) {\r\n      this._signer = this._ethersProvider?.getSigner(account);\r\n    }\r\n  }\r\n\r\n  public async getAccount(): Promise<null | string> {\r\n    if (this._signer) {\r\n      const account = await this._signer.getAddress();\r\n      if (utils.isAddress(account)) return account;\r\n    }\r\n\r\n    const accounts = await this._ethersProvider?.listAccounts();\r\n    const account = accounts?.[0] ?? null;\r\n    await this.setSignerFromAccount(account);\r\n    return Promise.resolve(accounts?.[0] ?? null);\r\n  }\r\n\r\n  public getSigner(): Signer | undefined {\r\n    return this._signer;\r\n  }\r\n\r\n  /**\r\n   * #### Summary\r\n   * Change the current signer and account used by the connector\r\n   * @param signer\r\n   */\r\n  public async changeSigner(signer: Signer): Promise<void> {\r\n    const account = await signer.getAddress();\r\n    if (utils.isAddress(account) && this.validState()) {\r\n      this._signer = signer;\r\n      this.handleAccountsChanged([account]);\r\n\r\n      console.log(`changeSigner: provider chainId ${await this.getChainId()}`);\r\n      console.log(`new signer chainId ${(await signer.provider?.getNetwork())?.chainId ?? ''}`);\r\n    }\r\n  }\r\n\r\n  protected validState(): boolean {\r\n    return this._providerBase != null && this._ethersProvider != null && this._web3Modal != null;\r\n  }\r\n\r\n  /**\r\n   * #### Summary\r\n   * Resets the web3Modal and clears the cache\r\n   */\r\n  public resetModal(): void {\r\n    if (this._web3Modal) {\r\n      this._web3Modal.clearCachedProvider();\r\n      this._providerBase = undefined;\r\n      this._ethersProvider = undefined;\r\n      this._signer = undefined;\r\n      this.emitUpdate?.({ account: undefined, provider: undefined, chainId: undefined });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * #### Summary\r\n   * Sets the web3modal theme: light | dark | ThemeColors\r\n   * @param theme\r\n   */\r\n  public setModalTheme(theme: TWeb3ModalTheme | ThemeColors): void {\r\n    this._theme = theme;\r\n  }\r\n}\r\n", "/**\r\n * @category EthersContext\r\n */\r\nexport class UserClosedModalError extends Error {\r\n  public constructor() {\r\n    super();\r\n    this.name = this.constructor.name;\r\n    this.message = 'EthersModalConnector: The user closed the modal with selecting a provider.';\r\n  }\r\n}\r\n\r\n/**\r\n * @category EthersContext\r\n */\r\nexport class CouldNotActivateError extends Error {\r\n  public constructor(error: unknown) {\r\n    super();\r\n    this.name = this.constructor.name;\r\n    this.message = `EthersModalConnector: Could not activate provider.  ${(error as string) ?? ''}`;\r\n  }\r\n}\r\n\r\n/**\r\n * @category EthersContext\r\n */\r\nexport class NoEthereumProviderFoundError extends Error {\r\n  public constructor() {\r\n    super();\r\n    this.name = this.constructor.name;\r\n    this.message = `EthersModalConnector: No ethereum provider Found.`;\r\n  }\r\n}\r\n", "export const const_web3DialogClosedByUser = 'Modal closed by user';\r\n", "import { StaticJsonRpcProvider } from '@ethersproject/providers';\r\nimport { IAbstractConnectorOptions } from 'web3modal';\r\n\r\n/**\r\n * #### Summary\r\n * A web3modal CustomProvider Options\r\n * - Options for web3modal that allows you to connect to a StaticJsonRpcProvider such as localhost\r\n *\r\n * @category EthersContext\r\n */\r\nexport interface IStaticJsonRpcProviderConnectorOptions extends IAbstractConnectorOptions {\r\n  rpc: { [chainId: number]: string };\r\n  currentChainId: number;\r\n}\r\n\r\n/**\r\n * #### Summary\r\n * A connector that can be used by apps to connect let web3Modal connect to a StaticJsonRpcProvider\r\n * - For example you can use this to connect to a localhost provider\r\n *\r\n * #### Notes\r\n * See scaffold-eth-typescript for an example that uses it to connect to a localhost burner wallet.\r\n * - [scaffold-eth-typescript example](https://github.com/scaffold-eth/scaffold-eth-typescript/blob/0225179a2a8bb7b3a255d6eff4802b47d72809dd/packages/vite-app-ts/src/config/web3ModalConfig.ts#L86)\r\n *\r\n * @category EthersContext\r\n *\r\n * @param _package not used\r\n * @param opts\r\n * @returns\r\n */\r\nexport const ConnectToStaticJsonRpcProvider = async (\r\n  _package: unknown,\r\n  opts: IStaticJsonRpcProviderConnectorOptions\r\n): Promise<StaticJsonRpcProvider | undefined> => {\r\n  const url = opts.rpc[opts.currentChainId];\r\n  try {\r\n    const provider = new StaticJsonRpcProvider(url, opts.currentChainId);\r\n    await provider.getNetwork();\r\n    await provider.getBlockNumber();\r\n    if (!provider?.anyNetwork) {\r\n      console.warn(`ConnectToStaticJsonRpcProvider: could not connect to chain: ${opts.currentChainId} url: ${url}`);\r\n    }\r\n    return provider;\r\n  } catch (e) {\r\n    throw new Error('No StaticJsonRpcProvider found');\r\n  }\r\n};\r\n", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, "export interface AbstractConnectorArguments {\n  supportedChainIds?: number[]\n}\n\nexport interface ConnectorUpdate<T = number | string> {\n  provider?: any\n  chainId?: T\n  account?: null | string\n}\n\nexport enum ConnectorEvent {\n  Update = 'Web3ReactUpdate',\n  Error = 'Web3ReactError',\n  Deactivate = 'Web3ReactDeactivate'\n}\n", "import { EventEmitter } from 'events'\nimport { AbstractConnectorArguments, ConnectorUpdate, ConnectorEvent } from '@web3-react/types'\n\nexport abstract class AbstractConnector extends EventEmitter {\n  public readonly supportedChainIds?: number[]\n\n  constructor({ supportedChainIds }: AbstractConnectorArguments = {}) {\n    super()\n    this.supportedChainIds = supportedChainIds\n  }\n\n  public abstract async activate(): Promise<ConnectorUpdate>\n  public abstract async getProvider(): Promise<any>\n  public abstract async getChainId(): Promise<number | string>\n  public abstract async getAccount(): Promise<null | string>\n  public abstract deactivate(): void\n\n  protected emitUpdate(update: ConnectorUpdate): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Update}' with payload`, update)\n    }\n    this.emit(ConnectorEvent.Update, update)\n  }\n\n  protected emitError(error: Error): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Error}' with payload`, error)\n    }\n    this.emit(ConnectorEvent.Error, error)\n  }\n\n  protected emitDeactivate(): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Deactivate}'`)\n    }\n    this.emit(ConnectorEvent.Deactivate)\n  }\n}\n", "// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n", "import { arrayify } from '@ethersproject/bytes'\nimport { keccak256 } from '@ethersproject/keccak256'\nimport invariant from 'tiny-invariant'\n\nexport function normalizeChainId(chainId: string | number): number {\n  if (typeof chainId === 'string') {\n    // Temporary fix until the next version of Metamask Mobile gets released.\n    // In the current version (0.2.13), the chainId starts with \u201COx\u201D rather\n    // than \u201C0x\u201D. Fix: https://github.com/MetaMask/metamask-mobile/pull/1275\n    chainId = chainId.replace(/^Ox/, '0x')\n\n    const parsedChainId = Number.parseInt(chainId, chainId.trim().substring(0, 2) === '0x' ? 16 : 10)\n    invariant(!Number.isNaN(parsedChainId), `chainId ${chainId} is not an integer`)\n    return parsedChainId\n  } else {\n    invariant(Number.isInteger(chainId), `chainId ${chainId} is not an integer`)\n    return chainId\n  }\n}\n\n// https://github.com/ethers-io/ethers.js/blob/d9d438a119bb11f8516fc9cf02c534ab3816fcb3/packages/address/src.ts/index.ts\nexport function normalizeAccount(_address: string): string {\n  invariant(typeof _address === 'string' && _address.match(/^(0x)?[0-9a-fA-F]{40}$/), `Invalid address ${_address}`)\n\n  const address = _address.substring(0, 2) === '0x' ? _address : `0x${_address}`\n  const chars = address\n    .toLowerCase()\n    .substring(2)\n    .split('')\n\n  const charsArray = new Uint8Array(40)\n  for (let i = 0; i < 40; i++) {\n    charsArray[i] = chars[i].charCodeAt(0)\n  }\n  const hashed = arrayify(keccak256(charsArray))\n\n  for (let i = 0; i < 40; i += 2) {\n    if (hashed[i >> 1] >> 4 >= 8) {\n      chars[i] = chars[i].toUpperCase()\n    }\n    if ((hashed[i >> 1] & 0x0f) >= 8) {\n      chars[i + 1] = chars[i + 1].toUpperCase()\n    }\n  }\n\n  const addressChecksum = `0x${chars.join('')}`\n\n  invariant(\n    !(address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && address !== addressChecksum),\n    `Bad address checksum ${address} ${addressChecksum}`\n  )\n\n  return addressChecksum\n}\n", "import { useReducer, useEffect, useCallback, useRef } from 'react'\nimport { ConnectorUpdate, ConnectorEvent } from '@web3-react/types'\nimport { AbstractConnector } from '@web3-react/abstract-connector'\nimport warning from 'tiny-warning'\n\nimport { Web3ReactManagerReturn } from './types'\nimport { normalizeChainId, normalizeAccount } from './normalizers'\n\nclass StaleConnectorError extends Error {\n  constructor() {\n    super()\n    this.name = this.constructor.name\n  }\n}\n\nexport class UnsupportedChainIdError extends Error {\n  public constructor(unsupportedChainId: number, supportedChainIds?: readonly number[]) {\n    super()\n    this.name = this.constructor.name\n    this.message = `Unsupported chain id: ${unsupportedChainId}. Supported chain ids are: ${supportedChainIds}.`\n  }\n}\n\ninterface Web3ReactManagerState {\n  connector?: AbstractConnector\n  provider?: any\n  chainId?: number\n  account?: null | string\n\n  onError?: (error: Error) => void\n\n  error?: Error\n}\n\nenum ActionType {\n  ACTIVATE_CONNECTOR,\n  UPDATE,\n  UPDATE_FROM_ERROR,\n  ERROR,\n  ERROR_FROM_ACTIVATION,\n  DEACTIVATE_CONNECTOR\n}\n\ninterface Action {\n  type: ActionType\n  payload?: any\n}\n\nfunction reducer(state: Web3ReactManagerState, { type, payload }: Action): Web3ReactManagerState {\n  switch (type) {\n    case ActionType.ACTIVATE_CONNECTOR: {\n      const { connector, provider, chainId, account, onError } = payload\n      return { connector, provider, chainId, account, onError }\n    }\n    case ActionType.UPDATE: {\n      const { provider, chainId, account } = payload\n      return {\n        ...state,\n        ...(provider === undefined ? {} : { provider }),\n        ...(chainId === undefined ? {} : { chainId }),\n        ...(account === undefined ? {} : { account })\n      }\n    }\n    case ActionType.UPDATE_FROM_ERROR: {\n      const { provider, chainId, account } = payload\n      return {\n        ...state,\n        ...(provider === undefined ? {} : { provider }),\n        ...(chainId === undefined ? {} : { chainId }),\n        ...(account === undefined ? {} : { account }),\n        error: undefined\n      }\n    }\n    case ActionType.ERROR: {\n      const { error } = payload\n      const { connector, onError } = state\n      return {\n        connector,\n        error,\n        onError\n      }\n    }\n    case ActionType.ERROR_FROM_ACTIVATION: {\n      const { connector, error } = payload\n      return {\n        connector,\n        error\n      }\n    }\n    case ActionType.DEACTIVATE_CONNECTOR: {\n      return {}\n    }\n  }\n}\n\nasync function augmentConnectorUpdate(\n  connector: AbstractConnector,\n  update: ConnectorUpdate\n): Promise<ConnectorUpdate<number>> {\n  const provider = update.provider === undefined ? await connector.getProvider() : update.provider\n  const [_chainId, _account] = (await Promise.all([\n    update.chainId === undefined ? connector.getChainId() : update.chainId,\n    update.account === undefined ? connector.getAccount() : update.account\n  ])) as [Required<ConnectorUpdate>['chainId'], Required<ConnectorUpdate>['account']]\n\n  const chainId = normalizeChainId(_chainId)\n  if (!!connector.supportedChainIds && !connector.supportedChainIds.includes(chainId)) {\n    throw new UnsupportedChainIdError(chainId, connector.supportedChainIds)\n  }\n  const account = _account === null ? _account : normalizeAccount(_account)\n\n  return { provider, chainId, account }\n}\n\nexport function useWeb3ReactManager(): Web3ReactManagerReturn {\n  const [state, dispatch] = useReducer(reducer, {})\n  const { connector, provider, chainId, account, onError, error } = state\n\n  const updateBusterRef = useRef(-1)\n  updateBusterRef.current += 1\n\n  const activate = useCallback(\n    async (\n      connector: AbstractConnector,\n      onError?: (error: Error) => void,\n      throwErrors: boolean = false\n    ): Promise<void> => {\n      const updateBusterInitial = updateBusterRef.current\n\n      let activated = false\n      try {\n        const update = await connector.activate().then(\n          (update): ConnectorUpdate => {\n            activated = true\n            return update\n          }\n        )\n\n        const augmentedUpdate = await augmentConnectorUpdate(connector, update)\n\n        if (updateBusterRef.current > updateBusterInitial) {\n          throw new StaleConnectorError()\n        }\n        dispatch({ type: ActionType.ACTIVATE_CONNECTOR, payload: { connector, ...augmentedUpdate, onError } })\n      } catch (error) {\n        if (error instanceof StaleConnectorError) {\n          activated && connector.deactivate()\n          warning(false, `Suppressed stale connector activation ${connector}`)\n        } else if (throwErrors) {\n          activated && connector.deactivate()\n          throw error\n        } else if (onError) {\n          activated && connector.deactivate()\n          onError(error)\n        } else {\n          // we don't call activated && connector.deactivate() here because it'll be handled in the useEffect\n          dispatch({ type: ActionType.ERROR_FROM_ACTIVATION, payload: { connector, error } })\n        }\n      }\n    },\n    []\n  )\n\n  const setError = useCallback((error: Error): void => {\n    dispatch({ type: ActionType.ERROR, payload: { error } })\n  }, [])\n\n  const deactivate = useCallback((): void => {\n    dispatch({ type: ActionType.DEACTIVATE_CONNECTOR })\n  }, [])\n\n  const handleUpdate = useCallback(\n    async (update: ConnectorUpdate): Promise<void> => {\n      if (!connector) {\n        throw Error(\"This should never happen, it's just so Typescript stops complaining\")\n      }\n\n      const updateBusterInitial = updateBusterRef.current\n\n      // updates are handled differently depending on whether the connector is active vs in an error state\n      if (!error) {\n        const chainId = update.chainId === undefined ? undefined : normalizeChainId(update.chainId)\n        if (chainId !== undefined && !!connector.supportedChainIds && !connector.supportedChainIds.includes(chainId)) {\n          const error = new UnsupportedChainIdError(chainId, connector.supportedChainIds)\n          onError ? onError(error) : dispatch({ type: ActionType.ERROR, payload: { error } })\n        } else {\n          const account = typeof update.account === 'string' ? normalizeAccount(update.account) : update.account\n          dispatch({ type: ActionType.UPDATE, payload: { provider: update.provider, chainId, account } })\n        }\n      } else {\n        try {\n          const augmentedUpdate = await augmentConnectorUpdate(connector, update)\n\n          if (updateBusterRef.current > updateBusterInitial) {\n            throw new StaleConnectorError()\n          }\n          dispatch({ type: ActionType.UPDATE_FROM_ERROR, payload: augmentedUpdate })\n        } catch (error) {\n          if (error instanceof StaleConnectorError) {\n            warning(false, `Suppressed stale connector update from error state ${connector} ${update}`)\n          } else {\n            // though we don't have to, we're re-circulating the new error\n            onError ? onError(error) : dispatch({ type: ActionType.ERROR, payload: { error } })\n          }\n        }\n      }\n    },\n    [connector, error, onError]\n  )\n  const handleError = useCallback(\n    (error: Error): void => {\n      onError ? onError(error) : dispatch({ type: ActionType.ERROR, payload: { error } })\n    },\n    [onError]\n  )\n  const handleDeactivate = useCallback((): void => {\n    dispatch({ type: ActionType.DEACTIVATE_CONNECTOR })\n  }, [])\n\n  // ensure that connectors which were set are deactivated\n  useEffect((): (() => void) => {\n    return () => {\n      if (connector) {\n        connector.deactivate()\n      }\n    }\n  }, [connector])\n\n  // ensure that events emitted from the set connector are handled appropriately\n  useEffect((): (() => void) => {\n    if (connector) {\n      connector\n        .on(ConnectorEvent.Update, handleUpdate)\n        .on(ConnectorEvent.Error, handleError)\n        .on(ConnectorEvent.Deactivate, handleDeactivate)\n    }\n\n    return () => {\n      if (connector) {\n        connector\n          .off(ConnectorEvent.Update, handleUpdate)\n          .off(ConnectorEvent.Error, handleError)\n          .off(ConnectorEvent.Deactivate, handleDeactivate)\n      }\n    }\n  }, [connector, handleUpdate, handleError, handleDeactivate])\n\n  return { connector, provider, chainId, account, activate, setError, deactivate, error }\n}\n", "import React, { createContext, useContext, useMemo } from 'react'\nimport invariant from 'tiny-invariant'\n\nimport { Web3ReactContextInterface } from './types'\nimport { useWeb3ReactManager } from './manager'\n\nexport const PRIMARY_KEY = 'primary'\nconst CONTEXTS: { [key: string]: React.Context<Web3ReactContextInterface> } = {}\n\ninterface Web3ReactProviderArguments {\n  getLibrary: (provider?: any, connector?: Required<Web3ReactContextInterface>['connector']) => any\n  children: any\n}\n\nexport function createWeb3ReactRoot(key: string): (args: Web3ReactProviderArguments) => JSX.Element {\n  invariant(!CONTEXTS[key], `A root already exists for provided key ${key}`)\n\n  CONTEXTS[key] = createContext<Web3ReactContextInterface>({\n    activate: async () => {\n      invariant(false, 'No <Web3ReactProvider ... /> found.')\n    },\n    setError: () => {\n      invariant(false, 'No <Web3ReactProvider ... /> found.')\n    },\n    deactivate: () => {\n      invariant(false, 'No <Web3ReactProvider ... /> found.')\n    },\n    active: false\n  })\n  CONTEXTS[key].displayName = `Web3ReactContext - ${key}`\n\n  const Provider = CONTEXTS[key].Provider\n\n  return function Web3ReactProvider({ getLibrary, children }: Web3ReactProviderArguments): JSX.Element {\n    const {\n      connector,\n      provider,\n      chainId,\n      account,\n\n      activate,\n      setError,\n      deactivate,\n\n      error\n    } = useWeb3ReactManager()\n\n    const active = connector !== undefined && chainId !== undefined && account !== undefined && !!!error\n    const library = useMemo(\n      () =>\n        active && chainId !== undefined && Number.isInteger(chainId) && !!connector\n          ? getLibrary(provider, connector)\n          : undefined,\n      [active, getLibrary, provider, connector, chainId]\n    )\n\n    const web3ReactContext: Web3ReactContextInterface = {\n      connector,\n      library,\n      chainId,\n      account,\n\n      activate,\n      setError,\n      deactivate,\n\n      active,\n      error\n    }\n\n    return <Provider value={web3ReactContext}>{children}</Provider>\n  }\n}\n\nexport const Web3ReactProvider = createWeb3ReactRoot(PRIMARY_KEY)\n\nexport function getWeb3ReactContext<T = any>(key: string = PRIMARY_KEY): React.Context<Web3ReactContextInterface<T>> {\n  invariant(Object.keys(CONTEXTS).includes(key), `Invalid key ${key}`)\n  return CONTEXTS[key]\n}\n\nexport function useWeb3React<T = any>(key?: string): Web3ReactContextInterface<T> {\n  return useContext(getWeb3ReactContext(key))\n}\n"],
  "mappings": "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",
  "names": []
}
