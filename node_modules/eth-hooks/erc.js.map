{
  "version": 3,
  "sources": ["../src/hooks/erc/useTokenBalance.ts"],
  "sourcesContent": ["import { BigNumber } from '@ethersproject/bignumber';\nimport { Contract } from '@ethersproject/contracts';\nimport { useCallback, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useEthersContext } from '~~/context';\nimport { useOnRepetition } from '~~/hooks';\nimport { TEthersProvider } from '~~/models';\n\nconst zero = BigNumber.from(0);\n/**\n * Get the balance of an ERC20 token in an address\n * \n * ~ Features ~\n  - Provide address and get balance corresponding to given address\n  - Change provider to access balance on different chains (ex. mainnetProvider)\n  - If no pollTime is passed, the balance will update on every new block\n * @param contract (ethers->Contract) contract object for the ERC20 token\n * @param address (string)\n * @param pollTime (number) :: if >0 use polling, else use instead of onBlock event\n * @returns (BigNumber) :: balance\n */\n\n/**\n * #### Summary\n * Get the balance of an ERC20 token in an address\n * - uses the ethers.Contract object's provider to access the network\n *\n * #### Notes\n * - uses useOnRepetition\n *\n * @category Hooks\n *\n * @param contract ethers.Contract class\n * @param address\n * @param pollTime if >0 use polling, else use instead of onBlock event\n * @returns\n */\nexport const useTokenBalance = (contract: Contract, address: string, pollTime: number = 0): BigNumber => {\n  const isMounted = useIsMounted();\n  const [balance, setBalance] = useState<BigNumber>(zero);\n  const ethersContext = useEthersContext();\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    if (contract != null) {\n      try {\n        const contractChainId = await contract?.signer?.getChainId();\n        if (ethersContext.chainId === contractChainId) {\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-call\n          const newBalance: BigNumber = (await contract?.balanceOf?.(address)) ?? zero;\n          if (isMounted()) {\n            setBalance((value) => {\n              if (value.toHexString() !== newBalance.toHexString()) return newBalance;\n              return value;\n            });\n          }\n        }\n      } catch (e) {\n        console.log('\u26A0 Could not get token balance', e);\n      }\n    }\n  }, [address, contract, ethersContext.chainId, isMounted]);\n\n  useOnRepetition(callFunc, {\n    pollTime,\n    leadingTrigger: contract?.provider != null,\n    provider: contract.provider as TEthersProvider,\n  });\n\n  return balance;\n};\n"],
  "mappings": "mNAAA,gDAEA,wCACA,sCAMA,GAAM,MAAO,UAAU,KAAK,GA6Bf,gBAAkB,CAAC,SAAoB,QAAiB,SAAmB,IAAiB,CACvG,GAAM,WAAY,eACZ,CAAC,QAAS,YAAc,SAAoB,MAC5C,cAAgB,mBAEhB,SAAW,YAAY,SAA2B,CA3C1D,aA4CI,GAAI,UAAY,KACd,GAAI,CACF,GAAM,iBAAkB,KAAM,oCAAU,SAAV,eAAkB,cAChD,GAAI,cAAc,UAAY,gBAAiB,CAE7C,GAAM,YAAyB,SAAM,oCAAU,YAAV,6BAAsB,YAA5B,QAAyC,KACxE,AAAI,aACF,WAAW,AAAC,OACN,MAAM,gBAAkB,WAAW,cAAsB,WACtD,cAIN,EAAP,CACA,QAAQ,IAAI,qCAAiC,KAGhD,CAAC,QAAS,SAAU,cAAc,QAAS,YAE9C,uBAAgB,SAAU,CACxB,SACA,eAAgB,gCAAU,WAAY,KACtC,SAAU,SAAS,WAGd",
  "names": []
}
