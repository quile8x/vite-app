{
  "version": 3,
  "sources": ["../src/hooks/useBalance.ts", "../src/hooks/useBlockNumber.ts", "../src/hooks/useBurnerSigner.ts", "../src/hooks/useContractExistsAtAddress.ts", "../src/hooks/useContractLoader.ts", "../src/hooks/useContractReader.ts", "../src/hooks/useEventListener.ts", "../src/hooks/useGasPrice.ts", "../src/hooks/useGetUserFromProviders.ts", "../src/hooks/useGetUserFromSigners.ts", "../src/hooks/useNonce.ts", "../src/hooks/useOnRepetition.ts", "../src/hooks/useTimestamp.ts", "../src/hooks/useUserAddress.ts", "../src/hooks/useWeb3Modal.ts"],
  "sourcesContent": ["import { BigNumber } from 'ethers';\nimport { useState, useCallback, useEffect } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useEthersContext, useBlockNumberContext } from '~~/context';\n\nconst zero = BigNumber.from(0);\n/**\n * #### Summary\n * Gets your balance in ETH for the given address.\n *\n * #### Notes\n * - updates triggered by {@link BlockNumberContext}\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\n *\n * @category Hooks\n *\n * @param address\n * @returns current balance\n */\nexport const useBalance = (address: string | undefined): BigNumber => {\n  const isMounted = useIsMounted();\n  const { ethersProvider } = useEthersContext();\n  const blockNumber = useBlockNumberContext();\n  const [balance, setBalance] = useState<BigNumber>(zero);\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    if (ethersProvider && address) {\n      const newBalance = await ethersProvider.getBalance(address);\n      if (isMounted()) {\n        setBalance((value) => {\n          if (value.toHexString() !== newBalance?.toHexString()) {\n            return newBalance;\n          }\n          return value;\n        });\n      }\n    }\n  }, [address, ethersProvider, isMounted]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return balance;\n};\n", "import { useCallback, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useOnRepetition } from '~~/hooks';\nimport { TEthersProvider } from '~~/models';\n\n/**\n * #### Summary\n * Get the current block number of the network. \u270B\uD83C\uDFFD @deprecated\n *\n * #### Notes\n * - \u270B\uD83C\uDFFD For app wide block number access use {@link BlockNumberContext} instead\n * - \u26A0 Deprecated\n * - uses the current ethersProvider from context\n *\n * @category Hooks\n *\n * @param provider\n * @param pollTime if > 0 uses polling, else it uses onBlock event\n * @returns block number\n */\nexport const useBlockNumber = (provider: TEthersProvider, pollTime: number = 0): number => {\n  const [blockNumber, setBlockNumber] = useState<number>(0);\n  const isMounted = useIsMounted();\n\n  const getBlockNumber = useCallback(async (): Promise<void> => {\n    const nextBlockNumber = await provider?.getBlockNumber();\n    if (isMounted() && provider != null) {\n      setBlockNumber((value) => {\n        if (value !== nextBlockNumber) {\n          return nextBlockNumber ?? 0;\n        }\n        return value;\n      });\n    }\n  }, [provider, isMounted]);\n\n  useOnRepetition(getBlockNumber, { provider: provider, pollTime });\n\n  return blockNumber;\n};\n", "import { BytesLike, ethers, Signer, Wallet } from 'ethers';\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { useDebounce } from 'use-debounce';\n\nimport { TEthersProvider } from '~~/models';\n\n/**\n * Is the private key valid\n * @internal\n * @param pk\n * @returns\n */\nconst isValidPk = (pk: BytesLike | undefined | null): boolean => {\n  return pk?.length === 64 || pk?.length === 66;\n};\n\n/**\n * Save the current burner private key to storage\n * @internal\n * @param incomingPK\n */\nconst saveBurnerKeyToStorage = (incomingPK: BytesLike): void => {\n  if (isValidPk(incomingPK)) {\n    const rawPK = incomingPK;\n    window.history.pushState({}, '', '/');\n    const currentPrivateKey = window.localStorage.getItem('metaPrivateKey');\n    if (currentPrivateKey && currentPrivateKey !== rawPK) {\n      window.localStorage.setItem(`metaPrivateKey_backup${Date.now()}`, currentPrivateKey);\n      console.log('\uD83D\uDD11 ...Saved Private Key');\n    }\n    window.localStorage.setItem('metaPrivateKey', rawPK.toString());\n  }\n};\n\n/**\n * Gets the current burner private key from storage\n * @internal\n * @returns\n */\nconst loadBurnerKeyFromStorage = (): string | null => {\n  const currentPrivateKey = window.localStorage.getItem('metaPrivateKey');\n  return currentPrivateKey;\n};\n\n/**\n * #### Summary\n * Return type of useBurnerSigner:\n *\n * #### Notes\n * - provides signer\n * - methods of interacting with burner signer\n * - methods to save and loadd signer from local storage\n *\n * @category Hooks\n */\nexport type TBurnerSigner = {\n  signer: Signer | undefined;\n  account: string | undefined;\n  /**\n   * save to local storage\n   */\n  saveBurner: () => void;\n  /**\n   * load from local storage, or if it doesn't exist, create\n   */\n  loadOrGenerateBurner: () => void;\n  /**\n   * create a new burner signer\n   */\n  generateBurnerSigner: () => void;\n  /**\n   * get your current burner pk\n   */\n  getBurnerPrivateKey: () => BytesLike | undefined;\n};\n\n/**\n * #### Summary\n * A hook that creates a burner signer/address and provides ways of interacting with\n * and updating the signer\n *\n * @category Hooks\n *\n * @param localProvider localhost provider\n * @returns IBurnerSigner\n */\nexport const useBurnerSigner = (localProvider: TEthersProvider | undefined): TBurnerSigner => {\n  const key = 'scaffold-eth-burner-privateKey';\n  const [privateKeyValue, setPrivateKey] = useState<BytesLike>();\n  const walletRef = useRef<Wallet>();\n  const creatingBurnerRef = useRef(false);\n  const [signer] = useDebounce(walletRef.current, 200, { trailing: true });\n  const [account] = useDebounce(walletRef.current?.address, 200, { trailing: true });\n\n  const setValue = (value: any): void => {\n    try {\n      setPrivateKey(value);\n      window.localStorage.setItem(key, value);\n    } catch (error) {\n      console.log(error);\n    }\n  };\n\n  useEffect(() => {\n    const storedKey = window.localStorage.getItem(key);\n    if (!storedKey) {\n      console.log('generating a new key');\n      const newWallet = ethers.Wallet.createRandom();\n      const newKey = newWallet.privateKey;\n      setValue(newKey);\n    } else {\n      setValue(storedKey);\n    }\n  }, []);\n\n  useEffect(() => {\n    if (privateKeyValue && localProvider) {\n      const wallet = new ethers.Wallet(privateKeyValue);\n      const newSigner = wallet.connect(localProvider);\n      walletRef.current = newSigner;\n    }\n  }, [privateKeyValue, localProvider]);\n\n  /**\n   * if valid save burner key to storage\n   */\n  const saveToStorage = useCallback(() => {\n    console.log('\uD83D\uDD11 Incoming Private Key...');\n    if (privateKeyValue != null) {\n      saveBurnerKeyToStorage(privateKeyValue);\n    }\n  }, [privateKeyValue]);\n\n  /**\n   * create a new burnerkey\n   */\n  const generateBurnerSigner = useCallback(() => {\n    if (localProvider && !creatingBurnerRef.current) {\n      creatingBurnerRef.current = true;\n      console.log('\uD83D\uDD11 Create new burner wallet...');\n      const wallet = Wallet.createRandom();\n      setPrivateKey((_v) => {\n        console.log('\uD83D\uDCDD ...Set key');\n        creatingBurnerRef.current = false;\n        return wallet.privateKey;\n      });\n    } else {\n      console.log('\u26A0 Could not create burner wallet');\n    }\n  }, [localProvider]);\n\n  /**\n   * Load burner key from storage\n   */\n  const loadOrGenerateBurner = useCallback(() => {\n    if (setPrivateKey != null) {\n      const pk = loadBurnerKeyFromStorage();\n      if (pk && isValidPk(pk)) {\n        console.log('\uD83D\uDD11 ...Loaded Private Key');\n        setPrivateKey(pk);\n      } else {\n        generateBurnerSigner();\n      }\n    }\n  }, [generateBurnerSigner]);\n\n  const getBurnerPrivateKey = (): BytesLike | undefined => {\n    return privateKeyValue;\n  };\n\n  return {\n    signer,\n    account,\n    saveBurner: saveToStorage,\n    loadOrGenerateBurner,\n    generateBurnerSigner,\n    getBurnerPrivateKey,\n  };\n};\n", "import { Contract, utils } from 'ethers';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useBlockNumberContext } from '~~/context';\n/**\n * #### Summary\n * Checks whether a contract exists on the blockchain\n *\n * #### Notes\n * - uses the ethers.Contract object's provider to access the network\n * - checks the contract address to see if the contract is deployed\n *\n * @category Hooks\n *\n * @param contract ethers.Contract class\n * @returns\n */\nexport const useContractExistsAtAddress = (contract: Contract | undefined): boolean => {\n  const isMounted = useIsMounted();\n  const [contractIsDeployed, setContractIsDeployed] = useState(false);\n  const blockNumber = useBlockNumberContext();\n\n  /**\n   * We can look at the blockchain and see what's stored at `contractAddress`\n   * If we find code then we know that a contract exists there.\n   * If we find nothing (0x0) then there is no contract deployed to that address\n   */\n  const callFunc = useCallback(async (): Promise<void> => {\n    if (!contract?.provider || !utils.isAddress(contract.address)) {\n      if (isMounted()) setContractIsDeployed(false);\n      return;\n    }\n\n    const bytecode = await contract.provider.getCode(contract.address);\n    if (isMounted()) setContractIsDeployed(bytecode !== '0x');\n  }, [contract, isMounted]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return contractIsDeployed;\n};\n", "import { BaseContract } from 'ethers';\nimport { useCallback, useEffect, useMemo, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useEthersContext } from '~~/context';\nimport {\n  TContractLoaderConfig,\n  TDeployedContractsJson,\n  TEthersProviderOrSigner,\n  TExternalContracts,\n  THardhatContractJson,\n} from '~~/models';\n\nexport const parseContractsInJson = (\n  contractList: TDeployedContractsJson,\n  chainId: number\n): Record<string, THardhatContractJson> => {\n  let combinedContracts: Record<string, THardhatContractJson> = {};\n\n  // combine partitioned contracts based on all the available and chain id.\n  if (contractList?.[chainId] != null) {\n    for (const network in contractList[chainId]) {\n      if (Object.prototype.hasOwnProperty.call(contractList[chainId], network)) {\n        const chainContracts = contractList?.[chainId]?.[network]?.contracts;\n        if (chainContracts != null) {\n          combinedContracts = {\n            ...combinedContracts,\n            ...chainContracts,\n          };\n        }\n      }\n    }\n  }\n\n  return combinedContracts;\n};\n/**\n * #### Summary\n *  Loads your contracts returns them and gives options to read values from contracts\n * or write transactions into them\n *\n * #### Notes\n * A optional providerOrSigner is needed to initalize the contract class\n * - if none is given, the context providerOrSigner is used if the chainId is the same.\n * - A signer is required for write contracts\n * Provider\n * - uses the current ethersProvider from context\n * ChainId\n * - if chain id is not given, it will use the chainId of the provider\n *\n * @category Hooks\n *\n * @param config\n * @param providerOrSigner (optional) used to initalize the contract class\n * @param configChainId (optional) can be used to target specific a particular network (such as mainnet) instead of the current provider\n * @returns Record of contractName:Contracts\n */\nexport const useContractLoader = (\n  config: TContractLoaderConfig = {},\n  providerOrSigner?: TEthersProviderOrSigner,\n  configChainId?: number\n): Record<string, BaseContract> => {\n  const isMounted = useIsMounted();\n  const { ethersProvider, chainId: contextChainId } = useEthersContext();\n  const chainId = configChainId ?? contextChainId;\n\n  const [contracts, setContracts] = useState<Record<string, BaseContract>>({});\n  const configDep: string = useMemo(\n    () => `${JSON.stringify(config ?? {})}, ${JSON.stringify({ chainId: chainId })}`,\n    [chainId, config]\n  );\n\n  const callFunc = useCallback(\n    (): void => {\n      if (ethersProvider && chainId && chainId > 0) {\n        try {\n          const contractList: TDeployedContractsJson = { ...(config.deployedContractsJson ?? {}) };\n          const externalContractList: TExternalContracts = {\n            ...(config.externalContracts ?? {}),\n          };\n          let combinedContracts: Record<string, THardhatContractJson> = parseContractsInJson(contractList, chainId);\n\n          // load external contracts if its the right chain\n          if (externalContractList?.[chainId] != null) {\n            combinedContracts = { ...combinedContracts, ...externalContractList[chainId].contracts };\n          }\n\n          const newContracts = Object.keys(combinedContracts).reduce(\n            (accumulator: Record<string, any>, contractName: string) => {\n              const address: string =\n                config.customAddresses && Object.keys(config.customAddresses).includes(contractName)\n                  ? config.customAddresses[contractName]\n                  : combinedContracts[contractName].address;\n\n              // use providerOrSigner, or ethersContext provider or undefined if appropriate\n              const provider = providerOrSigner ?? (chainId === contextChainId ? ethersProvider : undefined);\n              accumulator[contractName] = new BaseContract(address, combinedContracts[contractName].abi, provider);\n              return accumulator;\n            },\n            {}\n          );\n\n          if (isMounted()) {\n            setContracts((currValue) => {\n              if (\n                currValue !== newContracts &&\n                (Object.keys(currValue).length > 0 || Object.keys(newContracts).length > 0)\n              ) {\n                console.log(`\uD83C\uDF00 loading contracts..`);\n                return newContracts;\n              }\n              return currValue;\n            });\n          }\n        } catch (e) {\n          console.log('\u26A0 useContractLoader, ERROR LOADING CONTRACTS!!', e, config);\n        }\n      }\n    },\n    // disable as configDep is used for dep instead of config\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [ethersProvider, configDep, providerOrSigner]\n  );\n\n  useEffect(() => {\n    void callFunc();\n  }, [callFunc, chainId]);\n\n  return contracts;\n};\n", "import { BaseContract, ContractFunction } from 'ethers';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useEthersContext, useBlockNumberContext } from '~~/context';\nimport { TContractFunctionInfo } from '~~/models';\n\n/**\n * #### Summary\n * Enables you to call a contract function with arguments and receive the output.  You can use this to easily track of contract outputs in react states\n *\n * #### Notes\n * - uses the ethers.Contract object's provider to access the network\n * - formatter is a function that can change the format of the output\n *\n * @category Hooks\n *\n * @template OutputT return type\n * @param contract ethers.Contract class\n * @param contractFunctionInfo\n * @param formatter <OutputT> a function that can format the output\n * @param onChange callback with result as a parameter\n * @returns <OutputT>\n */\nexport const useContractReader = <OutputT>(\n  contract: BaseContract,\n  contractFunctionInfo: TContractFunctionInfo,\n  formatter?: (_value: OutputT | undefined) => OutputT,\n  onChange?: (_value?: OutputT) => void\n): OutputT | undefined => {\n  const isMounted = useIsMounted();\n  const [value, setValue] = useState<OutputT>();\n  const blockNumber = useBlockNumberContext();\n  const ethersContext = useEthersContext();\n\n  const callContractFunction = useCallback(async () => {\n    const contractFunction = contract.functions?.[contractFunctionInfo.functionName] as ContractFunction<OutputT>;\n    let result: OutputT | undefined = undefined;\n    try {\n      if (contractFunctionInfo.functionArgs && contractFunctionInfo.functionArgs.length > 0) {\n        result = await contractFunction?.(...contractFunctionInfo.functionArgs);\n      } else {\n        result = await contractFunction?.();\n      }\n    } catch (error: any) {\n      console.warn('Could not read from contract function', contractFunctionInfo);\n    }\n    return result;\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contract, contractFunctionInfo.functionArgs, contractFunctionInfo.functionName]);\n\n  const contractProvider = contract?.provider;\n\n  const callFunc = useCallback(async () => {\n    const contractChainId = (await contractProvider?.getNetwork())?.chainId;\n    if (\n      callContractFunction != null &&\n      contractChainId === ethersContext.chainId &&\n      contractProvider != null &&\n      ethersContext?.chainId\n    ) {\n      try {\n        let newResult = await callContractFunction();\n        if (formatter != null) {\n          newResult = formatter(newResult);\n        }\n\n        if (isMounted()) {\n          setValue((value) => {\n            if (!Object.is(value, newResult) && JSON.stringify(value) !== JSON.stringify(newResult)) {\n              return newResult;\n            }\n            return value;\n          });\n          onChange?.(newResult);\n        }\n      } catch (error: any) {\n        console.warn(error);\n      }\n    }\n  }, [contractProvider, callContractFunction, ethersContext?.chainId, formatter, isMounted, onChange]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return value;\n};\n", "import { Contract, EventFilter, Event } from 'ethers';\nimport { Result } from 'ethers/lib/utils';\nimport { useState, useEffect, useCallback } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { TypedEvent } from '~~/models';\n\nconst getEventKey = (m: Event | TypedEvent<Result>): string => {\n  return `${m.transactionHash}_${m.logIndex}`;\n};\n/**\n * #### Summary\n * Tracks the events of associated with a contract\n *\n * #### Notes\n * - updates triggered through ethers event listener\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\n *\n * @category Hooks\n *\n * @param contract ethers.Contract\n * @param eventName\n * @param startBlock\n * @returns\n */\nexport const useEventListener = (\n  contract: Contract | undefined,\n  eventName: string | EventFilter,\n  startBlock: number\n): TypedEvent<Result>[] => {\n  const isMounted = useIsMounted();\n\n  const [eventMap, setEventMap] = useState<TypedEvent<Result>[]>([]);\n\n  const queryEvents = useCallback(\n    (_listenerArgs: Event[]) => {\n      void (async (): Promise<void> => {\n        const result = await contract?.queryFilter(eventName as EventFilter, startBlock);\n        if (isMounted() && result) {\n          setEventMap((value) => {\n            if (JSON.stringify(value.map(getEventKey)) !== JSON.stringify(result.map(getEventKey))) {\n              return result as TypedEvent<Result>[];\n            } else {\n              return value;\n            }\n          });\n        }\n      })();\n    },\n    [contract, eventName, isMounted, startBlock]\n  );\n\n  // // get the events on initial load of hooks, without waiting for the next event\n  useEffect(() => {\n    if (contract?.queryFilter != null && setEventMap && (eventMap == null || eventMap?.length === 0) && queryEvents) {\n      queryEvents([]);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [contract?.queryFilter]);\n\n  useEffect(() => {\n    try {\n      contract?.on(eventName, queryEvents);\n      return (): void => {\n        contract?.off(eventName, queryEvents);\n      };\n    } catch (e) {\n      console.log(e);\n    }\n  }, [queryEvents, contract, eventName]);\n\n  return eventMap;\n};\n", "import { FeeData } from '@ethersproject/providers';\nimport axios, { AxiosResponse } from 'axios';\nimport { utils } from 'ethers';\nimport { useCallback, useEffect, useState } from 'react';\nimport { useDebounce } from 'use-debounce';\n\nimport { useEthersContext, useBlockNumberContext } from '~~/context';\nimport { TNetworkInfo } from '~~/models';\n\n/**\n * Preset speeds for Eth Gas Station API\n    - fast: Recommended fast(expected to be mined in < 2 minutes) gas price in x10 Gwei(divite by 10 to convert it to gwei)\n    - fastest: Recommended fastest(expected to be mined in < 30 seconds) gas price in x10 Gwei(divite by 10 to convert it to gwei)\n    - safeLow: Recommended safe(expected to be mined in < 30 minutes) gas price in x10 Gwei(divite by 10 to convert it to gwei)\n    - average: Recommended average(expected to be mined in < 5 minutes) gas price in x10 Gwei(divite by 10 to convert it to gwei)\n\n    @category Hooks\n */\nexport type TGasStationSpeed = 'fast' | 'fastest' | 'safeLow' | 'average';\n\n/**\n * #### Summary\n * Gets the gas price for the current network as gwei\n * - uses EthGasStation for mainnet\n * - uses ethers.estimateGas other networks\n * - can use currentNetworkInfo {@link TNetworkInfo.gasPrice} gasPrice as fallback\n *\n * #### Notes\n * - if the gas price is unknown it returns undefined\n * - updates triggered by {@link BlockNumberContext}\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\n *\n * @category Hooks\n *\n * @param speed\n * @param currentNetworkInfo uses gasPrice as a fallback\n * @returns gas as gwei\n */\nexport const useGasPrice = (\n  chainId: number | undefined,\n  speed: TGasStationSpeed,\n  currentNetworkInfo?: TNetworkInfo\n): number | undefined => {\n  const { ethersProvider } = useEthersContext();\n  const blockNumber = useBlockNumberContext();\n  const [currentChainId, setCurrentChainId] = useState<number>();\n  const [gasPrice, setGasPrice] = useState<number | undefined>();\n  const [gasPriceDebounced] = useDebounce(gasPrice, 250, { trailing: true });\n\n  const callFunc = useCallback((): void => {\n    if (currentChainId !== chainId) {\n      setCurrentChainId(chainId);\n      setGasPrice(undefined);\n    }\n\n    if (!chainId) {\n      setGasPrice(undefined);\n    } else if (chainId === 1) {\n      if (navigator.onLine) {\n        const gweiFactor = 10;\n        axios\n          .get('https://ethgasstation.info/json/ethgasAPI.json')\n          .then((response: AxiosResponse<any>) => {\n            const result: Record<string, any> = (response.data as Record<string, any>) ?? {};\n            let newGasPrice: number | undefined = result[speed] / gweiFactor;\n            if (!newGasPrice) newGasPrice = result['fast'] / gweiFactor;\n            setGasPrice(newGasPrice);\n          })\n          .catch((error) => {\n            console.log('\u26A0 Could not get gas Price!', error);\n            setGasPrice(undefined);\n          });\n      }\n    } else if (ethersProvider) {\n      void ethersProvider\n        .getFeeData()\n        .then((fee: FeeData) => {\n          const price = fee.gasPrice ?? fee.maxFeePerGas;\n          if (price && price?.toBigInt() > 0) {\n            const result = parseInt(utils.formatUnits(price, 'gwei')) ?? 0;\n            setGasPrice(result);\n          } else if (currentNetworkInfo?.gasPrice) {\n            setGasPrice(currentNetworkInfo.gasPrice);\n          } else {\n            setGasPrice(undefined);\n          }\n        })\n        .catch((_error) => {\n          console.log('\u26A0 Could not estimate gas!');\n          if (currentNetworkInfo?.gasPrice) {\n            setGasPrice(currentNetworkInfo.gasPrice);\n          } else {\n            setGasPrice(undefined);\n          }\n        });\n    } else if (currentNetworkInfo?.gasPrice) {\n      setGasPrice(currentNetworkInfo.gasPrice);\n    } else {\n      setGasPrice(undefined);\n    }\n  }, [currentChainId, chainId, ethersProvider, currentNetworkInfo?.gasPrice, speed]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n  return gasPriceDebounced;\n};\n", "import { ethers, Signer } from 'ethers';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { asyncSome } from '~~/functions/asyncSome';\nimport { parseProviderOrSigner } from '~~/functions/parseProviderOrSigner';\nimport { TEthersUser as TEthersUser, TEthersProvider } from '~~/models';\n\n/**\n * #### Summary\n * Gets the user {@link TEthersUser} from from the current provider or array of fallback providers\n *\n * #### Notes\n * - \uD83E\uDD1A\uD83C\uDFFD Consider using the context provider {@link ethersProvider}\n *\n * @category Hooks\n *\n * @param currentProvider\n * @param moreProviders\n * @returns\n */\nexport const useGetUserFromProviders = (\n  currentProvider: TEthersProvider | undefined,\n  ...moreProviders: TEthersProvider[]\n): TEthersUser => {\n  const [signer, setSigner] = useState<Signer>();\n  const [provider, setProvider] = useState<TEthersProvider>();\n  const [providerNetwork, setProviderNetwork] = useState<ethers.providers.Network>();\n  const [address, setAddress] = useState<string>();\n\n  const allProviders = [currentProvider, ...moreProviders].filter((f) => f != null) as TEthersProvider[];\n  const providerDeps: string = allProviders\n    .map((m) => {\n      return `${m?.network?.name}_${m?.network?.chainId}_${m?.connection.url}`;\n    })\n    .reduce((acc, value) => {\n      if (!acc) return value ?? '';\n      return acc + value ?? '';\n    }, '');\n\n  const callFunc = useCallback(\n    async (): Promise<void> => {\n      const foundSigner = await asyncSome(allProviders, async (provider) => {\n        const result = await parseProviderOrSigner(provider);\n        if (result.provider && result.providerNetwork && result.signer) {\n          setSigner(result.signer);\n          setProvider(result.provider);\n          setProviderNetwork(result.providerNetwork);\n          const address = await result.signer.getAddress();\n          setAddress(address);\n          return true;\n        }\n        return false;\n      });\n\n      if (!foundSigner && currentProvider != null) {\n        setProvider(currentProvider);\n        setSigner(undefined);\n        setProviderNetwork(undefined);\n        setAddress(undefined);\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [providerDeps]\n  );\n\n  useEffect(() => {\n    void callFunc();\n  }, [callFunc]);\n\n  return { signer, provider, providerNetwork, address };\n};\n", "import { ethers, Signer, Wallet } from 'ethers';\nimport { useCallback, useEffect, useState } from 'react';\n\nimport { parseProviderOrSigner } from '~~/functions/parseProviderOrSigner';\nimport { TEthersUser, TEthersProvider } from '~~/models';\n\n/**\n * #### Summary\n * Gets the user {@link TEthersUser} for a signer or wallet\n *\n * @category Hooks\n *\n * @param signer\n * @returns\n */\nexport const useGetUserFromSigners = (signer: Signer | Wallet | undefined): TEthersUser => {\n  const [resolvedSigner, setResolvedSigner] = useState<Signer>();\n  const [provider, setProvider] = useState<TEthersProvider>();\n  const [providerNetwork, setProviderNetwork] = useState<ethers.providers.Network>();\n  const [address, setAddress] = useState<string>();\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    const result = await parseProviderOrSigner(signer);\n    if (result.provider && result.providerNetwork && result.signer) {\n      setResolvedSigner(result.signer);\n      setProvider(result.provider);\n      setProviderNetwork(result.providerNetwork);\n      const address = await result.signer.getAddress();\n      setAddress(address);\n    } else {\n      setProvider(undefined);\n      setResolvedSigner(signer);\n      setProviderNetwork(undefined);\n      setAddress(undefined);\n    }\n  }, [signer]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [callFunc]);\n\n  return { signer: resolvedSigner, provider, providerNetwork, address };\n};\n", "import { useCallback, useEffect, useState } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useEthersContext, useBlockNumberContext } from '~~/context';\n\n/**\n * #### Summary\n * Get the current nonce for the address provided\n *\n * #### Notes\n * - updates triggered by {@link BlockNumberContext}\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\n *\n * @category Hooks\n *\n * @param address\n * @returns\n */\nexport const useNonce = (address: string): number => {\n  const isMounted = useIsMounted();\n  const { ethersProvider } = useEthersContext();\n  const blockNumber = useBlockNumberContext();\n\n  const [nonce, setNonce] = useState<number>(0);\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    let nextNonce: number = 0;\n    try {\n      nextNonce = (await ethersProvider?.getTransactionCount(address)) ?? 0;\n    } catch {\n      // do nothing\n    }\n    if (isMounted()) {\n      setNonce((value) => {\n        if (nextNonce && value !== nextNonce && value < nextNonce) return nextNonce;\n        return value;\n      });\n    }\n  }, [address, ethersProvider, isMounted]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return nonce;\n};\n", "import { useCallback, useEffect, useRef } from 'react';\r\n\r\nimport { TEthersProvider } from '~~/models';\r\n\r\nconst DEBUG = false;\r\n\r\n/**\r\n * Options for useOnRepetition\r\n */\r\ninterface IUseOnRepetitionOptions {\r\n  /**\r\n   * (number) :: if >0 use polling, else use instead of onBlock event.  the minimum polling time is 10s.\r\n   */\r\n  pollTime?: number;\r\n  /**\r\n   * (TEthersProvider)\r\n   */\r\n  provider?: TEthersProvider | undefined;\r\n  /**\r\n   * (boolean) :: invoke the callback after initialization\r\n   */\r\n  leadingTrigger?: boolean;\r\n}\r\n\r\n/**\r\n * #### Summary\r\n * A hook that will periodically invoke a callback.\r\n * It can use one of the two options to do so\r\n * - onBlock: the block event is used to invoke callback\r\n * - Polling: invoke the callback periodically via polling. The minimum time is 10s.\r\n *\r\n * #### Notes\r\n * The callback can be invoked once on leading edge when leadTrigger conditions are satisfied\r\n * - For example you may want to wait for the provider to initalize before first invocation.\r\n * - \uD83D\uDC69\uD83C\uDFFD\u200D\uD83C\uDFEB A provider is needed for onBlock.\r\n *\r\n * @category Hooks\r\n *\r\n * @param callback\r\n * @param options\r\n * @param args variable arguments for callback\r\n */\r\nexport const useOnRepetition = (\r\n  callback: (..._args: any[]) => void | Promise<void>,\r\n  options: IUseOnRepetitionOptions,\r\n  ...args: any[]\r\n): void => {\r\n  const isPolling = options?.pollTime != null && options.pollTime > 0;\r\n  const readyForEvents = options?.provider && !isPolling && options?.provider?.network?.chainId > 0;\r\n  const readyForLeadTrigger = (readyForEvents || isPolling) && options?.leadingTrigger;\r\n  const isFirstCall = useRef(true);\r\n\r\n  // created a strigified args to use for deps\r\n  const argDeps = JSON.stringify(args ?? []);\r\n\r\n  // create a callback for the input function\r\n  const callFunctionWithArgs = useCallback(() => {\r\n    if (DEBUG) console.log('create callback');\r\n    if (callback) {\r\n      if (args && args.length > 0) {\r\n        void callback(...args);\r\n      } else {\r\n        void callback();\r\n      }\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [callback, argDeps]);\r\n\r\n  // If event based, create a listener if we have a function & a provider\r\n  const listener = useCallback(\r\n    (_blockNumber: number): void => {\r\n      if (readyForEvents) callFunctionWithArgs();\r\n    },\r\n    [callFunctionWithArgs, readyForEvents]\r\n  );\r\n\r\n  // connect a listener to the network to listen for changes\r\n  useEffect(() => {\r\n    if (readyForEvents) {\r\n      options?.provider?.addListener?.('block', listener);\r\n    }\r\n\r\n    return (): void => {\r\n      options?.provider?.removeListener?.('block', listener);\r\n    };\r\n  }, [options.provider, readyForEvents, listener]);\r\n\r\n  // Set up the interval if its using polling\r\n  useEffect(() => {\r\n    const tick = (): void => {\r\n      if (DEBUG) console.log('polling: call function');\r\n      callFunctionWithArgs();\r\n    };\r\n\r\n    if (isPolling) {\r\n      const safePollTime = (options?.pollTime ?? 0) > 10000 ? options.pollTime : 10000;\r\n      const id = setInterval(tick, safePollTime);\r\n      return (): void => {\r\n        clearInterval(id);\r\n      };\r\n    }\r\n  }, [options.pollTime, isPolling, callFunctionWithArgs]);\r\n\r\n  // if the arguments have changed, reset the isFirstCall reference\r\n  useEffect(() => {\r\n    if (!isFirstCall.current) {\r\n      isFirstCall.current = true;\r\n    }\r\n  }, [argDeps]);\r\n\r\n  // trigger a first call to populate data.  Only if leadingTrigger is true\r\n  useEffect(() => {\r\n    if (readyForLeadTrigger && callFunctionWithArgs != null && isFirstCall?.current === true) {\r\n      isFirstCall.current = false;\r\n      callFunctionWithArgs();\r\n    }\r\n  }, [callFunctionWithArgs, readyForLeadTrigger]);\r\n};\r\n", "import { useState, useEffect, useCallback } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useBlockNumberContext, useEthersContext } from '~~/context';\n\n/**\n * #### Summary\n * Get the current timestamp from the latest block\n *\n * #### Notes\n * - updates triggered by {@link BlockNumberContext}\n * - uses the current provider {@link ethersProvider} from {@link useEthersContext}\n *\n * @category Hooks\n *\n * @param pollTime\n * @returns\n */\nexport const useTimestamp = (): number => {\n  const isMounted = useIsMounted();\n  const { ethersProvider } = useEthersContext();\n  const blockNumber = useBlockNumberContext();\n\n  const [timestamp, setTimestamp] = useState<number>(0);\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    if (blockNumber != null) {\n      const block = await ethersProvider?.getBlock(blockNumber);\n      if (block?.timestamp != null) {\n        const nextTimestamp = block.timestamp;\n        if (isMounted()) setTimestamp(nextTimestamp);\n      }\n    }\n  }, [blockNumber, ethersProvider, isMounted]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return timestamp;\n};\n", "import { useState, useEffect, useCallback } from 'react';\nimport { useIsMounted } from 'usehooks-ts';\n\nimport { useBlockNumberContext } from '~~/context';\nimport { signerHasNetwork } from '~~/functions';\nimport { TEthersSigner } from '~~/models';\n\n/**\n * #### Summary\n * Get the address from the signer\n *\n * @category Hooks\n *\n * @param signer\n * @returns\n */\nexport const useUserAddress = (signer: TEthersSigner | undefined): string | undefined => {\n  const isMounted = useIsMounted();\n  const [userAddress, setUserAddress] = useState<string>();\n  const blockNumber = useBlockNumberContext();\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    if (signerHasNetwork(signer)) {\n      const address = await signer?.getAddress();\n      if (isMounted()) {\n        setUserAddress(address);\n      }\n    }\n  }, [isMounted, signer]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return userAddress;\n};\n", "/* eslint-disable @typescript-eslint/no-unsafe-assignment */\r\nimport { Web3Provider } from '@ethersproject/providers';\r\nimport { useCallback, useEffect, useRef } from 'react';\r\nimport Web3Modal, { ICoreOptions, ThemeColors } from 'web3modal';\r\nimport '~~/helpers/__global';\r\n\r\nimport { TEthersProvider } from '~~/models';\r\nimport { const_web3DialogClosedByUser } from '~~/models/constants/common';\r\n\r\n/**\r\n * The current state of Web3Modal\r\n *\r\n * @category Hooks\r\n */\r\nexport type TWeb3ModalState = {\r\n  /**\r\n   * Is the modal initalizing\r\n   */\r\n  initializing: boolean;\r\n  /**\r\n   * A callback to open the modal\r\n   */\r\n  openWeb3ModalCallback: () => void;\r\n  /**\r\n   * A callback to close the modal\r\n   */\r\n  logoutOfWeb3ModalCallback: () => void;\r\n  /**\r\n   * A callback to change the modal theme\r\n   */\r\n  updateWeb3ModalThemeCallback: (theme: ThemeColors | string) => void;\r\n};\r\n/**\r\n * #### Summary\r\n * A hook that makes it easy to interact and use [web3Modal](https://github.com/Web3Modal/web3modal)\r\n * - provides callback to open, logout and update the modal theme\r\n *\r\n * #### Notes\r\n * - \uD83E\uDD1A\uD83C\uDFFD Consider using the context provider {@link ethersProvider} and {@link EthersModalConnector} instead.\r\n *\r\n * @category Hooks\r\n *\r\n * @param web3ModalConfig\r\n * @param setCurrentEthersProvider\r\n * @returns\r\n */\r\nexport const useWeb3Modal = (\r\n  web3ModalConfig: Partial<ICoreOptions>,\r\n  setCurrentEthersProvider: (newEthersProvider: TEthersProvider | undefined) => void\r\n): TWeb3ModalState => {\r\n  const web3ModalProviderRef = useRef<Web3Modal>();\r\n  const initalizingRef = useRef<boolean>();\r\n\r\n  /**\r\n   * initalize web3 object and save it to state\r\n   */\r\n  useEffect(() => {\r\n    if (!Web3Modal) {\r\n      throw 'Web3Modal is a peer dependancy to use this hook';\r\n    }\r\n    web3ModalProviderRef.current = new Web3Modal(web3ModalConfig ?? {});\r\n    initalizingRef.current = true;\r\n    setCurrentEthersProvider(undefined);\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [web3ModalConfig]);\r\n\r\n  /**\r\n   * a callback to reload the page and clear cache\r\n   */\r\n  const reloadPage = useCallback(() => {\r\n    return (_param: any): void => {\r\n      web3ModalProviderRef.current?.cachedProvider &&\r\n        setTimeout(() => {\r\n          window.location.reload();\r\n        }, 1);\r\n    };\r\n  }, []);\r\n\r\n  /**\r\n   * log out of web3modal provider\r\n   */\r\n  const logoutOfWeb3ModalCallback = useCallback(\r\n    (reload: boolean = true): void => {\r\n      initalizingRef.current = false;\r\n      setCurrentEthersProvider(undefined);\r\n      if (reload) {\r\n        reloadPage();\r\n      }\r\n    },\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n    [setCurrentEthersProvider]\r\n  );\r\n\r\n  /**\r\n   * the function that setups up and loads the web3modal\r\n   */\r\n  const loadWeb3Modal = useCallback(async () => {\r\n    try {\r\n      initalizingRef.current = true;\r\n      const provider = await web3ModalProviderRef.current?.connect();\r\n      setCurrentEthersProvider(new Web3Provider(provider, 'any'));\r\n\r\n      /* eslint-disable @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call */\r\n      if (provider?.on) {\r\n        provider.on('chainChanged', (chainId: number) => {\r\n          console.log(`chain changed to ${chainId}! updating providers`);\r\n          setCurrentEthersProvider(new Web3Provider(provider, 'any'));\r\n        });\r\n\r\n        provider.on('accountsChanged', () => {\r\n          console.log(`account changed!`);\r\n          setCurrentEthersProvider(new Web3Provider(provider, 'any'));\r\n        });\r\n\r\n        // Subscribe to session disconnection\r\n        provider.on('disconnect', (code: any, reason: any) => {\r\n          console.log(code, reason);\r\n          void logoutOfWeb3ModalCallback();\r\n          setCurrentEthersProvider(undefined);\r\n        });\r\n      }\r\n      /* eslint-enable */\r\n    } catch (e) {\r\n      if ((e as string).includes(const_web3DialogClosedByUser)) {\r\n        console.log(e);\r\n      } else {\r\n        throw e;\r\n      }\r\n    } finally {\r\n      initalizingRef.current = false;\r\n    }\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [setCurrentEthersProvider]);\r\n\r\n  /**\r\n   * On initalization, load modal\r\n   */\r\n  useEffect(() => {\r\n    if (web3ModalProviderRef.current?.cachedProvider) {\r\n      void loadWeb3Modal();\r\n    }\r\n  }, [loadWeb3Modal]);\r\n\r\n  /**\r\n   * a callback to open the modal\r\n   */\r\n  const openWeb3ModalCallback = useCallback(() => {\r\n    setCurrentEthersProvider(undefined);\r\n    web3ModalProviderRef.current?.clearCachedProvider();\r\n    void loadWeb3Modal();\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [loadWeb3Modal]);\r\n\r\n  const updateWeb3ModalThemeCallback = useCallback((theme: ThemeColors | string) => {\r\n    web3ModalProviderRef.current?.updateTheme(theme);\r\n  }, []);\r\n\r\n  return {\r\n    initializing: initalizingRef.current ?? false,\r\n    openWeb3ModalCallback,\r\n    logoutOfWeb3ModalCallback,\r\n    updateWeb3ModalThemeCallback,\r\n  };\r\n};\r\n"],
  "mappings": "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",
  "names": []
}
