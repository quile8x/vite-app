import { BaseContract } from 'ethers';
import { TContractLoaderConfig, TDeployedContractsJson, TEthersProviderOrSigner, THardhatContractJson } from "../models";
export declare const parseContractsInJson: (contractList: TDeployedContractsJson, chainId: number) => Record<string, THardhatContractJson>;
/**
 * #### Summary
 *  Loads your contracts returns them and gives options to read values from contracts
 * or write transactions into them
 *
 * #### Notes
 * A optional providerOrSigner is needed to initalize the contract class
 * - if none is given, the context providerOrSigner is used if the chainId is the same.
 * - A signer is required for write contracts
 * Provider
 * - uses the current ethersProvider from context
 * ChainId
 * - if chain id is not given, it will use the chainId of the provider
 *
 * @category Hooks
 *
 * @param config
 * @param providerOrSigner (optional) used to initalize the contract class
 * @param configChainId (optional) can be used to target specific a particular network (such as mainnet) instead of the current provider
 * @returns Record of contractName:Contracts
 */
export declare const useContractLoader: (config?: TContractLoaderConfig, providerOrSigner?: TEthersProviderOrSigner | undefined, configChainId?: number | undefined) => Record<string, BaseContract>;
//# sourceMappingURL=useContractLoader.d.ts.map