{
  "version": 3,
  "sources": ["../src/hooks/dapps/useDexEthPrice.ts", "../src/hooks/dapps/useDexTokenList.ts", "../src/hooks/dapps/useResolveEnsName.ts", "../src/hooks/dapps/useResolveEnsAddress.ts"],
  "sourcesContent": ["import { Token, WETH, Fetcher, Route } from '@uniswap/sdk';\nimport { useCallback, useState } from 'react';\n\nimport { useOnRepetition } from '~~/hooks';\nimport { TNetworkInfo } from '~~/models';\nimport { TEthersProvider } from '~~/models/providerTypes';\n\n/**\n * #### Summary\n * Get the Exchange price of ETH/USD (extrapolated from WETH/DAI) from uniswap\n *\n * #### Notes\n * - uses useOnRepetition, does not use context\n *\n * @category Hooks\n *\n * @param mainnetProvider\n * @param targetNetworkInfo\n * @param pollTime if >0 use polling, else use instead of onBlock event\n * @returns price in USD\n */\nexport const useDexEthPrice = (\n  mainnetProvider: TEthersProvider | undefined,\n  targetNetworkInfo?: TNetworkInfo,\n  pollTime: number = 0\n): number => {\n  const [price, setPrice] = useState(0);\n\n  const callFunc = useCallback(() => {\n    const getPrice = async (): Promise<void> => {\n      if (targetNetworkInfo?.price) {\n        setPrice(targetNetworkInfo.price);\n      } else if (mainnetProvider) {\n        const network = await mainnetProvider.getNetwork();\n\n        const DAI = new Token(network ? network.chainId : 1, '0x6B175474E89094C44Da98b954EedeAC495271d0F', 18);\n        const pair = await Fetcher.fetchPairData(DAI, WETH[DAI.chainId], mainnetProvider);\n        const route = new Route([pair], WETH[DAI.chainId]);\n        setPrice(parseFloat(route.midPrice.toSignificant(6)));\n      } else {\n        setPrice(-1);\n        console.warn('useDexEthPrice: mainnetProvider or targetNetwork not given');\n      }\n    };\n\n    void getPrice();\n  }, [targetNetworkInfo?.price, mainnetProvider]);\n\n  useOnRepetition(callFunc, { pollTime, provider: mainnetProvider });\n\n  return price;\n};\n", "import { TokenInfo, TokenList } from '@uniswap/token-lists';\nimport axios from 'axios';\nimport { useState, useCallback, useEffect } from 'react';\n\nimport { useBlockNumberContext } from '~~/context';\n/**\n * #### Summary\n * Gets a tokenlist from uniswap ipfs tokenlist\n *\n * #### Note\n * - you can also point it to another URI\n *\n * @category Hooks\n *\n * @param tokenListUri\n * @param chainId optional, you can filter by a particular chainId\n * @returns (TokenInfo[]) from '@uniswap/token-lists'\n */\nexport const useDexTokenList = (\n  tokenListUri: string = 'https://gateway.ipfs.io/ipns/tokens.uniswap.org',\n  chainId?: number\n): TokenInfo[] => {\n  const [tokenList, setTokenList] = useState<TokenInfo[]>([]);\n  const blockNumber = useBlockNumberContext();\n\n  const callFunc = useCallback(async (): Promise<void> => {\n    try {\n      const tokenListResp: TokenList = (await axios(tokenListUri)).data as TokenList;\n      if (tokenListResp != null) {\n        let tokenInfo: TokenInfo[] = [];\n\n        if (chainId) {\n          tokenInfo = tokenListResp.tokens.filter((t: TokenInfo) => {\n            return t.chainId === chainId;\n          });\n        } else {\n          tokenInfo = tokenListResp.tokens;\n        }\n\n        setTokenList(tokenInfo);\n      }\n    } catch (e) {\n      console.log(e);\n    }\n  }, [chainId, tokenListUri]);\n\n  useEffect(() => {\n    void callFunc();\n  }, [blockNumber, callFunc]);\n\n  return tokenList;\n};\n", "import { utils } from 'ethers';\nimport { useState, useEffect } from 'react';\n\nimport { TEthersProvider } from '~~/models';\n\n/**\n * @internal\n *\n * @param provider\n * @param address\n * @returns\n */\nconst lookupAddress = async (provider: TEthersProvider, address: string): Promise<string> => {\n  if (utils.isAddress(address)) {\n    try {\n      // Accuracy of reverse resolution is not enforced.\n      // We then manually ensure that the reported ens name resolves to address\n      const reportedName = await provider.lookupAddress(address);\n\n      const resolvedAddress = await provider.resolveName(reportedName);\n\n      if (address && utils.getAddress(address) === utils.getAddress(resolvedAddress)) {\n        return reportedName;\n      } else {\n        return utils.getAddress(address);\n      }\n    } catch (e) {\n      return utils.getAddress(address);\n    }\n  }\n  return '';\n};\n\n/**\n * #### Summary\n * Gets ENS name for given address\n *\n * @category Hooks\n *\n * @param mainnetProvider mainnet provider\n * @param address\n * @returns\n */\nexport const useResolveEnsName = (mainnetProvider: TEthersProvider | undefined, address: string): string => {\n  const [ensName, setEnsName] = useState(address);\n\n  useEffect(() => {\n    const storedData: any = window.localStorage.getItem('ensCache_' + address);\n    const cache = JSON.parse(storedData ?? '{}') as Record<string, any>;\n\n    if (cache && cache?.name && cache?.timestamp > Date.now()) {\n      setEnsName(cache?.name);\n    } else if (mainnetProvider) {\n      void lookupAddress(mainnetProvider, address).then((name) => {\n        if (name) {\n          setEnsName(name);\n          window.localStorage.setItem(\n            'ensCache_' + address,\n            JSON.stringify({\n              timestamp: Date.now() + 360000,\n              name,\n            })\n          );\n        }\n      });\n    }\n  }, [address, mainnetProvider]);\n\n  return ensName;\n};\n", "import { constants } from 'ethers';\nimport { useState, useEffect } from 'react';\n\nimport { TEthersProvider } from '~~/models';\n\n/**\n * #### Summary\n * Gets the address from an ENS name\n *\n * @category Hooks\n *\n * @param mainnetProvider mainnet provider\n * @param ensName\n * @returns\n */\nexport const useResolveEnsAddress = (mainnetProvider: TEthersProvider, ensName: string): string => {\n  const [address, setAddress] = useState<string>(constants.AddressZero);\n\n  useEffect(() => {\n    if (mainnetProvider) {\n      void mainnetProvider.resolveName(ensName).then((resolvedAddress: string) => setAddress(resolvedAddress));\n    }\n  }, [mainnetProvider, ensName]);\n\n  return address;\n};\n"],
  "mappings": "wNAAA,mDACA,wCAoBO,GAAM,gBAAiB,CAC5B,gBACA,kBACA,SAAmB,IACR,CACX,GAAM,CAAC,MAAO,UAAY,SAAS,GAE7B,SAAW,YAAY,IAAM,CAiBjC,AAAK,AAhBY,UAA2B,CAC1C,GAAI,iDAAmB,MACrB,SAAS,kBAAkB,eAClB,gBAAiB,CAC1B,GAAM,SAAU,KAAM,iBAAgB,aAEhC,IAAM,GAAI,OAAM,QAAU,QAAQ,QAAU,EAAG,6CAA8C,IAC7F,KAAO,KAAM,SAAQ,cAAc,IAAK,KAAK,IAAI,SAAU,iBAC3D,MAAQ,GAAI,OAAM,CAAC,MAAO,KAAK,IAAI,UACzC,SAAS,WAAW,MAAM,SAAS,cAAc,SAEjD,UAAS,IACT,QAAQ,KAAK,mEAKhB,CAAC,iDAAmB,MAAO,kBAE9B,uBAAgB,SAAU,CAAE,SAAU,SAAU,kBAEzC,OCjDT,yBACA,+EAgBO,GAAM,iBAAkB,CAC7B,aAAuB,kDACvB,UACgB,CAChB,GAAM,CAAC,UAAW,cAAgB,UAAsB,IAClD,YAAc,wBAEd,SAAW,aAAY,SAA2B,CACtD,GAAI,CACF,GAAM,eAA4B,MAAM,OAAM,eAAe,KAC7D,GAAI,eAAiB,KAAM,CACzB,GAAI,WAAyB,GAE7B,AAAI,QACF,UAAY,cAAc,OAAO,OAAO,AAAC,GAChC,EAAE,UAAY,SAGvB,UAAY,cAAc,OAG5B,aAAa,kBAER,EAAP,CACA,QAAQ,IAAI,KAEb,CAAC,QAAS,eAEb,iBAAU,IAAM,CACd,AAAK,YACJ,CAAC,YAAa,WAEV,WClDT,0BACA,iEAWA,GAAM,eAAgB,MAAO,SAA2B,UAAqC,CAC3F,GAAI,MAAM,UAAU,SAClB,GAAI,CAGF,GAAM,cAAe,KAAM,UAAS,cAAc,SAE5C,gBAAkB,KAAM,UAAS,YAAY,cAEnD,MAAI,UAAW,MAAM,WAAW,WAAa,MAAM,WAAW,iBACrD,aAEA,MAAM,WAAW,cAE1B,CACA,MAAO,OAAM,WAAW,SAG5B,MAAO,IAaI,kBAAoB,CAAC,gBAA8C,UAA4B,CAC1G,GAAM,CAAC,QAAS,YAAc,UAAS,SAEvC,kBAAU,IAAM,CACd,GAAM,YAAkB,OAAO,aAAa,QAAQ,YAAc,SAC5D,MAAQ,KAAK,MAAM,4BAAc,MAEvC,AAAI,OAAS,0BAAO,OAAQ,0BAAO,WAAY,KAAK,MAClD,WAAW,yBAAO,MACT,iBACJ,cAAc,gBAAiB,SAAS,KAAK,AAAC,MAAS,CAC1D,AAAI,MACF,YAAW,MACX,OAAO,aAAa,QAClB,YAAc,QACd,KAAK,UAAU,CACb,UAAW,KAAK,MAAQ,KACxB,YAMT,CAAC,QAAS,kBAEN,SCpET,8BACA,iEAcO,GAAM,sBAAuB,CAAC,gBAAkC,UAA4B,CACjG,GAAM,CAAC,QAAS,YAAc,UAAiB,UAAU,aAEzD,kBAAU,IAAM,CACd,AAAI,iBACG,gBAAgB,YAAY,SAAS,KAAK,AAAC,iBAA4B,WAAW,mBAExF,CAAC,gBAAiB,UAEd",
  "names": []
}
