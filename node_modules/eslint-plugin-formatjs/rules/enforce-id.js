"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("../util");
var ts_transformer_1 = require("@formatjs/ts-transformer");
function checkNode(context, node) {
    var msgs = (0, util_1.extractMessages)(node, context.settings);
    var options = context.options;
    var _a = options[0], opt = _a === void 0 ? {} : _a;
    var idInterpolationPattern = opt.idInterpolationPattern;
    var _loop_1 = function (defaultMessage, description, id, idPropNode, descriptionNode, messagePropNode) {
        if (!idInterpolationPattern && !idPropNode) {
            context.report({
                node: node,
                message: "id must be specified",
            });
        }
        else if (idInterpolationPattern) {
            if (!defaultMessage) {
                context.report({
                    node: node,
                    message: "defaultMessage must be a string literal to calculate generated IDs",
                });
            }
            else if (!description && descriptionNode) {
                context.report({
                    node: node,
                    message: "description must be a string literal to calculate generated IDs",
                });
            }
            else {
                var correctId_1 = (0, ts_transformer_1.interpolateName)({
                    resourcePath: context.getFilename(),
                }, idInterpolationPattern, {
                    content: description
                        ? defaultMessage + "#" + description
                        : defaultMessage,
                });
                if (id !== correctId_1) {
                    context.report({
                        node: node,
                        message: "\"id\" does not match with hash pattern " + idInterpolationPattern + ".\nExpected: " + correctId_1 + "\nActual: " + id,
                        fix: function (fixer) {
                            if (idPropNode) {
                                if (idPropNode.type === 'JSXAttribute') {
                                    return fixer.replaceText(idPropNode, "id=\"" + correctId_1 + "\"");
                                }
                                return fixer.replaceText(idPropNode, "id: '" + correctId_1 + "'");
                            }
                            // Insert after default message node
                            if (messagePropNode.type === 'JSXAttribute') {
                                return fixer.insertTextAfter(messagePropNode, " id=\"" + correctId_1 + "\"");
                            }
                            return fixer.replaceText(messagePropNode, "defaultMessage: '" + defaultMessage + "', id: '" + correctId_1 + "'");
                        },
                    });
                }
            }
        }
    };
    for (var _i = 0, msgs_1 = msgs; _i < msgs_1.length; _i++) {
        var _b = msgs_1[_i][0], _c = _b.message, defaultMessage = _c.defaultMessage, description = _c.description, id = _c.id, idPropNode = _b.idPropNode, descriptionNode = _b.descriptionNode, messagePropNode = _b.messagePropNode;
        _loop_1(defaultMessage, description, id, idPropNode, descriptionNode, messagePropNode);
    }
}
exports.default = {
    meta: {
        type: 'problem',
        docs: {
            description: 'Enforce (generated) ID in message descriptor',
            category: 'Errors',
            recommended: false,
            url: 'https://formatjs.io/docs/tooling/linter#enforce-id',
        },
        fixable: 'code',
        schema: [
            {
                type: 'object',
                properties: {
                    idInterpolationPattern: {
                        type: 'string',
                    },
                },
                required: ['idInterpolationPattern'],
                additionalProperties: false,
            },
        ],
    },
    create: function (context) {
        var callExpressionVisitor = function (node) {
            return checkNode(context, node);
        };
        if (context.parserServices.defineTemplateBodyVisitor) {
            return context.parserServices.defineTemplateBodyVisitor({
                CallExpression: callExpressionVisitor,
            }, {
                CallExpression: callExpressionVisitor,
            });
        }
        return {
            JSXOpeningElement: function (node) { return checkNode(context, node); },
            CallExpression: callExpressionVisitor,
        };
    },
};
