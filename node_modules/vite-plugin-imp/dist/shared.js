"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.log = exports.addImportToCode = exports.stylePathHandler = exports.codeIncludesLibraryName = exports.parseImportModule = void 0;
const parser = __importStar(require("@babel/parser"));
const generator_1 = __importDefault(require("@babel/generator"));
const chalk_1 = __importDefault(require("chalk"));
const param_case_1 = require("param-case");
const isArray = Array.isArray;
const isString = (str) => (typeof str === 'string');
function parseImportModule(code, libList, command) {
    const ast = parser.parse(code, {
        sourceType: "module",
        plugins: [
            // enable jsx and flow syntax
            "jsx"
        ]
    });
    const astBody = ast.program.body;
    const importMaps = {};
    const toBeRemoveIndex = [];
    let newImportStatement = '';
    /* istanbul ignore else */
    if (isArray(astBody)) {
        astBody.forEach((astNode, index) => {
            var _a, _b;
            const libName = ((_b = (_a = astNode) === null || _a === void 0 ? void 0 : _a.source) === null || _b === void 0 ? void 0 : _b.value) || '';
            const matchLib = libList.find(lib => lib.libName === libName);
            /* istanbul ignore else */
            if (astNode.type === 'ImportDeclaration' && matchLib) {
                const { camel2DashComponentName = true } = matchLib;
                astNode.specifiers.forEach((item) => {
                    var _a, _b, _c;
                    const name = (_a = item) === null || _a === void 0 ? void 0 : _a.imported.name;
                    const localName = (_b = item) === null || _b === void 0 ? void 0 : _b.local.name;
                    if (!name) {
                        return;
                    }
                    const { libDirectory = 'es' } = matchLib;
                    const libDir = libDirectory ? `${libDirectory}/` : '';
                    if (command === 'build' || (matchLib === null || matchLib === void 0 ? void 0 : matchLib.replaceOldImport)) {
                        let finalName = camel2DashComponentName ? param_case_1.paramCase(name) : name;
                        if (matchLib.nameFormatter) {
                            finalName = (_c = matchLib === null || matchLib === void 0 ? void 0 : matchLib.nameFormatter) === null || _c === void 0 ? void 0 : _c.call(matchLib, finalName, name);
                        }
                        newImportStatement += `import ${localName} from '${libName}/${libDir}${finalName}'\n`;
                        toBeRemoveIndex.push(index);
                    }
                    if (importMaps[libName]) {
                        importMaps[libName].push(name);
                    }
                    else {
                        importMaps[libName] = [name];
                    }
                });
            }
        });
    }
    ast.program.body = astBody.filter((item, index) => !toBeRemoveIndex.includes(index));
    let codeRemoveOriginImport = generator_1.default(ast).code;
    codeRemoveOriginImport = `${newImportStatement} \n ${codeRemoveOriginImport}`;
    return { importMaps, codeRemoveOriginImport };
}
exports.parseImportModule = parseImportModule;
const codeIncludesLibraryName = (code, libList) => {
    return !libList.every(({ libName }) => {
        return !new RegExp(`('${libName}')|("${libName}")`).test(code);
    });
};
exports.codeIncludesLibraryName = codeIncludesLibraryName;
const stylePathHandler = (stylePath) => {
    // for some case: when the component does not have a style file to import
    let str = '';
    if (isString(stylePath) && stylePath) {
        str += `import '${stylePath}'\n`;
    }
    else if (isArray(stylePath)) {
        stylePath.forEach(item => {
            str += `import '${item}'\n`;
        });
    }
    return str;
};
exports.stylePathHandler = stylePathHandler;
const addImportToCode = (code, impConfig, command = 'serve') => {
    const { importMaps, codeRemoveOriginImport } = parseImportModule(code, impConfig.libList, command);
    let importStr = '';
    impConfig.libList.forEach(({ libName, style, camel2DashComponentName = true }) => {
        if (importMaps[libName]) {
            importMaps[libName].forEach(item => {
                if (camel2DashComponentName) {
                    item = param_case_1.paramCase(item);
                }
                let stylePath = style(item);
                const styleImportString = exports.stylePathHandler(stylePath);
                importStr += styleImportString;
            });
        }
    });
    return `${importStr}${codeRemoveOriginImport}`;
};
exports.addImportToCode = addImportToCode;
const log = (...args) => {
    args[0] = `${chalk_1.default.green('[vite-plugin-imp]')} ${args[0]}`;
    console.log(...args);
};
exports.log = log;
//# sourceMappingURL=shared.js.map