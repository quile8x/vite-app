{
  "version": 3,
  "sources": ["../src/functions/transactor.ts"],
  "sourcesContent": ["import { TransactionRequest, TransactionResponse } from '@ethersproject/providers';\r\nimport { notification } from 'antd';\r\nimport Notify, { API, InitOptions } from 'bnc-notify';\r\nimport { parseProviderOrSigner } from 'eth-hooks/functions';\r\nimport { TEthersSigner } from 'eth-hooks/models';\r\nimport { BigNumber, ethers } from 'ethers';\r\nimport { Deferrable } from 'ethers/lib/utils';\r\n\r\nimport {\r\n  checkBlocknativeAppId,\r\n  IEthComponentsSettings as IEthComponentsSettings,\r\n} from '~~/models/EthComponentsSettings';\r\n\r\nconst callbacks: Record<string, any> = {};\r\nconst DEBUG = true;\r\nexport type TTransactor = (\r\n  tx: Deferrable<TransactionRequest> | Promise<TransactionResponse>,\r\n  callback?: ((_param: any) => void) | undefined\r\n) => Promise<Record<string, any> | TransactionResponse | undefined>;\r\n\r\n/**\r\n * this should probably just be renamed to \"notifier\"\r\n * it is basically just a wrapper around BlockNative's wonderful Notify.js\r\n * https://docs.blocknative.com/notify\r\n * @param settings (IEthComponentsContext)\r\n * @param provider\r\n * @param gasPrice\r\n * @param etherscan\r\n * @returns (transactor) a function to transact which calls a callback method parameter on completion\r\n */\r\nexport const transactor = (\r\n  settings: IEthComponentsSettings,\r\n  signer: TEthersSigner | undefined,\r\n  gasPrice?: number,\r\n  etherscan?: string,\r\n  throwOnError: boolean = false\r\n): TTransactor | undefined => {\r\n  if (signer != null) {\r\n    return async (\r\n      tx: Deferrable<TransactionRequest> | Promise<TransactionResponse>,\r\n      callback?: (_param: any) => void\r\n    ): Promise<Record<string, any> | TransactionResponse | undefined> => {\r\n      const { provider, providerNetwork } = await parseProviderOrSigner(signer);\r\n\r\n      checkBlocknativeAppId(settings);\r\n\r\n      let options: InitOptions | undefined;\r\n      let notify: API | undefined;\r\n      if (navigator.onLine) {\r\n        options = {\r\n          dappId: settings.apiKeys.BlocknativeDappId, // GET YOUR OWN KEY AT https://account.blocknative.com\r\n          system: 'ethereum',\r\n          networkId: providerNetwork?.chainId,\r\n          // darkMode: Boolean, // (default: false)\r\n          transactionHandler: (txInformation: any): void => {\r\n            if (DEBUG) console.log('HANDLE TX', txInformation);\r\n            const possibleFunction = callbacks[txInformation.transaction.hash];\r\n            if (typeof possibleFunction === 'function') {\r\n              possibleFunction(txInformation.transaction);\r\n            }\r\n          },\r\n        };\r\n        notify = Notify(options);\r\n      }\r\n\r\n      let etherscanNetwork = '';\r\n      if (providerNetwork?.name && providerNetwork?.chainId > 1) {\r\n        etherscanNetwork = providerNetwork.name + '.';\r\n      }\r\n\r\n      let etherscanTxUrl = 'https://' + etherscanNetwork + 'etherscan.io/tx/';\r\n      if (providerNetwork?.chainId === 100) {\r\n        etherscanTxUrl = 'https://blockscout.com/poa/xdai/tx/';\r\n      }\r\n\r\n      try {\r\n        let result: TransactionResponse | undefined;\r\n        if (tx instanceof Promise) {\r\n          if (DEBUG) console.log('AWAITING TX', tx);\r\n          const data = await tx;\r\n          result = data;\r\n        } else {\r\n          if (!tx.gasPrice) {\r\n            tx.gasPrice = gasPrice || ethers.utils.parseUnits('4.1', 'gwei');\r\n          }\r\n          if (!tx.gasLimit) {\r\n            tx.gasLimit = BigNumber.from(ethers.utils.hexlify(120000));\r\n          }\r\n          if (DEBUG) console.log('RUNNING TX', tx);\r\n          result = await signer?.sendTransaction(tx);\r\n        }\r\n        if (DEBUG) console.log('RESULT:', result);\r\n        // console.log(\"Notify\", notify);\r\n        if (callback && result) {\r\n          callbacks[result.hash] = callback;\r\n        }\r\n\r\n        // result is valid and is a TransactionResponse\r\n        if (result && 'wait' in result && result.wait) {\r\n          // if it is a valid Notify.js network, use that, if not, just send a default notification\r\n          if (\r\n            providerNetwork != null &&\r\n            [1, 3, 4, 5, 42, 100].indexOf(providerNetwork.chainId) >= 0 &&\r\n            notify != null\r\n          ) {\r\n            const { emitter } = notify.hash(result.hash);\r\n            emitter.on('all', (transaction) => {\r\n              return {\r\n                onclick: (): void => {\r\n                  window.open(`${etherscan ?? etherscanTxUrl ?? ''}${transaction.hash ?? ''}`);\r\n                },\r\n              };\r\n            });\r\n          } else {\r\n            notification.info({\r\n              message: 'Local Transaction Sent',\r\n              description: result?.hash,\r\n              placement: 'bottomRight',\r\n            });\r\n            // on most networks BlockNative will update a transaction handler,\r\n            // but locally we will set an interval to listen...\r\n            if (callback != null && result?.hash != null) {\r\n              let listeningInterval: NodeJS.Timeout | undefined = undefined;\r\n              // eslint-disable-next-line @typescript-eslint/no-misused-promises\r\n              listeningInterval = setInterval(async (): Promise<void> => {\r\n                if (result?.hash != null) {\r\n                  console.log('CHECK IN ON THE TX', result, provider);\r\n                  const currentTransactionReceipt = await provider?.getTransactionReceipt(result.hash);\r\n                  if (currentTransactionReceipt && currentTransactionReceipt.confirmations) {\r\n                    callback({ ...result, ...currentTransactionReceipt });\r\n                    if (listeningInterval) clearInterval(listeningInterval);\r\n                  }\r\n                }\r\n              }, 500);\r\n            }\r\n          }\r\n\r\n          await result.wait();\r\n        }\r\n\r\n        return result;\r\n      } catch (e: any) {\r\n        if (DEBUG) console.log(e);\r\n        // Accounts for Metamask and default signer on all networks\r\n        notification.error({\r\n          message: 'Transaction Error',\r\n          description: e?.message,\r\n        });\r\n\r\n        if (throwOnError) throw e;\r\n      }\r\n    };\r\n  }\r\n};\r\n"],
  "mappings": "uGACA,+BACA,+BACA,uDAEA,qCAQA,GAAM,WAAiC,GACjC,MAAQ,GAgBD,WAAa,CACxB,SACA,OACA,SACA,UACA,aAAwB,KACI,CAC5B,GAAI,QAAU,KACZ,MAAO,OACL,GACA,WACmE,CACnE,GAAM,CAAE,SAAU,iBAAoB,KAAM,uBAAsB,QAElE,sBAAsB,UAEtB,GAAI,SACA,OACJ,AAAI,UAAU,QACZ,SAAU,CACR,OAAQ,SAAS,QAAQ,kBACzB,OAAQ,WACR,UAAW,6CAAiB,QAE5B,mBAAoB,AAAC,eAA6B,CAChD,AAAI,OAAO,QAAQ,IAAI,YAAa,eACpC,GAAM,kBAAmB,UAAU,cAAc,YAAY,MAC7D,AAAI,MAAO,mBAAqB,YAC9B,iBAAiB,cAAc,eAIrC,OAAS,OAAO,UAGlB,GAAI,kBAAmB,GACvB,AAAI,8CAAiB,OAAQ,8CAAiB,SAAU,GACtD,kBAAmB,gBAAgB,KAAO,KAG5C,GAAI,gBAAiB,WAAa,iBAAmB,mBACrD,AAAI,8CAAiB,WAAY,KAC/B,gBAAiB,uCAGnB,GAAI,CACF,GAAI,QAsBJ,GArBA,AAAI,aAAc,SACZ,QAAO,QAAQ,IAAI,cAAe,IAEtC,OADa,KAAM,KAGd,IAAG,UACN,IAAG,SAAW,UAAY,OAAO,MAAM,WAAW,MAAO,SAEtD,GAAG,UACN,IAAG,SAAW,UAAU,KAAK,OAAO,MAAM,QAAQ,QAEhD,OAAO,QAAQ,IAAI,aAAc,IACrC,OAAS,KAAM,4BAAQ,gBAAgB,MAErC,OAAO,QAAQ,IAAI,UAAW,QAE9B,UAAY,QACd,WAAU,OAAO,MAAQ,UAIvB,QAAU,QAAU,SAAU,OAAO,KAAM,CAE7C,GACE,iBAAmB,MACnB,CAAC,EAAG,EAAG,EAAG,EAAG,GAAI,KAAK,QAAQ,gBAAgB,UAAY,GAC1D,QAAU,KACV,CACA,GAAM,CAAE,SAAY,OAAO,KAAK,OAAO,MACvC,QAAQ,GAAG,MAAO,AAAC,aACV,EACL,QAAS,IAAY,CA5GrC,UA6GkB,OAAO,KAAK,GAAG,8BAAa,iBAAb,QAA+B,KAAK,gBAAY,OAAZ,QAAoB,kBAK7E,aAAa,KAAK,CAChB,QAAS,yBACT,YAAa,2BAAQ,KACrB,UAAW,gBAIT,UAAY,MAAQ,4BAAQ,OAAQ,KAAM,CAC5C,GAAI,mBAEJ,kBAAoB,YAAY,SAA2B,CACzD,GAAI,4BAAQ,OAAQ,KAAM,CACxB,QAAQ,IAAI,qBAAsB,OAAQ,UAC1C,GAAM,2BAA4B,KAAM,gCAAU,sBAAsB,OAAO,OAC/E,AAAI,2BAA6B,0BAA0B,eACzD,UAAS,iCAAK,QAAW,4BACrB,mBAAmB,cAAc,sBAGxC,KAIP,KAAM,QAAO,OAGf,MAAO,cACA,EAAP,CAQA,GAPI,OAAO,QAAQ,IAAI,GAEvB,aAAa,MAAM,CACjB,QAAS,oBACT,YAAa,iBAAG,UAGd,aAAc,KAAM",
  "names": []
}
