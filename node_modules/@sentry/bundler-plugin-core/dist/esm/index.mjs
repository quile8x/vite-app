import { createUnplugin } from 'unplugin';
import MagicString from 'magic-string';
import SentryCli from '@sentry/cli';
import { NodeClient, defaultStackParser, makeNodeTransport, Hub, makeMain } from '@sentry/node';
import findUp from 'find-up';
import * as path from 'path';
import path__default from 'path';
import * as fs from 'fs';
import fs__default from 'fs';
import os from 'os';
import crypto from 'crypto';
import '@sentry/tracing';
import { createRequire } from 'module';
import * as util from 'util';
import { promisify } from 'util';
import { glob } from 'glob';
import webpackSources from 'webpack-sources';

function _regeneratorRuntime() {
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function () {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function (obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof value && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator.return && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) keys.push(key);

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function (skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
    },
    stop: function () {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function (exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function (type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function (record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function (finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    catch: function (tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function (iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

/** Internal global with common properties and Sentry extensions  */

// The code below for 'isGlobalObj' and 'GLOBAL_OBJ' was copied from core-js before modification
// https://github.com/zloirock/core-js/blob/1b944df55282cdc99c90db5f49eb0b6eda2cc0a3/packages/core-js/internals/global.js
// core-js has the following licence:
//
// Copyright (c) 2014-2022 Denis Pushkarev
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

/** Returns 'obj' if it's the global object, otherwise returns undefined */
function isGlobalObj(obj) {
  return obj && obj.Math == Math ? obj : undefined;
}

/** Get's the global object for the current JavaScript runtime */
const GLOBAL_OBJ =
  (typeof globalThis == 'object' && isGlobalObj(globalThis)) ||
  // eslint-disable-next-line no-restricted-globals
  (typeof window == 'object' && isGlobalObj(window)) ||
  (typeof self == 'object' && isGlobalObj(self)) ||
  (typeof global == 'object' && isGlobalObj(global)) ||
  (function () {
    return this;
  })() ||
  {};

/**
 * @deprecated Use GLOBAL_OBJ instead or WINDOW from @sentry/browser. This will be removed in v8
 */
function getGlobalObject() {
  return GLOBAL_OBJ ;
}

/**
 * Returns a global singleton contained in the global `__SENTRY__` object.
 *
 * If the singleton doesn't already exist in `__SENTRY__`, it will be created using the given factory
 * function and added to the `__SENTRY__` object.
 *
 * @param name name of the global singleton on __SENTRY__
 * @param creator creator Factory function to create the singleton if it doesn't already exist on `__SENTRY__`
 * @param obj (Optional) The global object on which to look for `__SENTRY__`, if not `GLOBAL_OBJ`'s return value
 * @returns the singleton
 */
function getGlobalSingleton(name, creator, obj) {
  const gbl = (obj || GLOBAL_OBJ) ;
  const __SENTRY__ = (gbl.__SENTRY__ = gbl.__SENTRY__ || {});
  const singleton = __SENTRY__[name] || (__SENTRY__[name] = creator());
  return singleton;
}

/** Prefix for logging strings */
const PREFIX = 'Sentry Logger ';

const CONSOLE_LEVELS = ['debug', 'info', 'warn', 'error', 'log', 'assert', 'trace'] ;

/**
 * Temporarily disable sentry console instrumentations.
 *
 * @param callback The function to run against the original `console` messages
 * @returns The results of the callback
 */
function consoleSandbox(callback) {
  if (!('console' in GLOBAL_OBJ)) {
    return callback();
  }

  const originalConsole = GLOBAL_OBJ.console ;
  const wrappedLevels = {};

  // Restore all wrapped console methods
  CONSOLE_LEVELS.forEach(level => {
    // TODO(v7): Remove this check as it's only needed for Node 6
    const originalWrappedFunc =
      originalConsole[level] && (originalConsole[level] ).__sentry_original__;
    if (level in originalConsole && originalWrappedFunc) {
      wrappedLevels[level] = originalConsole[level] ;
      originalConsole[level] = originalWrappedFunc ;
    }
  });

  try {
    return callback();
  } finally {
    // Revert restoration to wrapped state
    Object.keys(wrappedLevels).forEach(level => {
      originalConsole[level] = wrappedLevels[level ];
    });
  }
}

function makeLogger() {
  let enabled = false;
  const logger = {
    enable: () => {
      enabled = true;
    },
    disable: () => {
      enabled = false;
    },
  };

  if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
    CONSOLE_LEVELS.forEach(name => {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      logger[name] = (...args) => {
        if (enabled) {
          consoleSandbox(() => {
            GLOBAL_OBJ.console[name](`${PREFIX}[${name}]:`, ...args);
          });
        }
      };
    });
  } else {
    CONSOLE_LEVELS.forEach(name => {
      logger[name] = () => undefined;
    });
  }

  return logger ;
}

// Ensure we only have a single logger instance, even if multiple versions of @sentry/utils are being used
let logger;
if ((typeof __SENTRY_DEBUG__ === 'undefined' || __SENTRY_DEBUG__)) {
  logger = getGlobalSingleton('logger', makeLogger);
} else {
  logger = makeLogger();
}

/*
 * This module exists for optimizations in the build process through rollup and terser.  We define some global
 * constants, which can be overridden during build. By guarding certain pieces of code with functions that return these
 * constants, we can control whether or not they appear in the final bundle. (Any code guarded by a false condition will
 * never run, and will hence be dropped during treeshaking.) The two primary uses for this are stripping out calls to
 * `logger` and preventing node-related code from appearing in browser bundles.
 *
 * Attention:
 * This file should not be used to define constants/flags that are intended to be used for tree-shaking conducted by
 * users. These fags should live in their respective packages, as we identified user tooling (specifically webpack)
 * having issues tree-shaking these constants across package boundaries.
 * An example for this is the __SENTRY_DEBUG__ constant. It is declared in each package individually because we want
 * users to be able to shake away expressions that it guards.
 */

/**
 * Figures out if we're building a browser bundle.
 *
 * @returns true if this is a browser bundle build.
 */
function isBrowserBundle() {
  return typeof __SENTRY_BROWSER_BUNDLE__ !== 'undefined' && !!__SENTRY_BROWSER_BUNDLE__;
}

/**
 * NOTE: In order to avoid circular dependencies, if you add a function to this module and it needs to print something,
 * you must either a) use `console.log` rather than the logger, or b) put your function elsewhere.
 */

/**
 * Checks whether we're in the Node.js or Browser environment
 *
 * @returns Answer to given question
 */
function isNodeEnv() {
  // explicitly check for browser bundles as those can be optimized statically
  // by terser/rollup.
  return (
    !isBrowserBundle() &&
    Object.prototype.toString.call(typeof process !== 'undefined' ? process : 0) === '[object process]'
  );
}

/**
 * Requires a module which is protected against bundler minification.
 *
 * @param request The module path to resolve
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/no-explicit-any
function dynamicRequire(mod, request) {
  // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
  return mod.require(request);
}

/* eslint-disable @typescript-eslint/explicit-function-return-type */

/** SyncPromise internal states */
var States; (function (States) {
  /** Pending */
  const PENDING = 0; States[States["PENDING"] = PENDING] = "PENDING";
  /** Resolved / OK */
  const RESOLVED = 1; States[States["RESOLVED"] = RESOLVED] = "RESOLVED";
  /** Rejected / Error */
  const REJECTED = 2; States[States["REJECTED"] = REJECTED] = "REJECTED";
})(States || (States = {}));

// eslint-disable-next-line deprecation/deprecation
const WINDOW = getGlobalObject();

/**
 * An object that can return the current timestamp in seconds since the UNIX epoch.
 */

/**
 * A TimestampSource implementation for environments that do not support the Performance Web API natively.
 *
 * Note that this TimestampSource does not use a monotonic clock. A call to `nowSeconds` may return a timestamp earlier
 * than a previously returned value. We do not try to emulate a monotonic behavior in order to facilitate debugging. It
 * is more obvious to explain "why does my span have negative duration" than "why my spans have zero duration".
 */
const dateTimestampSource = {
  nowSeconds: () => Date.now() / 1000,
};

/**
 * A partial definition of the [Performance Web API]{@link https://developer.mozilla.org/en-US/docs/Web/API/Performance}
 * for accessing a high-resolution monotonic clock.
 */

/**
 * Returns a wrapper around the native Performance API browser implementation, or undefined for browsers that do not
 * support the API.
 *
 * Wrapping the native API works around differences in behavior from different browsers.
 */
function getBrowserPerformance() {
  const { performance } = WINDOW;
  if (!performance || !performance.now) {
    return undefined;
  }

  // Replace performance.timeOrigin with our own timeOrigin based on Date.now().
  //
  // This is a partial workaround for browsers reporting performance.timeOrigin such that performance.timeOrigin +
  // performance.now() gives a date arbitrarily in the past.
  //
  // Additionally, computing timeOrigin in this way fills the gap for browsers where performance.timeOrigin is
  // undefined.
  //
  // The assumption that performance.timeOrigin + performance.now() ~= Date.now() is flawed, but we depend on it to
  // interact with data coming out of performance entries.
  //
  // Note that despite recommendations against it in the spec, browsers implement the Performance API with a clock that
  // might stop when the computer is asleep (and perhaps under other circumstances). Such behavior causes
  // performance.timeOrigin + performance.now() to have an arbitrary skew over Date.now(). In laptop computers, we have
  // observed skews that can be as long as days, weeks or months.
  //
  // See https://github.com/getsentry/sentry-javascript/issues/2590.
  //
  // BUG: despite our best intentions, this workaround has its limitations. It mostly addresses timings of pageload
  // transactions, but ignores the skew built up over time that can aversely affect timestamps of navigation
  // transactions of long-lived web pages.
  const timeOrigin = Date.now() - performance.now();

  return {
    now: () => performance.now(),
    timeOrigin,
  };
}

/**
 * Returns the native Performance API implementation from Node.js. Returns undefined in old Node.js versions that don't
 * implement the API.
 */
function getNodePerformance() {
  try {
    const perfHooks = dynamicRequire(module, 'perf_hooks') ;
    return perfHooks.performance;
  } catch (_) {
    return undefined;
  }
}

/**
 * The Performance API implementation for the current platform, if available.
 */
const platformPerformance = isNodeEnv() ? getNodePerformance() : getBrowserPerformance();

const timestampSource =
  platformPerformance === undefined
    ? dateTimestampSource
    : {
        nowSeconds: () => (platformPerformance.timeOrigin + platformPerformance.now()) / 1000,
      };

/**
 * Returns a timestamp in seconds since the UNIX epoch using the Date API.
 */
dateTimestampSource.nowSeconds.bind(dateTimestampSource);

/**
 * Returns a timestamp in seconds since the UNIX epoch using either the Performance or Date APIs, depending on the
 * availability of the Performance API.
 *
 * See `usingPerformanceAPI` to test whether the Performance API is used.
 *
 * BUG: Note that because of how browsers implement the Performance API, the clock might stop when the computer is
 * asleep. This creates a skew between `dateTimestampInSeconds` and `timestampInSeconds`. The
 * skew can grow to arbitrary amounts like days, weeks or months.
 * See https://github.com/getsentry/sentry-javascript/issues/2590.
 */
timestampSource.nowSeconds.bind(timestampSource);

/**
 * The number of milliseconds since the UNIX epoch. This value is only usable in a browser, and only when the
 * performance API is available.
 */
(() => {
  // Unfortunately browsers may report an inaccurate time origin data, through either performance.timeOrigin or
  // performance.timing.navigationStart, which results in poor results in performance data. We only treat time origin
  // data as reliable if they are within a reasonable threshold of the current time.

  const { performance } = WINDOW;
  if (!performance || !performance.now) {
    return undefined;
  }

  const threshold = 3600 * 1000;
  const performanceNow = performance.now();
  const dateNow = Date.now();

  // if timeOrigin isn't available set delta to threshold so it isn't used
  const timeOriginDelta = performance.timeOrigin
    ? Math.abs(performance.timeOrigin + performanceNow - dateNow)
    : threshold;
  const timeOriginIsReliable = timeOriginDelta < threshold;

  // While performance.timing.navigationStart is deprecated in favor of performance.timeOrigin, performance.timeOrigin
  // is not as widely supported. Namely, performance.timeOrigin is undefined in Safari as of writing.
  // Also as of writing, performance.timing is not available in Web Workers in mainstream browsers, so it is not always
  // a valid fallback. In the absence of an initial time provided by the browser, fallback to the current time from the
  // Date API.
  // eslint-disable-next-line deprecation/deprecation
  const navigationStart = performance.timing && performance.timing.navigationStart;
  const hasNavigationStart = typeof navigationStart === 'number';
  // if navigationStart isn't available set delta to threshold so it isn't used
  const navigationStartDelta = hasNavigationStart ? Math.abs(navigationStart + performanceNow - dateNow) : threshold;
  const navigationStartIsReliable = navigationStartDelta < threshold;

  if (timeOriginIsReliable || navigationStartIsReliable) {
    // Use the more reliable time origin
    if (timeOriginDelta <= navigationStartDelta) {
      return performance.timeOrigin;
    } else {
      return navigationStart;
    }
  }
  return dateNow;
})();

/**
 * Checks whether the given input is already an array, and if it isn't, wraps it in one.
 *
 * @param maybeArray Input to turn into an array, if necessary
 * @returns The input, if already an array, or an array with the input as the only element, if not
 */

function arrayify(maybeArray) {
  return Array.isArray(maybeArray) ? maybeArray : [maybeArray];
}

/**
 * Get the closes package.json from a given starting point upwards.
 * This handles a few edge cases:
 * * Check if a given file package.json appears to be an actual NPM package.json file
 * * Stop at the home dir, to avoid looking too deeply
 */
function getPackageJson() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      cwd = _ref.cwd,
      stopAt = _ref.stopAt;

  return lookupPackageJson(cwd !== null && cwd !== void 0 ? cwd : process.cwd(), path__default.normalize(stopAt !== null && stopAt !== void 0 ? stopAt : os.homedir()));
}
function parseMajorVersion(version) {
  // if it has a `v` prefix, remove it
  if (version.startsWith("v")) {
    version = version.slice(1);
  } // First, try simple lookup of exact, ~ and ^ versions


  var regex = /^[\^~]?(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var match = version.match(regex);

  if (match) {
    return parseInt(match[1], 10);
  } // Try to parse e.g. 1.x


  var coerced = parseInt(version, 10);

  if (!Number.isNaN(coerced)) {
    return coerced;
  } // Match <= and >= ranges.


  var gteLteRegex = /^[<>]=\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var gteLteMatch = version.match(gteLteRegex);

  if (gteLteMatch) {
    return parseInt(gteLteMatch[1], 10);
  } // match < ranges


  var ltRegex = /^<\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var ltMatch = version.match(ltRegex);

  if (ltMatch) {
    // Two scenarios:
    // a) < 2.0.0 --> return 1
    // b) < 2.1.0 --> return 2
    var major = parseInt(ltMatch[1], 10);

    if ( // minor version > 0
    typeof ltMatch[2] === "string" && parseInt(ltMatch[2].slice(1), 10) > 0 || // patch version > 0
    typeof ltMatch[3] === "string" && parseInt(ltMatch[3].slice(1), 10) > 0) {
      return major;
    }

    return major - 1;
  } // match > ranges


  var gtRegex = /^>\s*(\d+)(\.\d+)?(\.\d+)?(-.+)?/;
  var gtMatch = version.match(gtRegex);

  if (gtMatch) {
    // We always return the version here, even though it _may_ be incorrect
    // E.g. if given > 2.0.0, it should be 2 if there exists any 2.x.x version, else 3
    // Since there is no way for us to know this, we're going to assume any kind of patch/feature release probably exists
    return parseInt(gtMatch[1], 10);
  }

  return undefined;
} // This is an explicit list of packages where we want to include the (major) version number.

var PACKAGES_TO_INCLUDE_VERSION = ["react", "@angular/core", "vue", "ember-source", "svelte", "@sveltejs/kit", "webpack", "vite", "gatsby", "next", "remix", "rollup", "esbuild"];
function getDependencies(packageJson) {
  var _packageJson$devDepen, _packageJson$dependen;

  var dependencies = Object.assign({}, (_packageJson$devDepen = packageJson["devDependencies"]) !== null && _packageJson$devDepen !== void 0 ? _packageJson$devDepen : {}, (_packageJson$dependen = packageJson["dependencies"]) !== null && _packageJson$dependen !== void 0 ? _packageJson$dependen : {});
  var deps = Object.keys(dependencies).sort();
  var depsVersions = deps.reduce(function (depsVersions, depName) {
    if (PACKAGES_TO_INCLUDE_VERSION.includes(depName)) {
      var version = dependencies[depName];
      var majorVersion = parseMajorVersion(version);

      if (majorVersion) {
        depsVersions[depName] = majorVersion;
      }
    }

    return depsVersions;
  }, {});
  return {
    deps: deps,
    depsVersions: depsVersions
  };
}

function lookupPackageJson(cwd, stopAt) {
  var jsonPath = findUp.sync(function (dirName) {
    // Stop if we reach this dir
    if (path__default.normalize(dirName) === stopAt) {
      return findUp.stop;
    }

    return findUp.sync.exists(dirName + "/package.json") ? "package.json" : undefined;
  }, {
    cwd: cwd
  });

  if (!jsonPath) {
    return undefined;
  }

  try {
    var jsonStr = fs__default.readFileSync(jsonPath, "utf8");
    var json = JSON.parse(jsonStr); // Ensure it is an actual package.json
    // This is very much not bulletproof, but should be good enough

    if ("name" in json || "private" in json) {
      return json;
    }
  } catch (error) {// Ignore and walk up
  } // Continue up the tree, if we find a fitting package.json


  var newCwd = path__default.dirname(path__default.resolve(jsonPath + "/.."));
  return lookupPackageJson(newCwd, stopAt);
}
/**
 * Deterministically hashes a string and turns the hash into a uuid.
 */


function stringToUUID(str) {
  var md5sum = crypto.createHash("md5");
  md5sum.update(str);
  var md5Hash = md5sum.digest("hex");
  return (md5Hash.substring(0, 8) + "-" + md5Hash.substring(8, 12) + "-4" + md5Hash.substring(13, 16) + "-" + md5Hash.substring(16, 20) + "-" + md5Hash.substring(20)).toLowerCase();
}

var SENTRY_SAAS_URL = "https://sentry.io";
function normalizeUserOptions(userOptions) {
  var _userOptions$org, _userOptions$project, _ref, _userOptions$release, _ref2, _userOptions$url, _userOptions$finalize, _userOptions$cleanArt, _userOptions$dryRun, _userOptions$debug, _userOptions$silent, _userOptions$telemetr, _userOptions$injectRe, _userOptions$injectRe2, _userOptions$uploadSo, _userOptions$_experim;

  var options = {
    // include is the only strictly required option
    // (normalizeInclude needs all userOptions to access top-level include options)
    include: normalizeInclude(userOptions),
    // These options must be set b/c we need them for release injection.
    // They can also be set as environment variables. Technically, they
    // could be set in the config file but this would be too late for
    // release injection because we only pass the config file path
    // to the CLI
    org: (_userOptions$org = userOptions.org) !== null && _userOptions$org !== void 0 ? _userOptions$org : process.env["SENTRY_ORG"],
    project: (_userOptions$project = userOptions.project) !== null && _userOptions$project !== void 0 ? _userOptions$project : process.env["SENTRY_PROJECT"],
    // Falling back to the empty string here b/c at a later point, we use
    // Sentry CLI to determine a release if none was specified via options
    // or env vars. In case we don't find one, we'll bail at that point.
    release: (_ref = (_userOptions$release = userOptions.release) !== null && _userOptions$release !== void 0 ? _userOptions$release : process.env["SENTRY_RELEASE"]) !== null && _ref !== void 0 ? _ref : "",
    // We technically don't need the URL for anything release-specific
    // but we want to make sure that we're only sending Sentry data
    // of SaaS customers. Hence we want to read it anyway.
    url: (_ref2 = (_userOptions$url = userOptions.url) !== null && _userOptions$url !== void 0 ? _userOptions$url : process.env["SENTRY_URL"]) !== null && _ref2 !== void 0 ? _ref2 : SENTRY_SAAS_URL,
    // Options with default values
    finalize: (_userOptions$finalize = userOptions.finalize) !== null && _userOptions$finalize !== void 0 ? _userOptions$finalize : true,
    cleanArtifacts: (_userOptions$cleanArt = userOptions.cleanArtifacts) !== null && _userOptions$cleanArt !== void 0 ? _userOptions$cleanArt : false,
    dryRun: (_userOptions$dryRun = userOptions.dryRun) !== null && _userOptions$dryRun !== void 0 ? _userOptions$dryRun : false,
    debug: (_userOptions$debug = userOptions.debug) !== null && _userOptions$debug !== void 0 ? _userOptions$debug : false,
    silent: (_userOptions$silent = userOptions.silent) !== null && _userOptions$silent !== void 0 ? _userOptions$silent : false,
    telemetry: (_userOptions$telemetr = userOptions.telemetry) !== null && _userOptions$telemetr !== void 0 ? _userOptions$telemetr : true,
    injectReleasesMap: (_userOptions$injectRe = userOptions.injectReleasesMap) !== null && _userOptions$injectRe !== void 0 ? _userOptions$injectRe : false,
    injectRelease: (_userOptions$injectRe2 = userOptions.injectRelease) !== null && _userOptions$injectRe2 !== void 0 ? _userOptions$injectRe2 : true,
    uploadSourceMaps: (_userOptions$uploadSo = userOptions.uploadSourceMaps) !== null && _userOptions$uploadSo !== void 0 ? _userOptions$uploadSo : true,
    sourcemaps: userOptions.sourcemaps,
    _experiments: (_userOptions$_experim = userOptions._experiments) !== null && _userOptions$_experim !== void 0 ? _userOptions$_experim : {},
    // These options and can also be set via env variables or the config file.
    // If they're set in the options, we simply pass them to the CLI constructor.
    // Sentry CLI will internally query env variables and read its config file if
    // the passed options are undefined.
    authToken: userOptions.authToken,
    // env var: `SENTRY_AUTH_TOKEN`
    headers: userOptions.headers,
    vcsRemote: userOptions.vcsRemote,
    // env var: `SENTRY_VSC_REMOTE`
    // Optional options
    setCommits: userOptions.setCommits,
    deploy: userOptions.deploy,
    releaseInjectionTargets: normalizeReleaseInjectionTargets(userOptions.releaseInjectionTargets),
    dist: userOptions.dist,
    errorHandler: userOptions.errorHandler,
    configFile: userOptions.configFile
  };
  return options;
}
/**
 * Converts the user-facing `releaseInjectionTargets` option to the internal
 * `releaseInjectionTargets` option
 */

function normalizeReleaseInjectionTargets(userReleaseInjectionTargets) {
  if (userReleaseInjectionTargets === undefined) {
    return undefined;
  } else if (typeof userReleaseInjectionTargets === "function") {
    return userReleaseInjectionTargets;
  } else {
    return arrayify(userReleaseInjectionTargets);
  }
}
/**
 * Converts the user-facing `include` option to the internal `include` option,
 * resulting in an array of `InternalIncludeEntry` objects. This later on lets us
 * work with only one type of include data structure instead of multiple.
 *
 * During the process, we hoist top-level include options (e.g. urlPrefix) into each
 * object if they were not alrady specified in an `IncludeEntry`, making every object
 * fully self-contained. This is also the reason why we pass the entire options
 * object and not just `include`.
 *
 * @param userOptions the entire user-facing `options` object
 *
 * @return an array of `InternalIncludeEntry` objects.
 */


function normalizeInclude(userOptions) {
  if (!userOptions.include) {
    return [];
  }

  return arrayify(userOptions.include).map(function (includeItem) {
    return typeof includeItem === "string" ? {
      paths: [includeItem]
    } : includeItem;
  }).map(function (userIncludeEntry) {
    return normalizeIncludeEntry(userOptions, userIncludeEntry);
  });
}
/**
 * Besides array-ifying the `ignore` option, this function hoists top level options into the items of the `include`
 * option. This is to simplify the handling of of the `include` items later on.
 */


function normalizeIncludeEntry(userOptions, includeEntry) {
  var _ref3, _includeEntry$ignore, _ref4, _includeEntry$ext, _includeEntry$ignoreF, _includeEntry$urlPref, _includeEntry$urlSuff, _includeEntry$stripPr, _ref5, _includeEntry$stripCo, _ref6, _includeEntry$sourceM, _ref7, _includeEntry$rewrite, _ref8, _includeEntry$validat;

  var ignoreOption = (_ref3 = (_includeEntry$ignore = includeEntry.ignore) !== null && _includeEntry$ignore !== void 0 ? _includeEntry$ignore : userOptions.ignore) !== null && _ref3 !== void 0 ? _ref3 : ["node_modules"];
  var ignore = Array.isArray(ignoreOption) ? ignoreOption : [ignoreOption]; // We're prefixing all entries in the `ext` option with a `.` (if it isn't already) to align with Node.js' `path.extname()`

  var ext = (_ref4 = (_includeEntry$ext = includeEntry.ext) !== null && _includeEntry$ext !== void 0 ? _includeEntry$ext : userOptions.ext) !== null && _ref4 !== void 0 ? _ref4 : ["js", "map", "jsbundle", "bundle"];
  var dotPrefixedExt = ext.map(function (extension) {
    return ".".concat(extension.replace(/^\./, ""));
  });
  return {
    paths: includeEntry.paths,
    ignore: ignore,
    ignoreFile: (_includeEntry$ignoreF = includeEntry.ignoreFile) !== null && _includeEntry$ignoreF !== void 0 ? _includeEntry$ignoreF : userOptions.ignoreFile,
    ext: dotPrefixedExt,
    urlPrefix: (_includeEntry$urlPref = includeEntry.urlPrefix) !== null && _includeEntry$urlPref !== void 0 ? _includeEntry$urlPref : userOptions.urlPrefix,
    urlSuffix: (_includeEntry$urlSuff = includeEntry.urlSuffix) !== null && _includeEntry$urlSuff !== void 0 ? _includeEntry$urlSuff : userOptions.urlSuffix,
    stripPrefix: (_includeEntry$stripPr = includeEntry.stripPrefix) !== null && _includeEntry$stripPr !== void 0 ? _includeEntry$stripPr : userOptions.stripPrefix,
    stripCommonPrefix: (_ref5 = (_includeEntry$stripCo = includeEntry.stripCommonPrefix) !== null && _includeEntry$stripCo !== void 0 ? _includeEntry$stripCo : userOptions.stripCommonPrefix) !== null && _ref5 !== void 0 ? _ref5 : false,
    sourceMapReference: (_ref6 = (_includeEntry$sourceM = includeEntry.sourceMapReference) !== null && _includeEntry$sourceM !== void 0 ? _includeEntry$sourceM : userOptions.sourceMapReference) !== null && _ref6 !== void 0 ? _ref6 : true,
    rewrite: (_ref7 = (_includeEntry$rewrite = includeEntry.rewrite) !== null && _includeEntry$rewrite !== void 0 ? _includeEntry$rewrite : userOptions.rewrite) !== null && _ref7 !== void 0 ? _ref7 : true,
    validate: (_ref8 = (_includeEntry$validat = includeEntry.validate) !== null && _includeEntry$validat !== void 0 ? _includeEntry$validat : userOptions.validate) !== null && _ref8 !== void 0 ? _ref8 : false
  };
}
/**
 * Validates a few combinations of options that are not checked by Sentry CLI.
 *
 * For all other options, we can rely on Sentry CLI to validate them. In fact,
 * we can't validate them in the plugin because Sentry CLI might pick up options from
 * its config file.
 *
 * @param options the internal options
 * @param logger the logger
 *
 * @returns `true` if the options are valid, `false` otherwise
 */


function validateOptions(options, logger) {
  if (options.injectReleasesMap && !options.org) {
    logger.error("The `injectReleasesMap` option was set but it is only supported when the `org` option is also specified.", "Please set the `org` option (you can also set the SENTRY_ORG environment variable) or disable the `injectReleasesMap` option.");
    return false;
  }

  var setCommits = options.setCommits;

  if (setCommits) {
    if (!setCommits.auto && !(setCommits.repo && setCommits.commit)) {
      logger.error("The `setCommits` option was specified but is missing required properties.", "Please set either `auto` or both, `repo` and `commit`.");
      return false;
    }

    if (setCommits.auto && setCommits.repo && setCommits) {
      logger.warn("The `setCommits` options includes `auto` but also `repo` and `commit`.", "Ignoring `repo` and `commit`.", "Please only set either `auto` or both, `repo` and `commit`.");
    }
  }

  if (options.deploy && !options.deploy.env) {
    logger.error("The `deploy` option was specified but is missing the required `env` property.", "Please set the `env` property.");
    return false;
  }

  return true;
}

var SENTRY_SAAS_HOSTNAME = "sentry.io";
function makeSentryClient(dsn, allowedToSendTelemetryPromise, userProject) {
  var client = new NodeClient({
    dsn: dsn,
    tracesSampleRate: 1,
    sampleRate: 1,
    // We're also sending the user project in dist because it is an indexed fieldso we can use this data effectively in
    // a dashboard.
    // Yes, this is slightly abusing the purpose of this field.
    dist: userProject,
    release: "0.7.2",
    integrations: [],
    tracePropagationTargets: ["sentry.io/api"],
    stackParser: defaultStackParser,
    beforeSend: function beforeSend(event) {
      var _event$exception, _event$exception$valu;

      (_event$exception = event.exception) === null || _event$exception === void 0 ? void 0 : (_event$exception$valu = _event$exception.values) === null || _event$exception$valu === void 0 ? void 0 : _event$exception$valu.forEach(function (exception) {
        delete exception.stacktrace;
      });
      delete event.server_name; // Server name might contain PII

      return event;
    },
    beforeSendTransaction: function beforeSendTransaction(event) {
      delete event.server_name; // Server name might contain PII

      return event;
    },
    // We create a transport that stalls sending events until we know that we're allowed to (i.e. when Sentry CLI told
    // us that the upload URL is the Sentry SaaS URL)
    transport: function transport(nodeTransportOptions) {
      var nodeTransport = makeNodeTransport(nodeTransportOptions);
      return {
        flush: function flush(timeout) {
          return nodeTransport.flush(timeout);
        },
        send: function () {
          var _send = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(request) {
            var isAllowedToSend;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) {
                switch (_context.prev = _context.next) {
                  case 0:
                    _context.next = 2;
                    return allowedToSendTelemetryPromise;

                  case 2:
                    isAllowedToSend = _context.sent;

                    if (!isAllowedToSend) {
                      _context.next = 7;
                      break;
                    }

                    return _context.abrupt("return", nodeTransport.send(request));

                  case 7:
                    return _context.abrupt("return", undefined);

                  case 8:
                  case "end":
                    return _context.stop();
                }
              }
            }, _callee);
          }));

          function send(_x) {
            return _send.apply(this, arguments);
          }

          return send;
        }()
      };
    }
  });
  var hub = new Hub(client);
  return {
    sentryClient: client,
    sentryHub: hub
  };
}
/**
 * Adds a span to the passed parentSpan or to the current transaction that's on the passed hub's scope.
 */

function addSpanToTransaction(ctx, op, description) {
  var _hub$getScope;

  var hub = ctx.hub,
      parentSpan = ctx.parentSpan;
  var actualSpan = parentSpan || ((_hub$getScope = hub.getScope()) === null || _hub$getScope === void 0 ? void 0 : _hub$getScope.getTransaction());
  var span = actualSpan === null || actualSpan === void 0 ? void 0 : actualSpan.startChild({
    op: op,
    description: description
  });
  hub.configureScope(function (scope) {
    return scope.setSpan(span);
  });
  return span;
}
function addPluginOptionInformationToHub(options, hub, bundler) {
  var org = options.org,
      project = options.project,
      cleanArtifacts = options.cleanArtifacts,
      finalize = options.finalize,
      setCommits = options.setCommits,
      injectReleasesMap = options.injectReleasesMap,
      dryRun = options.dryRun,
      errorHandler = options.errorHandler,
      deploy = options.deploy,
      include = options.include,
      sourcemaps = options.sourcemaps;
  hub.setTag("include", include.length > 1 ? "multiple-entries" : "single-entry"); // Optional release pipeline steps

  if (cleanArtifacts) {
    hub.setTag("clean-artifacts", true);
  }

  if (setCommits) {
    hub.setTag("set-commits", setCommits.auto === true ? "auto" : "manual");
  }

  if (finalize) {
    hub.setTag("finalize-release", true);
  }

  if (deploy) {
    hub.setTag("add-deploy", true);
  } // Miscelaneous options


  if (dryRun) {
    hub.setTag("dry-run", true);
  }

  if (injectReleasesMap) {
    hub.setTag("inject-releases-map", true);
  }

  if (errorHandler) {
    hub.setTag("error-handler", "custom");
  }

  if (sourcemaps !== null && sourcemaps !== void 0 && sourcemaps.assets) {
    hub.setTag("debug-id-upload", true);
  }

  hub.setTag("node", process.version);
  hub.setTags({
    organization: org,
    project: project,
    bundler: bundler
  });
  hub.setUser({
    id: org
  });
}
function shouldSendTelemetry(_x2) {
  return _shouldSendTelemetry.apply(this, arguments);
}

function _shouldSendTelemetry() {
  _shouldSendTelemetry = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options) {
    var _cliInfo$split$, _cliInfo$split$$repla;

    var silent, org, project, authToken, url, vcsRemote, headers, telemetry, dryRun, cli, cliInfo, cliInfoUrl;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            silent = options.silent, org = options.org, project = options.project, authToken = options.authToken, url = options.url, vcsRemote = options.vcsRemote, headers = options.headers, telemetry = options.telemetry, dryRun = options.dryRun; // `options.telemetry` defaults to true

            if (!(telemetry === false)) {
              _context2.next = 3;
              break;
            }

            return _context2.abrupt("return", false);

          case 3:
            if (!dryRun) {
              _context2.next = 5;
              break;
            }

            return _context2.abrupt("return", false);

          case 5:
            if (!(url === SENTRY_SAAS_URL)) {
              _context2.next = 7;
              break;
            }

            return _context2.abrupt("return", true);

          case 7:
            cli = new SentryCli(options.configFile, {
              url: url,
              authToken: authToken,
              org: org,
              project: project,
              vcsRemote: vcsRemote,
              silent: silent,
              headers: headers
            });
            _context2.prev = 8;
            _context2.next = 11;
            return cli.execute(["info"], false);

          case 11:
            cliInfo = _context2.sent;
            _context2.next = 17;
            break;

          case 14:
            _context2.prev = 14;
            _context2.t0 = _context2["catch"](8);
            throw new Error('Sentry CLI "info" command failed, make sure you have an auth token configured, and your `url` option is correct.');

          case 17:
            cliInfoUrl = (_cliInfo$split$ = cliInfo.split(/(\r\n|\n|\r)/)[0]) === null || _cliInfo$split$ === void 0 ? void 0 : (_cliInfo$split$$repla = _cliInfo$split$.replace(/^Sentry Server: /, "")) === null || _cliInfo$split$$repla === void 0 ? void 0 : _cliInfo$split$$repla.trim();

            if (!(cliInfoUrl === undefined)) {
              _context2.next = 20;
              break;
            }

            return _context2.abrupt("return", false);

          case 20:
            return _context2.abrupt("return", new URL(cliInfoUrl).hostname === SENTRY_SAAS_HOSTNAME);

          case 21:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[8, 14]]);
  }));
  return _shouldSendTelemetry.apply(this, arguments);
}

function createNewRelease(_x, _x2, _x3) {
  return _createNewRelease.apply(this, arguments);
}

function _createNewRelease() {
  _createNewRelease = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(options, ctx, releaseName) {
    var span;
    return _regeneratorRuntime().wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            span = addSpanToTransaction(ctx, "function.plugin.create_release");
            _context.prev = 1;
            _context.next = 4;
            return ctx.cli.releases["new"](releaseName);

          case 4:
            _context.next = 10;
            break;

          case 6:
            _context.prev = 6;
            _context.t0 = _context["catch"](1);
            ctx.hub.captureException(new Error("CLI Error: Creating new release failed"));
            throw _context.t0;

          case 10:
            _context.prev = 10;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context.finish(10);

          case 13:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully created release."
            });
            ctx.logger.info("Successfully created release.");

          case 15:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[1, 6, 10, 13]]);
  }));
  return _createNewRelease.apply(this, arguments);
}

function cleanArtifacts(_x4, _x5, _x6) {
  return _cleanArtifacts.apply(this, arguments);
}

function _cleanArtifacts() {
  _cleanArtifacts = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(options, ctx, releaseName) {
    var span;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            if (options.cleanArtifacts) {
              _context2.next = 3;
              break;
            }

            logger.debug("Skipping artifact cleanup.");
            return _context2.abrupt("return");

          case 3:
            span = addSpanToTransaction(ctx, "function.plugin.clean_artifacts");
            _context2.prev = 4;
            _context2.next = 7;
            return ctx.cli.releases.execute(["releases", "files", releaseName, "delete", "--all"], true);

          case 7:
            _context2.next = 13;
            break;

          case 9:
            _context2.prev = 9;
            _context2.t0 = _context2["catch"](4);
            ctx.hub.captureException(new Error("CLI Error: Deleting release files failed"));
            throw _context2.t0;

          case 13:
            _context2.prev = 13;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context2.finish(13);

          case 16:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully cleaned previous artifacts."
            });
            ctx.logger.info("Successfully cleaned previous artifacts.");

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[4, 9, 13, 16]]);
  }));
  return _cleanArtifacts.apply(this, arguments);
}

function uploadSourceMaps(_x7, _x8, _x9) {
  return _uploadSourceMaps.apply(this, arguments);
}

function _uploadSourceMaps() {
  _uploadSourceMaps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(options, ctx, releaseName) {
    var span;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            if (options.uploadSourceMaps) {
              _context3.next = 3;
              break;
            }

            logger.debug("Skipping source maps upload.");
            return _context3.abrupt("return");

          case 3:
            span = addSpanToTransaction(ctx, "function.plugin.upload_sourcemaps");
            ctx.logger.info("Uploading Sourcemaps."); // Since our internal include entries contain all top-level sourcemaps options,
            // we only need to pass the include option here.

            _context3.prev = 5;
            _context3.next = 8;
            return ctx.cli.releases.uploadSourceMaps(releaseName, {
              include: options.include,
              dist: options.dist
            });

          case 8:
            _context3.next = 14;
            break;

          case 10:
            _context3.prev = 10;
            _context3.t0 = _context3["catch"](5);
            ctx.hub.captureException(new Error("CLI Error: Uploading source maps failed"));
            throw _context3.t0;

          case 14:
            _context3.prev = 14;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context3.finish(14);

          case 17:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully uploaded source maps."
            });
            ctx.logger.info("Successfully uploaded source maps.");

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[5, 10, 14, 17]]);
  }));
  return _uploadSourceMaps.apply(this, arguments);
}

function uploadDebugIdSourcemaps(_x10, _x11, _x12, _x13) {
  return _uploadDebugIdSourcemaps.apply(this, arguments);
}

function _uploadDebugIdSourcemaps() {
  _uploadDebugIdSourcemaps = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(options, ctx, folderPathToUpload, releaseName) {
    var span;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            span = addSpanToTransaction(ctx, "function.plugin.upload_debug_id_sourcemaps");
            ctx.logger.info("Uploading debug ID Sourcemaps."); // Since our internal include entries contain all top-level sourcemaps options,
            // we only need to pass the include option here.

            _context4.prev = 2;
            _context4.next = 5;
            return ctx.cli.releases.uploadSourceMaps(releaseName, {
              include: [{
                paths: [folderPathToUpload],
                rewrite: false,
                dist: options.dist
              }],
              useArtifactBundle: true
            });

          case 5:
            _context4.next = 11;
            break;

          case 7:
            _context4.prev = 7;
            _context4.t0 = _context4["catch"](2);
            ctx.hub.captureException(new Error("CLI Error: Uploading debug ID source maps failed"));
            throw _context4.t0;

          case 11:
            _context4.prev = 11;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context4.finish(11);

          case 14:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully uploaded debug ID source maps."
            });
            ctx.logger.info("Successfully uploaded debug ID source maps.");

          case 16:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[2, 7, 11, 14]]);
  }));
  return _uploadDebugIdSourcemaps.apply(this, arguments);
}

function setCommits(_x14, _x15, _x16) {
  return _setCommits.apply(this, arguments);
}

function _setCommits() {
  _setCommits = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(options, ctx, releaseName) {
    var span, _options$setCommits, auto, repo, commit, previousCommit, ignoreMissing, ignoreEmpty;

    return _regeneratorRuntime().wrap(function _callee5$(_context5) {
      while (1) {
        switch (_context5.prev = _context5.next) {
          case 0:
            if (options.setCommits) {
              _context5.next = 3;
              break;
            }

            logger.debug("Skipping setting commits to release.");
            return _context5.abrupt("return");

          case 3:
            span = addSpanToTransaction(ctx, "function.plugin.set_commits");
            _options$setCommits = options.setCommits, auto = _options$setCommits.auto, repo = _options$setCommits.repo, commit = _options$setCommits.commit, previousCommit = _options$setCommits.previousCommit, ignoreMissing = _options$setCommits.ignoreMissing, ignoreEmpty = _options$setCommits.ignoreEmpty;
            _context5.prev = 5;
            _context5.next = 8;
            return ctx.cli.releases.setCommits(releaseName, {
              commit: commit,
              previousCommit: previousCommit,
              repo: repo,
              auto: auto,
              ignoreMissing: ignoreMissing,
              ignoreEmpty: ignoreEmpty
            });

          case 8:
            _context5.next = 14;
            break;

          case 10:
            _context5.prev = 10;
            _context5.t0 = _context5["catch"](5);
            ctx.hub.captureException(new Error("CLI Error: Setting commits failed"));
            throw _context5.t0;

          case 14:
            _context5.prev = 14;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context5.finish(14);

          case 17:
            ctx.logger.info("Successfully set commits.");

          case 18:
          case "end":
            return _context5.stop();
        }
      }
    }, _callee5, null, [[5, 10, 14, 17]]);
  }));
  return _setCommits.apply(this, arguments);
}

function finalizeRelease(_x17, _x18, _x19) {
  return _finalizeRelease.apply(this, arguments);
}

function _finalizeRelease() {
  _finalizeRelease = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(options, ctx, releaseName) {
    var span;
    return _regeneratorRuntime().wrap(function _callee6$(_context6) {
      while (1) {
        switch (_context6.prev = _context6.next) {
          case 0:
            if (options.finalize) {
              _context6.next = 4;
              break;
            }

            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Skipping release finalization."
            });
            logger.debug("Skipping release finalization.");
            return _context6.abrupt("return");

          case 4:
            span = addSpanToTransaction(ctx, "function.plugin.finalize_release");
            _context6.prev = 5;
            _context6.next = 8;
            return ctx.cli.releases.finalize(releaseName);

          case 8:
            _context6.next = 14;
            break;

          case 10:
            _context6.prev = 10;
            _context6.t0 = _context6["catch"](5);
            ctx.hub.captureException(new Error("CLI Error: Finalizing release failed"));
            throw _context6.t0;

          case 14:
            _context6.prev = 14;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context6.finish(14);

          case 17:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully finalized release."
            });
            ctx.logger.info("Successfully finalized release.");

          case 19:
          case "end":
            return _context6.stop();
        }
      }
    }, _callee6, null, [[5, 10, 14, 17]]);
  }));
  return _finalizeRelease.apply(this, arguments);
}

function addDeploy(_x20, _x21, _x22) {
  return _addDeploy.apply(this, arguments);
}

function _addDeploy() {
  _addDeploy = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(options, ctx, releaseName) {
    var span, _options$deploy, env, started, finished, time, name, url;

    return _regeneratorRuntime().wrap(function _callee7$(_context7) {
      while (1) {
        switch (_context7.prev = _context7.next) {
          case 0:
            if (options.deploy) {
              _context7.next = 4;
              break;
            }

            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Skipping adding deploy info to release."
            });
            logger.debug("Skipping adding deploy info to release.");
            return _context7.abrupt("return");

          case 4:
            span = addSpanToTransaction(ctx, "function.plugin.deploy");
            _options$deploy = options.deploy, env = _options$deploy.env, started = _options$deploy.started, finished = _options$deploy.finished, time = _options$deploy.time, name = _options$deploy.name, url = _options$deploy.url;
            _context7.prev = 6;
            _context7.next = 9;
            return ctx.cli.releases.newDeploy(releaseName, {
              env: env,
              started: started,
              finished: finished,
              time: time,
              name: name,
              url: url
            });

          case 9:
            _context7.next = 15;
            break;

          case 11:
            _context7.prev = 11;
            _context7.t0 = _context7["catch"](6);
            ctx.hub.captureException(new Error("CLI Error: Adding deploy info failed"));
            throw _context7.t0;

          case 15:
            _context7.prev = 15;
            span === null || span === void 0 ? void 0 : span.finish();
            return _context7.finish(15);

          case 18:
            ctx.hub.addBreadcrumb({
              level: "info",
              message: "Successfully added deploy."
            });
            ctx.logger.info("Successfully added deploy.");

          case 20:
          case "end":
            return _context7.stop();
        }
      }
    }, _callee7, null, [[6, 11, 15, 18]]);
  }));
  return _addDeploy.apply(this, arguments);
}

function createLogger(options) {
  return {
    info: function info(message) {
      if (!options.silent) {
        var _console;

        for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          params[_key - 1] = arguments[_key];
        }

        // eslint-disable-next-line no-console
        (_console = console).log.apply(_console, ["".concat(options.prefix, " Info: ").concat(message)].concat(params));
      }
    },
    warn: function warn(message) {
      if (!options.silent) {
        var _console2;

        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }

        // eslint-disable-next-line no-console
        (_console2 = console).log.apply(_console2, ["".concat(options.prefix, " Warning: ").concat(message)].concat(params));
      }
    },
    error: function error(message) {
      if (!options.silent) {
        var _console3;

        for (var _len3 = arguments.length, params = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
          params[_key3 - 1] = arguments[_key3];
        }

        // eslint-disable-next-line no-console
        (_console3 = console).log.apply(_console3, ["".concat(options.prefix, " Error: ").concat(message)].concat(params));
      }
    },
    debug: function debug(message) {
      if (!options.silent && options.debug) {
        var _console4;

        for (var _len4 = arguments.length, params = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
          params[_key4 - 1] = arguments[_key4];
        }

        // eslint-disable-next-line no-console
        (_console4 = console).log.apply(_console4, ["".concat(options.prefix, " Debug: ").concat(message)].concat(params));
      }
    }
  };
}

/**
 * Creates a new Sentry CLI instance.
 *
 * In case, users selected the `dryRun` options, this returns a stub
 * that makes no-ops out of most CLI operations
 */
function getSentryCli(internalOptions, logger) {
  var silent = internalOptions.silent,
      org = internalOptions.org,
      project = internalOptions.project,
      authToken = internalOptions.authToken,
      url = internalOptions.url,
      vcsRemote = internalOptions.vcsRemote,
      headers = internalOptions.headers;
  var cli = new SentryCli(internalOptions.configFile, {
    url: url,
    authToken: authToken,
    org: org,
    project: project,
    vcsRemote: vcsRemote,
    silent: silent,
    headers: headers
  });

  if (internalOptions.dryRun) {
    logger.info("In DRY RUN Mode");
    return getDryRunCLI(cli, logger);
  }

  return cli;
}

function getDryRunCLI(cli, logger) {
  return {
    releases: {
      proposeVersion: function proposeVersion() {
        return cli.releases.proposeVersion().then(function (version) {
          logger.info("Proposed version:\n", version);
          return version;
        });
      },
      "new": function _new(release) {
        logger.info("Creating new release:\n", release);
        return Promise.resolve(release);
      },
      uploadSourceMaps: function uploadSourceMaps(release, config) {
        logger.info("Calling upload-sourcemaps with:\n", config);
        return Promise.resolve(release);
      },
      finalize: function finalize(release) {
        logger.info("Finalizing release:\n", release);
        return Promise.resolve(release);
      },
      setCommits: function setCommits(release, config) {
        logger.info("Calling set-commits with:\n", config);
        return Promise.resolve(release);
      },
      newDeploy: function newDeploy(release, config) {
        logger.info("Calling deploy with:\n", config);
        return Promise.resolve(release);
      },
      execute: function execute(args, live) {
        logger.info("Executing", args, "live:", live);
        return Promise.resolve("");
      }
    },
    execute: function execute(args, live) {
      logger.info("Executing", args, "live:", live);
      return Promise.resolve("Executed");
    }
  };
}

var DEBUG_ID_INJECTOR_SNIPPET = ';!function(){try{var e="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},n=(new Error).stack;n&&(e._sentryDebugIds=e._sentryDebugIds||{},e._sentryDebugIds[n]="__SENTRY_DEBUG_ID__",e._sentryDebugIdIdentifier="sentry-dbid-__SENTRY_DEBUG_ID__")}catch(e){}}();';
function injectDebugIdSnippetIntoChunk(code, filename) {
  var _code$match;

  var debugId = stringToUUID(code); // generate a deterministic debug ID

  var ms = new MagicString(code, {
    filename: filename
  });
  var codeToInject = DEBUG_ID_INJECTOR_SNIPPET.replace(/__SENTRY_DEBUG_ID__/g, debugId); // We need to be careful not to inject the snippet before any `"use strict";`s.
  // As an additional complication `"use strict";`s may come after any number of comments.

  var commentUseStrictRegex = /^(?:\s*|\/\*(.|\r|\n)*?\*\/|\/\/.*?[\n\r])*(?:"use strict";|'use strict';)?/;

  if ((_code$match = code.match(commentUseStrictRegex)) !== null && _code$match !== void 0 && _code$match[0]) {
    // Add injected code after any comments or "use strict" at the beginning of the bundle.
    ms.replace(commentUseStrictRegex, function (match) {
      return "".concat(match).concat(codeToInject);
    });
  } else {
    // ms.replace() doesn't work when there is an empty string match (which happens if
    // there is neither, a comment, nor a "use strict" at the top of the chunk) so we
    // need this special case here.
    ms.prepend(codeToInject);
  }

  return {
    code: ms.toString(),
    map: ms.generateMap()
  };
}
function prepareBundleForDebugIdUpload(_x, _x2, _x3, _x4) {
  return _prepareBundleForDebugIdUpload.apply(this, arguments);
}
/**
 * Looks for a particular string pattern (`sdbid-[debug ID]`) in the bundle
 * source and extracts the bundle's debug ID from it.
 *
 * The string pattern is injected via the debug ID injection snipped.
 */

function _prepareBundleForDebugIdUpload() {
  _prepareBundleForDebugIdUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(bundleFilePath, uploadFolder, uniqueUploadName, logger) {
    var bundleContent, debugId, writeSourceFilePromise, writeSourceMapFilePromise;
    return _regeneratorRuntime().wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _context2.prev = 0;
            _context2.next = 3;
            return util.promisify(fs.readFile)(bundleFilePath, "utf8");

          case 3:
            bundleContent = _context2.sent;
            _context2.next = 10;
            break;

          case 6:
            _context2.prev = 6;
            _context2.t0 = _context2["catch"](0);
            logger.warn("Could not read bundle to determine debug ID and source map: ".concat(bundleFilePath));
            return _context2.abrupt("return");

          case 10:
            debugId = determineDebugIdFromBundleSource(bundleContent);

            if (!(debugId === undefined)) {
              _context2.next = 14;
              break;
            }

            logger.warn("Could not determine debug ID from bundle: ".concat(bundleFilePath));
            return _context2.abrupt("return");

          case 14:
            bundleContent += "\n//# debugId=".concat(debugId);
            writeSourceFilePromise = util.promisify(fs.writeFile)(path.join(uploadFolder, "".concat(uniqueUploadName, ".js")), bundleContent, "utf-8");
            writeSourceMapFilePromise = determineSourceMapPathFromBundle(bundleFilePath, bundleContent, logger).then( /*#__PURE__*/function () {
              var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(sourceMapPath) {
                return _regeneratorRuntime().wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!sourceMapPath) {
                          _context.next = 4;
                          break;
                        }

                        _context.next = 3;
                        return prepareSourceMapForDebugIdUpload(sourceMapPath, path.join(uploadFolder, "".concat(uniqueUploadName, ".js.map")), debugId, logger);

                      case 3:
                        return _context.abrupt("return", _context.sent);

                      case 4:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              }));

              return function (_x12) {
                return _ref.apply(this, arguments);
              };
            }());
            return _context2.abrupt("return", Promise.all([writeSourceFilePromise, writeSourceMapFilePromise]));

          case 18:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, null, [[0, 6]]);
  }));
  return _prepareBundleForDebugIdUpload.apply(this, arguments);
}

function determineDebugIdFromBundleSource(code) {
  var match = code.match(/sentry-dbid-([0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12})/);

  if (match) {
    return match[1];
  } else {
    return undefined;
  }
}
/**
 * Applies a set of heuristics to find the source map for a particular bundle.
 *
 * @returns the path to the bundle's source map or `undefined` if none could be found.
 */


function determineSourceMapPathFromBundle(_x5, _x6, _x7) {
  return _determineSourceMapPathFromBundle.apply(this, arguments);
}
/**
 * Reads a source map, injects debug ID fields, and writes the source map to the target path.
 */


function _determineSourceMapPathFromBundle() {
  _determineSourceMapPathFromBundle = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(bundlePath, bundleSource, logger) {
    var sourceMappingUrlMatch, sourceMappingUrl, adjacentSourceMapFilePath;
    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
      while (1) {
        switch (_context3.prev = _context3.next) {
          case 0:
            // 1. try to find source map at `sourceMappingURL` location
            sourceMappingUrlMatch = bundleSource.match(/^\/\/# sourceMappingURL=(.*)$/);

            if (!sourceMappingUrlMatch) {
              _context3.next = 8;
              break;
            }

            sourceMappingUrl = path.normalize(sourceMappingUrlMatch[1]);

            if (!path.isAbsolute(sourceMappingUrl)) {
              _context3.next = 7;
              break;
            }

            return _context3.abrupt("return", sourceMappingUrl);

          case 7:
            return _context3.abrupt("return", path.join(path.dirname(bundlePath), sourceMappingUrl));

          case 8:
            _context3.prev = 8;
            adjacentSourceMapFilePath = bundlePath + ".map";
            _context3.next = 12;
            return util.promisify(fs.access)(adjacentSourceMapFilePath);

          case 12:
            return _context3.abrupt("return", adjacentSourceMapFilePath);

          case 15:
            _context3.prev = 15;
            _context3.t0 = _context3["catch"](8);

          case 17:
            logger.warn("Could not determine source map path for bundle: ".concat(bundlePath));
            return _context3.abrupt("return", undefined);

          case 19:
          case "end":
            return _context3.stop();
        }
      }
    }, _callee3, null, [[8, 15]]);
  }));
  return _determineSourceMapPathFromBundle.apply(this, arguments);
}

function prepareSourceMapForDebugIdUpload(_x8, _x9, _x10, _x11) {
  return _prepareSourceMapForDebugIdUpload.apply(this, arguments);
}

function _prepareSourceMapForDebugIdUpload() {
  _prepareSourceMapForDebugIdUpload = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(sourceMapPath, targetPath, debugId, logger) {
    var sourceMapFileContent, map;
    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
      while (1) {
        switch (_context4.prev = _context4.next) {
          case 0:
            _context4.prev = 0;
            _context4.next = 3;
            return util.promisify(fs.readFile)(sourceMapPath, {
              encoding: "utf8"
            });

          case 3:
            sourceMapFileContent = _context4.sent;
            map = JSON.parse(sourceMapFileContent); // For now we write both fields until we know what will become the standard - if ever.

            map["debug_id"] = debugId;
            map["debugId"] = debugId;
            _context4.next = 9;
            return util.promisify(fs.writeFile)(targetPath, JSON.stringify(map), {
              encoding: "utf8"
            });

          case 9:
            _context4.next = 14;
            break;

          case 11:
            _context4.prev = 11;
            _context4.t0 = _context4["catch"](0);
            logger.warn("Failed to prepare source map for debug ID upload: ".concat(sourceMapPath));

          case 14:
          case "end":
            return _context4.stop();
        }
      }
    }, _callee4, null, [[0, 11]]);
  }));
  return _prepareSourceMapForDebugIdUpload.apply(this, arguments);
}

var ALLOWED_TRANSFORMATION_FILE_ENDINGS = [".js", ".ts", ".jsx", ".tsx", ".mjs"]; // Use createRequire because esm doesn't like built-in require.resolve

var require = createRequire(import.meta.url);

var releaseInjectionFilePath = require.resolve("@sentry/bundler-plugin-core/sentry-release-injection-file");

var esbuildDebugIdInjectionFilePath = require.resolve("@sentry/bundler-plugin-core/sentry-esbuild-debugid-injection-file");
/**
 * The sentry bundler plugin concerns itself with two things:
 * - Release injection
 * - Sourcemaps upload
 *
 * Release injection:
 * Per default the sentry bundler plugin will inject a global `SENTRY_RELEASE` into each JavaScript/TypeScript module
 * that is part of the bundle. On a technical level this is done by appending an import (`import "sentry-release-injector;"`)
 * to all entrypoint files of the user code (see `transformInclude` and `transform` hooks). This import is then resolved
 * by the sentry plugin to a virtual module that sets the global variable (see `resolveId` and `load` hooks).
 * If a user wants to inject the release into a particular set of modules they can use the `releaseInjectionTargets` option.
 *
 * Source maps upload:
 *
 * The sentry bundler plugin will also take care of uploading source maps to Sentry. This
 * is all done in the `writeBundle` hook. In this hook the sentry plugin will execute the
 * release creation pipeline:
 *
 * 1. Create a new release
 * 2. Delete already uploaded artifacts for this release (if `cleanArtifacts` is enabled)
 * 3. Upload sourcemaps based on `include` and source-map-specific options
 * 4. Associate a range of commits with the release (if `setCommits` is specified)
 * 5. Finalize the release (unless `finalize` is disabled)
 * 6. Add deploy information to the release (if `deploy` is specified)
 *
 * This release creation pipeline relies on Sentry CLI to execute the different steps.
 */


var unplugin = createUnplugin(function (userOptions, unpluginMetaContext) {
  var options = normalizeUserOptions(userOptions);
  var allowedToSendTelemetryPromise = shouldSendTelemetry(options);

  var _makeSentryClient = makeSentryClient("https://4c2bae7d9fbc413e8f7385f55c515d51@o1.ingest.sentry.io/6690737", allowedToSendTelemetryPromise, options.project),
      sentryHub = _makeSentryClient.sentryHub,
      sentryClient = _makeSentryClient.sentryClient;

  addPluginOptionInformationToHub(options, sentryHub, unpluginMetaContext.framework); //TODO: This call is problematic because as soon as we set our hub as the current hub
  //      we might interfere with other plugins that use Sentry. However, for now, we'll
  //      leave it in because without it, we can't get distributed traces (which are pretty nice)
  //      Let's keep it until someone complains about interference.
  //      The ideal solution would be a code change in the JS SDK but it's not a straight-forward fix.

  makeMain(sentryHub);
  var logger = createLogger({
    prefix: "[sentry-".concat(unpluginMetaContext.framework, "-plugin]"),
    silent: options.silent,
    debug: options.debug
  });

  if (!validateOptions(options, logger)) {
    handleError(new Error("Options were not set correctly. See output above for more details."), logger, options.errorHandler);
  }

  var cli = getSentryCli(options, logger);
  var releaseNamePromise = new Promise(function (resolve) {
    if (userOptions.release) {
      resolve(userOptions.release);
    } else {
      resolve(cli.releases.proposeVersion());
    }
  });
  var transaction;
  var releaseInjectionSpan;
  var plugins = [];
  plugins.push({
    name: "sentry-plugin",
    enforce: "pre",
    // needed for Vite to call resolveId hook

    /**
     * Responsible for starting the plugin execution transaction and the release injection span
     */
    buildStart: function buildStart() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var isAllowedToSendToSendTelemetry, releaseName;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                logger.debug("Called 'buildStart'");
                _context.next = 3;
                return allowedToSendTelemetryPromise;

              case 3:
                isAllowedToSendToSendTelemetry = _context.sent;

                if (isAllowedToSendToSendTelemetry) {
                  logger.info("Sending error and performance telemetry data to Sentry.");
                  logger.info("To disable telemetry, set `options.telemetry` to `false`.");
                  sentryHub.addBreadcrumb({
                    level: "info",
                    message: "Telemetry enabled."
                  });
                } else {
                  sentryHub.addBreadcrumb({
                    level: "info",
                    message: "Telemetry disabled. This should never show up in a Sentry event."
                  });
                }

                if (process.cwd().match(/\\node_modules\\|\/node_modules\//)) {
                  logger.warn("Running Sentry plugin from within a `node_modules` folder. Some features may not work.");
                }

                _context.next = 8;
                return releaseNamePromise;

              case 8:
                releaseName = _context.sent;

                // At this point, we either have determined a release or we have to bail
                if (!releaseName) {
                  handleError(new Error("Unable to determine a release name. Make sure to set the `release` option or use an environment that supports auto-detection https://docs.sentry.io/cli/releases/#creating-releases`"), logger, options.errorHandler);
                }

                transaction = sentryHub.startTransaction({
                  op: "function.plugin",
                  name: "Sentry Bundler Plugin execution"
                });
                releaseInjectionSpan = addSpanToTransaction({
                  hub: sentryHub,
                  parentSpan: transaction,
                  logger: logger,
                  cli: cli
                }, "function.plugin.inject_release", "Release injection");

              case 12:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }))();
    },

    /**
     * Responsible for returning the "sentry-release-injector" ID when we encounter it. We return the ID so load is
     * called and we can "virtually" load the module. See `load` hook for more info on why it's virtual.
     *
     * We also record the id (i.e. absolute path) of any non-entrypoint.
     *
     * @param id For imports: The absolute path of the module to be imported. For entrypoints: The path the user defined as entrypoint - may also be relative.
     * @param importer For imports: The absolute path of the module that imported this module. For entrypoints: `undefined`.
     * @param options Additional information to use for making a resolving decision.
     * @returns `"sentry-release-injector"` when the imported file is called `"sentry-release-injector"`. Otherwise returns `undefined`.
     */
    resolveId: function resolveId(id, importer, _ref) {
      var isEntry = _ref.isEntry;
      logger.debug('Called "resolveId":', {
        id: id,
        importer: importer,
        isEntry: isEntry
      });
      return undefined;
    },

    /**
     * This hook determines whether we want to transform a module. In the sentry bundler plugin we want to transform every entrypoint
     * unless configured otherwise with the `releaseInjectionTargets` option.
     *
     * @param id Always the absolute (fully resolved) path to the module.
     * @returns `true` or `false` depending on whether we want to transform the module. For the sentry bundler plugin we only
     * want to transform the release injector file.
     */
    transformInclude: function transformInclude(id) {
      logger.debug('Called "transformInclude":', {
        id: id
      });

      if (id.includes("sentry-release-injection-file")) {
        return true;
      }

      if (id.match(/\\node_modules\\|\/node_modules\//)) {
        return false; // never transform 3rd party modules
      } // We normalize the id because vite always passes `id` as a unix style path which causes problems when a user passes
      // a windows style path to `releaseInjectionTargets`


      var normalizedId = path__default.normalize(id);

      if (options.releaseInjectionTargets) {
        // If there's an `releaseInjectionTargets` option transform (ie. inject the release varible) when the file path matches the option.
        if (typeof options.releaseInjectionTargets === "function") {
          return options.releaseInjectionTargets(normalizedId);
        }

        return options.releaseInjectionTargets.some(function (entry) {
          if (entry instanceof RegExp) {
            return entry.test(normalizedId);
          } else {
            var normalizedEntry = path__default.normalize(entry);
            return normalizedId === normalizedEntry;
          }
        });
      } else {
        var pathIsOrdinary = !normalizedId.includes("?") && !normalizedId.includes("#");
        var pathHasAllowedFileEnding = ALLOWED_TRANSFORMATION_FILE_ENDINGS.some(function (allowedFileEnding) {
          return normalizedId.endsWith(allowedFileEnding);
        });
        return pathIsOrdinary && pathHasAllowedFileEnding;
      }
    },

    /**
     * This hook is responsible for injecting the "sentry release injector" imoprt statement into each entrypoint unless
     * configured otherwise with the `releaseInjectionTargets` option (logic for that is in the `transformInclude` hook).
     *
     * @param code Code of the file to transform.
     * @param id Always the absolute (fully resolved) path to the module.
     * @returns transformed code + source map
     */
    transform: function transform(code, id) {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {
        var ms;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) {
            switch (_context2.prev = _context2.next) {
              case 0:
                logger.debug('Called "transform":', {
                  id: id
                });

                if (options.injectRelease) {
                  _context2.next = 3;
                  break;
                }

                return _context2.abrupt("return");

              case 3:
                // The MagicString library allows us to generate sourcemaps for the changes we make to the user code.
                ms = new MagicString(code);

                if (!code.includes("_sentry_release_injection_file")) {
                  _context2.next = 19;
                  break;
                }

                _context2.t0 = ms;
                _context2.t1 = generateGlobalInjectorCode;
                _context2.next = 9;
                return releaseNamePromise;

              case 9:
                _context2.t2 = _context2.sent;
                _context2.t3 = options.injectReleasesMap;
                _context2.t4 = options._experiments.injectBuildInformation || false;
                _context2.t5 = options.org;
                _context2.t6 = options.project;
                _context2.t7 = {
                  release: _context2.t2,
                  injectReleasesMap: _context2.t3,
                  injectBuildInformation: _context2.t4,
                  org: _context2.t5,
                  project: _context2.t6
                };
                _context2.t8 = (0, _context2.t1)(_context2.t7);

                _context2.t0.append.call(_context2.t0, _context2.t8);

                _context2.next = 20;
                break;

              case 19:
                // Appending instead of prepending has less probability of mucking with user's source maps.
                // Luckily import statements get hoisted to the top anyways.
                // The import needs to be an absolute path because Rollup doesn't bundle stuff in `node_modules` by default when bundling CJS (unless the import path is absolute or the node-resolve-plugin is used).
                ms.append(";\nimport \"".concat(releaseInjectionFilePath.replace(/\\/g, "\\\\"), "\";"));

              case 20:
                if (!(unpluginMetaContext.framework === "esbuild")) {
                  _context2.next = 24;
                  break;
                }

                return _context2.abrupt("return", ms.toString());

              case 24:
                return _context2.abrupt("return", {
                  code: ms.toString(),
                  map: ms.generateMap()
                });

              case 25:
              case "end":
                return _context2.stop();
            }
          }
        }, _callee2);
      }))();
    },

    /**
     * Responsible for executing the sentry release creation pipeline (i.e. creating a release on
     * Sentry.io, uploading sourcemaps, associating commits and deploys and finalizing the release)
     */
    writeBundle: function writeBundle() {
      return _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {
        var _releaseInjectionSpan;

        var releasePipelineSpan, ctx, releaseName, tmpUploadFolder, _transaction, _options$sourcemaps, debugIdChunkFilePaths, sourceFileUploadFolderPromise, _transaction2, _transaction3;

        return _regeneratorRuntime().wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                logger.debug('Called "writeBundle"');
                (_releaseInjectionSpan = releaseInjectionSpan) === null || _releaseInjectionSpan === void 0 ? void 0 : _releaseInjectionSpan.finish();
                releasePipelineSpan = transaction && addSpanToTransaction({
                  hub: sentryHub,
                  parentSpan: transaction,
                  logger: logger,
                  cli: cli
                }, "function.plugin.release", "Release pipeline");
                sentryHub.addBreadcrumb({
                  category: "writeBundle:start",
                  level: "info"
                });
                ctx = {
                  hub: sentryHub,
                  parentSpan: releasePipelineSpan,
                  logger: logger,
                  cli: cli
                };
                _context5.next = 7;
                return releaseNamePromise;

              case 7:
                releaseName = _context5.sent;
                _context5.prev = 8;

                if (unpluginMetaContext.watchMode) {
                  _context5.next = 37;
                  break;
                }

                if (!((_options$sourcemaps = options.sourcemaps) !== null && _options$sourcemaps !== void 0 && _options$sourcemaps.assets)) {
                  _context5.next = 25;
                  break;
                }

                _context5.next = 13;
                return glob(options.sourcemaps.assets, {
                  absolute: true,
                  nodir: true,
                  ignore: options.sourcemaps.ignore
                });

              case 13:
                debugIdChunkFilePaths = _context5.sent.filter(function (p) {
                  return p.endsWith(".js") || p.endsWith(".mjs") || p.endsWith(".cjs");
                });

                if (!(unpluginMetaContext.framework === "esbuild")) {
                  _context5.next = 17;
                  break;
                }

                _context5.next = 17;
                return Promise.all(debugIdChunkFilePaths.map( /*#__PURE__*/function () {
                  var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(debugIdChunkFilePath) {
                    var chunkFileContents, debugId, newChunkFileContents;
                    return _regeneratorRuntime().wrap(function _callee3$(_context3) {
                      while (1) {
                        switch (_context3.prev = _context3.next) {
                          case 0:
                            _context3.next = 2;
                            return promisify(fs__default.readFile)(debugIdChunkFilePath, "utf-8");

                          case 2:
                            chunkFileContents = _context3.sent;
                            debugId = stringToUUID(chunkFileContents);
                            newChunkFileContents = chunkFileContents.replace(/__SENTRY_DEBUG_ID__/g, debugId);
                            _context3.next = 7;
                            return promisify(fs__default.writeFile)(debugIdChunkFilePath, newChunkFileContents, "utf-8");

                          case 7:
                          case "end":
                            return _context3.stop();
                        }
                      }
                    }, _callee3);
                  }));

                  return function (_x) {
                    return _ref2.apply(this, arguments);
                  };
                }()));

              case 17:
                sourceFileUploadFolderPromise = promisify(fs__default.mkdtemp)(path__default.join(os.tmpdir(), "sentry-bundler-plugin-upload-"));
                _context5.next = 20;
                return Promise.all(debugIdChunkFilePaths.map( /*#__PURE__*/function () {
                  var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(chunkFilePath, chunkIndex) {
                    return _regeneratorRuntime().wrap(function _callee4$(_context4) {
                      while (1) {
                        switch (_context4.prev = _context4.next) {
                          case 0:
                            _context4.t0 = prepareBundleForDebugIdUpload;
                            _context4.t1 = chunkFilePath;
                            _context4.next = 4;
                            return sourceFileUploadFolderPromise;

                          case 4:
                            _context4.t2 = _context4.sent;
                            _context4.t3 = String(chunkIndex);
                            _context4.t4 = logger;
                            _context4.next = 9;
                            return (0, _context4.t0)(_context4.t1, _context4.t2, _context4.t3, _context4.t4);

                          case 9:
                          case "end":
                            return _context4.stop();
                        }
                      }
                    }, _callee4);
                  }));

                  return function (_x2, _x3) {
                    return _ref3.apply(this, arguments);
                  };
                }()));

              case 20:
                _context5.next = 22;
                return sourceFileUploadFolderPromise;

              case 22:
                tmpUploadFolder = _context5.sent;
                _context5.next = 25;
                return uploadDebugIdSourcemaps(options, ctx, tmpUploadFolder, releaseName);

              case 25:
                _context5.next = 27;
                return createNewRelease(options, ctx, releaseName);

              case 27:
                _context5.next = 29;
                return cleanArtifacts(options, ctx, releaseName);

              case 29:
                _context5.next = 31;
                return uploadSourceMaps(options, ctx, releaseName);

              case 31:
                _context5.next = 33;
                return setCommits(options, ctx, releaseName);

              case 33:
                _context5.next = 35;
                return finalizeRelease(options, ctx, releaseName);

              case 35:
                _context5.next = 37;
                return addDeploy(options, ctx, releaseName);

              case 37:
                (_transaction = transaction) === null || _transaction === void 0 ? void 0 : _transaction.setStatus("ok");
                _context5.next = 45;
                break;

              case 40:
                _context5.prev = 40;
                _context5.t0 = _context5["catch"](8);
                (_transaction2 = transaction) === null || _transaction2 === void 0 ? void 0 : _transaction2.setStatus("cancelled");
                sentryHub.addBreadcrumb({
                  level: "error",
                  message: "Error during writeBundle"
                });
                handleError(_context5.t0, logger, options.errorHandler);

              case 45:
                _context5.prev = 45;

                if (tmpUploadFolder) {
                  fs__default.rm(tmpUploadFolder, {
                    recursive: true,
                    force: true
                  }, function () {// We don't care if this errors
                  });
                }

                releasePipelineSpan === null || releasePipelineSpan === void 0 ? void 0 : releasePipelineSpan.finish();
                (_transaction3 = transaction) === null || _transaction3 === void 0 ? void 0 : _transaction3.finish();
                _context5.next = 51;
                return sentryClient.flush().then(null, function () {
                  logger.warn("Sending of telemetry failed");
                });

              case 51:
                return _context5.finish(45);

              case 52:
                sentryHub.addBreadcrumb({
                  category: "writeBundle:finish",
                  level: "info"
                });

              case 53:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, null, [[8, 40, 45, 52]]);
      }))();
    },
    rollup: {
      renderChunk: function renderChunk(code, chunk) {
        var _options$sourcemaps2;

        if ((_options$sourcemaps2 = options.sourcemaps) !== null && _options$sourcemaps2 !== void 0 && _options$sourcemaps2.assets && [".js", ".mjs", ".cjs"].some(function (ending) {
          return chunk.fileName.endsWith(ending);
        }) // chunks could be any file (html, md, ...)
        ) {
          return injectDebugIdSnippetIntoChunk(code);
        } else {
          return null; // returning null means not modifying the chunk at all
        }
      }
    },
    vite: {
      renderChunk: function renderChunk(code, chunk) {
        var _options$sourcemaps3;

        if ((_options$sourcemaps3 = options.sourcemaps) !== null && _options$sourcemaps3 !== void 0 && _options$sourcemaps3.assets && [".js", ".mjs", ".cjs"].some(function (ending) {
          return chunk.fileName.endsWith(ending);
        }) // chunks could be any file (html, md, ...)
        ) {
          return injectDebugIdSnippetIntoChunk(code);
        } else {
          return null; // returning null means not modifying the chunk at all
        }
      }
    },
    webpack: function webpack(compiler) {
      var _options$sourcemaps4;

      if ((_options$sourcemaps4 = options.sourcemaps) !== null && _options$sourcemaps4 !== void 0 && _options$sourcemaps4.assets) {
        // Cache inspired by https://github.com/webpack/webpack/pull/15454
        var cache = new WeakMap();
        compiler.hooks.compilation.tap("sentry-plugin", function (compilation) {
          compilation.hooks.optimizeChunkAssets.tap("sentry-plugin", function (chunks) {
            chunks.forEach(function (chunk) {
              var fileNames = chunk.files;
              fileNames.forEach(function (fileName) {
                var source = compilation.assets[fileName];

                if (!source) {
                  logger.warn("Unable to access compilation assets. If you see this warning, it is likely a bug in the Sentry webpack plugin. Feel free to open an issue at https://github.com/getsentry/sentry-javascript-bundler-plugins with reproduction steps.");
                  return;
                }

                compilation.updateAsset(fileName, function (oldSource) {
                  var cached = cache.get(oldSource);

                  if (cached) {
                    return cached;
                  }

                  var originalCode = source.source().toString(); // The source map type is very annoying :(
                  // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-explicit-any

                  var originalSourceMap = source.map();

                  var _injectDebugIdSnippet = injectDebugIdSnippetIntoChunk(originalCode, fileName),
                      newCode = _injectDebugIdSnippet.code,
                      newSourceMap = _injectDebugIdSnippet.map; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access


                  newSourceMap.sources = originalSourceMap.sources; // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access

                  newSourceMap.sourcesContent = originalSourceMap.sourcesContent;
                  var newSource = new webpackSources.SourceMapSource(newCode, fileName, // eslint-disable-next-line @typescript-eslint/no-unsafe-argument
                  originalSourceMap, originalCode, newSourceMap, false);
                  cache.set(oldSource, newSource);
                  return newSource;
                });
              });
            });
          });
        });
      }
    }
  });

  if (unpluginMetaContext.framework === "esbuild") {
    var _options$sourcemaps5;

    if ((_options$sourcemaps5 = options.sourcemaps) !== null && _options$sourcemaps5 !== void 0 && _options$sourcemaps5.assets) {
      plugins.push({
        name: "sentry-esbuild-debug-id-plugin",
        esbuild: {
          setup: function setup(_ref4) {
            var initialOptions = _ref4.initialOptions;
            initialOptions.inject = initialOptions.inject || [];
            initialOptions.inject.push(esbuildDebugIdInjectionFilePath);
          }
        }
      });
    }
  }

  return plugins;
});

function handleError(unknownError, logger, errorHandler) {
  if (unknownError instanceof Error) {
    logger.error(unknownError.message);
  } else {
    logger.error(String(unknownError));
  }

  if (errorHandler) {
    if (unknownError instanceof Error) {
      errorHandler(unknownError);
    } else {
      errorHandler(new Error("An unknown error occured"));
    }
  } else {
    throw unknownError;
  }
}
/**
 * Generates code for the global injector which is responsible for setting the global
 * `SENTRY_RELEASE` & `SENTRY_BUILD_INFO` variables.
 */


function generateGlobalInjectorCode(_ref5) {
  var release = _ref5.release,
      injectReleasesMap = _ref5.injectReleasesMap,
      injectBuildInformation = _ref5.injectBuildInformation,
      org = _ref5.org,
      project = _ref5.project;
  // The code below is mostly ternary operators because it saves bundle size.
  // The checks are to support as many environments as possible. (Node.js, Browser, webworkers, etc.)
  var code = "\n    var _global =\n      typeof window !== 'undefined' ?\n        window :\n        typeof global !== 'undefined' ?\n          global :\n          typeof self !== 'undefined' ?\n            self :\n            {};\n\n    _global.SENTRY_RELEASE={id:\"".concat(release, "\"};");

  if (injectReleasesMap && project) {
    var key = org ? "".concat(project, "@").concat(org) : project;
    code += "\n      _global.SENTRY_RELEASES=_global.SENTRY_RELEASES || {};\n      _global.SENTRY_RELEASES[\"".concat(key, "\"]={id:\"").concat(release, "\"};");
  }

  if (injectBuildInformation) {
    var buildInfo = getBuildInformation();
    code += "\n      _global.SENTRY_BUILD_INFO=".concat(JSON.stringify(buildInfo), ";");
  }

  return code;
}

function getBuildInformation() {
  var packageJson = getPackageJson();

  var _ref6 = packageJson ? getDependencies(packageJson) : {
    deps: [],
    depsVersions: {}
  },
      deps = _ref6.deps,
      depsVersions = _ref6.depsVersions;

  return {
    deps: deps,
    depsVersions: depsVersions,
    nodeVersion: parseMajorVersion(process.version)
  };
}
/**
 * Determines whether the Sentry CLI binary is in its expected location.
 * This function is useful since `@sentry/cli` installs the binary via a post-install
 * script and post-install scripts may not always run. E.g. with `npm i --ignore-scripts`.
 */

function sentryCliBinaryExists() {
  return fs__default.existsSync(SentryCli.getPath());
} // eslint-disable-next-line @typescript-eslint/no-explicit-any

var sentryVitePlugin = unplugin.vite; // eslint-disable-next-line @typescript-eslint/no-explicit-any

var sentryRollupPlugin = unplugin.rollup; // eslint-disable-next-line @typescript-eslint/no-explicit-any

var sentryWebpackPlugin = unplugin.webpack; // eslint-disable-next-line @typescript-eslint/no-explicit-any

var sentryEsbuildPlugin = unplugin.esbuild;

export { getBuildInformation, sentryCliBinaryExists, sentryEsbuildPlugin, sentryRollupPlugin, sentryVitePlugin, sentryWebpackPlugin };
//# sourceMappingURL=index.mjs.map
